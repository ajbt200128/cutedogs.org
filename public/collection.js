var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// node_modules/openseadragon/build/openseadragon/openseadragon.js
var require_openseadragon = __commonJS((exports, module) => {
  //! openseadragon 5.0.1
  //! Built on 2024-12-09
  //! Git commit: v5.0.1-0-480de92d
  //! http://openseadragon.github.io
  //! License: http://openseadragon.github.io/license/
  function OpenSeadragon(options) {
    return new OpenSeadragon.Viewer(options);
  }
  (function($) {
    $.version = {
      versionStr: "5.0.1",
      major: parseInt("5", 10),
      minor: parseInt("0", 10),
      revision: parseInt("1", 10)
    };
    var class2type = {
      "[object Boolean]": "boolean",
      "[object Number]": "number",
      "[object String]": "string",
      "[object Function]": "function",
      "[object AsyncFunction]": "function",
      "[object Promise]": "promise",
      "[object Array]": "array",
      "[object Date]": "date",
      "[object RegExp]": "regexp",
      "[object Object]": "object"
    }, toString = Object.prototype.toString, hasOwn = Object.prototype.hasOwnProperty;
    $.isFunction = function(obj) {
      return $.type(obj) === "function";
    };
    $.isArray = Array.isArray || function(obj) {
      return $.type(obj) === "array";
    };
    $.isWindow = function(obj) {
      return obj && typeof obj === "object" && "setInterval" in obj;
    };
    $.type = function(obj) {
      return obj === null || obj === undefined ? String(obj) : class2type[toString.call(obj)] || "object";
    };
    $.isPlainObject = function(obj) {
      if (!obj || OpenSeadragon.type(obj) !== "object" || obj.nodeType || $.isWindow(obj)) {
        return false;
      }
      if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
        return false;
      }
      var lastKey;
      for (var key in obj) {
        lastKey = key;
      }
      return lastKey === undefined || hasOwn.call(obj, lastKey);
    };
    $.isEmptyObject = function(obj) {
      for (var name in obj) {
        return false;
      }
      return true;
    };
    $.freezeObject = function(obj) {
      if (Object.freeze) {
        $.freezeObject = Object.freeze;
      } else {
        $.freezeObject = function(obj2) {
          return obj2;
        };
      }
      return $.freezeObject(obj);
    };
    $.supportsCanvas = function() {
      var canvasElement = document.createElement("canvas");
      return !!($.isFunction(canvasElement.getContext) && canvasElement.getContext("2d"));
    }();
    $.isCanvasTainted = function(canvas) {
      var isTainted = false;
      try {
        canvas.getContext("2d").getImageData(0, 0, 1, 1);
      } catch (e) {
        isTainted = true;
      }
      return isTainted;
    };
    $.supportsAddEventListener = function() {
      return !!(document.documentElement.addEventListener && document.addEventListener);
    }();
    $.supportsRemoveEventListener = function() {
      return !!(document.documentElement.removeEventListener && document.removeEventListener);
    }();
    $.supportsEventListenerOptions = function() {
      var supported = 0;
      if ($.supportsAddEventListener) {
        try {
          var options = {
            get capture() {
              supported++;
              return false;
            },
            get once() {
              supported++;
              return false;
            },
            get passive() {
              supported++;
              return false;
            }
          };
          window.addEventListener("test", null, options);
          window.removeEventListener("test", null, options);
        } catch (e) {
          supported = 0;
        }
      }
      return supported >= 3;
    }();
    $.getCurrentPixelDensityRatio = function() {
      if ($.supportsCanvas) {
        var context = document.createElement("canvas").getContext("2d");
        var devicePixelRatio = window.devicePixelRatio || 1;
        var backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
        return Math.max(devicePixelRatio, 1) / backingStoreRatio;
      } else {
        return 1;
      }
    };
    $.pixelDensityRatio = $.getCurrentPixelDensityRatio();
  })(OpenSeadragon);
  (function($) {
    $.extend = function() {
      var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, length = arguments.length, deep = false, i = 1;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i = 2;
      }
      if (typeof target !== "object" && !OpenSeadragon.isFunction(target)) {
        target = {};
      }
      if (length === i) {
        target = this;
        --i;
      }
      for (;i < length; i++) {
        options = arguments[i];
        if (options !== null || options !== undefined) {
          for (name in options) {
            var descriptor = Object.getOwnPropertyDescriptor(options, name);
            if (descriptor !== undefined) {
              if (descriptor.get || descriptor.set) {
                Object.defineProperty(target, name, descriptor);
                continue;
              }
              copy = descriptor.value;
            } else {
              $.console.warn('Could not copy inherited property "' + name + '".');
              continue;
            }
            if (target === copy) {
              continue;
            }
            if (deep && copy && (OpenSeadragon.isPlainObject(copy) || (copyIsArray = OpenSeadragon.isArray(copy)))) {
              src = target[name];
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && OpenSeadragon.isArray(src) ? src : [];
              } else {
                clone = src && OpenSeadragon.isPlainObject(src) ? src : {};
              }
              target[name] = OpenSeadragon.extend(deep, clone, copy);
            } else if (copy !== undefined) {
              target[name] = copy;
            }
          }
        }
      }
      return target;
    };
    var isIOSDevice = function() {
      if (typeof navigator !== "object") {
        return false;
      }
      var userAgent = navigator.userAgent;
      if (typeof userAgent !== "string") {
        return false;
      }
      return userAgent.indexOf("iPhone") !== -1 || userAgent.indexOf("iPad") !== -1 || userAgent.indexOf("iPod") !== -1;
    };
    $.extend($, {
      DEFAULT_SETTINGS: {
        xmlPath: null,
        tileSources: null,
        tileHost: null,
        initialPage: 0,
        crossOriginPolicy: false,
        ajaxWithCredentials: false,
        loadTilesWithAjax: false,
        ajaxHeaders: {},
        splitHashDataForPost: false,
        panHorizontal: true,
        panVertical: true,
        constrainDuringPan: false,
        wrapHorizontal: false,
        wrapVertical: false,
        visibilityRatio: 0.5,
        minPixelRatio: 0.5,
        defaultZoomLevel: 0,
        minZoomLevel: null,
        maxZoomLevel: null,
        homeFillsViewer: false,
        clickTimeThreshold: 300,
        clickDistThreshold: 5,
        dblClickTimeThreshold: 300,
        dblClickDistThreshold: 20,
        springStiffness: 6.5,
        animationTime: 1.2,
        gestureSettingsMouse: {
          dragToPan: true,
          scrollToZoom: true,
          clickToZoom: true,
          dblClickToZoom: false,
          dblClickDragToZoom: false,
          pinchToZoom: false,
          zoomToRefPoint: true,
          flickEnabled: false,
          flickMinSpeed: 120,
          flickMomentum: 0.25,
          pinchRotate: false
        },
        gestureSettingsTouch: {
          dragToPan: true,
          scrollToZoom: false,
          clickToZoom: false,
          dblClickToZoom: true,
          dblClickDragToZoom: true,
          pinchToZoom: true,
          zoomToRefPoint: true,
          flickEnabled: true,
          flickMinSpeed: 120,
          flickMomentum: 0.25,
          pinchRotate: false
        },
        gestureSettingsPen: {
          dragToPan: true,
          scrollToZoom: false,
          clickToZoom: true,
          dblClickToZoom: false,
          dblClickDragToZoom: false,
          pinchToZoom: false,
          zoomToRefPoint: true,
          flickEnabled: false,
          flickMinSpeed: 120,
          flickMomentum: 0.25,
          pinchRotate: false
        },
        gestureSettingsUnknown: {
          dragToPan: true,
          scrollToZoom: false,
          clickToZoom: false,
          dblClickToZoom: true,
          dblClickDragToZoom: false,
          pinchToZoom: true,
          zoomToRefPoint: true,
          flickEnabled: true,
          flickMinSpeed: 120,
          flickMomentum: 0.25,
          pinchRotate: false
        },
        zoomPerClick: 2,
        zoomPerScroll: 1.2,
        zoomPerDblClickDrag: 1.2,
        zoomPerSecond: 1,
        blendTime: 0,
        alwaysBlend: false,
        autoHideControls: true,
        immediateRender: false,
        minZoomImageRatio: 0.9,
        maxZoomPixelRatio: 1.1,
        smoothTileEdgesMinZoom: 1.1,
        iOSDevice: isIOSDevice(),
        pixelsPerWheelLine: 40,
        pixelsPerArrowPress: 40,
        autoResize: true,
        preserveImageSizeOnResize: false,
        minScrollDeltaTime: 50,
        rotationIncrement: 90,
        maxTilesPerFrame: 1,
        showSequenceControl: true,
        sequenceControlAnchor: null,
        preserveViewport: false,
        preserveOverlays: false,
        navPrevNextWrap: false,
        showNavigationControl: true,
        navigationControlAnchor: null,
        showZoomControl: true,
        showHomeControl: true,
        showFullPageControl: true,
        showRotationControl: false,
        showFlipControl: false,
        controlsFadeDelay: 2000,
        controlsFadeLength: 1500,
        mouseNavEnabled: true,
        showNavigator: false,
        navigatorElement: null,
        navigatorId: null,
        navigatorPosition: null,
        navigatorSizeRatio: 0.2,
        navigatorMaintainSizeRatio: false,
        navigatorTop: null,
        navigatorLeft: null,
        navigatorHeight: null,
        navigatorWidth: null,
        navigatorAutoResize: true,
        navigatorAutoFade: true,
        navigatorRotate: true,
        navigatorBackground: "#000",
        navigatorOpacity: 0.8,
        navigatorBorderColor: "#555",
        navigatorDisplayRegionColor: "#900",
        degrees: 0,
        flipped: false,
        overlayPreserveContentDirection: true,
        opacity: 1,
        compositeOperation: null,
        drawer: ["webgl", "canvas", "html"],
        drawerOptions: {
          webgl: {},
          canvas: {},
          html: {},
          custom: {}
        },
        preload: false,
        imageSmoothingEnabled: true,
        placeholderFillStyle: null,
        subPixelRoundingForTransparency: null,
        showReferenceStrip: false,
        referenceStripScroll: "horizontal",
        referenceStripElement: null,
        referenceStripHeight: null,
        referenceStripWidth: null,
        referenceStripPosition: "BOTTOM_LEFT",
        referenceStripSizeRatio: 0.2,
        collectionRows: 3,
        collectionColumns: 0,
        collectionLayout: "horizontal",
        collectionMode: false,
        collectionTileSize: 800,
        collectionTileMargin: 80,
        imageLoaderLimit: 0,
        maxImageCacheCount: 200,
        timeout: 30000,
        tileRetryMax: 0,
        tileRetryDelay: 2500,
        prefixUrl: "/images/",
        navImages: {
          zoomIn: {
            REST: "zoomin_rest.png",
            GROUP: "zoomin_grouphover.png",
            HOVER: "zoomin_hover.png",
            DOWN: "zoomin_pressed.png"
          },
          zoomOut: {
            REST: "zoomout_rest.png",
            GROUP: "zoomout_grouphover.png",
            HOVER: "zoomout_hover.png",
            DOWN: "zoomout_pressed.png"
          },
          home: {
            REST: "home_rest.png",
            GROUP: "home_grouphover.png",
            HOVER: "home_hover.png",
            DOWN: "home_pressed.png"
          },
          fullpage: {
            REST: "fullpage_rest.png",
            GROUP: "fullpage_grouphover.png",
            HOVER: "fullpage_hover.png",
            DOWN: "fullpage_pressed.png"
          },
          rotateleft: {
            REST: "rotateleft_rest.png",
            GROUP: "rotateleft_grouphover.png",
            HOVER: "rotateleft_hover.png",
            DOWN: "rotateleft_pressed.png"
          },
          rotateright: {
            REST: "rotateright_rest.png",
            GROUP: "rotateright_grouphover.png",
            HOVER: "rotateright_hover.png",
            DOWN: "rotateright_pressed.png"
          },
          flip: {
            REST: "flip_rest.png",
            GROUP: "flip_grouphover.png",
            HOVER: "flip_hover.png",
            DOWN: "flip_pressed.png"
          },
          previous: {
            REST: "previous_rest.png",
            GROUP: "previous_grouphover.png",
            HOVER: "previous_hover.png",
            DOWN: "previous_pressed.png"
          },
          next: {
            REST: "next_rest.png",
            GROUP: "next_grouphover.png",
            HOVER: "next_hover.png",
            DOWN: "next_pressed.png"
          }
        },
        debugMode: false,
        debugGridColor: ["#437AB2", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666"],
        silenceMultiImageWarnings: false
      },
      delegate: function(object, method) {
        return function() {
          var args = arguments;
          if (args === undefined) {
            args = [];
          }
          return method.apply(object, args);
        };
      },
      BROWSERS: {
        UNKNOWN: 0,
        IE: 1,
        FIREFOX: 2,
        SAFARI: 3,
        CHROME: 4,
        OPERA: 5,
        EDGE: 6,
        CHROMEEDGE: 7
      },
      SUBPIXEL_ROUNDING_OCCURRENCES: {
        NEVER: 0,
        ONLY_AT_REST: 1,
        ALWAYS: 2
      },
      _viewers: new Map,
      getViewer: function(element) {
        return $._viewers.get(this.getElement(element));
      },
      getElement: function(element) {
        if (typeof element === "string") {
          element = document.getElementById(element);
        }
        return element;
      },
      getElementPosition: function(element) {
        var result = new $.Point, isFixed, offsetParent;
        element = $.getElement(element);
        isFixed = $.getElementStyle(element).position === "fixed";
        offsetParent = getOffsetParent(element, isFixed);
        while (offsetParent) {
          result.x += element.offsetLeft;
          result.y += element.offsetTop;
          if (isFixed) {
            result = result.plus($.getPageScroll());
          }
          element = offsetParent;
          isFixed = $.getElementStyle(element).position === "fixed";
          offsetParent = getOffsetParent(element, isFixed);
        }
        return result;
      },
      getElementOffset: function(element) {
        element = $.getElement(element);
        var doc = element && element.ownerDocument, docElement, win, boundingRect = { top: 0, left: 0 };
        if (!doc) {
          return new $.Point;
        }
        docElement = doc.documentElement;
        if (typeof element.getBoundingClientRect !== "undefined") {
          boundingRect = element.getBoundingClientRect();
        }
        win = doc === doc.window ? doc : doc.nodeType === 9 ? doc.defaultView || doc.parentWindow : false;
        return new $.Point(boundingRect.left + (win.pageXOffset || docElement.scrollLeft) - (docElement.clientLeft || 0), boundingRect.top + (win.pageYOffset || docElement.scrollTop) - (docElement.clientTop || 0));
      },
      getElementSize: function(element) {
        element = $.getElement(element);
        return new $.Point(element.clientWidth, element.clientHeight);
      },
      getElementStyle: document.documentElement.currentStyle ? function(element) {
        element = $.getElement(element);
        return element.currentStyle;
      } : function(element) {
        element = $.getElement(element);
        return window.getComputedStyle(element, "");
      },
      getCssPropertyWithVendorPrefix: function(property) {
        var memo = {};
        $.getCssPropertyWithVendorPrefix = function(property2) {
          if (memo[property2] !== undefined) {
            return memo[property2];
          }
          var style = document.createElement("div").style;
          var result = null;
          if (style[property2] !== undefined) {
            result = property2;
          } else {
            var prefixes = [
              "Webkit",
              "Moz",
              "MS",
              "O",
              "webkit",
              "moz",
              "ms",
              "o"
            ];
            var suffix = $.capitalizeFirstLetter(property2);
            for (var i = 0;i < prefixes.length; i++) {
              var prop = prefixes[i] + suffix;
              if (style[prop] !== undefined) {
                result = prop;
                break;
              }
            }
          }
          memo[property2] = result;
          return result;
        };
        return $.getCssPropertyWithVendorPrefix(property);
      },
      capitalizeFirstLetter: function(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
      },
      positiveModulo: function(number, modulo) {
        var result = number % modulo;
        if (result < 0) {
          result += modulo;
        }
        return result;
      },
      pointInElement: function(element, point) {
        element = $.getElement(element);
        var offset = $.getElementOffset(element), size = $.getElementSize(element);
        return point.x >= offset.x && point.x < offset.x + size.x && point.y < offset.y + size.y && point.y >= offset.y;
      },
      getMousePosition: function(event) {
        if (typeof event.pageX === "number") {
          $.getMousePosition = function(event2) {
            var result = new $.Point;
            result.x = event2.pageX;
            result.y = event2.pageY;
            return result;
          };
        } else if (typeof event.clientX === "number") {
          $.getMousePosition = function(event2) {
            var result = new $.Point;
            result.x = event2.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
            result.y = event2.clientY + document.body.scrollTop + document.documentElement.scrollTop;
            return result;
          };
        } else {
          throw new Error("Unknown event mouse position, no known technique.");
        }
        return $.getMousePosition(event);
      },
      getPageScroll: function() {
        var docElement = document.documentElement || {}, body = document.body || {};
        if (typeof window.pageXOffset === "number") {
          $.getPageScroll = function() {
            return new $.Point(window.pageXOffset, window.pageYOffset);
          };
        } else if (body.scrollLeft || body.scrollTop) {
          $.getPageScroll = function() {
            return new $.Point(document.body.scrollLeft, document.body.scrollTop);
          };
        } else if (docElement.scrollLeft || docElement.scrollTop) {
          $.getPageScroll = function() {
            return new $.Point(document.documentElement.scrollLeft, document.documentElement.scrollTop);
          };
        } else {
          return new $.Point(0, 0);
        }
        return $.getPageScroll();
      },
      setPageScroll: function(scroll) {
        if (typeof window.scrollTo !== "undefined") {
          $.setPageScroll = function(scroll2) {
            window.scrollTo(scroll2.x, scroll2.y);
          };
        } else {
          var originalScroll = $.getPageScroll();
          if (originalScroll.x === scroll.x && originalScroll.y === scroll.y) {
            return;
          }
          document.body.scrollLeft = scroll.x;
          document.body.scrollTop = scroll.y;
          var currentScroll = $.getPageScroll();
          if (currentScroll.x !== originalScroll.x && currentScroll.y !== originalScroll.y) {
            $.setPageScroll = function(scroll2) {
              document.body.scrollLeft = scroll2.x;
              document.body.scrollTop = scroll2.y;
            };
            return;
          }
          document.documentElement.scrollLeft = scroll.x;
          document.documentElement.scrollTop = scroll.y;
          currentScroll = $.getPageScroll();
          if (currentScroll.x !== originalScroll.x && currentScroll.y !== originalScroll.y) {
            $.setPageScroll = function(scroll2) {
              document.documentElement.scrollLeft = scroll2.x;
              document.documentElement.scrollTop = scroll2.y;
            };
            return;
          }
          $.setPageScroll = function(scroll2) {};
        }
        $.setPageScroll(scroll);
      },
      getWindowSize: function() {
        var docElement = document.documentElement || {}, body = document.body || {};
        if (typeof window.innerWidth === "number") {
          $.getWindowSize = function() {
            return new $.Point(window.innerWidth, window.innerHeight);
          };
        } else if (docElement.clientWidth || docElement.clientHeight) {
          $.getWindowSize = function() {
            return new $.Point(document.documentElement.clientWidth, document.documentElement.clientHeight);
          };
        } else if (body.clientWidth || body.clientHeight) {
          $.getWindowSize = function() {
            return new $.Point(document.body.clientWidth, document.body.clientHeight);
          };
        } else {
          throw new Error("Unknown window size, no known technique.");
        }
        return $.getWindowSize();
      },
      makeCenteredNode: function(element) {
        element = $.getElement(element);
        var wrappers = [
          $.makeNeutralElement("div"),
          $.makeNeutralElement("div"),
          $.makeNeutralElement("div")
        ];
        $.extend(wrappers[0].style, {
          display: "table",
          height: "100%",
          width: "100%"
        });
        $.extend(wrappers[1].style, {
          display: "table-row"
        });
        $.extend(wrappers[2].style, {
          display: "table-cell",
          verticalAlign: "middle",
          textAlign: "center"
        });
        wrappers[0].appendChild(wrappers[1]);
        wrappers[1].appendChild(wrappers[2]);
        wrappers[2].appendChild(element);
        return wrappers[0];
      },
      makeNeutralElement: function(tagName) {
        var element = document.createElement(tagName), style = element.style;
        style.background = "transparent none";
        style.border = "none";
        style.margin = "0px";
        style.padding = "0px";
        style.position = "static";
        return element;
      },
      now: function() {
        if (Date.now) {
          $.now = Date.now;
        } else {
          $.now = function() {
            return new Date().getTime();
          };
        }
        return $.now();
      },
      makeTransparentImage: function(src) {
        var img = $.makeNeutralElement("img");
        img.src = src;
        return img;
      },
      setElementOpacity: function(element, opacity, usesAlpha) {
        var ieOpacity, ieFilter;
        element = $.getElement(element);
        if (usesAlpha && !$.Browser.alpha) {
          opacity = Math.round(opacity);
        }
        if ($.Browser.opacity) {
          element.style.opacity = opacity < 1 ? opacity : "";
        } else {
          if (opacity < 1) {
            ieOpacity = Math.round(100 * opacity);
            ieFilter = "alpha(opacity=" + ieOpacity + ")";
            element.style.filter = ieFilter;
          } else {
            element.style.filter = "";
          }
        }
      },
      setElementTouchActionNone: function(element) {
        element = $.getElement(element);
        if (typeof element.style.touchAction !== "undefined") {
          element.style.touchAction = "none";
        } else if (typeof element.style.msTouchAction !== "undefined") {
          element.style.msTouchAction = "none";
        }
      },
      setElementPointerEvents: function(element, value) {
        element = $.getElement(element);
        if (typeof element.style !== "undefined" && typeof element.style.pointerEvents !== "undefined") {
          element.style.pointerEvents = value;
        }
      },
      setElementPointerEventsNone: function(element) {
        $.setElementPointerEvents(element, "none");
      },
      addClass: function(element, className) {
        element = $.getElement(element);
        if (!element.className) {
          element.className = className;
        } else if ((" " + element.className + " ").indexOf(" " + className + " ") === -1) {
          element.className += " " + className;
        }
      },
      indexOf: function(array, searchElement, fromIndex) {
        if (Array.prototype.indexOf) {
          this.indexOf = function(array2, searchElement2, fromIndex2) {
            return array2.indexOf(searchElement2, fromIndex2);
          };
        } else {
          this.indexOf = function(array2, searchElement2, fromIndex2) {
            var i, pivot = fromIndex2 ? fromIndex2 : 0, length;
            if (!array2) {
              throw new TypeError;
            }
            length = array2.length;
            if (length === 0 || pivot >= length) {
              return -1;
            }
            if (pivot < 0) {
              pivot = length - Math.abs(pivot);
            }
            for (i = pivot;i < length; i++) {
              if (array2[i] === searchElement2) {
                return i;
              }
            }
            return -1;
          };
        }
        return this.indexOf(array, searchElement, fromIndex);
      },
      removeClass: function(element, className) {
        var oldClasses, newClasses = [], i;
        element = $.getElement(element);
        oldClasses = element.className.split(/\s+/);
        for (i = 0;i < oldClasses.length; i++) {
          if (oldClasses[i] && oldClasses[i] !== className) {
            newClasses.push(oldClasses[i]);
          }
        }
        element.className = newClasses.join(" ");
      },
      normalizeEventListenerOptions: function(options) {
        var opts;
        if (typeof options !== "undefined") {
          if (typeof options === "boolean") {
            opts = $.supportsEventListenerOptions ? { capture: options } : options;
          } else {
            opts = $.supportsEventListenerOptions ? options : typeof options.capture !== "undefined" ? options.capture : false;
          }
        } else {
          opts = $.supportsEventListenerOptions ? { capture: false } : false;
        }
        return opts;
      },
      addEvent: function() {
        if ($.supportsAddEventListener) {
          return function(element, eventName, handler, options) {
            options = $.normalizeEventListenerOptions(options);
            element = $.getElement(element);
            element.addEventListener(eventName, handler, options);
          };
        } else if (document.documentElement.attachEvent && document.attachEvent) {
          return function(element, eventName, handler) {
            element = $.getElement(element);
            element.attachEvent("on" + eventName, handler);
          };
        } else {
          throw new Error("No known event model.");
        }
      }(),
      removeEvent: function() {
        if ($.supportsRemoveEventListener) {
          return function(element, eventName, handler, options) {
            options = $.normalizeEventListenerOptions(options);
            element = $.getElement(element);
            element.removeEventListener(eventName, handler, options);
          };
        } else if (document.documentElement.detachEvent && document.detachEvent) {
          return function(element, eventName, handler) {
            element = $.getElement(element);
            element.detachEvent("on" + eventName, handler);
          };
        } else {
          throw new Error("No known event model.");
        }
      }(),
      cancelEvent: function(event) {
        event.preventDefault();
      },
      eventIsCanceled: function(event) {
        return event.defaultPrevented;
      },
      stopEvent: function(event) {
        event.stopPropagation();
      },
      createCallback: function(object, method) {
        console.error("The createCallback function is deprecated and will be removed in future versions. Please use alternativeFunction instead.");
        var initialArgs = [], i;
        for (i = 2;i < arguments.length; i++) {
          initialArgs.push(arguments[i]);
        }
        return function() {
          var args = initialArgs.concat([]), i2;
          for (i2 = 0;i2 < arguments.length; i2++) {
            args.push(arguments[i2]);
          }
          return method.apply(object, args);
        };
      },
      getUrlParameter: function(key) {
        var value = URLPARAMS[key];
        return value ? value : null;
      },
      getUrlProtocol: function(url) {
        var match = url.match(/^([a-z]+:)\/\//i);
        if (match === null) {
          return window.location.protocol;
        }
        return match[1].toLowerCase();
      },
      createAjaxRequest: function() {
        if (window.XMLHttpRequest) {
          $.createAjaxRequest = function() {
            return new XMLHttpRequest;
          };
          return new XMLHttpRequest;
        } else {
          throw new Error("Browser doesn't support XMLHttpRequest.");
        }
      },
      makeAjaxRequest: function(url, onSuccess, onError) {
        var withCredentials;
        var headers;
        var responseType;
        var postData;
        if ($.isPlainObject(url)) {
          onSuccess = url.success;
          onError = url.error;
          withCredentials = url.withCredentials;
          headers = url.headers;
          responseType = url.responseType || null;
          postData = url.postData || null;
          url = url.url;
        }
        var protocol = $.getUrlProtocol(url);
        var request = $.createAjaxRequest();
        if (!$.isFunction(onSuccess)) {
          throw new Error("makeAjaxRequest requires a success callback");
        }
        request.onreadystatechange = function() {
          if (request.readyState === 4) {
            request.onreadystatechange = function() {};
            if (request.status >= 200 && request.status < 300 || request.status === 0 && protocol !== "http:" && protocol !== "https:") {
              onSuccess(request);
            } else {
              if ($.isFunction(onError)) {
                onError(request);
              } else {
                $.console.error("AJAX request returned %d: %s", request.status, url);
              }
            }
          }
        };
        var method = postData ? "POST" : "GET";
        try {
          request.open(method, url, true);
          if (responseType) {
            request.responseType = responseType;
          }
          if (headers) {
            for (var headerName in headers) {
              if (Object.prototype.hasOwnProperty.call(headers, headerName) && headers[headerName]) {
                request.setRequestHeader(headerName, headers[headerName]);
              }
            }
          }
          if (withCredentials) {
            request.withCredentials = true;
          }
          request.send(postData);
        } catch (e) {
          $.console.error("%s while making AJAX request: %s", e.name, e.message);
          request.onreadystatechange = function() {};
          if ($.isFunction(onError)) {
            onError(request, e);
          }
        }
        return request;
      },
      jsonp: function(options) {
        var script, url = options.url, head = document.head || document.getElementsByTagName("head")[0] || document.documentElement, jsonpCallback = options.callbackName || "openseadragon" + $.now(), previous = window[jsonpCallback], replace = "$1" + jsonpCallback + "$2", callbackParam = options.param || "callback", callback = options.callback;
        url = url.replace(/(=)\?(&|$)|\?\?/i, replace);
        url += (/\?/.test(url) ? "&" : "?") + callbackParam + "=" + jsonpCallback;
        window[jsonpCallback] = function(response) {
          if (!previous) {
            try {
              delete window[jsonpCallback];
            } catch (e) {}
          } else {
            window[jsonpCallback] = previous;
          }
          if (callback && $.isFunction(callback)) {
            callback(response);
          }
        };
        script = document.createElement("script");
        if (options.async !== undefined || options.async !== false) {
          script.async = "async";
        }
        if (options.scriptCharset) {
          script.charset = options.scriptCharset;
        }
        script.src = url;
        script.onload = script.onreadystatechange = function(_, isAbort) {
          if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {
            script.onload = script.onreadystatechange = null;
            if (head && script.parentNode) {
              head.removeChild(script);
            }
            script = undefined;
          }
        };
        head.insertBefore(script, head.firstChild);
      },
      createFromDZI: function() {
        throw "OpenSeadragon.createFromDZI is deprecated, use Viewer.open.";
      },
      parseXml: function(string) {
        if (window.DOMParser) {
          $.parseXml = function(string2) {
            var xmlDoc = null, parser;
            parser = new DOMParser;
            xmlDoc = parser.parseFromString(string2, "text/xml");
            return xmlDoc;
          };
        } else {
          throw new Error("Browser doesn't support XML DOM.");
        }
        return $.parseXml(string);
      },
      parseJSON: function(string) {
        $.parseJSON = window.JSON.parse;
        return $.parseJSON(string);
      },
      imageFormatSupported: function(extension) {
        extension = extension ? extension : "";
        return !!FILEFORMATS[extension.toLowerCase()];
      },
      setImageFormatsSupported: function(formats) {
        $.extend(FILEFORMATS, formats);
      }
    });
    var nullfunction = function(msg) {};
    $.console = window.console || {
      log: nullfunction,
      debug: nullfunction,
      info: nullfunction,
      warn: nullfunction,
      error: nullfunction,
      assert: nullfunction
    };
    $.Browser = {
      vendor: $.BROWSERS.UNKNOWN,
      version: 0,
      alpha: true
    };
    var FILEFORMATS = {
      avif: true,
      bmp: false,
      jpeg: true,
      jpg: true,
      png: true,
      tif: false,
      wdp: false,
      webp: true
    }, URLPARAMS = {};
    (function() {
      var { appVersion: ver, userAgent: ua } = navigator, regex;
      switch (navigator.appName) {
        case "Microsoft Internet Explorer":
          if (!!window.attachEvent && !!window.ActiveXObject) {
            $.Browser.vendor = $.BROWSERS.IE;
            $.Browser.version = parseFloat(ua.substring(ua.indexOf("MSIE") + 5, ua.indexOf(";", ua.indexOf("MSIE"))));
          }
          break;
        case "Netscape":
          if (window.addEventListener) {
            if (ua.indexOf("Edge") >= 0) {
              $.Browser.vendor = $.BROWSERS.EDGE;
              $.Browser.version = parseFloat(ua.substring(ua.indexOf("Edge") + 5));
            } else if (ua.indexOf("Edg") >= 0) {
              $.Browser.vendor = $.BROWSERS.CHROMEEDGE;
              $.Browser.version = parseFloat(ua.substring(ua.indexOf("Edg") + 4));
            } else if (ua.indexOf("Firefox") >= 0) {
              $.Browser.vendor = $.BROWSERS.FIREFOX;
              $.Browser.version = parseFloat(ua.substring(ua.indexOf("Firefox") + 8));
            } else if (ua.indexOf("Safari") >= 0) {
              $.Browser.vendor = ua.indexOf("Chrome") >= 0 ? $.BROWSERS.CHROME : $.BROWSERS.SAFARI;
              $.Browser.version = parseFloat(ua.substring(ua.substring(0, ua.indexOf("Safari")).lastIndexOf("/") + 1, ua.indexOf("Safari")));
            } else {
              regex = new RegExp("Trident/.*rv:([0-9]{1,}[.0-9]{0,})");
              if (regex.exec(ua) !== null) {
                $.Browser.vendor = $.BROWSERS.IE;
                $.Browser.version = parseFloat(RegExp.$1);
              }
            }
          }
          break;
        case "Opera":
          $.Browser.vendor = $.BROWSERS.OPERA;
          $.Browser.version = parseFloat(ver);
          break;
      }
      var query = window.location.search.substring(1), parts = query.split("&"), part, sep, i;
      for (i = 0;i < parts.length; i++) {
        part = parts[i];
        sep = part.indexOf("=");
        if (sep > 0) {
          var key = part.substring(0, sep), value = part.substring(sep + 1);
          try {
            URLPARAMS[key] = decodeURIComponent(value);
          } catch (e) {
            $.console.error("Ignoring malformed URL parameter: %s=%s", key, value);
          }
        }
      }
      $.Browser.alpha = !($.Browser.vendor === $.BROWSERS.CHROME && $.Browser.version < 2);
      $.Browser.opacity = true;
      if ($.Browser.vendor === $.BROWSERS.IE) {
        $.console.error("Internet Explorer is not supported by OpenSeadragon");
      }
    })();
    (function(w) {
      var requestAnimationFrame = w.requestAnimationFrame || w.mozRequestAnimationFrame || w.webkitRequestAnimationFrame || w.msRequestAnimationFrame;
      var cancelAnimationFrame = w.cancelAnimationFrame || w.mozCancelAnimationFrame || w.webkitCancelAnimationFrame || w.msCancelAnimationFrame;
      if (requestAnimationFrame && cancelAnimationFrame) {
        $.requestAnimationFrame = function() {
          return requestAnimationFrame.apply(w, arguments);
        };
        $.cancelAnimationFrame = function() {
          return cancelAnimationFrame.apply(w, arguments);
        };
      } else {
        var aAnimQueue = [], processing = [], iRequestId = 0, iIntervalId;
        $.requestAnimationFrame = function(callback) {
          aAnimQueue.push([++iRequestId, callback]);
          if (!iIntervalId) {
            iIntervalId = setInterval(function() {
              if (aAnimQueue.length) {
                var time = $.now();
                var temp = processing;
                processing = aAnimQueue;
                aAnimQueue = temp;
                while (processing.length) {
                  processing.shift()[1](time);
                }
              } else {
                clearInterval(iIntervalId);
                iIntervalId = undefined;
              }
            }, 1000 / 50);
          }
          return iRequestId;
        };
        $.cancelAnimationFrame = function(requestId) {
          var i, j;
          for (i = 0, j = aAnimQueue.length;i < j; i += 1) {
            if (aAnimQueue[i][0] === requestId) {
              aAnimQueue.splice(i, 1);
              return;
            }
          }
          for (i = 0, j = processing.length;i < j; i += 1) {
            if (processing[i][0] === requestId) {
              processing.splice(i, 1);
              return;
            }
          }
        };
      }
    })(window);
    function getOffsetParent(element, isFixed) {
      if (isFixed && element !== document.body) {
        return document.body;
      } else {
        return element.offsetParent;
      }
    }
  })(OpenSeadragon);
  (function(root, factory) {
    if (typeof define === "function" && define.amd) {
      define([], factory);
    } else if (typeof module === "object" && module.exports) {
      module.exports = factory();
    } else {
      root.OpenSeadragon = factory();
    }
  })(exports, function() {
    return OpenSeadragon;
  });
  (function($) {

    class Mat3 {
      constructor(values) {
        if (!values) {
          values = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ];
        }
        this.values = values;
      }
      static makeIdentity() {
        return new Mat3([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      }
      static makeTranslation(tx, ty) {
        return new Mat3([
          1,
          0,
          0,
          0,
          1,
          0,
          tx,
          ty,
          1
        ]);
      }
      static makeRotation(angleInRadians) {
        var c = Math.cos(angleInRadians);
        var s = Math.sin(angleInRadians);
        return new Mat3([
          c,
          -s,
          0,
          s,
          c,
          0,
          0,
          0,
          1
        ]);
      }
      static makeScaling(sx, sy) {
        return new Mat3([
          sx,
          0,
          0,
          0,
          sy,
          0,
          0,
          0,
          1
        ]);
      }
      multiply(other) {
        let a = this.values;
        let b = other.values;
        var a00 = a[0 * 3 + 0];
        var a01 = a[0 * 3 + 1];
        var a02 = a[0 * 3 + 2];
        var a10 = a[1 * 3 + 0];
        var a11 = a[1 * 3 + 1];
        var a12 = a[1 * 3 + 2];
        var a20 = a[2 * 3 + 0];
        var a21 = a[2 * 3 + 1];
        var a22 = a[2 * 3 + 2];
        var b00 = b[0 * 3 + 0];
        var b01 = b[0 * 3 + 1];
        var b02 = b[0 * 3 + 2];
        var b10 = b[1 * 3 + 0];
        var b11 = b[1 * 3 + 1];
        var b12 = b[1 * 3 + 2];
        var b20 = b[2 * 3 + 0];
        var b21 = b[2 * 3 + 1];
        var b22 = b[2 * 3 + 2];
        return new Mat3([
          b00 * a00 + b01 * a10 + b02 * a20,
          b00 * a01 + b01 * a11 + b02 * a21,
          b00 * a02 + b01 * a12 + b02 * a22,
          b10 * a00 + b11 * a10 + b12 * a20,
          b10 * a01 + b11 * a11 + b12 * a21,
          b10 * a02 + b11 * a12 + b12 * a22,
          b20 * a00 + b21 * a10 + b22 * a20,
          b20 * a01 + b21 * a11 + b22 * a21,
          b20 * a02 + b21 * a12 + b22 * a22
        ]);
      }
    }
    $.Mat3 = Mat3;
  })(OpenSeadragon);
  (function($) {
    var fullScreenApi = {
      supportsFullScreen: false,
      isFullScreen: function() {
        return false;
      },
      getFullScreenElement: function() {
        return null;
      },
      requestFullScreen: function() {},
      exitFullScreen: function() {},
      cancelFullScreen: function() {},
      fullScreenEventName: "",
      fullScreenErrorEventName: ""
    };
    if (document.exitFullscreen) {
      fullScreenApi.supportsFullScreen = true;
      fullScreenApi.getFullScreenElement = function() {
        return document.fullscreenElement;
      };
      fullScreenApi.requestFullScreen = function(element) {
        return element.requestFullscreen().catch(function(msg) {
          $.console.error("Fullscreen request failed: ", msg);
        });
      };
      fullScreenApi.exitFullScreen = function() {
        document.exitFullscreen().catch(function(msg) {
          $.console.error("Error while exiting fullscreen: ", msg);
        });
      };
      fullScreenApi.fullScreenEventName = "fullscreenchange";
      fullScreenApi.fullScreenErrorEventName = "fullscreenerror";
    } else if (document.msExitFullscreen) {
      fullScreenApi.supportsFullScreen = true;
      fullScreenApi.getFullScreenElement = function() {
        return document.msFullscreenElement;
      };
      fullScreenApi.requestFullScreen = function(element) {
        return element.msRequestFullscreen();
      };
      fullScreenApi.exitFullScreen = function() {
        document.msExitFullscreen();
      };
      fullScreenApi.fullScreenEventName = "MSFullscreenChange";
      fullScreenApi.fullScreenErrorEventName = "MSFullscreenError";
    } else if (document.webkitExitFullscreen) {
      fullScreenApi.supportsFullScreen = true;
      fullScreenApi.getFullScreenElement = function() {
        return document.webkitFullscreenElement;
      };
      fullScreenApi.requestFullScreen = function(element) {
        return element.webkitRequestFullscreen();
      };
      fullScreenApi.exitFullScreen = function() {
        document.webkitExitFullscreen();
      };
      fullScreenApi.fullScreenEventName = "webkitfullscreenchange";
      fullScreenApi.fullScreenErrorEventName = "webkitfullscreenerror";
    } else if (document.webkitCancelFullScreen) {
      fullScreenApi.supportsFullScreen = true;
      fullScreenApi.getFullScreenElement = function() {
        return document.webkitCurrentFullScreenElement;
      };
      fullScreenApi.requestFullScreen = function(element) {
        return element.webkitRequestFullScreen();
      };
      fullScreenApi.exitFullScreen = function() {
        document.webkitCancelFullScreen();
      };
      fullScreenApi.fullScreenEventName = "webkitfullscreenchange";
      fullScreenApi.fullScreenErrorEventName = "webkitfullscreenerror";
    } else if (document.mozCancelFullScreen) {
      fullScreenApi.supportsFullScreen = true;
      fullScreenApi.getFullScreenElement = function() {
        return document.mozFullScreenElement;
      };
      fullScreenApi.requestFullScreen = function(element) {
        return element.mozRequestFullScreen();
      };
      fullScreenApi.exitFullScreen = function() {
        document.mozCancelFullScreen();
      };
      fullScreenApi.fullScreenEventName = "mozfullscreenchange";
      fullScreenApi.fullScreenErrorEventName = "mozfullscreenerror";
    }
    fullScreenApi.isFullScreen = function() {
      return fullScreenApi.getFullScreenElement() !== null;
    };
    fullScreenApi.cancelFullScreen = function() {
      $.console.error("cancelFullScreen is deprecated. Use exitFullScreen instead.");
      fullScreenApi.exitFullScreen();
    };
    $.extend($, fullScreenApi);
  })(OpenSeadragon);
  (function($) {
    $.EventSource = function() {
      this.events = {};
      this._rejectedEventList = {};
    };
    $.EventSource.prototype = {
      addOnceHandler: function(eventName, handler, userData, times, priority) {
        var self2 = this;
        times = times || 1;
        var count = 0;
        var onceHandler = function(event) {
          count++;
          if (count === times) {
            self2.removeHandler(eventName, onceHandler);
          }
          return handler(event);
        };
        return this.addHandler(eventName, onceHandler, userData, priority);
      },
      addHandler: function(eventName, handler, userData, priority) {
        if (Object.prototype.hasOwnProperty.call(this._rejectedEventList, eventName)) {
          $.console.error(`Error adding handler for ${eventName}. ${this._rejectedEventList[eventName]}`);
          return false;
        }
        var events = this.events[eventName];
        if (!events) {
          this.events[eventName] = events = [];
        }
        if (handler && $.isFunction(handler)) {
          var index = events.length, event = { handler, userData: userData || null, priority: priority || 0 };
          events[index] = event;
          while (index > 0 && events[index - 1].priority < events[index].priority) {
            events[index] = events[index - 1];
            events[index - 1] = event;
            index--;
          }
        }
        return true;
      },
      removeHandler: function(eventName, handler) {
        var events = this.events[eventName], handlers = [], i;
        if (!events) {
          return;
        }
        if ($.isArray(events)) {
          for (i = 0;i < events.length; i++) {
            if (events[i].handler !== handler) {
              handlers.push(events[i]);
            }
          }
          this.events[eventName] = handlers;
        }
      },
      numberOfHandlers: function(eventName) {
        var events = this.events[eventName];
        if (!events) {
          return 0;
        }
        return events.length;
      },
      removeAllHandlers: function(eventName) {
        if (eventName) {
          this.events[eventName] = [];
        } else {
          for (var eventType in this.events) {
            this.events[eventType] = [];
          }
        }
      },
      getHandler: function(eventName) {
        var events = this.events[eventName];
        if (!events || !events.length) {
          return null;
        }
        events = events.length === 1 ? [events[0]] : Array.apply(null, events);
        return function(source, args) {
          var i, length = events.length;
          for (i = 0;i < length; i++) {
            if (events[i]) {
              args.eventSource = source;
              args.userData = events[i].userData;
              events[i].handler(args);
            }
          }
        };
      },
      raiseEvent: function(eventName, eventArgs) {
        if (Object.prototype.hasOwnProperty.call(this._rejectedEventList, eventName)) {
          $.console.error(`Error adding handler for ${eventName}. ${this._rejectedEventList[eventName]}`);
          return false;
        }
        var handler = this.getHandler(eventName);
        if (handler) {
          handler(this, eventArgs || {});
        }
        return true;
      },
      rejectEventHandler(eventName, errorMessage = "") {
        this._rejectedEventList[eventName] = errorMessage;
      },
      allowEventHandler(eventName) {
        delete this._rejectedEventList[eventName];
      }
    };
  })(OpenSeadragon);
  (function($) {
    var MOUSETRACKERS = [];
    var THIS = {};
    $.MouseTracker = function(options) {
      MOUSETRACKERS.push(this);
      var args = arguments;
      if (!$.isPlainObject(options)) {
        options = {
          element: args[0],
          clickTimeThreshold: args[1],
          clickDistThreshold: args[2]
        };
      }
      this.hash = Math.random();
      this.element = $.getElement(options.element);
      this.clickTimeThreshold = options.clickTimeThreshold || $.DEFAULT_SETTINGS.clickTimeThreshold;
      this.clickDistThreshold = options.clickDistThreshold || $.DEFAULT_SETTINGS.clickDistThreshold;
      this.dblClickTimeThreshold = options.dblClickTimeThreshold || $.DEFAULT_SETTINGS.dblClickTimeThreshold;
      this.dblClickDistThreshold = options.dblClickDistThreshold || $.DEFAULT_SETTINGS.dblClickDistThreshold;
      this.userData = options.userData || null;
      this.stopDelay = options.stopDelay || 50;
      this.preProcessEventHandler = options.preProcessEventHandler || null;
      this.contextMenuHandler = options.contextMenuHandler || null;
      this.enterHandler = options.enterHandler || null;
      this.leaveHandler = options.leaveHandler || null;
      this.exitHandler = options.exitHandler || null;
      this.overHandler = options.overHandler || null;
      this.outHandler = options.outHandler || null;
      this.pressHandler = options.pressHandler || null;
      this.nonPrimaryPressHandler = options.nonPrimaryPressHandler || null;
      this.releaseHandler = options.releaseHandler || null;
      this.nonPrimaryReleaseHandler = options.nonPrimaryReleaseHandler || null;
      this.moveHandler = options.moveHandler || null;
      this.scrollHandler = options.scrollHandler || null;
      this.clickHandler = options.clickHandler || null;
      this.dblClickHandler = options.dblClickHandler || null;
      this.dragHandler = options.dragHandler || null;
      this.dragEndHandler = options.dragEndHandler || null;
      this.pinchHandler = options.pinchHandler || null;
      this.stopHandler = options.stopHandler || null;
      this.keyDownHandler = options.keyDownHandler || null;
      this.keyUpHandler = options.keyUpHandler || null;
      this.keyHandler = options.keyHandler || null;
      this.focusHandler = options.focusHandler || null;
      this.blurHandler = options.blurHandler || null;
      var _this = this;
      THIS[this.hash] = {
        click: function(event) {
          onClick(_this, event);
        },
        dblclick: function(event) {
          onDblClick(_this, event);
        },
        keydown: function(event) {
          onKeyDown(_this, event);
        },
        keyup: function(event) {
          onKeyUp(_this, event);
        },
        keypress: function(event) {
          onKeyPress(_this, event);
        },
        focus: function(event) {
          onFocus(_this, event);
        },
        blur: function(event) {
          onBlur(_this, event);
        },
        contextmenu: function(event) {
          onContextMenu(_this, event);
        },
        wheel: function(event) {
          onWheel(_this, event);
        },
        mousewheel: function(event) {
          onMouseWheel(_this, event);
        },
        DOMMouseScroll: function(event) {
          onMouseWheel(_this, event);
        },
        MozMousePixelScroll: function(event) {
          onMouseWheel(_this, event);
        },
        losecapture: function(event) {
          onLoseCapture(_this, event);
        },
        mouseenter: function(event) {
          onPointerEnter(_this, event);
        },
        mouseleave: function(event) {
          onPointerLeave(_this, event);
        },
        mouseover: function(event) {
          onPointerOver(_this, event);
        },
        mouseout: function(event) {
          onPointerOut(_this, event);
        },
        mousedown: function(event) {
          onPointerDown(_this, event);
        },
        mouseup: function(event) {
          onPointerUp(_this, event);
        },
        mousemove: function(event) {
          onPointerMove(_this, event);
        },
        touchstart: function(event) {
          onTouchStart(_this, event);
        },
        touchend: function(event) {
          onTouchEnd(_this, event);
        },
        touchmove: function(event) {
          onTouchMove(_this, event);
        },
        touchcancel: function(event) {
          onTouchCancel(_this, event);
        },
        gesturestart: function(event) {
          onGestureStart(_this, event);
        },
        gesturechange: function(event) {
          onGestureChange(_this, event);
        },
        gotpointercapture: function(event) {
          onGotPointerCapture(_this, event);
        },
        lostpointercapture: function(event) {
          onLostPointerCapture(_this, event);
        },
        pointerenter: function(event) {
          onPointerEnter(_this, event);
        },
        pointerleave: function(event) {
          onPointerLeave(_this, event);
        },
        pointerover: function(event) {
          onPointerOver(_this, event);
        },
        pointerout: function(event) {
          onPointerOut(_this, event);
        },
        pointerdown: function(event) {
          onPointerDown(_this, event);
        },
        pointerup: function(event) {
          onPointerUp(_this, event);
        },
        pointermove: function(event) {
          onPointerMove(_this, event);
        },
        pointercancel: function(event) {
          onPointerCancel(_this, event);
        },
        pointerupcaptured: function(event) {
          onPointerUpCaptured(_this, event);
        },
        pointermovecaptured: function(event) {
          onPointerMoveCaptured(_this, event);
        },
        tracking: false,
        activePointersLists: [],
        lastClickPos: null,
        dblClickTimeOut: null,
        pinchGPoints: [],
        lastPinchDist: 0,
        currentPinchDist: 0,
        lastPinchCenter: null,
        currentPinchCenter: null,
        sentDragEvent: false
      };
      this.hasGestureHandlers = !!(this.pressHandler || this.nonPrimaryPressHandler || this.releaseHandler || this.nonPrimaryReleaseHandler || this.clickHandler || this.dblClickHandler || this.dragHandler || this.dragEndHandler || this.pinchHandler);
      this.hasScrollHandler = !!this.scrollHandler;
      if ($.MouseTracker.havePointerEvents) {
        $.setElementPointerEvents(this.element, "auto");
      }
      if (this.exitHandler) {
        $.console.error("MouseTracker.exitHandler is deprecated. Use MouseTracker.leaveHandler instead.");
      }
      if (!options.startDisabled) {
        this.setTracking(true);
      }
    };
    $.MouseTracker.prototype = {
      destroy: function() {
        var i;
        stopTracking(this);
        this.element = null;
        for (i = 0;i < MOUSETRACKERS.length; i++) {
          if (MOUSETRACKERS[i] === this) {
            MOUSETRACKERS.splice(i, 1);
            break;
          }
        }
        THIS[this.hash] = null;
        delete THIS[this.hash];
      },
      isTracking: function() {
        return THIS[this.hash].tracking;
      },
      setTracking: function(track) {
        if (track) {
          startTracking(this);
        } else {
          stopTracking(this);
        }
        return this;
      },
      getActivePointersListByType: function(type) {
        var delegate = THIS[this.hash], i, len = delegate ? delegate.activePointersLists.length : 0, list;
        for (i = 0;i < len; i++) {
          if (delegate.activePointersLists[i].type === type) {
            return delegate.activePointersLists[i];
          }
        }
        list = new $.MouseTracker.GesturePointList(type);
        if (delegate) {
          delegate.activePointersLists.push(list);
        }
        return list;
      },
      getActivePointerCount: function() {
        var delegate = THIS[this.hash], i, len = delegate.activePointersLists.length, count = 0;
        for (i = 0;i < len; i++) {
          count += delegate.activePointersLists[i].getLength();
        }
        return count;
      },
      preProcessEventHandler: function() {},
      contextMenuHandler: function() {},
      enterHandler: function() {},
      leaveHandler: function() {},
      exitHandler: function() {},
      overHandler: function() {},
      outHandler: function() {},
      pressHandler: function() {},
      nonPrimaryPressHandler: function() {},
      releaseHandler: function() {},
      nonPrimaryReleaseHandler: function() {},
      moveHandler: function() {},
      scrollHandler: function() {},
      clickHandler: function() {},
      dblClickHandler: function() {},
      dragHandler: function() {},
      dragEndHandler: function() {},
      pinchHandler: function() {},
      stopHandler: function() {},
      keyDownHandler: function() {},
      keyUpHandler: function() {},
      keyHandler: function() {},
      focusHandler: function() {},
      blurHandler: function() {}
    };
    var isInIframe = function() {
      try {
        return window.self !== window.top;
      } catch (e) {
        return true;
      }
    }();
    function canAccessEvents(target) {
      try {
        return target.addEventListener && target.removeEventListener;
      } catch (e) {
        return false;
      }
    }
    $.MouseTracker.gesturePointVelocityTracker = function() {
      var trackerPoints = [], intervalId = 0, lastTime = 0;
      var _generateGuid = function(tracker, gPoint) {
        return tracker.hash.toString() + gPoint.type + gPoint.id.toString();
      };
      var _doTracking = function() {
        var i, len = trackerPoints.length, trackPoint, gPoint, now = $.now(), elapsedTime, distance, speed;
        elapsedTime = now - lastTime;
        lastTime = now;
        for (i = 0;i < len; i++) {
          trackPoint = trackerPoints[i];
          gPoint = trackPoint.gPoint;
          gPoint.direction = Math.atan2(gPoint.currentPos.y - trackPoint.lastPos.y, gPoint.currentPos.x - trackPoint.lastPos.x);
          distance = trackPoint.lastPos.distanceTo(gPoint.currentPos);
          trackPoint.lastPos = gPoint.currentPos;
          speed = 1000 * distance / (elapsedTime + 1);
          gPoint.speed = 0.75 * speed + 0.25 * gPoint.speed;
        }
      };
      var addPoint = function(tracker, gPoint) {
        var guid = _generateGuid(tracker, gPoint);
        trackerPoints.push({
          guid,
          gPoint,
          lastPos: gPoint.currentPos
        });
        if (trackerPoints.length === 1) {
          lastTime = $.now();
          intervalId = window.setInterval(_doTracking, 50);
        }
      };
      var removePoint = function(tracker, gPoint) {
        var guid = _generateGuid(tracker, gPoint), i, len = trackerPoints.length;
        for (i = 0;i < len; i++) {
          if (trackerPoints[i].guid === guid) {
            trackerPoints.splice(i, 1);
            len--;
            if (len === 0) {
              window.clearInterval(intervalId);
            }
            break;
          }
        }
      };
      return {
        addPoint,
        removePoint
      };
    }();
    $.MouseTracker.captureElement = document;
    $.MouseTracker.wheelEventName = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== undefined ? "mousewheel" : "DOMMouseScroll";
    $.MouseTracker.subscribeEvents = ["click", "dblclick", "keydown", "keyup", "keypress", "focus", "blur", "contextmenu", $.MouseTracker.wheelEventName];
    if ($.MouseTracker.wheelEventName === "DOMMouseScroll") {
      $.MouseTracker.subscribeEvents.push("MozMousePixelScroll");
    }
    if (window.PointerEvent) {
      $.MouseTracker.havePointerEvents = true;
      $.MouseTracker.subscribeEvents.push("pointerenter", "pointerleave", "pointerover", "pointerout", "pointerdown", "pointerup", "pointermove", "pointercancel");
      $.MouseTracker.havePointerCapture = function() {
        var divElement = document.createElement("div");
        return $.isFunction(divElement.setPointerCapture) && $.isFunction(divElement.releasePointerCapture);
      }();
      if ($.MouseTracker.havePointerCapture) {
        $.MouseTracker.subscribeEvents.push("gotpointercapture", "lostpointercapture");
      }
    } else {
      $.MouseTracker.havePointerEvents = false;
      $.MouseTracker.subscribeEvents.push("mouseenter", "mouseleave", "mouseover", "mouseout", "mousedown", "mouseup", "mousemove");
      $.MouseTracker.mousePointerId = "legacy-mouse";
      $.MouseTracker.havePointerCapture = function() {
        var divElement = document.createElement("div");
        return $.isFunction(divElement.setCapture) && $.isFunction(divElement.releaseCapture);
      }();
      if ($.MouseTracker.havePointerCapture) {
        $.MouseTracker.subscribeEvents.push("losecapture");
      }
      if ("ontouchstart" in window) {
        $.MouseTracker.subscribeEvents.push("touchstart", "touchend", "touchmove", "touchcancel");
      }
      if ("ongesturestart" in window) {
        $.MouseTracker.subscribeEvents.push("gesturestart", "gesturechange");
      }
    }
    $.MouseTracker.GesturePointList = function(type) {
      this._gPoints = [];
      this.type = type;
      this.buttons = 0;
      this.contacts = 0;
      this.clicks = 0;
      this.captureCount = 0;
    };
    $.MouseTracker.GesturePointList.prototype = {
      getLength: function() {
        return this._gPoints.length;
      },
      asArray: function() {
        return this._gPoints;
      },
      add: function(gp) {
        return this._gPoints.push(gp);
      },
      removeById: function(id) {
        var i, len = this._gPoints.length;
        for (i = 0;i < len; i++) {
          if (this._gPoints[i].id === id) {
            this._gPoints.splice(i, 1);
            break;
          }
        }
        return this._gPoints.length;
      },
      getByIndex: function(index) {
        if (index < this._gPoints.length) {
          return this._gPoints[index];
        }
        return null;
      },
      getById: function(id) {
        var i, len = this._gPoints.length;
        for (i = 0;i < len; i++) {
          if (this._gPoints[i].id === id) {
            return this._gPoints[i];
          }
        }
        return null;
      },
      getPrimary: function(id) {
        var i, len = this._gPoints.length;
        for (i = 0;i < len; i++) {
          if (this._gPoints[i].isPrimary) {
            return this._gPoints[i];
          }
        }
        return null;
      },
      addContact: function() {
        ++this.contacts;
        if (this.contacts > 1 && (this.type === "mouse" || this.type === "pen")) {
          $.console.warn("GesturePointList.addContact() Implausible contacts value");
          this.contacts = 1;
        }
      },
      removeContact: function() {
        --this.contacts;
        if (this.contacts < 0) {
          this.contacts = 0;
        }
      }
    };
    function clearTrackedPointers(tracker) {
      var delegate = THIS[tracker.hash], i, j, pointsList, gPoints, gPointsToRemove, pointerListCount = delegate.activePointersLists.length;
      for (i = 0;i < pointerListCount; i++) {
        pointsList = delegate.activePointersLists[i];
        if (pointsList.getLength() > 0) {
          gPointsToRemove = [];
          gPoints = pointsList.asArray();
          for (j = 0;j < gPoints.length; j++) {
            gPointsToRemove.push(gPoints[j]);
          }
          for (j = 0;j < gPointsToRemove.length; j++) {
            stopTrackingPointer(tracker, pointsList, gPointsToRemove[j]);
          }
        }
      }
      for (i = 0;i < pointerListCount; i++) {
        delegate.activePointersLists.pop();
      }
      delegate.sentDragEvent = false;
    }
    function startTracking(tracker) {
      var delegate = THIS[tracker.hash], event, i;
      if (!delegate.tracking) {
        for (i = 0;i < $.MouseTracker.subscribeEvents.length; i++) {
          event = $.MouseTracker.subscribeEvents[i];
          $.addEvent(tracker.element, event, delegate[event], event === $.MouseTracker.wheelEventName ? { passive: false, capture: false } : false);
        }
        clearTrackedPointers(tracker);
        delegate.tracking = true;
      }
    }
    function stopTracking(tracker) {
      var delegate = THIS[tracker.hash], event, i;
      if (delegate.tracking) {
        for (i = 0;i < $.MouseTracker.subscribeEvents.length; i++) {
          event = $.MouseTracker.subscribeEvents[i];
          $.removeEvent(tracker.element, event, delegate[event], false);
        }
        clearTrackedPointers(tracker);
        delegate.tracking = false;
      }
    }
    function getCaptureEventParams(tracker, pointerType) {
      var delegate = THIS[tracker.hash];
      if (pointerType === "pointerevent") {
        return {
          upName: "pointerup",
          upHandler: delegate.pointerupcaptured,
          moveName: "pointermove",
          moveHandler: delegate.pointermovecaptured
        };
      } else if (pointerType === "mouse") {
        return {
          upName: "pointerup",
          upHandler: delegate.pointerupcaptured,
          moveName: "pointermove",
          moveHandler: delegate.pointermovecaptured
        };
      } else if (pointerType === "touch") {
        return {
          upName: "touchend",
          upHandler: delegate.touchendcaptured,
          moveName: "touchmove",
          moveHandler: delegate.touchmovecaptured
        };
      } else {
        throw new Error("MouseTracker.getCaptureEventParams: Unknown pointer type.");
      }
    }
    function capturePointer(tracker, gPoint) {
      var eventParams;
      if ($.MouseTracker.havePointerCapture) {
        if ($.MouseTracker.havePointerEvents) {
          try {
            tracker.element.setPointerCapture(gPoint.id);
          } catch (e) {
            $.console.warn("setPointerCapture() called on invalid pointer ID");
            return;
          }
        } else {
          tracker.element.setCapture(true);
        }
      } else {
        eventParams = getCaptureEventParams(tracker, $.MouseTracker.havePointerEvents ? "pointerevent" : gPoint.type);
        if (isInIframe && canAccessEvents(window.top)) {
          $.addEvent(window.top, eventParams.upName, eventParams.upHandler, true);
        }
        $.addEvent($.MouseTracker.captureElement, eventParams.upName, eventParams.upHandler, true);
        $.addEvent($.MouseTracker.captureElement, eventParams.moveName, eventParams.moveHandler, true);
      }
      updatePointerCaptured(tracker, gPoint, true);
    }
    function releasePointer(tracker, gPoint) {
      var eventParams;
      var pointsList;
      var cachedGPoint;
      if ($.MouseTracker.havePointerCapture) {
        if ($.MouseTracker.havePointerEvents) {
          pointsList = tracker.getActivePointersListByType(gPoint.type);
          cachedGPoint = pointsList.getById(gPoint.id);
          if (!cachedGPoint || !cachedGPoint.captured) {
            return;
          }
          try {
            tracker.element.releasePointerCapture(gPoint.id);
          } catch (e) {}
        } else {
          tracker.element.releaseCapture();
        }
      } else {
        eventParams = getCaptureEventParams(tracker, $.MouseTracker.havePointerEvents ? "pointerevent" : gPoint.type);
        if (isInIframe && canAccessEvents(window.top)) {
          $.removeEvent(window.top, eventParams.upName, eventParams.upHandler, true);
        }
        $.removeEvent($.MouseTracker.captureElement, eventParams.moveName, eventParams.moveHandler, true);
        $.removeEvent($.MouseTracker.captureElement, eventParams.upName, eventParams.upHandler, true);
      }
      updatePointerCaptured(tracker, gPoint, false);
    }
    function getPointerId(event) {
      return $.MouseTracker.havePointerEvents ? event.pointerId : $.MouseTracker.mousePointerId;
    }
    function getPointerType(event) {
      return $.MouseTracker.havePointerEvents && event.pointerType ? event.pointerType : "mouse";
    }
    function getIsPrimary(event) {
      return $.MouseTracker.havePointerEvents ? event.isPrimary : true;
    }
    function getMouseAbsolute(event) {
      return $.getMousePosition(event);
    }
    function getMouseRelative(event, element) {
      return getPointRelativeToAbsolute(getMouseAbsolute(event), element);
    }
    function getPointRelativeToAbsolute(point, element) {
      var offset = $.getElementOffset(element);
      return point.minus(offset);
    }
    function getCenterPoint(point1, point2) {
      return new $.Point((point1.x + point2.x) / 2, (point1.y + point2.y) / 2);
    }
    function onClick(tracker, event) {
      var eventInfo = {
        originalEvent: event,
        eventType: "click",
        pointerType: "mouse",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $.stopEvent(event);
      }
    }
    function onDblClick(tracker, event) {
      var eventInfo = {
        originalEvent: event,
        eventType: "dblclick",
        pointerType: "mouse",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $.stopEvent(event);
      }
    }
    function onKeyDown(tracker, event) {
      var eventArgs = null;
      var eventInfo = {
        originalEvent: event,
        eventType: "keydown",
        pointerType: "",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      if (tracker.keyDownHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
        eventArgs = {
          eventSource: tracker,
          keyCode: event.keyCode ? event.keyCode : event.charCode,
          ctrl: event.ctrlKey,
          shift: event.shiftKey,
          alt: event.altKey,
          meta: event.metaKey,
          originalEvent: event,
          preventDefault: eventInfo.preventDefault || eventInfo.defaultPrevented,
          userData: tracker.userData
        };
        tracker.keyDownHandler(eventArgs);
      }
      if (eventArgs && eventArgs.preventDefault || eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $.stopEvent(event);
      }
    }
    function onKeyUp(tracker, event) {
      var eventArgs = null;
      var eventInfo = {
        originalEvent: event,
        eventType: "keyup",
        pointerType: "",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      if (tracker.keyUpHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
        eventArgs = {
          eventSource: tracker,
          keyCode: event.keyCode ? event.keyCode : event.charCode,
          ctrl: event.ctrlKey,
          shift: event.shiftKey,
          alt: event.altKey,
          meta: event.metaKey,
          originalEvent: event,
          preventDefault: eventInfo.preventDefault || eventInfo.defaultPrevented,
          userData: tracker.userData
        };
        tracker.keyUpHandler(eventArgs);
      }
      if (eventArgs && eventArgs.preventDefault || eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $.stopEvent(event);
      }
    }
    function onKeyPress(tracker, event) {
      var eventArgs = null;
      var eventInfo = {
        originalEvent: event,
        eventType: "keypress",
        pointerType: "",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      if (tracker.keyHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
        eventArgs = {
          eventSource: tracker,
          keyCode: event.keyCode ? event.keyCode : event.charCode,
          ctrl: event.ctrlKey,
          shift: event.shiftKey,
          alt: event.altKey,
          meta: event.metaKey,
          originalEvent: event,
          preventDefault: eventInfo.preventDefault || eventInfo.defaultPrevented,
          userData: tracker.userData
        };
        tracker.keyHandler(eventArgs);
      }
      if (eventArgs && eventArgs.preventDefault || eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $.stopEvent(event);
      }
    }
    function onFocus(tracker, event) {
      var eventInfo = {
        originalEvent: event,
        eventType: "focus",
        pointerType: "",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      if (tracker.focusHandler && !eventInfo.preventGesture) {
        tracker.focusHandler({
          eventSource: tracker,
          originalEvent: event,
          userData: tracker.userData
        });
      }
    }
    function onBlur(tracker, event) {
      var eventInfo = {
        originalEvent: event,
        eventType: "blur",
        pointerType: "",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      if (tracker.blurHandler && !eventInfo.preventGesture) {
        tracker.blurHandler({
          eventSource: tracker,
          originalEvent: event,
          userData: tracker.userData
        });
      }
    }
    function onContextMenu(tracker, event) {
      var eventArgs = null;
      var eventInfo = {
        originalEvent: event,
        eventType: "contextmenu",
        pointerType: "mouse",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      if (tracker.contextMenuHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
        eventArgs = {
          eventSource: tracker,
          position: getPointRelativeToAbsolute(getMouseAbsolute(event), tracker.element),
          originalEvent: eventInfo.originalEvent,
          preventDefault: eventInfo.preventDefault || eventInfo.defaultPrevented,
          userData: tracker.userData
        };
        tracker.contextMenuHandler(eventArgs);
      }
      if (eventArgs && eventArgs.preventDefault || eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $.stopEvent(event);
      }
    }
    function onWheel(tracker, event) {
      handleWheelEvent(tracker, event, event);
    }
    function onMouseWheel(tracker, event) {
      var simulatedEvent = {
        target: event.target || event.srcElement,
        type: "wheel",
        shiftKey: event.shiftKey || false,
        clientX: event.clientX,
        clientY: event.clientY,
        pageX: event.pageX ? event.pageX : event.clientX,
        pageY: event.pageY ? event.pageY : event.clientY,
        deltaMode: event.type === "MozMousePixelScroll" ? 0 : 1,
        deltaX: 0,
        deltaZ: 0
      };
      if ($.MouseTracker.wheelEventName === "mousewheel") {
        simulatedEvent.deltaY = -event.wheelDelta / $.DEFAULT_SETTINGS.pixelsPerWheelLine;
      } else {
        simulatedEvent.deltaY = event.detail;
      }
      handleWheelEvent(tracker, simulatedEvent, event);
    }
    function handleWheelEvent(tracker, event, originalEvent) {
      var nDelta = 0, eventInfo;
      var eventArgs = null;
      nDelta = event.deltaY ? event.deltaY < 0 ? 1 : -1 : 0;
      eventInfo = {
        originalEvent: event,
        eventType: "wheel",
        pointerType: "mouse",
        isEmulated: event !== originalEvent
      };
      preProcessEvent(tracker, eventInfo);
      if (tracker.scrollHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
        eventArgs = {
          eventSource: tracker,
          pointerType: "mouse",
          position: getMouseRelative(event, tracker.element),
          scroll: nDelta,
          shift: event.shiftKey,
          isTouchEvent: false,
          originalEvent,
          preventDefault: eventInfo.preventDefault || eventInfo.defaultPrevented,
          userData: tracker.userData
        };
        tracker.scrollHandler(eventArgs);
      }
      if (eventInfo.stopPropagation) {
        $.stopEvent(originalEvent);
      }
      if (eventArgs && eventArgs.preventDefault || eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $.cancelEvent(originalEvent);
      }
    }
    function onLoseCapture(tracker, event) {
      var gPoint = {
        id: $.MouseTracker.mousePointerId,
        type: "mouse"
      };
      var eventInfo = {
        originalEvent: event,
        eventType: "lostpointercapture",
        pointerType: "mouse",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      if (event.target === tracker.element) {
        updatePointerCaptured(tracker, gPoint, false);
      }
      if (eventInfo.stopPropagation) {
        $.stopEvent(event);
      }
    }
    function onTouchStart(tracker, event) {
      var time, i, touchCount = event.changedTouches.length, gPoint, pointsList = tracker.getActivePointersListByType("touch");
      time = $.now();
      if (pointsList.getLength() > event.touches.length - touchCount) {
        $.console.warn("Tracked touch contact count doesn't match event.touches.length");
      }
      var eventInfo = {
        originalEvent: event,
        eventType: "pointerdown",
        pointerType: "touch",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      for (i = 0;i < touchCount; i++) {
        gPoint = {
          id: event.changedTouches[i].identifier,
          type: "touch",
          isPrimary: pointsList.getLength() === 0,
          currentPos: getMouseAbsolute(event.changedTouches[i]),
          currentTime: time
        };
        updatePointerEnter(tracker, eventInfo, gPoint);
        updatePointerDown(tracker, eventInfo, gPoint, 0);
        updatePointerCaptured(tracker, gPoint, true);
      }
      if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $.stopEvent(event);
      }
    }
    function onTouchEnd(tracker, event) {
      var time, i, touchCount = event.changedTouches.length, gPoint;
      time = $.now();
      var eventInfo = {
        originalEvent: event,
        eventType: "pointerup",
        pointerType: "touch",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      for (i = 0;i < touchCount; i++) {
        gPoint = {
          id: event.changedTouches[i].identifier,
          type: "touch",
          currentPos: getMouseAbsolute(event.changedTouches[i]),
          currentTime: time
        };
        updatePointerUp(tracker, eventInfo, gPoint, 0);
        updatePointerCaptured(tracker, gPoint, false);
        updatePointerLeave(tracker, eventInfo, gPoint);
      }
      if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $.stopEvent(event);
      }
    }
    function onTouchMove(tracker, event) {
      var time, i, touchCount = event.changedTouches.length, gPoint;
      time = $.now();
      var eventInfo = {
        originalEvent: event,
        eventType: "pointermove",
        pointerType: "touch",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      for (i = 0;i < touchCount; i++) {
        gPoint = {
          id: event.changedTouches[i].identifier,
          type: "touch",
          currentPos: getMouseAbsolute(event.changedTouches[i]),
          currentTime: time
        };
        updatePointerMove(tracker, eventInfo, gPoint);
      }
      if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $.stopEvent(event);
      }
    }
    function onTouchCancel(tracker, event) {
      var touchCount = event.changedTouches.length, i, gPoint;
      var eventInfo = {
        originalEvent: event,
        eventType: "pointercancel",
        pointerType: "touch",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      for (i = 0;i < touchCount; i++) {
        gPoint = {
          id: event.changedTouches[i].identifier,
          type: "touch"
        };
        updatePointerCancel(tracker, eventInfo, gPoint);
      }
      if (eventInfo.stopPropagation) {
        $.stopEvent(event);
      }
    }
    function onGestureStart(tracker, event) {
      if (!$.eventIsCanceled(event)) {
        event.preventDefault();
      }
      return false;
    }
    function onGestureChange(tracker, event) {
      if (!$.eventIsCanceled(event)) {
        event.preventDefault();
      }
      return false;
    }
    function onGotPointerCapture(tracker, event) {
      var eventInfo = {
        originalEvent: event,
        eventType: "gotpointercapture",
        pointerType: getPointerType(event),
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      if (event.target === tracker.element) {
        updatePointerCaptured(tracker, {
          id: event.pointerId,
          type: getPointerType(event)
        }, true);
      }
      if (eventInfo.stopPropagation) {
        $.stopEvent(event);
      }
    }
    function onLostPointerCapture(tracker, event) {
      var eventInfo = {
        originalEvent: event,
        eventType: "lostpointercapture",
        pointerType: getPointerType(event),
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      if (event.target === tracker.element) {
        updatePointerCaptured(tracker, {
          id: event.pointerId,
          type: getPointerType(event)
        }, false);
      }
      if (eventInfo.stopPropagation) {
        $.stopEvent(event);
      }
    }
    function onPointerEnter(tracker, event) {
      var gPoint = {
        id: getPointerId(event),
        type: getPointerType(event),
        isPrimary: getIsPrimary(event),
        currentPos: getMouseAbsolute(event),
        currentTime: $.now()
      };
      var eventInfo = {
        originalEvent: event,
        eventType: "pointerenter",
        pointerType: gPoint.type,
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      updatePointerEnter(tracker, eventInfo, gPoint);
    }
    function onPointerLeave(tracker, event) {
      var gPoint = {
        id: getPointerId(event),
        type: getPointerType(event),
        isPrimary: getIsPrimary(event),
        currentPos: getMouseAbsolute(event),
        currentTime: $.now()
      };
      var eventInfo = {
        originalEvent: event,
        eventType: "pointerleave",
        pointerType: gPoint.type,
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      updatePointerLeave(tracker, eventInfo, gPoint);
    }
    function onPointerOver(tracker, event) {
      var gPoint = {
        id: getPointerId(event),
        type: getPointerType(event),
        isPrimary: getIsPrimary(event),
        currentPos: getMouseAbsolute(event),
        currentTime: $.now()
      };
      var eventInfo = {
        originalEvent: event,
        eventType: "pointerover",
        pointerType: gPoint.type,
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      updatePointerOver(tracker, eventInfo, gPoint);
      if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $.stopEvent(event);
      }
    }
    function onPointerOut(tracker, event) {
      var gPoint = {
        id: getPointerId(event),
        type: getPointerType(event),
        isPrimary: getIsPrimary(event),
        currentPos: getMouseAbsolute(event),
        currentTime: $.now()
      };
      var eventInfo = {
        originalEvent: event,
        eventType: "pointerout",
        pointerType: gPoint.type,
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      updatePointerOut(tracker, eventInfo, gPoint);
      if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $.stopEvent(event);
      }
    }
    function onPointerDown(tracker, event) {
      var gPoint = {
        id: getPointerId(event),
        type: getPointerType(event),
        isPrimary: getIsPrimary(event),
        currentPos: getMouseAbsolute(event),
        currentTime: $.now()
      };
      var implicitlyCaptured = $.MouseTracker.havePointerEvents && gPoint.type === "touch";
      var eventInfo = {
        originalEvent: event,
        eventType: "pointerdown",
        pointerType: gPoint.type,
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      updatePointerDown(tracker, eventInfo, gPoint, event.button);
      if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $.stopEvent(event);
      }
      if (eventInfo.shouldCapture) {
        if (implicitlyCaptured) {
          updatePointerCaptured(tracker, gPoint, true);
        } else {
          capturePointer(tracker, gPoint);
        }
      }
    }
    function onPointerUp(tracker, event) {
      handlePointerUp(tracker, event);
    }
    function onPointerUpCaptured(tracker, event) {
      var pointsList = tracker.getActivePointersListByType(getPointerType(event));
      if (pointsList.getById(event.pointerId)) {
        handlePointerUp(tracker, event);
      }
      $.stopEvent(event);
    }
    function handlePointerUp(tracker, event) {
      var gPoint;
      gPoint = {
        id: getPointerId(event),
        type: getPointerType(event),
        isPrimary: getIsPrimary(event),
        currentPos: getMouseAbsolute(event),
        currentTime: $.now()
      };
      var eventInfo = {
        originalEvent: event,
        eventType: "pointerup",
        pointerType: gPoint.type,
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      updatePointerUp(tracker, eventInfo, gPoint, event.button);
      if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $.stopEvent(event);
      }
      if (eventInfo.shouldReleaseCapture) {
        if (event.target === tracker.element) {
          releasePointer(tracker, gPoint);
        } else {
          updatePointerCaptured(tracker, gPoint, false);
        }
      }
    }
    function onPointerMove(tracker, event) {
      handlePointerMove(tracker, event);
    }
    function onPointerMoveCaptured(tracker, event) {
      var pointsList = tracker.getActivePointersListByType(getPointerType(event));
      if (pointsList.getById(event.pointerId)) {
        handlePointerMove(tracker, event);
      }
      $.stopEvent(event);
    }
    function handlePointerMove(tracker, event) {
      var gPoint = {
        id: getPointerId(event),
        type: getPointerType(event),
        isPrimary: getIsPrimary(event),
        currentPos: getMouseAbsolute(event),
        currentTime: $.now()
      };
      var eventInfo = {
        originalEvent: event,
        eventType: "pointermove",
        pointerType: gPoint.type,
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      updatePointerMove(tracker, eventInfo, gPoint);
      if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $.stopEvent(event);
      }
    }
    function onPointerCancel(tracker, event) {
      var gPoint = {
        id: event.pointerId,
        type: getPointerType(event)
      };
      var eventInfo = {
        originalEvent: event,
        eventType: "pointercancel",
        pointerType: gPoint.type,
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      updatePointerCancel(tracker, eventInfo, gPoint);
      if (eventInfo.stopPropagation) {
        $.stopEvent(event);
      }
    }
    function startTrackingPointer(pointsList, gPoint) {
      gPoint.speed = 0;
      gPoint.direction = 0;
      gPoint.contactPos = gPoint.currentPos;
      gPoint.contactTime = gPoint.currentTime;
      gPoint.lastPos = gPoint.currentPos;
      gPoint.lastTime = gPoint.currentTime;
      return pointsList.add(gPoint);
    }
    function stopTrackingPointer(tracker, pointsList, gPoint) {
      var listLength;
      var trackedGPoint = pointsList.getById(gPoint.id);
      if (trackedGPoint) {
        if (trackedGPoint.captured) {
          $.console.warn("stopTrackingPointer() called on captured pointer");
          releasePointer(tracker, trackedGPoint);
        }
        pointsList.removeContact();
        listLength = pointsList.removeById(gPoint.id);
      } else {
        listLength = pointsList.getLength();
      }
      return listLength;
    }
    function getEventProcessDefaults(tracker, eventInfo) {
      switch (eventInfo.eventType) {
        case "pointermove":
          eventInfo.isStoppable = true;
          eventInfo.isCancelable = true;
          eventInfo.preventDefault = false;
          eventInfo.preventGesture = !tracker.hasGestureHandlers;
          eventInfo.stopPropagation = false;
          break;
        case "pointerover":
        case "pointerout":
        case "contextmenu":
        case "keydown":
        case "keyup":
        case "keypress":
          eventInfo.isStoppable = true;
          eventInfo.isCancelable = true;
          eventInfo.preventDefault = false;
          eventInfo.preventGesture = false;
          eventInfo.stopPropagation = false;
          break;
        case "pointerdown":
          eventInfo.isStoppable = true;
          eventInfo.isCancelable = true;
          eventInfo.preventDefault = false;
          eventInfo.preventGesture = !tracker.hasGestureHandlers;
          eventInfo.stopPropagation = false;
          break;
        case "pointerup":
          eventInfo.isStoppable = true;
          eventInfo.isCancelable = true;
          eventInfo.preventDefault = false;
          eventInfo.preventGesture = !tracker.hasGestureHandlers;
          eventInfo.stopPropagation = false;
          break;
        case "wheel":
          eventInfo.isStoppable = true;
          eventInfo.isCancelable = true;
          eventInfo.preventDefault = false;
          eventInfo.preventGesture = !tracker.hasScrollHandler;
          eventInfo.stopPropagation = false;
          break;
        case "gotpointercapture":
        case "lostpointercapture":
        case "pointercancel":
          eventInfo.isStoppable = true;
          eventInfo.isCancelable = false;
          eventInfo.preventDefault = false;
          eventInfo.preventGesture = false;
          eventInfo.stopPropagation = false;
          break;
        case "click":
          eventInfo.isStoppable = true;
          eventInfo.isCancelable = true;
          eventInfo.preventDefault = !!tracker.clickHandler;
          eventInfo.preventGesture = false;
          eventInfo.stopPropagation = false;
          break;
        case "dblclick":
          eventInfo.isStoppable = true;
          eventInfo.isCancelable = true;
          eventInfo.preventDefault = !!tracker.dblClickHandler;
          eventInfo.preventGesture = false;
          eventInfo.stopPropagation = false;
          break;
        case "focus":
        case "blur":
        case "pointerenter":
        case "pointerleave":
        default:
          eventInfo.isStoppable = false;
          eventInfo.isCancelable = false;
          eventInfo.preventDefault = false;
          eventInfo.preventGesture = false;
          eventInfo.stopPropagation = false;
          break;
      }
    }
    function preProcessEvent(tracker, eventInfo) {
      eventInfo.eventSource = tracker;
      eventInfo.eventPhase = eventInfo.originalEvent ? typeof eventInfo.originalEvent.eventPhase !== "undefined" ? eventInfo.originalEvent.eventPhase : 0 : 0;
      eventInfo.defaultPrevented = $.eventIsCanceled(eventInfo.originalEvent);
      eventInfo.shouldCapture = false;
      eventInfo.shouldReleaseCapture = false;
      eventInfo.userData = tracker.userData;
      getEventProcessDefaults(tracker, eventInfo);
      if (tracker.preProcessEventHandler) {
        tracker.preProcessEventHandler(eventInfo);
      }
    }
    function updatePointerCaptured(tracker, gPoint, isCaptured) {
      var pointsList = tracker.getActivePointersListByType(gPoint.type);
      var updateGPoint = pointsList.getById(gPoint.id);
      if (updateGPoint) {
        if (isCaptured && !updateGPoint.captured) {
          updateGPoint.captured = true;
          pointsList.captureCount++;
        } else if (!isCaptured && updateGPoint.captured) {
          updateGPoint.captured = false;
          pointsList.captureCount--;
          if (pointsList.captureCount < 0) {
            pointsList.captureCount = 0;
            $.console.warn("updatePointerCaptured() - pointsList.captureCount went negative");
          }
        }
      } else {
        $.console.warn("updatePointerCaptured() called on untracked pointer");
      }
    }
    function updatePointerEnter(tracker, eventInfo, gPoint) {
      var pointsList = tracker.getActivePointersListByType(gPoint.type), updateGPoint;
      updateGPoint = pointsList.getById(gPoint.id);
      if (updateGPoint) {
        updateGPoint.insideElement = true;
        updateGPoint.lastPos = updateGPoint.currentPos;
        updateGPoint.lastTime = updateGPoint.currentTime;
        updateGPoint.currentPos = gPoint.currentPos;
        updateGPoint.currentTime = gPoint.currentTime;
        gPoint = updateGPoint;
      } else {
        gPoint.captured = false;
        gPoint.insideElementPressed = false;
        gPoint.insideElement = true;
        startTrackingPointer(pointsList, gPoint);
      }
      if (tracker.enterHandler) {
        tracker.enterHandler({
          eventSource: tracker,
          pointerType: gPoint.type,
          position: getPointRelativeToAbsolute(gPoint.currentPos, tracker.element),
          buttons: pointsList.buttons,
          pointers: tracker.getActivePointerCount(),
          insideElementPressed: gPoint.insideElementPressed,
          buttonDownAny: pointsList.buttons !== 0,
          isTouchEvent: gPoint.type === "touch",
          originalEvent: eventInfo.originalEvent,
          userData: tracker.userData
        });
      }
    }
    function updatePointerLeave(tracker, eventInfo, gPoint) {
      var pointsList = tracker.getActivePointersListByType(gPoint.type), updateGPoint, dispatchEventObj;
      updateGPoint = pointsList.getById(gPoint.id);
      if (updateGPoint) {
        if (updateGPoint.captured) {
          updateGPoint.insideElement = false;
          updateGPoint.lastPos = updateGPoint.currentPos;
          updateGPoint.lastTime = updateGPoint.currentTime;
          updateGPoint.currentPos = gPoint.currentPos;
          updateGPoint.currentTime = gPoint.currentTime;
        } else {
          stopTrackingPointer(tracker, pointsList, updateGPoint);
        }
        gPoint = updateGPoint;
      } else {
        gPoint.captured = false;
        gPoint.insideElementPressed = false;
      }
      if (tracker.leaveHandler || tracker.exitHandler) {
        dispatchEventObj = {
          eventSource: tracker,
          pointerType: gPoint.type,
          position: gPoint.currentPos && getPointRelativeToAbsolute(gPoint.currentPos, tracker.element),
          buttons: pointsList.buttons,
          pointers: tracker.getActivePointerCount(),
          insideElementPressed: gPoint.insideElementPressed,
          buttonDownAny: pointsList.buttons !== 0,
          isTouchEvent: gPoint.type === "touch",
          originalEvent: eventInfo.originalEvent,
          userData: tracker.userData
        };
        if (tracker.leaveHandler) {
          tracker.leaveHandler(dispatchEventObj);
        }
        if (tracker.exitHandler) {
          tracker.exitHandler(dispatchEventObj);
        }
      }
    }
    function updatePointerOver(tracker, eventInfo, gPoint) {
      var pointsList, updateGPoint;
      pointsList = tracker.getActivePointersListByType(gPoint.type);
      updateGPoint = pointsList.getById(gPoint.id);
      if (updateGPoint) {
        gPoint = updateGPoint;
      } else {
        gPoint.captured = false;
        gPoint.insideElementPressed = false;
      }
      if (tracker.overHandler) {
        tracker.overHandler({
          eventSource: tracker,
          pointerType: gPoint.type,
          position: getPointRelativeToAbsolute(gPoint.currentPos, tracker.element),
          buttons: pointsList.buttons,
          pointers: tracker.getActivePointerCount(),
          insideElementPressed: gPoint.insideElementPressed,
          buttonDownAny: pointsList.buttons !== 0,
          isTouchEvent: gPoint.type === "touch",
          originalEvent: eventInfo.originalEvent,
          userData: tracker.userData
        });
      }
    }
    function updatePointerOut(tracker, eventInfo, gPoint) {
      var pointsList, updateGPoint;
      pointsList = tracker.getActivePointersListByType(gPoint.type);
      updateGPoint = pointsList.getById(gPoint.id);
      if (updateGPoint) {
        gPoint = updateGPoint;
      } else {
        gPoint.captured = false;
        gPoint.insideElementPressed = false;
      }
      if (tracker.outHandler) {
        tracker.outHandler({
          eventSource: tracker,
          pointerType: gPoint.type,
          position: gPoint.currentPos && getPointRelativeToAbsolute(gPoint.currentPos, tracker.element),
          buttons: pointsList.buttons,
          pointers: tracker.getActivePointerCount(),
          insideElementPressed: gPoint.insideElementPressed,
          buttonDownAny: pointsList.buttons !== 0,
          isTouchEvent: gPoint.type === "touch",
          originalEvent: eventInfo.originalEvent,
          userData: tracker.userData
        });
      }
    }
    function updatePointerDown(tracker, eventInfo, gPoint, buttonChanged) {
      var delegate = THIS[tracker.hash], pointsList = tracker.getActivePointersListByType(gPoint.type), updateGPoint;
      if (typeof eventInfo.originalEvent.buttons !== "undefined") {
        pointsList.buttons = eventInfo.originalEvent.buttons;
      } else {
        if (buttonChanged === 0) {
          pointsList.buttons |= 1;
        } else if (buttonChanged === 1) {
          pointsList.buttons |= 4;
        } else if (buttonChanged === 2) {
          pointsList.buttons |= 2;
        } else if (buttonChanged === 3) {
          pointsList.buttons |= 8;
        } else if (buttonChanged === 4) {
          pointsList.buttons |= 16;
        } else if (buttonChanged === 5) {
          pointsList.buttons |= 32;
        }
      }
      if (buttonChanged !== 0) {
        eventInfo.shouldCapture = false;
        eventInfo.shouldReleaseCapture = false;
        if (tracker.nonPrimaryPressHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
          eventInfo.preventDefault = true;
          tracker.nonPrimaryPressHandler({
            eventSource: tracker,
            pointerType: gPoint.type,
            position: getPointRelativeToAbsolute(gPoint.currentPos, tracker.element),
            button: buttonChanged,
            buttons: pointsList.buttons,
            isTouchEvent: gPoint.type === "touch",
            originalEvent: eventInfo.originalEvent,
            userData: tracker.userData
          });
        }
        return;
      }
      updateGPoint = pointsList.getById(gPoint.id);
      if (updateGPoint) {
        updateGPoint.insideElementPressed = true;
        updateGPoint.insideElement = true;
        updateGPoint.originalTarget = eventInfo.originalEvent.target;
        updateGPoint.contactPos = gPoint.currentPos;
        updateGPoint.contactTime = gPoint.currentTime;
        updateGPoint.lastPos = updateGPoint.currentPos;
        updateGPoint.lastTime = updateGPoint.currentTime;
        updateGPoint.currentPos = gPoint.currentPos;
        updateGPoint.currentTime = gPoint.currentTime;
        gPoint = updateGPoint;
      } else {
        gPoint.captured = false;
        gPoint.insideElementPressed = true;
        gPoint.insideElement = true;
        gPoint.originalTarget = eventInfo.originalEvent.target;
        startTrackingPointer(pointsList, gPoint);
      }
      pointsList.addContact();
      if (!eventInfo.preventGesture && !eventInfo.defaultPrevented) {
        eventInfo.shouldCapture = true;
        eventInfo.shouldReleaseCapture = false;
        eventInfo.preventDefault = true;
        if (tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler) {
          $.MouseTracker.gesturePointVelocityTracker.addPoint(tracker, gPoint);
        }
        if (pointsList.contacts === 1) {
          if (tracker.pressHandler && !eventInfo.preventGesture) {
            tracker.pressHandler({
              eventSource: tracker,
              pointerType: gPoint.type,
              position: getPointRelativeToAbsolute(gPoint.contactPos, tracker.element),
              buttons: pointsList.buttons,
              isTouchEvent: gPoint.type === "touch",
              originalEvent: eventInfo.originalEvent,
              userData: tracker.userData
            });
          }
        } else if (pointsList.contacts === 2) {
          if (tracker.pinchHandler && gPoint.type === "touch") {
            delegate.pinchGPoints = pointsList.asArray();
            delegate.lastPinchDist = delegate.currentPinchDist = delegate.pinchGPoints[0].currentPos.distanceTo(delegate.pinchGPoints[1].currentPos);
            delegate.lastPinchCenter = delegate.currentPinchCenter = getCenterPoint(delegate.pinchGPoints[0].currentPos, delegate.pinchGPoints[1].currentPos);
          }
        }
      } else {
        eventInfo.shouldCapture = false;
        eventInfo.shouldReleaseCapture = false;
      }
    }
    function updatePointerUp(tracker, eventInfo, gPoint, buttonChanged) {
      var delegate = THIS[tracker.hash], pointsList = tracker.getActivePointersListByType(gPoint.type), releasePoint, releaseTime, updateGPoint, wasCaptured = false, quick;
      if (typeof eventInfo.originalEvent.buttons !== "undefined") {
        pointsList.buttons = eventInfo.originalEvent.buttons;
      } else {
        if (buttonChanged === 0) {
          pointsList.buttons ^= ~1;
        } else if (buttonChanged === 1) {
          pointsList.buttons ^= ~4;
        } else if (buttonChanged === 2) {
          pointsList.buttons ^= ~2;
        } else if (buttonChanged === 3) {
          pointsList.buttons ^= ~8;
        } else if (buttonChanged === 4) {
          pointsList.buttons ^= ~16;
        } else if (buttonChanged === 5) {
          pointsList.buttons ^= ~32;
        }
      }
      eventInfo.shouldCapture = false;
      if (buttonChanged !== 0) {
        eventInfo.shouldReleaseCapture = false;
        if (tracker.nonPrimaryReleaseHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
          eventInfo.preventDefault = true;
          tracker.nonPrimaryReleaseHandler({
            eventSource: tracker,
            pointerType: gPoint.type,
            position: getPointRelativeToAbsolute(gPoint.currentPos, tracker.element),
            button: buttonChanged,
            buttons: pointsList.buttons,
            isTouchEvent: gPoint.type === "touch",
            originalEvent: eventInfo.originalEvent,
            userData: tracker.userData
          });
        }
        return;
      }
      updateGPoint = pointsList.getById(gPoint.id);
      if (updateGPoint) {
        pointsList.removeContact();
        if (updateGPoint.captured) {
          wasCaptured = true;
        }
        updateGPoint.lastPos = updateGPoint.currentPos;
        updateGPoint.lastTime = updateGPoint.currentTime;
        updateGPoint.currentPos = gPoint.currentPos;
        updateGPoint.currentTime = gPoint.currentTime;
        if (!updateGPoint.insideElement) {
          stopTrackingPointer(tracker, pointsList, updateGPoint);
        }
        releasePoint = updateGPoint.currentPos;
        releaseTime = updateGPoint.currentTime;
      } else {
        gPoint.captured = false;
        gPoint.insideElementPressed = false;
        gPoint.insideElement = true;
        startTrackingPointer(pointsList, gPoint);
        updateGPoint = gPoint;
      }
      if (!eventInfo.preventGesture && !eventInfo.defaultPrevented) {
        if (wasCaptured) {
          eventInfo.shouldReleaseCapture = true;
          eventInfo.preventDefault = true;
          if (tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler) {
            $.MouseTracker.gesturePointVelocityTracker.removePoint(tracker, updateGPoint);
          }
          if (pointsList.contacts === 0) {
            if (tracker.releaseHandler && releasePoint) {
              tracker.releaseHandler({
                eventSource: tracker,
                pointerType: updateGPoint.type,
                position: getPointRelativeToAbsolute(releasePoint, tracker.element),
                buttons: pointsList.buttons,
                insideElementPressed: updateGPoint.insideElementPressed,
                insideElementReleased: updateGPoint.insideElement,
                isTouchEvent: updateGPoint.type === "touch",
                originalEvent: eventInfo.originalEvent,
                userData: tracker.userData
              });
            }
            if (tracker.dragEndHandler && delegate.sentDragEvent) {
              tracker.dragEndHandler({
                eventSource: tracker,
                pointerType: updateGPoint.type,
                position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
                speed: updateGPoint.speed,
                direction: updateGPoint.direction,
                shift: eventInfo.originalEvent.shiftKey,
                isTouchEvent: updateGPoint.type === "touch",
                originalEvent: eventInfo.originalEvent,
                userData: tracker.userData
              });
            }
            delegate.sentDragEvent = false;
            if ((tracker.clickHandler || tracker.dblClickHandler) && updateGPoint.insideElement) {
              quick = releaseTime - updateGPoint.contactTime <= tracker.clickTimeThreshold && updateGPoint.contactPos.distanceTo(releasePoint) <= tracker.clickDistThreshold;
              if (tracker.clickHandler) {
                tracker.clickHandler({
                  eventSource: tracker,
                  pointerType: updateGPoint.type,
                  position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
                  quick,
                  shift: eventInfo.originalEvent.shiftKey,
                  isTouchEvent: updateGPoint.type === "touch",
                  originalEvent: eventInfo.originalEvent,
                  originalTarget: updateGPoint.originalTarget,
                  userData: tracker.userData
                });
              }
              if (tracker.dblClickHandler && quick) {
                pointsList.clicks++;
                if (pointsList.clicks === 1) {
                  delegate.lastClickPos = releasePoint;
                  delegate.dblClickTimeOut = setTimeout(function() {
                    pointsList.clicks = 0;
                  }, tracker.dblClickTimeThreshold);
                } else if (pointsList.clicks === 2) {
                  clearTimeout(delegate.dblClickTimeOut);
                  pointsList.clicks = 0;
                  if (delegate.lastClickPos.distanceTo(releasePoint) <= tracker.dblClickDistThreshold) {
                    tracker.dblClickHandler({
                      eventSource: tracker,
                      pointerType: updateGPoint.type,
                      position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
                      shift: eventInfo.originalEvent.shiftKey,
                      isTouchEvent: updateGPoint.type === "touch",
                      originalEvent: eventInfo.originalEvent,
                      userData: tracker.userData
                    });
                  }
                  delegate.lastClickPos = null;
                }
              }
            }
          } else if (pointsList.contacts === 2) {
            if (tracker.pinchHandler && updateGPoint.type === "touch") {
              delegate.pinchGPoints = pointsList.asArray();
              delegate.lastPinchDist = delegate.currentPinchDist = delegate.pinchGPoints[0].currentPos.distanceTo(delegate.pinchGPoints[1].currentPos);
              delegate.lastPinchCenter = delegate.currentPinchCenter = getCenterPoint(delegate.pinchGPoints[0].currentPos, delegate.pinchGPoints[1].currentPos);
            }
          }
        } else {
          eventInfo.shouldReleaseCapture = false;
          if (tracker.releaseHandler && releasePoint) {
            tracker.releaseHandler({
              eventSource: tracker,
              pointerType: updateGPoint.type,
              position: getPointRelativeToAbsolute(releasePoint, tracker.element),
              buttons: pointsList.buttons,
              insideElementPressed: updateGPoint.insideElementPressed,
              insideElementReleased: updateGPoint.insideElement,
              isTouchEvent: updateGPoint.type === "touch",
              originalEvent: eventInfo.originalEvent,
              userData: tracker.userData
            });
            eventInfo.preventDefault = true;
          }
        }
      }
    }
    function updatePointerMove(tracker, eventInfo, gPoint) {
      var delegate = THIS[tracker.hash], pointsList = tracker.getActivePointersListByType(gPoint.type), updateGPoint, gPointArray, delta;
      if (typeof eventInfo.originalEvent.buttons !== "undefined") {
        pointsList.buttons = eventInfo.originalEvent.buttons;
      }
      updateGPoint = pointsList.getById(gPoint.id);
      if (updateGPoint) {
        updateGPoint.lastPos = updateGPoint.currentPos;
        updateGPoint.lastTime = updateGPoint.currentTime;
        updateGPoint.currentPos = gPoint.currentPos;
        updateGPoint.currentTime = gPoint.currentTime;
      } else {
        return;
      }
      eventInfo.shouldCapture = false;
      eventInfo.shouldReleaseCapture = false;
      if (tracker.stopHandler && gPoint.type === "mouse") {
        clearTimeout(tracker.stopTimeOut);
        tracker.stopTimeOut = setTimeout(function() {
          handlePointerStop(tracker, eventInfo.originalEvent, gPoint.type);
        }, tracker.stopDelay);
      }
      if (pointsList.contacts === 0) {
        if (tracker.moveHandler) {
          tracker.moveHandler({
            eventSource: tracker,
            pointerType: gPoint.type,
            position: getPointRelativeToAbsolute(gPoint.currentPos, tracker.element),
            buttons: pointsList.buttons,
            isTouchEvent: gPoint.type === "touch",
            originalEvent: eventInfo.originalEvent,
            userData: tracker.userData
          });
        }
      } else if (pointsList.contacts === 1) {
        if (tracker.moveHandler) {
          updateGPoint = pointsList.asArray()[0];
          tracker.moveHandler({
            eventSource: tracker,
            pointerType: updateGPoint.type,
            position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
            buttons: pointsList.buttons,
            isTouchEvent: updateGPoint.type === "touch",
            originalEvent: eventInfo.originalEvent,
            userData: tracker.userData
          });
        }
        if (tracker.dragHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
          updateGPoint = pointsList.asArray()[0];
          delta = updateGPoint.currentPos.minus(updateGPoint.lastPos);
          tracker.dragHandler({
            eventSource: tracker,
            pointerType: updateGPoint.type,
            position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
            buttons: pointsList.buttons,
            delta,
            speed: updateGPoint.speed,
            direction: updateGPoint.direction,
            shift: eventInfo.originalEvent.shiftKey,
            isTouchEvent: updateGPoint.type === "touch",
            originalEvent: eventInfo.originalEvent,
            userData: tracker.userData
          });
          eventInfo.preventDefault = true;
          delegate.sentDragEvent = true;
        }
      } else if (pointsList.contacts === 2) {
        if (tracker.moveHandler) {
          gPointArray = pointsList.asArray();
          tracker.moveHandler({
            eventSource: tracker,
            pointerType: gPointArray[0].type,
            position: getPointRelativeToAbsolute(getCenterPoint(gPointArray[0].currentPos, gPointArray[1].currentPos), tracker.element),
            buttons: pointsList.buttons,
            isTouchEvent: gPointArray[0].type === "touch",
            originalEvent: eventInfo.originalEvent,
            userData: tracker.userData
          });
        }
        if (tracker.pinchHandler && gPoint.type === "touch" && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
          delta = delegate.pinchGPoints[0].currentPos.distanceTo(delegate.pinchGPoints[1].currentPos);
          if (delta !== delegate.currentPinchDist) {
            delegate.lastPinchDist = delegate.currentPinchDist;
            delegate.currentPinchDist = delta;
            delegate.lastPinchCenter = delegate.currentPinchCenter;
            delegate.currentPinchCenter = getCenterPoint(delegate.pinchGPoints[0].currentPos, delegate.pinchGPoints[1].currentPos);
            tracker.pinchHandler({
              eventSource: tracker,
              pointerType: "touch",
              gesturePoints: delegate.pinchGPoints,
              lastCenter: getPointRelativeToAbsolute(delegate.lastPinchCenter, tracker.element),
              center: getPointRelativeToAbsolute(delegate.currentPinchCenter, tracker.element),
              lastDistance: delegate.lastPinchDist,
              distance: delegate.currentPinchDist,
              shift: eventInfo.originalEvent.shiftKey,
              originalEvent: eventInfo.originalEvent,
              userData: tracker.userData
            });
            eventInfo.preventDefault = true;
          }
        }
      }
    }
    function updatePointerCancel(tracker, eventInfo, gPoint) {
      var pointsList = tracker.getActivePointersListByType(gPoint.type), updateGPoint;
      updateGPoint = pointsList.getById(gPoint.id);
      if (updateGPoint) {
        stopTrackingPointer(tracker, pointsList, updateGPoint);
      }
    }
    function handlePointerStop(tracker, originalMoveEvent, pointerType) {
      if (tracker.stopHandler) {
        tracker.stopHandler({
          eventSource: tracker,
          pointerType,
          position: getMouseRelative(originalMoveEvent, tracker.element),
          buttons: tracker.getActivePointersListByType(pointerType).buttons,
          isTouchEvent: pointerType === "touch",
          originalEvent: originalMoveEvent,
          userData: tracker.userData
        });
      }
    }
  })(OpenSeadragon);
  (function($) {
    $.ControlAnchor = {
      NONE: 0,
      TOP_LEFT: 1,
      TOP_RIGHT: 2,
      BOTTOM_RIGHT: 3,
      BOTTOM_LEFT: 4,
      ABSOLUTE: 5
    };
    $.Control = function(element, options, container) {
      var parent = element.parentNode;
      if (typeof options === "number") {
        $.console.error("Passing an anchor directly into the OpenSeadragon.Control constructor is deprecated; " + "please use an options object instead.  " + "Support for this deprecated variant is scheduled for removal in December 2013");
        options = { anchor: options };
      }
      options.attachToViewer = typeof options.attachToViewer === "undefined" ? true : options.attachToViewer;
      this.autoFade = typeof options.autoFade === "undefined" ? true : options.autoFade;
      this.element = element;
      this.anchor = options.anchor;
      this.container = container;
      if (this.anchor === $.ControlAnchor.ABSOLUTE) {
        this.wrapper = $.makeNeutralElement("div");
        this.wrapper.style.position = "absolute";
        this.wrapper.style.top = typeof options.top === "number" ? options.top + "px" : options.top;
        this.wrapper.style.left = typeof options.left === "number" ? options.left + "px" : options.left;
        this.wrapper.style.height = typeof options.height === "number" ? options.height + "px" : options.height;
        this.wrapper.style.width = typeof options.width === "number" ? options.width + "px" : options.width;
        this.wrapper.style.margin = "0px";
        this.wrapper.style.padding = "0px";
        this.element.style.position = "relative";
        this.element.style.top = "0px";
        this.element.style.left = "0px";
        this.element.style.height = "100%";
        this.element.style.width = "100%";
      } else {
        this.wrapper = $.makeNeutralElement("div");
        this.wrapper.style.display = "inline-block";
        if (this.anchor === $.ControlAnchor.NONE) {
          this.wrapper.style.width = this.wrapper.style.height = "100%";
        }
      }
      this.wrapper.appendChild(this.element);
      if (options.attachToViewer) {
        if (this.anchor === $.ControlAnchor.TOP_RIGHT || this.anchor === $.ControlAnchor.BOTTOM_RIGHT) {
          this.container.insertBefore(this.wrapper, this.container.firstChild);
        } else {
          this.container.appendChild(this.wrapper);
        }
      } else {
        parent.appendChild(this.wrapper);
      }
    };
    $.Control.prototype = {
      destroy: function() {
        this.wrapper.removeChild(this.element);
        if (this.anchor !== $.ControlAnchor.NONE) {
          this.container.removeChild(this.wrapper);
        }
      },
      isVisible: function() {
        return this.wrapper.style.display !== "none";
      },
      setVisible: function(visible) {
        this.wrapper.style.display = visible ? this.anchor === $.ControlAnchor.ABSOLUTE ? "block" : "inline-block" : "none";
      },
      setOpacity: function(opacity) {
        $.setElementOpacity(this.wrapper, opacity, true);
      }
    };
  })(OpenSeadragon);
  (function($) {
    $.ControlDock = function(options) {
      var layouts = ["topleft", "topright", "bottomright", "bottomleft"], layout, i;
      $.extend(true, this, {
        id: "controldock-" + $.now() + "-" + Math.floor(Math.random() * 1e6),
        container: $.makeNeutralElement("div"),
        controls: []
      }, options);
      this.container.onsubmit = function() {
        return false;
      };
      if (this.element) {
        this.element = $.getElement(this.element);
        this.element.appendChild(this.container);
        if ($.getElementStyle(this.element).position === "static") {
          this.element.style.position = "relative";
        }
        this.container.style.width = "100%";
        this.container.style.height = "100%";
      }
      for (i = 0;i < layouts.length; i++) {
        layout = layouts[i];
        this.controls[layout] = $.makeNeutralElement("div");
        this.controls[layout].style.position = "absolute";
        if (layout.match("left")) {
          this.controls[layout].style.left = "0px";
        }
        if (layout.match("right")) {
          this.controls[layout].style.right = "0px";
        }
        if (layout.match("top")) {
          this.controls[layout].style.top = "0px";
        }
        if (layout.match("bottom")) {
          this.controls[layout].style.bottom = "0px";
        }
      }
      this.container.appendChild(this.controls.topleft);
      this.container.appendChild(this.controls.topright);
      this.container.appendChild(this.controls.bottomright);
      this.container.appendChild(this.controls.bottomleft);
    };
    $.ControlDock.prototype = {
      addControl: function(element, controlOptions) {
        element = $.getElement(element);
        var div = null;
        if (getControlIndex(this, element) >= 0) {
          return;
        }
        switch (controlOptions.anchor) {
          case $.ControlAnchor.TOP_RIGHT:
            div = this.controls.topright;
            element.style.position = "relative";
            element.style.paddingRight = "0px";
            element.style.paddingTop = "0px";
            break;
          case $.ControlAnchor.BOTTOM_RIGHT:
            div = this.controls.bottomright;
            element.style.position = "relative";
            element.style.paddingRight = "0px";
            element.style.paddingBottom = "0px";
            break;
          case $.ControlAnchor.BOTTOM_LEFT:
            div = this.controls.bottomleft;
            element.style.position = "relative";
            element.style.paddingLeft = "0px";
            element.style.paddingBottom = "0px";
            break;
          case $.ControlAnchor.TOP_LEFT:
            div = this.controls.topleft;
            element.style.position = "relative";
            element.style.paddingLeft = "0px";
            element.style.paddingTop = "0px";
            break;
          case $.ControlAnchor.ABSOLUTE:
            div = this.container;
            element.style.margin = "0px";
            element.style.padding = "0px";
            break;
          default:
          case $.ControlAnchor.NONE:
            div = this.container;
            element.style.margin = "0px";
            element.style.padding = "0px";
            break;
        }
        this.controls.push(new $.Control(element, controlOptions, div));
        element.style.display = "inline-block";
      },
      removeControl: function(element) {
        element = $.getElement(element);
        var i = getControlIndex(this, element);
        if (i >= 0) {
          this.controls[i].destroy();
          this.controls.splice(i, 1);
        }
        return this;
      },
      clearControls: function() {
        while (this.controls.length > 0) {
          this.controls.pop().destroy();
        }
        return this;
      },
      areControlsEnabled: function() {
        var i;
        for (i = this.controls.length - 1;i >= 0; i--) {
          if (this.controls[i].isVisible()) {
            return true;
          }
        }
        return false;
      },
      setControlsEnabled: function(enabled) {
        var i;
        for (i = this.controls.length - 1;i >= 0; i--) {
          this.controls[i].setVisible(enabled);
        }
        return this;
      }
    };
    function getControlIndex(dock, element) {
      var controls = dock.controls, i;
      for (i = controls.length - 1;i >= 0; i--) {
        if (controls[i].element === element) {
          return i;
        }
      }
      return -1;
    }
  })(OpenSeadragon);
  (function($) {
    $.Placement = $.freezeObject({
      CENTER: 0,
      TOP_LEFT: 1,
      TOP: 2,
      TOP_RIGHT: 3,
      RIGHT: 4,
      BOTTOM_RIGHT: 5,
      BOTTOM: 6,
      BOTTOM_LEFT: 7,
      LEFT: 8,
      properties: {
        0: {
          isLeft: false,
          isHorizontallyCentered: true,
          isRight: false,
          isTop: false,
          isVerticallyCentered: true,
          isBottom: false
        },
        1: {
          isLeft: true,
          isHorizontallyCentered: false,
          isRight: false,
          isTop: true,
          isVerticallyCentered: false,
          isBottom: false
        },
        2: {
          isLeft: false,
          isHorizontallyCentered: true,
          isRight: false,
          isTop: true,
          isVerticallyCentered: false,
          isBottom: false
        },
        3: {
          isLeft: false,
          isHorizontallyCentered: false,
          isRight: true,
          isTop: true,
          isVerticallyCentered: false,
          isBottom: false
        },
        4: {
          isLeft: false,
          isHorizontallyCentered: false,
          isRight: true,
          isTop: false,
          isVerticallyCentered: true,
          isBottom: false
        },
        5: {
          isLeft: false,
          isHorizontallyCentered: false,
          isRight: true,
          isTop: false,
          isVerticallyCentered: false,
          isBottom: true
        },
        6: {
          isLeft: false,
          isHorizontallyCentered: true,
          isRight: false,
          isTop: false,
          isVerticallyCentered: false,
          isBottom: true
        },
        7: {
          isLeft: true,
          isHorizontallyCentered: false,
          isRight: false,
          isTop: false,
          isVerticallyCentered: false,
          isBottom: true
        },
        8: {
          isLeft: true,
          isHorizontallyCentered: false,
          isRight: false,
          isTop: false,
          isVerticallyCentered: true,
          isBottom: false
        }
      }
    });
  })(OpenSeadragon);
  (function($) {
    var THIS = {};
    var nextHash = 1;
    $.Viewer = function(options) {
      var args = arguments, _this = this, i;
      if (!$.isPlainObject(options)) {
        options = {
          id: args[0],
          xmlPath: args.length > 1 ? args[1] : undefined,
          prefixUrl: args.length > 2 ? args[2] : undefined,
          controls: args.length > 3 ? args[3] : undefined,
          overlays: args.length > 4 ? args[4] : undefined
        };
      }
      if (options.config) {
        $.extend(true, options, options.config);
        delete options.config;
      }
      let drawerOptionList = [
        "useCanvas"
      ];
      options.drawerOptions = Object.assign({}, drawerOptionList.reduce((drawerOptions, option) => {
        drawerOptions[option] = options[option];
        delete options[option];
        return drawerOptions;
      }, {}), options.drawerOptions);
      $.extend(true, this, {
        id: options.id,
        hash: options.hash || nextHash++,
        initialPage: 0,
        element: null,
        container: null,
        canvas: null,
        overlays: [],
        overlaysContainer: null,
        previousBody: [],
        customControls: [],
        source: null,
        drawer: null,
        world: null,
        viewport: null,
        navigator: null,
        collectionViewport: null,
        collectionDrawer: null,
        navImages: null,
        buttonGroup: null,
        profiler: null
      }, $.DEFAULT_SETTINGS, options);
      if (typeof this.hash === "undefined") {
        throw new Error("A hash must be defined, either by specifying options.id or options.hash.");
      }
      if (typeof THIS[this.hash] !== "undefined") {
        $.console.warn("Hash " + this.hash + " has already been used.");
      }
      THIS[this.hash] = {
        fsBoundsDelta: new $.Point(1, 1),
        prevContainerSize: null,
        animating: false,
        forceRedraw: false,
        needsResize: false,
        forceResize: false,
        mouseInside: false,
        group: null,
        zooming: false,
        zoomFactor: null,
        lastZoomTime: null,
        fullPage: false,
        onfullscreenchange: null,
        lastClickTime: null,
        draggingToZoom: false
      };
      this._sequenceIndex = 0;
      this._firstOpen = true;
      this._updateRequestId = null;
      this._loadQueue = [];
      this.currentOverlays = [];
      this._updatePixelDensityRatioBind = null;
      this._lastScrollTime = $.now();
      $.EventSource.call(this);
      this.addHandler("open-failed", function(event) {
        var msg = $.getString("Errors.OpenFailed", event.eventSource, event.message);
        _this._showMessage(msg);
      });
      $.ControlDock.call(this, options);
      if (this.xmlPath) {
        this.tileSources = [this.xmlPath];
      }
      this.element = this.element || document.getElementById(this.id);
      this.canvas = $.makeNeutralElement("div");
      this.canvas.className = "openseadragon-canvas";
      (function(style) {
        style.width = "100%";
        style.height = "100%";
        style.overflow = "hidden";
        style.position = "absolute";
        style.top = "0px";
        style.left = "0px";
      })(this.canvas.style);
      $.setElementTouchActionNone(this.canvas);
      if (options.tabIndex !== "") {
        this.canvas.tabIndex = options.tabIndex === undefined ? 0 : options.tabIndex;
      }
      this.container.className = "openseadragon-container";
      (function(style) {
        style.width = "100%";
        style.height = "100%";
        style.position = "relative";
        style.overflow = "hidden";
        style.left = "0px";
        style.top = "0px";
        style.textAlign = "left";
      })(this.container.style);
      $.setElementTouchActionNone(this.container);
      this.container.insertBefore(this.canvas, this.container.firstChild);
      this.element.appendChild(this.container);
      this.bodyWidth = document.body.style.width;
      this.bodyHeight = document.body.style.height;
      this.bodyOverflow = document.body.style.overflow;
      this.docOverflow = document.documentElement.style.overflow;
      this.innerTracker = new $.MouseTracker({
        userData: "Viewer.innerTracker",
        element: this.canvas,
        startDisabled: !this.mouseNavEnabled,
        clickTimeThreshold: this.clickTimeThreshold,
        clickDistThreshold: this.clickDistThreshold,
        dblClickTimeThreshold: this.dblClickTimeThreshold,
        dblClickDistThreshold: this.dblClickDistThreshold,
        contextMenuHandler: $.delegate(this, onCanvasContextMenu),
        keyDownHandler: $.delegate(this, onCanvasKeyDown),
        keyHandler: $.delegate(this, onCanvasKeyPress),
        clickHandler: $.delegate(this, onCanvasClick),
        dblClickHandler: $.delegate(this, onCanvasDblClick),
        dragHandler: $.delegate(this, onCanvasDrag),
        dragEndHandler: $.delegate(this, onCanvasDragEnd),
        enterHandler: $.delegate(this, onCanvasEnter),
        leaveHandler: $.delegate(this, onCanvasLeave),
        pressHandler: $.delegate(this, onCanvasPress),
        releaseHandler: $.delegate(this, onCanvasRelease),
        nonPrimaryPressHandler: $.delegate(this, onCanvasNonPrimaryPress),
        nonPrimaryReleaseHandler: $.delegate(this, onCanvasNonPrimaryRelease),
        scrollHandler: $.delegate(this, onCanvasScroll),
        pinchHandler: $.delegate(this, onCanvasPinch),
        focusHandler: $.delegate(this, onCanvasFocus),
        blurHandler: $.delegate(this, onCanvasBlur)
      });
      this.outerTracker = new $.MouseTracker({
        userData: "Viewer.outerTracker",
        element: this.container,
        startDisabled: !this.mouseNavEnabled,
        clickTimeThreshold: this.clickTimeThreshold,
        clickDistThreshold: this.clickDistThreshold,
        dblClickTimeThreshold: this.dblClickTimeThreshold,
        dblClickDistThreshold: this.dblClickDistThreshold,
        enterHandler: $.delegate(this, onContainerEnter),
        leaveHandler: $.delegate(this, onContainerLeave)
      });
      if (this.toolbar) {
        this.toolbar = new $.ControlDock({ element: this.toolbar });
      }
      this.bindStandardControls();
      THIS[this.hash].prevContainerSize = _getSafeElemSize(this.container);
      if (window.ResizeObserver) {
        this._autoResizePolling = false;
        this._resizeObserver = new ResizeObserver(function() {
          THIS[_this.hash].needsResize = true;
        });
        this._resizeObserver.observe(this.container, {});
      } else {
        this._autoResizePolling = true;
      }
      this.world = new $.World({
        viewer: this
      });
      this.world.addHandler("add-item", function(event) {
        _this.source = _this.world.getItemAt(0).source;
        THIS[_this.hash].forceRedraw = true;
        if (!_this._updateRequestId) {
          _this._updateRequestId = scheduleUpdate(_this, updateMulti);
        }
      });
      this.world.addHandler("remove-item", function(event) {
        if (_this.world.getItemCount()) {
          _this.source = _this.world.getItemAt(0).source;
        } else {
          _this.source = null;
        }
        THIS[_this.hash].forceRedraw = true;
      });
      this.world.addHandler("metrics-change", function(event) {
        if (_this.viewport) {
          _this.viewport._setContentBounds(_this.world.getHomeBounds(), _this.world.getContentFactor());
        }
      });
      this.world.addHandler("item-index-change", function(event) {
        _this.source = _this.world.getItemAt(0).source;
      });
      this.viewport = new $.Viewport({
        containerSize: THIS[this.hash].prevContainerSize,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime,
        minZoomImageRatio: this.minZoomImageRatio,
        maxZoomPixelRatio: this.maxZoomPixelRatio,
        visibilityRatio: this.visibilityRatio,
        wrapHorizontal: this.wrapHorizontal,
        wrapVertical: this.wrapVertical,
        defaultZoomLevel: this.defaultZoomLevel,
        minZoomLevel: this.minZoomLevel,
        maxZoomLevel: this.maxZoomLevel,
        viewer: this,
        degrees: this.degrees,
        flipped: this.flipped,
        overlayPreserveContentDirection: this.overlayPreserveContentDirection,
        navigatorRotate: this.navigatorRotate,
        homeFillsViewer: this.homeFillsViewer,
        margins: this.viewportMargins,
        silenceMultiImageWarnings: this.silenceMultiImageWarnings
      });
      this.viewport._setContentBounds(this.world.getHomeBounds(), this.world.getContentFactor());
      this.imageLoader = new $.ImageLoader({
        jobLimit: this.imageLoaderLimit,
        timeout: options.timeout,
        tileRetryMax: this.tileRetryMax,
        tileRetryDelay: this.tileRetryDelay
      });
      this.tileCache = new $.TileCache({
        maxImageCacheCount: this.maxImageCacheCount
      });
      if (Object.prototype.hasOwnProperty.call(this.drawerOptions, "useCanvas")) {
        $.console.error('useCanvas is deprecated, use the "drawer" option to indicate preferred drawer(s)');
        if (!this.drawerOptions.useCanvas) {
          this.drawer = $.HTMLDrawer;
        }
        delete this.drawerOptions.useCanvas;
      }
      let drawerCandidates = Array.isArray(this.drawer) ? this.drawer : [this.drawer];
      if (drawerCandidates.length === 0) {
        drawerCandidates = [$.DEFAULT_SETTINGS.drawer].flat();
        $.console.warn("No valid drawers were selected. Using the default value.");
      }
      this.drawer = null;
      for (const drawerCandidate of drawerCandidates) {
        let success = this.requestDrawer(drawerCandidate, { mainDrawer: true, redrawImmediately: false });
        if (success) {
          break;
        }
      }
      if (!this.drawer) {
        $.console.error("No drawer could be created!");
        throw "Error with creating the selected drawer(s)";
      }
      this.drawer.setImageSmoothingEnabled(this.imageSmoothingEnabled);
      this.overlaysContainer = $.makeNeutralElement("div");
      this.canvas.appendChild(this.overlaysContainer);
      if (!this.drawer.canRotate()) {
        if (this.rotateLeft) {
          i = this.buttonGroup.buttons.indexOf(this.rotateLeft);
          this.buttonGroup.buttons.splice(i, 1);
          this.buttonGroup.element.removeChild(this.rotateLeft.element);
        }
        if (this.rotateRight) {
          i = this.buttonGroup.buttons.indexOf(this.rotateRight);
          this.buttonGroup.buttons.splice(i, 1);
          this.buttonGroup.element.removeChild(this.rotateRight.element);
        }
      }
      this._addUpdatePixelDensityRatioEvent();
      if (this.showNavigator) {
        this.navigator = new $.Navigator({
          element: this.navigatorElement,
          id: this.navigatorId,
          position: this.navigatorPosition,
          sizeRatio: this.navigatorSizeRatio,
          maintainSizeRatio: this.navigatorMaintainSizeRatio,
          top: this.navigatorTop,
          left: this.navigatorLeft,
          width: this.navigatorWidth,
          height: this.navigatorHeight,
          autoResize: this.navigatorAutoResize,
          autoFade: this.navigatorAutoFade,
          prefixUrl: this.prefixUrl,
          viewer: this,
          navigatorRotate: this.navigatorRotate,
          background: this.navigatorBackground,
          opacity: this.navigatorOpacity,
          borderColor: this.navigatorBorderColor,
          displayRegionColor: this.navigatorDisplayRegionColor,
          crossOriginPolicy: this.crossOriginPolicy,
          animationTime: this.animationTime,
          drawer: this.drawer.getType(),
          loadTilesWithAjax: this.loadTilesWithAjax,
          ajaxHeaders: this.ajaxHeaders,
          ajaxWithCredentials: this.ajaxWithCredentials
        });
      }
      if (this.sequenceMode) {
        this.bindSequenceControls();
      }
      if (this.tileSources) {
        this.open(this.tileSources);
      }
      for (i = 0;i < this.customControls.length; i++) {
        this.addControl(this.customControls[i].id, { anchor: this.customControls[i].anchor });
      }
      $.requestAnimationFrame(function() {
        beginControlsAutoHide(_this);
      });
      $._viewers.set(this.element, this);
    };
    $.extend($.Viewer.prototype, $.EventSource.prototype, $.ControlDock.prototype, {
      isOpen: function() {
        return !!this.world.getItemCount();
      },
      openDzi: function(dzi) {
        $.console.error("[Viewer.openDzi] this function is deprecated; use Viewer.open() instead.");
        return this.open(dzi);
      },
      openTileSource: function(tileSource) {
        $.console.error("[Viewer.openTileSource] this function is deprecated; use Viewer.open() instead.");
        return this.open(tileSource);
      },
      get buttons() {
        $.console.warn("Viewer.buttons is deprecated; Please use Viewer.buttonGroup");
        return this.buttonGroup;
      },
      open: function(tileSources, initialPage) {
        var _this = this;
        this.close();
        if (!tileSources) {
          return this;
        }
        if (this.sequenceMode && $.isArray(tileSources)) {
          if (this.referenceStrip) {
            this.referenceStrip.destroy();
            this.referenceStrip = null;
          }
          if (typeof initialPage !== "undefined" && !isNaN(initialPage)) {
            this.initialPage = initialPage;
          }
          this.tileSources = tileSources;
          this._sequenceIndex = Math.max(0, Math.min(this.tileSources.length - 1, this.initialPage));
          if (this.tileSources.length) {
            this.open(this.tileSources[this._sequenceIndex]);
            if (this.showReferenceStrip) {
              this.addReferenceStrip();
            }
          }
          this._updateSequenceButtons(this._sequenceIndex);
          return this;
        }
        if (!$.isArray(tileSources)) {
          tileSources = [tileSources];
        }
        if (!tileSources.length) {
          return this;
        }
        this._opening = true;
        var expected = tileSources.length;
        var successes = 0;
        var failures = 0;
        var failEvent;
        var checkCompletion = function() {
          if (successes + failures === expected) {
            if (successes) {
              if (_this._firstOpen || !_this.preserveViewport) {
                _this.viewport.goHome(true);
                _this.viewport.update();
              }
              _this._firstOpen = false;
              var source = tileSources[0];
              if (source.tileSource) {
                source = source.tileSource;
              }
              if (_this.overlays && !_this.preserveOverlays) {
                for (var i2 = 0;i2 < _this.overlays.length; i2++) {
                  _this.currentOverlays[i2] = getOverlayObject(_this, _this.overlays[i2]);
                }
              }
              _this._drawOverlays();
              _this._opening = false;
              _this.raiseEvent("open", { source });
            } else {
              _this._opening = false;
              _this.raiseEvent("open-failed", failEvent);
            }
          }
        };
        var doOne = function(options) {
          if (!$.isPlainObject(options) || !options.tileSource) {
            options = {
              tileSource: options
            };
          }
          if (options.index !== undefined) {
            $.console.error("[Viewer.open] setting indexes here is not supported; use addTiledImage instead");
            delete options.index;
          }
          if (options.collectionImmediately === undefined) {
            options.collectionImmediately = true;
          }
          var originalSuccess = options.success;
          options.success = function(event) {
            successes++;
            if (options.tileSource.overlays) {
              for (var i2 = 0;i2 < options.tileSource.overlays.length; i2++) {
                _this.addOverlay(options.tileSource.overlays[i2]);
              }
            }
            if (originalSuccess) {
              originalSuccess(event);
            }
            checkCompletion();
          };
          var originalError = options.error;
          options.error = function(event) {
            failures++;
            if (!failEvent) {
              failEvent = event;
            }
            if (originalError) {
              originalError(event);
            }
            checkCompletion();
          };
          _this.addTiledImage(options);
        };
        for (var i = 0;i < tileSources.length; i++) {
          doOne(tileSources[i]);
        }
        return this;
      },
      close: function() {
        if (!THIS[this.hash]) {
          return this;
        }
        this._opening = false;
        if (this.navigator) {
          this.navigator.close();
        }
        if (!this.preserveOverlays) {
          this.clearOverlays();
          this.overlaysContainer.innerHTML = "";
        }
        THIS[this.hash].animating = false;
        this.world.removeAll();
        this.imageLoader.clear();
        this.raiseEvent("close");
        return this;
      },
      destroy: function() {
        if (!THIS[this.hash]) {
          return;
        }
        this.raiseEvent("before-destroy");
        this._removeUpdatePixelDensityRatioEvent();
        this.close();
        this.clearOverlays();
        this.overlaysContainer.innerHTML = "";
        if (this._resizeObserver) {
          this._resizeObserver.disconnect();
        }
        if (this.referenceStrip) {
          this.referenceStrip.destroy();
          this.referenceStrip = null;
        }
        if (this._updateRequestId !== null) {
          $.cancelAnimationFrame(this._updateRequestId);
          this._updateRequestId = null;
        }
        if (this.drawer) {
          this.drawer.destroy();
        }
        if (this.navigator) {
          this.navigator.destroy();
          THIS[this.navigator.hash] = null;
          delete THIS[this.navigator.hash];
          this.navigator = null;
        }
        if (this.buttonGroup) {
          this.buttonGroup.destroy();
        } else if (this.customButtons) {
          while (this.customButtons.length) {
            this.customButtons.pop().destroy();
          }
        }
        if (this.paging) {
          this.paging.destroy();
        }
        if (this.element) {
          while (this.element.firstChild) {
            this.element.removeChild(this.element.firstChild);
          }
        }
        this.container.onsubmit = null;
        this.clearControls();
        if (this.innerTracker) {
          this.innerTracker.destroy();
        }
        if (this.outerTracker) {
          this.outerTracker.destroy();
        }
        THIS[this.hash] = null;
        delete THIS[this.hash];
        this.canvas = null;
        this.container = null;
        $._viewers.delete(this.element);
        this.element = null;
        this.raiseEvent("destroy");
        this.removeAllHandlers();
      },
      requestDrawer(drawerCandidate, options) {
        const defaultOpts = {
          mainDrawer: true,
          redrawImmediately: true,
          drawerOptions: null
        };
        options = $.extend(true, defaultOpts, options);
        const mainDrawer = options.mainDrawer;
        const redrawImmediately = options.redrawImmediately;
        const drawerOptions = options.drawerOptions;
        const oldDrawer = this.drawer;
        let Drawer = null;
        if (drawerCandidate && drawerCandidate.prototype instanceof $.DrawerBase) {
          Drawer = drawerCandidate;
          drawerCandidate = "custom";
        } else if (typeof drawerCandidate === "string") {
          Drawer = $.determineDrawer(drawerCandidate);
        }
        if (!Drawer) {
          $.console.warn("Unsupported drawer! Drawer must be an existing string type, or a class that extends OpenSeadragon.DrawerBase.");
        }
        if (Drawer && Drawer.isSupported()) {
          if (oldDrawer && mainDrawer) {
            oldDrawer.destroy();
          }
          const newDrawer = new Drawer({
            viewer: this,
            viewport: this.viewport,
            element: this.canvas,
            debugGridColor: this.debugGridColor,
            options: drawerOptions || this.drawerOptions[drawerCandidate]
          });
          if (mainDrawer) {
            this.drawer = newDrawer;
            if (redrawImmediately) {
              this.forceRedraw();
            }
          }
          return newDrawer;
        }
        return false;
      },
      isMouseNavEnabled: function() {
        return this.innerTracker.isTracking();
      },
      setMouseNavEnabled: function(enabled) {
        this.innerTracker.setTracking(enabled);
        this.outerTracker.setTracking(enabled);
        this.raiseEvent("mouse-enabled", { enabled });
        return this;
      },
      areControlsEnabled: function() {
        var enabled = this.controls.length, i;
        for (i = 0;i < this.controls.length; i++) {
          enabled = enabled && this.controls[i].isVisible();
        }
        return enabled;
      },
      setControlsEnabled: function(enabled) {
        if (enabled) {
          abortControlsAutoHide(this);
        } else {
          beginControlsAutoHide(this);
        }
        this.raiseEvent("controls-enabled", { enabled });
        return this;
      },
      setDebugMode: function(debugMode) {
        for (var i = 0;i < this.world.getItemCount(); i++) {
          this.world.getItemAt(i).debugMode = debugMode;
        }
        this.debugMode = debugMode;
        this.forceRedraw();
      },
      setAjaxHeaders: function(ajaxHeaders, propagate) {
        if (ajaxHeaders === null) {
          ajaxHeaders = {};
        }
        if (!$.isPlainObject(ajaxHeaders)) {
          console.error("[Viewer.setAjaxHeaders] Ignoring invalid headers, must be a plain object");
          return;
        }
        if (propagate === undefined) {
          propagate = true;
        }
        this.ajaxHeaders = ajaxHeaders;
        if (propagate) {
          for (var i = 0;i < this.world.getItemCount(); i++) {
            this.world.getItemAt(i)._updateAjaxHeaders(true);
          }
          if (this.navigator) {
            this.navigator.setAjaxHeaders(this.ajaxHeaders, true);
          }
          if (this.referenceStrip && this.referenceStrip.miniViewers) {
            for (var key in this.referenceStrip.miniViewers) {
              this.referenceStrip.miniViewers[key].setAjaxHeaders(this.ajaxHeaders, true);
            }
          }
        }
      },
      addButton: function(button) {
        this.buttonGroup.addButton(button);
      },
      isFullPage: function() {
        return THIS[this.hash] && THIS[this.hash].fullPage;
      },
      setFullPage: function(fullPage) {
        var body = document.body, bodyStyle = body.style, docStyle = document.documentElement.style, _this = this, nodes, i;
        if (fullPage === this.isFullPage()) {
          return this;
        }
        var fullPageEventArgs = {
          fullPage,
          preventDefaultAction: false
        };
        this.raiseEvent("pre-full-page", fullPageEventArgs);
        if (fullPageEventArgs.preventDefaultAction) {
          return this;
        }
        if (fullPage && this.element) {
          this.elementSize = $.getElementSize(this.element);
          this.pageScroll = $.getPageScroll();
          this.elementMargin = this.element.style.margin;
          this.element.style.margin = "0";
          this.elementPadding = this.element.style.padding;
          this.element.style.padding = "0";
          this.bodyMargin = bodyStyle.margin;
          this.docMargin = docStyle.margin;
          bodyStyle.margin = "0";
          docStyle.margin = "0";
          this.bodyPadding = bodyStyle.padding;
          this.docPadding = docStyle.padding;
          bodyStyle.padding = "0";
          docStyle.padding = "0";
          this.bodyWidth = bodyStyle.width;
          this.docWidth = docStyle.width;
          bodyStyle.width = "100%";
          docStyle.width = "100%";
          this.bodyHeight = bodyStyle.height;
          this.docHeight = docStyle.height;
          bodyStyle.height = "100%";
          docStyle.height = "100%";
          this.bodyDisplay = bodyStyle.display;
          bodyStyle.display = "block";
          this.previousBody = [];
          THIS[this.hash].prevElementParent = this.element.parentNode;
          THIS[this.hash].prevNextSibling = this.element.nextSibling;
          THIS[this.hash].prevElementWidth = this.element.style.width;
          THIS[this.hash].prevElementHeight = this.element.style.height;
          nodes = body.childNodes.length;
          for (i = 0;i < nodes; i++) {
            this.previousBody.push(body.childNodes[0]);
            body.removeChild(body.childNodes[0]);
          }
          if (this.toolbar && this.toolbar.element) {
            this.toolbar.parentNode = this.toolbar.element.parentNode;
            this.toolbar.nextSibling = this.toolbar.element.nextSibling;
            body.appendChild(this.toolbar.element);
            $.addClass(this.toolbar.element, "fullpage");
          }
          $.addClass(this.element, "fullpage");
          body.appendChild(this.element);
          this.element.style.height = "100vh";
          this.element.style.width = "100vw";
          if (this.toolbar && this.toolbar.element) {
            this.element.style.height = $.getElementSize(this.element).y - $.getElementSize(this.toolbar.element).y + "px";
          }
          THIS[this.hash].fullPage = true;
          $.delegate(this, onContainerEnter)({});
        } else {
          this.element.style.margin = this.elementMargin;
          this.element.style.padding = this.elementPadding;
          bodyStyle.margin = this.bodyMargin;
          docStyle.margin = this.docMargin;
          bodyStyle.padding = this.bodyPadding;
          docStyle.padding = this.docPadding;
          bodyStyle.width = this.bodyWidth;
          docStyle.width = this.docWidth;
          bodyStyle.height = this.bodyHeight;
          docStyle.height = this.docHeight;
          bodyStyle.display = this.bodyDisplay;
          body.removeChild(this.element);
          nodes = this.previousBody.length;
          for (i = 0;i < nodes; i++) {
            body.appendChild(this.previousBody.shift());
          }
          $.removeClass(this.element, "fullpage");
          THIS[this.hash].prevElementParent.insertBefore(this.element, THIS[this.hash].prevNextSibling);
          if (this.toolbar && this.toolbar.element) {
            body.removeChild(this.toolbar.element);
            $.removeClass(this.toolbar.element, "fullpage");
            this.toolbar.parentNode.insertBefore(this.toolbar.element, this.toolbar.nextSibling);
            delete this.toolbar.parentNode;
            delete this.toolbar.nextSibling;
          }
          this.element.style.width = THIS[this.hash].prevElementWidth;
          this.element.style.height = THIS[this.hash].prevElementHeight;
          var restoreScrollCounter = 0;
          var restoreScroll = function() {
            $.setPageScroll(_this.pageScroll);
            var pageScroll = $.getPageScroll();
            restoreScrollCounter++;
            if (restoreScrollCounter < 10 && (pageScroll.x !== _this.pageScroll.x || pageScroll.y !== _this.pageScroll.y)) {
              $.requestAnimationFrame(restoreScroll);
            }
          };
          $.requestAnimationFrame(restoreScroll);
          THIS[this.hash].fullPage = false;
          $.delegate(this, onContainerLeave)({});
        }
        if (this.navigator && this.viewport) {
          this.navigator.update(this.viewport);
        }
        this.raiseEvent("full-page", { fullPage });
        return this;
      },
      setFullScreen: function(fullScreen) {
        var _this = this;
        if (!$.supportsFullScreen) {
          return this.setFullPage(fullScreen);
        }
        if ($.isFullScreen() === fullScreen) {
          return this;
        }
        var fullScreeEventArgs = {
          fullScreen,
          preventDefaultAction: false
        };
        this.raiseEvent("pre-full-screen", fullScreeEventArgs);
        if (fullScreeEventArgs.preventDefaultAction) {
          return this;
        }
        if (fullScreen) {
          this.setFullPage(true);
          if (!this.isFullPage()) {
            return this;
          }
          this.fullPageStyleWidth = this.element.style.width;
          this.fullPageStyleHeight = this.element.style.height;
          this.element.style.width = "100%";
          this.element.style.height = "100%";
          var onFullScreenChange = function() {
            var isFullScreen = $.isFullScreen();
            if (!isFullScreen) {
              $.removeEvent(document, $.fullScreenEventName, onFullScreenChange);
              $.removeEvent(document, $.fullScreenErrorEventName, onFullScreenChange);
              _this.setFullPage(false);
              if (_this.isFullPage()) {
                _this.element.style.width = _this.fullPageStyleWidth;
                _this.element.style.height = _this.fullPageStyleHeight;
              }
            }
            if (_this.navigator && _this.viewport) {
              setTimeout(function() {
                _this.navigator.update(_this.viewport);
              });
            }
            _this.raiseEvent("full-screen", { fullScreen: isFullScreen });
          };
          $.addEvent(document, $.fullScreenEventName, onFullScreenChange);
          $.addEvent(document, $.fullScreenErrorEventName, onFullScreenChange);
          $.requestFullScreen(document.body);
        } else {
          $.exitFullScreen();
        }
        return this;
      },
      isVisible: function() {
        return this.container.style.visibility !== "hidden";
      },
      isFullScreen: function() {
        return $.isFullScreen() && this.isFullPage();
      },
      setVisible: function(visible) {
        this.container.style.visibility = visible ? "" : "hidden";
        this.raiseEvent("visible", { visible });
        return this;
      },
      addTiledImage: function(options) {
        $.console.assert(options, "[Viewer.addTiledImage] options is required");
        $.console.assert(options.tileSource, "[Viewer.addTiledImage] options.tileSource is required");
        $.console.assert(!options.replace || options.index > -1 && options.index < this.world.getItemCount(), "[Viewer.addTiledImage] if options.replace is used, options.index must be a valid index in Viewer.world");
        var _this = this;
        if (options.replace) {
          options.replaceItem = _this.world.getItemAt(options.index);
        }
        this._hideMessage();
        if (options.placeholderFillStyle === undefined) {
          options.placeholderFillStyle = this.placeholderFillStyle;
        }
        if (options.opacity === undefined) {
          options.opacity = this.opacity;
        }
        if (options.preload === undefined) {
          options.preload = this.preload;
        }
        if (options.compositeOperation === undefined) {
          options.compositeOperation = this.compositeOperation;
        }
        if (options.crossOriginPolicy === undefined) {
          options.crossOriginPolicy = options.tileSource.crossOriginPolicy !== undefined ? options.tileSource.crossOriginPolicy : this.crossOriginPolicy;
        }
        if (options.ajaxWithCredentials === undefined) {
          options.ajaxWithCredentials = this.ajaxWithCredentials;
        }
        if (options.loadTilesWithAjax === undefined) {
          options.loadTilesWithAjax = this.loadTilesWithAjax;
        }
        if (!$.isPlainObject(options.ajaxHeaders)) {
          options.ajaxHeaders = {};
        }
        var myQueueItem = {
          options
        };
        function raiseAddItemFailed(event) {
          for (var i = 0;i < _this._loadQueue.length; i++) {
            if (_this._loadQueue[i] === myQueueItem) {
              _this._loadQueue.splice(i, 1);
              break;
            }
          }
          if (_this._loadQueue.length === 0) {
            refreshWorld(myQueueItem);
          }
          _this.raiseEvent("add-item-failed", event);
          if (options.error) {
            options.error(event);
          }
        }
        function refreshWorld(theItem) {
          if (_this.collectionMode) {
            _this.world.arrange({
              immediately: theItem.options.collectionImmediately,
              rows: _this.collectionRows,
              columns: _this.collectionColumns,
              layout: _this.collectionLayout,
              tileSize: _this.collectionTileSize,
              tileMargin: _this.collectionTileMargin
            });
            _this.world.setAutoRefigureSizes(true);
          }
        }
        if ($.isArray(options.tileSource)) {
          setTimeout(function() {
            raiseAddItemFailed({
              message: "[Viewer.addTiledImage] Sequences can not be added; add them one at a time instead.",
              source: options.tileSource,
              options
            });
          });
          return;
        }
        this._loadQueue.push(myQueueItem);
        function processReadyItems() {
          var queueItem, tiledImage, optionsClone;
          while (_this._loadQueue.length) {
            queueItem = _this._loadQueue[0];
            if (!queueItem.tileSource) {
              break;
            }
            _this._loadQueue.splice(0, 1);
            if (queueItem.options.replace) {
              var newIndex = _this.world.getIndexOfItem(queueItem.options.replaceItem);
              if (newIndex !== -1) {
                queueItem.options.index = newIndex;
              }
              _this.world.removeItem(queueItem.options.replaceItem);
            }
            tiledImage = new $.TiledImage({
              viewer: _this,
              source: queueItem.tileSource,
              viewport: _this.viewport,
              drawer: _this.drawer,
              tileCache: _this.tileCache,
              imageLoader: _this.imageLoader,
              x: queueItem.options.x,
              y: queueItem.options.y,
              width: queueItem.options.width,
              height: queueItem.options.height,
              fitBounds: queueItem.options.fitBounds,
              fitBoundsPlacement: queueItem.options.fitBoundsPlacement,
              clip: queueItem.options.clip,
              placeholderFillStyle: queueItem.options.placeholderFillStyle,
              opacity: queueItem.options.opacity,
              preload: queueItem.options.preload,
              degrees: queueItem.options.degrees,
              flipped: queueItem.options.flipped,
              compositeOperation: queueItem.options.compositeOperation,
              springStiffness: _this.springStiffness,
              animationTime: _this.animationTime,
              minZoomImageRatio: _this.minZoomImageRatio,
              wrapHorizontal: _this.wrapHorizontal,
              wrapVertical: _this.wrapVertical,
              maxTilesPerFrame: _this.maxTilesPerFrame,
              immediateRender: _this.immediateRender,
              blendTime: _this.blendTime,
              alwaysBlend: _this.alwaysBlend,
              minPixelRatio: _this.minPixelRatio,
              smoothTileEdgesMinZoom: _this.smoothTileEdgesMinZoom,
              iOSDevice: _this.iOSDevice,
              crossOriginPolicy: queueItem.options.crossOriginPolicy,
              ajaxWithCredentials: queueItem.options.ajaxWithCredentials,
              loadTilesWithAjax: queueItem.options.loadTilesWithAjax,
              ajaxHeaders: queueItem.options.ajaxHeaders,
              debugMode: _this.debugMode,
              subPixelRoundingForTransparency: _this.subPixelRoundingForTransparency
            });
            if (_this.collectionMode) {
              _this.world.setAutoRefigureSizes(false);
            }
            if (_this.navigator) {
              optionsClone = $.extend({}, queueItem.options, {
                replace: false,
                originalTiledImage: tiledImage,
                tileSource: queueItem.tileSource
              });
              _this.navigator.addTiledImage(optionsClone);
            }
            _this.world.addItem(tiledImage, {
              index: queueItem.options.index
            });
            if (_this._loadQueue.length === 0) {
              refreshWorld(queueItem);
            }
            if (_this.world.getItemCount() === 1 && !_this.preserveViewport) {
              _this.viewport.goHome(true);
            }
            if (queueItem.options.success) {
              queueItem.options.success({
                item: tiledImage
              });
            }
          }
        }
        getTileSourceImplementation(this, options.tileSource, options, function(tileSource) {
          myQueueItem.tileSource = tileSource;
          processReadyItems();
        }, function(event) {
          event.options = options;
          raiseAddItemFailed(event);
          processReadyItems();
        });
      },
      addSimpleImage: function(options) {
        $.console.assert(options, "[Viewer.addSimpleImage] options is required");
        $.console.assert(options.url, "[Viewer.addSimpleImage] options.url is required");
        var opts = $.extend({}, options, {
          tileSource: {
            type: "image",
            url: options.url
          }
        });
        delete opts.url;
        this.addTiledImage(opts);
      },
      addLayer: function(options) {
        var _this = this;
        $.console.error("[Viewer.addLayer] this function is deprecated; use Viewer.addTiledImage() instead.");
        var optionsClone = $.extend({}, options, {
          success: function(event) {
            _this.raiseEvent("add-layer", {
              options,
              drawer: event.item
            });
          },
          error: function(event) {
            _this.raiseEvent("add-layer-failed", event);
          }
        });
        this.addTiledImage(optionsClone);
        return this;
      },
      getLayerAtLevel: function(level) {
        $.console.error("[Viewer.getLayerAtLevel] this function is deprecated; use World.getItemAt() instead.");
        return this.world.getItemAt(level);
      },
      getLevelOfLayer: function(drawer) {
        $.console.error("[Viewer.getLevelOfLayer] this function is deprecated; use World.getIndexOfItem() instead.");
        return this.world.getIndexOfItem(drawer);
      },
      getLayersCount: function() {
        $.console.error("[Viewer.getLayersCount] this function is deprecated; use World.getItemCount() instead.");
        return this.world.getItemCount();
      },
      setLayerLevel: function(drawer, level) {
        $.console.error("[Viewer.setLayerLevel] this function is deprecated; use World.setItemIndex() instead.");
        return this.world.setItemIndex(drawer, level);
      },
      removeLayer: function(drawer) {
        $.console.error("[Viewer.removeLayer] this function is deprecated; use World.removeItem() instead.");
        return this.world.removeItem(drawer);
      },
      forceRedraw: function() {
        THIS[this.hash].forceRedraw = true;
        return this;
      },
      forceResize: function() {
        THIS[this.hash].needsResize = true;
        THIS[this.hash].forceResize = true;
      },
      bindSequenceControls: function() {
        var onFocusHandler = $.delegate(this, onFocus), onBlurHandler = $.delegate(this, onBlur), onNextHandler = $.delegate(this, this.goToNextPage), onPreviousHandler = $.delegate(this, this.goToPreviousPage), navImages = this.navImages, useGroup = true;
        if (this.showSequenceControl) {
          if (this.previousButton || this.nextButton) {
            useGroup = false;
          }
          this.previousButton = new $.Button({
            element: this.previousButton ? $.getElement(this.previousButton) : null,
            clickTimeThreshold: this.clickTimeThreshold,
            clickDistThreshold: this.clickDistThreshold,
            tooltip: $.getString("Tooltips.PreviousPage"),
            srcRest: resolveUrl(this.prefixUrl, navImages.previous.REST),
            srcGroup: resolveUrl(this.prefixUrl, navImages.previous.GROUP),
            srcHover: resolveUrl(this.prefixUrl, navImages.previous.HOVER),
            srcDown: resolveUrl(this.prefixUrl, navImages.previous.DOWN),
            onRelease: onPreviousHandler,
            onFocus: onFocusHandler,
            onBlur: onBlurHandler
          });
          this.nextButton = new $.Button({
            element: this.nextButton ? $.getElement(this.nextButton) : null,
            clickTimeThreshold: this.clickTimeThreshold,
            clickDistThreshold: this.clickDistThreshold,
            tooltip: $.getString("Tooltips.NextPage"),
            srcRest: resolveUrl(this.prefixUrl, navImages.next.REST),
            srcGroup: resolveUrl(this.prefixUrl, navImages.next.GROUP),
            srcHover: resolveUrl(this.prefixUrl, navImages.next.HOVER),
            srcDown: resolveUrl(this.prefixUrl, navImages.next.DOWN),
            onRelease: onNextHandler,
            onFocus: onFocusHandler,
            onBlur: onBlurHandler
          });
          if (!this.navPrevNextWrap) {
            this.previousButton.disable();
          }
          if (!this.tileSources || !this.tileSources.length) {
            this.nextButton.disable();
          }
          if (useGroup) {
            this.paging = new $.ButtonGroup({
              buttons: [
                this.previousButton,
                this.nextButton
              ],
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold
            });
            this.pagingControl = this.paging.element;
            if (this.toolbar) {
              this.toolbar.addControl(this.pagingControl, { anchor: $.ControlAnchor.BOTTOM_RIGHT });
            } else {
              this.addControl(this.pagingControl, { anchor: this.sequenceControlAnchor || $.ControlAnchor.TOP_LEFT });
            }
          }
        }
        return this;
      },
      bindStandardControls: function() {
        var beginZoomingInHandler = $.delegate(this, beginZoomingIn), endZoomingHandler = $.delegate(this, endZooming), doSingleZoomInHandler = $.delegate(this, doSingleZoomIn), beginZoomingOutHandler = $.delegate(this, beginZoomingOut), doSingleZoomOutHandler = $.delegate(this, doSingleZoomOut), onHomeHandler = $.delegate(this, onHome), onFullScreenHandler = $.delegate(this, onFullScreen), onRotateLeftHandler = $.delegate(this, onRotateLeft), onRotateRightHandler = $.delegate(this, onRotateRight), onFlipHandler = $.delegate(this, onFlip), onFocusHandler = $.delegate(this, onFocus), onBlurHandler = $.delegate(this, onBlur), navImages = this.navImages, buttons = [], useGroup = true;
        if (this.showNavigationControl) {
          if (this.zoomInButton || this.zoomOutButton || this.homeButton || this.fullPageButton || this.rotateLeftButton || this.rotateRightButton || this.flipButton) {
            useGroup = false;
          }
          if (this.showZoomControl) {
            buttons.push(this.zoomInButton = new $.Button({
              element: this.zoomInButton ? $.getElement(this.zoomInButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: $.getString("Tooltips.ZoomIn"),
              srcRest: resolveUrl(this.prefixUrl, navImages.zoomIn.REST),
              srcGroup: resolveUrl(this.prefixUrl, navImages.zoomIn.GROUP),
              srcHover: resolveUrl(this.prefixUrl, navImages.zoomIn.HOVER),
              srcDown: resolveUrl(this.prefixUrl, navImages.zoomIn.DOWN),
              onPress: beginZoomingInHandler,
              onRelease: endZoomingHandler,
              onClick: doSingleZoomInHandler,
              onEnter: beginZoomingInHandler,
              onExit: endZoomingHandler,
              onFocus: onFocusHandler,
              onBlur: onBlurHandler
            }));
            buttons.push(this.zoomOutButton = new $.Button({
              element: this.zoomOutButton ? $.getElement(this.zoomOutButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: $.getString("Tooltips.ZoomOut"),
              srcRest: resolveUrl(this.prefixUrl, navImages.zoomOut.REST),
              srcGroup: resolveUrl(this.prefixUrl, navImages.zoomOut.GROUP),
              srcHover: resolveUrl(this.prefixUrl, navImages.zoomOut.HOVER),
              srcDown: resolveUrl(this.prefixUrl, navImages.zoomOut.DOWN),
              onPress: beginZoomingOutHandler,
              onRelease: endZoomingHandler,
              onClick: doSingleZoomOutHandler,
              onEnter: beginZoomingOutHandler,
              onExit: endZoomingHandler,
              onFocus: onFocusHandler,
              onBlur: onBlurHandler
            }));
          }
          if (this.showHomeControl) {
            buttons.push(this.homeButton = new $.Button({
              element: this.homeButton ? $.getElement(this.homeButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: $.getString("Tooltips.Home"),
              srcRest: resolveUrl(this.prefixUrl, navImages.home.REST),
              srcGroup: resolveUrl(this.prefixUrl, navImages.home.GROUP),
              srcHover: resolveUrl(this.prefixUrl, navImages.home.HOVER),
              srcDown: resolveUrl(this.prefixUrl, navImages.home.DOWN),
              onRelease: onHomeHandler,
              onFocus: onFocusHandler,
              onBlur: onBlurHandler
            }));
          }
          if (this.showFullPageControl) {
            buttons.push(this.fullPageButton = new $.Button({
              element: this.fullPageButton ? $.getElement(this.fullPageButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: $.getString("Tooltips.FullPage"),
              srcRest: resolveUrl(this.prefixUrl, navImages.fullpage.REST),
              srcGroup: resolveUrl(this.prefixUrl, navImages.fullpage.GROUP),
              srcHover: resolveUrl(this.prefixUrl, navImages.fullpage.HOVER),
              srcDown: resolveUrl(this.prefixUrl, navImages.fullpage.DOWN),
              onRelease: onFullScreenHandler,
              onFocus: onFocusHandler,
              onBlur: onBlurHandler
            }));
          }
          if (this.showRotationControl) {
            buttons.push(this.rotateLeftButton = new $.Button({
              element: this.rotateLeftButton ? $.getElement(this.rotateLeftButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: $.getString("Tooltips.RotateLeft"),
              srcRest: resolveUrl(this.prefixUrl, navImages.rotateleft.REST),
              srcGroup: resolveUrl(this.prefixUrl, navImages.rotateleft.GROUP),
              srcHover: resolveUrl(this.prefixUrl, navImages.rotateleft.HOVER),
              srcDown: resolveUrl(this.prefixUrl, navImages.rotateleft.DOWN),
              onRelease: onRotateLeftHandler,
              onFocus: onFocusHandler,
              onBlur: onBlurHandler
            }));
            buttons.push(this.rotateRightButton = new $.Button({
              element: this.rotateRightButton ? $.getElement(this.rotateRightButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: $.getString("Tooltips.RotateRight"),
              srcRest: resolveUrl(this.prefixUrl, navImages.rotateright.REST),
              srcGroup: resolveUrl(this.prefixUrl, navImages.rotateright.GROUP),
              srcHover: resolveUrl(this.prefixUrl, navImages.rotateright.HOVER),
              srcDown: resolveUrl(this.prefixUrl, navImages.rotateright.DOWN),
              onRelease: onRotateRightHandler,
              onFocus: onFocusHandler,
              onBlur: onBlurHandler
            }));
          }
          if (this.showFlipControl) {
            buttons.push(this.flipButton = new $.Button({
              element: this.flipButton ? $.getElement(this.flipButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: $.getString("Tooltips.Flip"),
              srcRest: resolveUrl(this.prefixUrl, navImages.flip.REST),
              srcGroup: resolveUrl(this.prefixUrl, navImages.flip.GROUP),
              srcHover: resolveUrl(this.prefixUrl, navImages.flip.HOVER),
              srcDown: resolveUrl(this.prefixUrl, navImages.flip.DOWN),
              onRelease: onFlipHandler,
              onFocus: onFocusHandler,
              onBlur: onBlurHandler
            }));
          }
          if (useGroup) {
            this.buttonGroup = new $.ButtonGroup({
              buttons,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold
            });
            this.navControl = this.buttonGroup.element;
            this.addHandler("open", $.delegate(this, lightUp));
            if (this.toolbar) {
              this.toolbar.addControl(this.navControl, { anchor: this.navigationControlAnchor || $.ControlAnchor.TOP_LEFT });
            } else {
              this.addControl(this.navControl, { anchor: this.navigationControlAnchor || $.ControlAnchor.TOP_LEFT });
            }
          } else {
            this.customButtons = buttons;
          }
        }
        return this;
      },
      currentPage: function() {
        return this._sequenceIndex;
      },
      goToPage: function(page) {
        if (this.tileSources && page >= 0 && page < this.tileSources.length) {
          this._sequenceIndex = page;
          this._updateSequenceButtons(page);
          this.open(this.tileSources[page]);
          if (this.referenceStrip) {
            this.referenceStrip.setFocus(page);
          }
          this.raiseEvent("page", { page });
        }
        return this;
      },
      addOverlay: function(element, location, placement, onDraw) {
        var options;
        if ($.isPlainObject(element)) {
          options = element;
        } else {
          options = {
            element,
            location,
            placement,
            onDraw
          };
        }
        element = $.getElement(options.element);
        if (getOverlayIndex(this.currentOverlays, element) >= 0) {
          return this;
        }
        var overlay = getOverlayObject(this, options);
        this.currentOverlays.push(overlay);
        overlay.drawHTML(this.overlaysContainer, this.viewport);
        this.raiseEvent("add-overlay", {
          element,
          location: options.location,
          placement: options.placement
        });
        return this;
      },
      updateOverlay: function(element, location, placement) {
        var i;
        element = $.getElement(element);
        i = getOverlayIndex(this.currentOverlays, element);
        if (i >= 0) {
          this.currentOverlays[i].update(location, placement);
          THIS[this.hash].forceRedraw = true;
          this.raiseEvent("update-overlay", {
            element,
            location,
            placement
          });
        }
        return this;
      },
      removeOverlay: function(element) {
        var i;
        element = $.getElement(element);
        i = getOverlayIndex(this.currentOverlays, element);
        if (i >= 0) {
          this.currentOverlays[i].destroy();
          this.currentOverlays.splice(i, 1);
          THIS[this.hash].forceRedraw = true;
          this.raiseEvent("remove-overlay", {
            element
          });
        }
        return this;
      },
      clearOverlays: function() {
        while (this.currentOverlays.length > 0) {
          this.currentOverlays.pop().destroy();
        }
        THIS[this.hash].forceRedraw = true;
        this.raiseEvent("clear-overlay", {});
        return this;
      },
      getOverlayById: function(element) {
        var i;
        element = $.getElement(element);
        i = getOverlayIndex(this.currentOverlays, element);
        if (i >= 0) {
          return this.currentOverlays[i];
        } else {
          return null;
        }
      },
      _updateSequenceButtons: function(page) {
        if (this.nextButton) {
          if (!this.tileSources || this.tileSources.length - 1 === page) {
            if (!this.navPrevNextWrap) {
              this.nextButton.disable();
            }
          } else {
            this.nextButton.enable();
          }
        }
        if (this.previousButton) {
          if (page > 0) {
            this.previousButton.enable();
          } else {
            if (!this.navPrevNextWrap) {
              this.previousButton.disable();
            }
          }
        }
      },
      _showMessage: function(message) {
        this._hideMessage();
        var div = $.makeNeutralElement("div");
        div.appendChild(document.createTextNode(message));
        this.messageDiv = $.makeCenteredNode(div);
        $.addClass(this.messageDiv, "openseadragon-message");
        this.container.appendChild(this.messageDiv);
      },
      _hideMessage: function() {
        var div = this.messageDiv;
        if (div) {
          div.parentNode.removeChild(div);
          delete this.messageDiv;
        }
      },
      gestureSettingsByDeviceType: function(type) {
        switch (type) {
          case "mouse":
            return this.gestureSettingsMouse;
          case "touch":
            return this.gestureSettingsTouch;
          case "pen":
            return this.gestureSettingsPen;
          default:
            return this.gestureSettingsUnknown;
        }
      },
      _drawOverlays: function() {
        var i, length = this.currentOverlays.length;
        for (i = 0;i < length; i++) {
          this.currentOverlays[i].drawHTML(this.overlaysContainer, this.viewport);
        }
      },
      _cancelPendingImages: function() {
        this._loadQueue = [];
      },
      removeReferenceStrip: function() {
        this.showReferenceStrip = false;
        if (this.referenceStrip) {
          this.referenceStrip.destroy();
          this.referenceStrip = null;
        }
      },
      addReferenceStrip: function() {
        this.showReferenceStrip = true;
        if (this.sequenceMode) {
          if (this.referenceStrip) {
            return;
          }
          if (this.tileSources.length && this.tileSources.length > 1) {
            this.referenceStrip = new $.ReferenceStrip({
              id: this.referenceStripElement,
              position: this.referenceStripPosition,
              sizeRatio: this.referenceStripSizeRatio,
              scroll: this.referenceStripScroll,
              height: this.referenceStripHeight,
              width: this.referenceStripWidth,
              tileSources: this.tileSources,
              prefixUrl: this.prefixUrl,
              viewer: this
            });
            this.referenceStrip.setFocus(this._sequenceIndex);
          }
        } else {
          $.console.warn('Attempting to display a reference strip while "sequenceMode" is off.');
        }
      },
      _addUpdatePixelDensityRatioEvent: function() {
        this._updatePixelDensityRatioBind = this._updatePixelDensityRatio.bind(this);
        $.addEvent(window, "resize", this._updatePixelDensityRatioBind);
      },
      _removeUpdatePixelDensityRatioEvent: function() {
        $.removeEvent(window, "resize", this._updatePixelDensityRatioBind);
      },
      _updatePixelDensityRatio: function() {
        var previusPixelDensityRatio = $.pixelDensityRatio;
        var currentPixelDensityRatio = $.getCurrentPixelDensityRatio();
        if (previusPixelDensityRatio !== currentPixelDensityRatio) {
          $.pixelDensityRatio = currentPixelDensityRatio;
          this.forceResize();
        }
      },
      goToPreviousPage: function() {
        var previous = this._sequenceIndex - 1;
        if (this.navPrevNextWrap && previous < 0) {
          previous += this.tileSources.length;
        }
        this.goToPage(previous);
      },
      goToNextPage: function() {
        var next = this._sequenceIndex + 1;
        if (this.navPrevNextWrap && next >= this.tileSources.length) {
          next = 0;
        }
        this.goToPage(next);
      },
      isAnimating: function() {
        return THIS[this.hash].animating;
      }
    });
    function _getSafeElemSize(oElement) {
      oElement = $.getElement(oElement);
      return new $.Point(oElement.clientWidth === 0 ? 1 : oElement.clientWidth, oElement.clientHeight === 0 ? 1 : oElement.clientHeight);
    }
    function getTileSourceImplementation(viewer, tileSource, imgOptions, successCallback, failCallback) {
      var _this = viewer;
      if ($.type(tileSource) === "string") {
        if (tileSource.match(/^\s*<.*>\s*$/)) {
          tileSource = $.parseXml(tileSource);
        } else if (tileSource.match(/^\s*[{[].*[}\]]\s*$/)) {
          try {
            var tileSourceJ = $.parseJSON(tileSource);
            tileSource = tileSourceJ;
          } catch (e) {}
        }
      }
      function waitUntilReady(tileSource2, originalTileSource) {
        if (tileSource2.ready) {
          successCallback(tileSource2);
        } else {
          tileSource2.addHandler("ready", function() {
            successCallback(tileSource2);
          });
          tileSource2.addHandler("open-failed", function(event) {
            failCallback({
              message: event.message,
              source: originalTileSource
            });
          });
        }
      }
      setTimeout(function() {
        if ($.type(tileSource) === "string") {
          tileSource = new $.TileSource({
            url: tileSource,
            crossOriginPolicy: imgOptions.crossOriginPolicy !== undefined ? imgOptions.crossOriginPolicy : viewer.crossOriginPolicy,
            ajaxWithCredentials: viewer.ajaxWithCredentials,
            ajaxHeaders: imgOptions.ajaxHeaders ? imgOptions.ajaxHeaders : viewer.ajaxHeaders,
            splitHashDataForPost: viewer.splitHashDataForPost,
            success: function(event) {
              successCallback(event.tileSource);
            }
          });
          tileSource.addHandler("open-failed", function(event) {
            failCallback(event);
          });
        } else if ($.isPlainObject(tileSource) || tileSource.nodeType) {
          if (tileSource.crossOriginPolicy === undefined && (imgOptions.crossOriginPolicy !== undefined || viewer.crossOriginPolicy !== undefined)) {
            tileSource.crossOriginPolicy = imgOptions.crossOriginPolicy !== undefined ? imgOptions.crossOriginPolicy : viewer.crossOriginPolicy;
          }
          if (tileSource.ajaxWithCredentials === undefined) {
            tileSource.ajaxWithCredentials = viewer.ajaxWithCredentials;
          }
          if ($.isFunction(tileSource.getTileUrl)) {
            var customTileSource = new $.TileSource(tileSource);
            customTileSource.getTileUrl = tileSource.getTileUrl;
            successCallback(customTileSource);
          } else {
            var $TileSource = $.TileSource.determineType(_this, tileSource);
            if (!$TileSource) {
              failCallback({
                message: "Unable to load TileSource",
                source: tileSource
              });
              return;
            }
            var options = $TileSource.prototype.configure.apply(_this, [tileSource]);
            waitUntilReady(new $TileSource(options), tileSource);
          }
        } else {
          waitUntilReady(tileSource, tileSource);
        }
      });
    }
    function getOverlayObject(viewer, overlay) {
      if (overlay instanceof $.Overlay) {
        return overlay;
      }
      var element = null;
      if (overlay.element) {
        element = $.getElement(overlay.element);
      } else {
        var id = overlay.id ? overlay.id : "openseadragon-overlay-" + Math.floor(Math.random() * 1e7);
        element = $.getElement(overlay.id);
        if (!element) {
          element = document.createElement("a");
          element.href = "#/overlay/" + id;
        }
        element.id = id;
        $.addClass(element, overlay.className ? overlay.className : "openseadragon-overlay");
      }
      var location = overlay.location;
      var width = overlay.width;
      var height = overlay.height;
      if (!location) {
        var x = overlay.x;
        var y = overlay.y;
        if (overlay.px !== undefined) {
          var rect = viewer.viewport.imageToViewportRectangle(new $.Rect(overlay.px, overlay.py, width || 0, height || 0));
          x = rect.x;
          y = rect.y;
          width = width !== undefined ? rect.width : undefined;
          height = height !== undefined ? rect.height : undefined;
        }
        location = new $.Point(x, y);
      }
      var placement = overlay.placement;
      if (placement && $.type(placement) === "string") {
        placement = $.Placement[overlay.placement.toUpperCase()];
      }
      return new $.Overlay({
        element,
        location,
        placement,
        onDraw: overlay.onDraw,
        checkResize: overlay.checkResize,
        width,
        height,
        rotationMode: overlay.rotationMode
      });
    }
    function getOverlayIndex(overlays, element) {
      var i;
      for (i = overlays.length - 1;i >= 0; i--) {
        if (overlays[i].element === element) {
          return i;
        }
      }
      return -1;
    }
    function scheduleUpdate(viewer, updateFunc) {
      return $.requestAnimationFrame(function() {
        updateFunc(viewer);
      });
    }
    function scheduleControlsFade(viewer) {
      $.requestAnimationFrame(function() {
        updateControlsFade(viewer);
      });
    }
    function beginControlsAutoHide(viewer) {
      if (!viewer.autoHideControls) {
        return;
      }
      viewer.controlsShouldFade = true;
      viewer.controlsFadeBeginTime = $.now() + viewer.controlsFadeDelay;
      window.setTimeout(function() {
        scheduleControlsFade(viewer);
      }, viewer.controlsFadeDelay);
    }
    function updateControlsFade(viewer) {
      var currentTime, deltaTime, opacity, i;
      if (viewer.controlsShouldFade) {
        currentTime = $.now();
        deltaTime = currentTime - viewer.controlsFadeBeginTime;
        opacity = 1 - deltaTime / viewer.controlsFadeLength;
        opacity = Math.min(1, opacity);
        opacity = Math.max(0, opacity);
        for (i = viewer.controls.length - 1;i >= 0; i--) {
          if (viewer.controls[i].autoFade) {
            viewer.controls[i].setOpacity(opacity);
          }
        }
        if (opacity > 0) {
          scheduleControlsFade(viewer);
        }
      }
    }
    function abortControlsAutoHide(viewer) {
      var i;
      viewer.controlsShouldFade = false;
      for (i = viewer.controls.length - 1;i >= 0; i--) {
        viewer.controls[i].setOpacity(1);
      }
    }
    function onFocus() {
      abortControlsAutoHide(this);
    }
    function onBlur() {
      beginControlsAutoHide(this);
    }
    function onCanvasContextMenu(event) {
      var eventArgs = {
        tracker: event.eventSource,
        position: event.position,
        originalEvent: event.originalEvent,
        preventDefault: event.preventDefault
      };
      this.raiseEvent("canvas-contextmenu", eventArgs);
      event.preventDefault = eventArgs.preventDefault;
    }
    function onCanvasKeyDown(event) {
      var canvasKeyDownEventArgs = {
        originalEvent: event.originalEvent,
        preventDefaultAction: false,
        preventVerticalPan: event.preventVerticalPan || !this.panVertical,
        preventHorizontalPan: event.preventHorizontalPan || !this.panHorizontal
      };
      this.raiseEvent("canvas-key", canvasKeyDownEventArgs);
      if (!canvasKeyDownEventArgs.preventDefaultAction && !event.ctrl && !event.alt && !event.meta) {
        switch (event.keyCode) {
          case 38:
            if (!canvasKeyDownEventArgs.preventVerticalPan) {
              if (event.shift) {
                this.viewport.zoomBy(1.1);
              } else {
                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, -this.pixelsPerArrowPress)));
              }
              this.viewport.applyConstraints();
            }
            event.preventDefault = true;
            break;
          case 40:
            if (!canvasKeyDownEventArgs.preventVerticalPan) {
              if (event.shift) {
                this.viewport.zoomBy(0.9);
              } else {
                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, this.pixelsPerArrowPress)));
              }
              this.viewport.applyConstraints();
            }
            event.preventDefault = true;
            break;
          case 37:
            if (!canvasKeyDownEventArgs.preventHorizontalPan) {
              this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(-this.pixelsPerArrowPress, 0)));
              this.viewport.applyConstraints();
            }
            event.preventDefault = true;
            break;
          case 39:
            if (!canvasKeyDownEventArgs.preventHorizontalPan) {
              this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(this.pixelsPerArrowPress, 0)));
              this.viewport.applyConstraints();
            }
            event.preventDefault = true;
            break;
          case 187:
            this.viewport.zoomBy(1.1);
            this.viewport.applyConstraints();
            event.preventDefault = true;
            break;
          case 189:
            this.viewport.zoomBy(0.9);
            this.viewport.applyConstraints();
            event.preventDefault = true;
            break;
          case 48:
            this.viewport.goHome();
            this.viewport.applyConstraints();
            event.preventDefault = true;
            break;
          case 87:
            if (!canvasKeyDownEventArgs.preventVerticalPan) {
              if (event.shift) {
                this.viewport.zoomBy(1.1);
              } else {
                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, -40)));
              }
              this.viewport.applyConstraints();
            }
            event.preventDefault = true;
            break;
          case 83:
            if (!canvasKeyDownEventArgs.preventVerticalPan) {
              if (event.shift) {
                this.viewport.zoomBy(0.9);
              } else {
                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, 40)));
              }
              this.viewport.applyConstraints();
            }
            event.preventDefault = true;
            break;
          case 65:
            if (!canvasKeyDownEventArgs.preventHorizontalPan) {
              this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(-40, 0)));
              this.viewport.applyConstraints();
            }
            event.preventDefault = true;
            break;
          case 68:
            if (!canvasKeyDownEventArgs.preventHorizontalPan) {
              this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(40, 0)));
              this.viewport.applyConstraints();
            }
            event.preventDefault = true;
            break;
          case 82:
            if (event.shift) {
              if (this.viewport.flipped) {
                this.viewport.setRotation(this.viewport.getRotation() + this.rotationIncrement);
              } else {
                this.viewport.setRotation(this.viewport.getRotation() - this.rotationIncrement);
              }
            } else {
              if (this.viewport.flipped) {
                this.viewport.setRotation(this.viewport.getRotation() - this.rotationIncrement);
              } else {
                this.viewport.setRotation(this.viewport.getRotation() + this.rotationIncrement);
              }
            }
            this.viewport.applyConstraints();
            event.preventDefault = true;
            break;
          case 70:
            this.viewport.toggleFlip();
            event.preventDefault = true;
            break;
          case 74:
            this.goToPreviousPage();
            break;
          case 75:
            this.goToNextPage();
            break;
          default:
            event.preventDefault = false;
            break;
        }
      } else {
        event.preventDefault = false;
      }
    }
    function onCanvasKeyPress(event) {
      var canvasKeyPressEventArgs = {
        originalEvent: event.originalEvent
      };
      this.raiseEvent("canvas-key-press", canvasKeyPressEventArgs);
    }
    function onCanvasClick(event) {
      var gestureSettings;
      var haveKeyboardFocus = document.activeElement === this.canvas;
      if (!haveKeyboardFocus) {
        this.canvas.focus();
      }
      if (this.viewport.flipped) {
        event.position.x = this.viewport.getContainerSize().x - event.position.x;
      }
      var canvasClickEventArgs = {
        tracker: event.eventSource,
        position: event.position,
        quick: event.quick,
        shift: event.shift,
        originalEvent: event.originalEvent,
        originalTarget: event.originalTarget,
        preventDefaultAction: false
      };
      this.raiseEvent("canvas-click", canvasClickEventArgs);
      if (!canvasClickEventArgs.preventDefaultAction && this.viewport && event.quick) {
        gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
        if (gestureSettings.clickToZoom === true) {
          this.viewport.zoomBy(event.shift ? 1 / this.zoomPerClick : this.zoomPerClick, gestureSettings.zoomToRefPoint ? this.viewport.pointFromPixel(event.position, true) : null);
          this.viewport.applyConstraints();
        }
        if (gestureSettings.dblClickDragToZoom) {
          if (THIS[this.hash].draggingToZoom === true) {
            THIS[this.hash].lastClickTime = null;
            THIS[this.hash].draggingToZoom = false;
          } else {
            THIS[this.hash].lastClickTime = $.now();
          }
        }
      }
    }
    function onCanvasDblClick(event) {
      var gestureSettings;
      var canvasDblClickEventArgs = {
        tracker: event.eventSource,
        position: event.position,
        shift: event.shift,
        originalEvent: event.originalEvent,
        preventDefaultAction: false
      };
      this.raiseEvent("canvas-double-click", canvasDblClickEventArgs);
      if (!canvasDblClickEventArgs.preventDefaultAction && this.viewport) {
        gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
        if (gestureSettings.dblClickToZoom) {
          this.viewport.zoomBy(event.shift ? 1 / this.zoomPerClick : this.zoomPerClick, gestureSettings.zoomToRefPoint ? this.viewport.pointFromPixel(event.position, true) : null);
          this.viewport.applyConstraints();
        }
      }
    }
    function onCanvasDrag(event) {
      var gestureSettings;
      var canvasDragEventArgs = {
        tracker: event.eventSource,
        pointerType: event.pointerType,
        position: event.position,
        delta: event.delta,
        speed: event.speed,
        direction: event.direction,
        shift: event.shift,
        originalEvent: event.originalEvent,
        preventDefaultAction: false
      };
      this.raiseEvent("canvas-drag", canvasDragEventArgs);
      gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
      if (!canvasDragEventArgs.preventDefaultAction && this.viewport) {
        if (gestureSettings.dblClickDragToZoom && THIS[this.hash].draggingToZoom) {
          var factor = Math.pow(this.zoomPerDblClickDrag, event.delta.y / 50);
          this.viewport.zoomBy(factor);
        } else if (gestureSettings.dragToPan && !THIS[this.hash].draggingToZoom) {
          if (!this.panHorizontal) {
            event.delta.x = 0;
          }
          if (!this.panVertical) {
            event.delta.y = 0;
          }
          if (this.viewport.flipped) {
            event.delta.x = -event.delta.x;
          }
          if (this.constrainDuringPan) {
            var delta = this.viewport.deltaPointsFromPixels(event.delta.negate());
            this.viewport.centerSpringX.target.value += delta.x;
            this.viewport.centerSpringY.target.value += delta.y;
            var constrainedBounds = this.viewport.getConstrainedBounds();
            this.viewport.centerSpringX.target.value -= delta.x;
            this.viewport.centerSpringY.target.value -= delta.y;
            if (constrainedBounds.xConstrained) {
              event.delta.x = 0;
            }
            if (constrainedBounds.yConstrained) {
              event.delta.y = 0;
            }
          }
          this.viewport.panBy(this.viewport.deltaPointsFromPixels(event.delta.negate()), gestureSettings.flickEnabled && !this.constrainDuringPan);
        }
      }
    }
    function onCanvasDragEnd(event) {
      var gestureSettings;
      var canvasDragEndEventArgs = {
        tracker: event.eventSource,
        pointerType: event.pointerType,
        position: event.position,
        speed: event.speed,
        direction: event.direction,
        shift: event.shift,
        originalEvent: event.originalEvent,
        preventDefaultAction: false
      };
      this.raiseEvent("canvas-drag-end", canvasDragEndEventArgs);
      gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
      if (!canvasDragEndEventArgs.preventDefaultAction && this.viewport) {
        if (!THIS[this.hash].draggingToZoom && gestureSettings.dragToPan && gestureSettings.flickEnabled && event.speed >= gestureSettings.flickMinSpeed) {
          var amplitudeX = 0;
          if (this.panHorizontal) {
            amplitudeX = gestureSettings.flickMomentum * event.speed * Math.cos(event.direction);
          }
          var amplitudeY = 0;
          if (this.panVertical) {
            amplitudeY = gestureSettings.flickMomentum * event.speed * Math.sin(event.direction);
          }
          var center = this.viewport.pixelFromPoint(this.viewport.getCenter(true));
          var target = this.viewport.pointFromPixel(new $.Point(center.x - amplitudeX, center.y - amplitudeY));
          this.viewport.panTo(target, false);
        }
        this.viewport.applyConstraints();
      }
      if (gestureSettings.dblClickDragToZoom && THIS[this.hash].draggingToZoom === true) {
        THIS[this.hash].draggingToZoom = false;
      }
    }
    function onCanvasEnter(event) {
      this.raiseEvent("canvas-enter", {
        tracker: event.eventSource,
        pointerType: event.pointerType,
        position: event.position,
        buttons: event.buttons,
        pointers: event.pointers,
        insideElementPressed: event.insideElementPressed,
        buttonDownAny: event.buttonDownAny,
        originalEvent: event.originalEvent
      });
    }
    function onCanvasLeave(event) {
      this.raiseEvent("canvas-exit", {
        tracker: event.eventSource,
        pointerType: event.pointerType,
        position: event.position,
        buttons: event.buttons,
        pointers: event.pointers,
        insideElementPressed: event.insideElementPressed,
        buttonDownAny: event.buttonDownAny,
        originalEvent: event.originalEvent
      });
    }
    function onCanvasPress(event) {
      var gestureSettings;
      this.raiseEvent("canvas-press", {
        tracker: event.eventSource,
        pointerType: event.pointerType,
        position: event.position,
        insideElementPressed: event.insideElementPressed,
        insideElementReleased: event.insideElementReleased,
        originalEvent: event.originalEvent
      });
      gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
      if (gestureSettings.dblClickDragToZoom) {
        var lastClickTime = THIS[this.hash].lastClickTime;
        var currClickTime = $.now();
        if (lastClickTime === null) {
          return;
        }
        if (currClickTime - lastClickTime < this.dblClickTimeThreshold) {
          THIS[this.hash].draggingToZoom = true;
        }
        THIS[this.hash].lastClickTime = null;
      }
    }
    function onCanvasRelease(event) {
      this.raiseEvent("canvas-release", {
        tracker: event.eventSource,
        pointerType: event.pointerType,
        position: event.position,
        insideElementPressed: event.insideElementPressed,
        insideElementReleased: event.insideElementReleased,
        originalEvent: event.originalEvent
      });
    }
    function onCanvasNonPrimaryPress(event) {
      this.raiseEvent("canvas-nonprimary-press", {
        tracker: event.eventSource,
        position: event.position,
        pointerType: event.pointerType,
        button: event.button,
        buttons: event.buttons,
        originalEvent: event.originalEvent
      });
    }
    function onCanvasNonPrimaryRelease(event) {
      this.raiseEvent("canvas-nonprimary-release", {
        tracker: event.eventSource,
        position: event.position,
        pointerType: event.pointerType,
        button: event.button,
        buttons: event.buttons,
        originalEvent: event.originalEvent
      });
    }
    function onCanvasPinch(event) {
      var gestureSettings, centerPt, lastCenterPt, panByPt;
      var canvasPinchEventArgs = {
        tracker: event.eventSource,
        pointerType: event.pointerType,
        gesturePoints: event.gesturePoints,
        lastCenter: event.lastCenter,
        center: event.center,
        lastDistance: event.lastDistance,
        distance: event.distance,
        shift: event.shift,
        originalEvent: event.originalEvent,
        preventDefaultPanAction: false,
        preventDefaultZoomAction: false,
        preventDefaultRotateAction: false
      };
      this.raiseEvent("canvas-pinch", canvasPinchEventArgs);
      if (this.viewport) {
        gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
        if (gestureSettings.pinchToZoom && (!canvasPinchEventArgs.preventDefaultPanAction || !canvasPinchEventArgs.preventDefaultZoomAction)) {
          centerPt = this.viewport.pointFromPixel(event.center, true);
          if (gestureSettings.zoomToRefPoint && !canvasPinchEventArgs.preventDefaultPanAction) {
            lastCenterPt = this.viewport.pointFromPixel(event.lastCenter, true);
            panByPt = lastCenterPt.minus(centerPt);
            if (!this.panHorizontal) {
              panByPt.x = 0;
            }
            if (!this.panVertical) {
              panByPt.y = 0;
            }
            this.viewport.panBy(panByPt, true);
          }
          if (!canvasPinchEventArgs.preventDefaultZoomAction) {
            this.viewport.zoomBy(event.distance / event.lastDistance, centerPt, true);
          }
          this.viewport.applyConstraints();
        }
        if (gestureSettings.pinchRotate && !canvasPinchEventArgs.preventDefaultRotateAction) {
          var angle1 = Math.atan2(event.gesturePoints[0].currentPos.y - event.gesturePoints[1].currentPos.y, event.gesturePoints[0].currentPos.x - event.gesturePoints[1].currentPos.x);
          var angle2 = Math.atan2(event.gesturePoints[0].lastPos.y - event.gesturePoints[1].lastPos.y, event.gesturePoints[0].lastPos.x - event.gesturePoints[1].lastPos.x);
          centerPt = this.viewport.pointFromPixel(event.center, true);
          this.viewport.rotateTo(this.viewport.getRotation(true) + (angle1 - angle2) * (180 / Math.PI), centerPt, true);
        }
      }
    }
    function onCanvasFocus(event) {
      this.raiseEvent("canvas-focus", {
        tracker: event.eventSource,
        originalEvent: event.originalEvent
      });
    }
    function onCanvasBlur(event) {
      this.raiseEvent("canvas-blur", {
        tracker: event.eventSource,
        originalEvent: event.originalEvent
      });
    }
    function onCanvasScroll(event) {
      var canvasScrollEventArgs, gestureSettings, factor, thisScrollTime, deltaScrollTime;
      thisScrollTime = $.now();
      deltaScrollTime = thisScrollTime - this._lastScrollTime;
      if (deltaScrollTime > this.minScrollDeltaTime) {
        this._lastScrollTime = thisScrollTime;
        canvasScrollEventArgs = {
          tracker: event.eventSource,
          position: event.position,
          scroll: event.scroll,
          shift: event.shift,
          originalEvent: event.originalEvent,
          preventDefaultAction: false,
          preventDefault: true
        };
        this.raiseEvent("canvas-scroll", canvasScrollEventArgs);
        if (!canvasScrollEventArgs.preventDefaultAction && this.viewport) {
          if (this.viewport.flipped) {
            event.position.x = this.viewport.getContainerSize().x - event.position.x;
          }
          gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
          if (gestureSettings.scrollToZoom) {
            factor = Math.pow(this.zoomPerScroll, event.scroll);
            this.viewport.zoomBy(factor, gestureSettings.zoomToRefPoint ? this.viewport.pointFromPixel(event.position, true) : null);
            this.viewport.applyConstraints();
          }
        }
        event.preventDefault = canvasScrollEventArgs.preventDefault;
      } else {
        event.preventDefault = true;
      }
    }
    function onContainerEnter(event) {
      THIS[this.hash].mouseInside = true;
      abortControlsAutoHide(this);
      this.raiseEvent("container-enter", {
        tracker: event.eventSource,
        pointerType: event.pointerType,
        position: event.position,
        buttons: event.buttons,
        pointers: event.pointers,
        insideElementPressed: event.insideElementPressed,
        buttonDownAny: event.buttonDownAny,
        originalEvent: event.originalEvent
      });
    }
    function onContainerLeave(event) {
      if (event.pointers < 1) {
        THIS[this.hash].mouseInside = false;
        if (!THIS[this.hash].animating) {
          beginControlsAutoHide(this);
        }
      }
      this.raiseEvent("container-exit", {
        tracker: event.eventSource,
        pointerType: event.pointerType,
        position: event.position,
        buttons: event.buttons,
        pointers: event.pointers,
        insideElementPressed: event.insideElementPressed,
        buttonDownAny: event.buttonDownAny,
        originalEvent: event.originalEvent
      });
    }
    function updateMulti(viewer) {
      updateOnce(viewer);
      if (viewer.isOpen()) {
        viewer._updateRequestId = scheduleUpdate(viewer, updateMulti);
      } else {
        viewer._updateRequestId = false;
      }
    }
    function doViewerResize(viewer, containerSize) {
      var viewport = viewer.viewport;
      var zoom = viewport.getZoom();
      var center = viewport.getCenter();
      viewport.resize(containerSize, viewer.preserveImageSizeOnResize);
      viewport.panTo(center, true);
      var resizeRatio;
      if (viewer.preserveImageSizeOnResize) {
        resizeRatio = THIS[viewer.hash].prevContainerSize.x / containerSize.x;
      } else {
        var origin = new $.Point(0, 0);
        var prevDiag = new $.Point(THIS[viewer.hash].prevContainerSize.x, THIS[viewer.hash].prevContainerSize.y).distanceTo(origin);
        var newDiag = new $.Point(containerSize.x, containerSize.y).distanceTo(origin);
        resizeRatio = newDiag / prevDiag * THIS[viewer.hash].prevContainerSize.x / containerSize.x;
      }
      viewport.zoomTo(zoom * resizeRatio, null, true);
      THIS[viewer.hash].prevContainerSize = containerSize;
      THIS[viewer.hash].forceRedraw = true;
      THIS[viewer.hash].needsResize = false;
      THIS[viewer.hash].forceResize = false;
    }
    function updateOnce(viewer) {
      if (viewer._opening || !THIS[viewer.hash]) {
        return;
      }
      if (viewer.autoResize || THIS[viewer.hash].forceResize) {
        var containerSize;
        if (viewer._autoResizePolling) {
          containerSize = _getSafeElemSize(viewer.container);
          var prevContainerSize = THIS[viewer.hash].prevContainerSize;
          if (!containerSize.equals(prevContainerSize)) {
            THIS[viewer.hash].needsResize = true;
          }
        }
        if (THIS[viewer.hash].needsResize) {
          doViewerResize(viewer, containerSize || _getSafeElemSize(viewer.container));
        }
      }
      var viewportChange = viewer.viewport.update();
      var animated = viewer.world.update(viewportChange) || viewportChange;
      if (viewportChange) {
        viewer.raiseEvent("viewport-change");
      }
      if (viewer.referenceStrip) {
        animated = viewer.referenceStrip.update(viewer.viewport) || animated;
      }
      var currentAnimating = THIS[viewer.hash].animating;
      if (!currentAnimating && animated) {
        viewer.raiseEvent("animation-start");
        abortControlsAutoHide(viewer);
      }
      var isAnimationFinished = currentAnimating && !animated;
      if (isAnimationFinished) {
        THIS[viewer.hash].animating = false;
      }
      if (animated || isAnimationFinished || THIS[viewer.hash].forceRedraw || viewer.world.needsDraw()) {
        drawWorld(viewer);
        viewer._drawOverlays();
        if (viewer.navigator) {
          viewer.navigator.update(viewer.viewport);
        }
        THIS[viewer.hash].forceRedraw = false;
        if (animated) {
          viewer.raiseEvent("animation");
        }
      }
      if (isAnimationFinished) {
        viewer.raiseEvent("animation-finish");
        if (!THIS[viewer.hash].mouseInside) {
          beginControlsAutoHide(viewer);
        }
      }
      THIS[viewer.hash].animating = animated;
    }
    function drawWorld(viewer) {
      viewer.imageLoader.clear();
      viewer.world.draw();
      viewer.raiseEvent("update-viewport", {});
    }
    function resolveUrl(prefix, url) {
      return prefix ? prefix + url : url;
    }
    function beginZoomingIn() {
      THIS[this.hash].lastZoomTime = $.now();
      THIS[this.hash].zoomFactor = this.zoomPerSecond;
      THIS[this.hash].zooming = true;
      scheduleZoom(this);
    }
    function beginZoomingOut() {
      THIS[this.hash].lastZoomTime = $.now();
      THIS[this.hash].zoomFactor = 1 / this.zoomPerSecond;
      THIS[this.hash].zooming = true;
      scheduleZoom(this);
    }
    function endZooming() {
      THIS[this.hash].zooming = false;
    }
    function scheduleZoom(viewer) {
      $.requestAnimationFrame($.delegate(viewer, doZoom));
    }
    function doZoom() {
      var currentTime, deltaTime, adjustedFactor;
      if (THIS[this.hash].zooming && this.viewport) {
        currentTime = $.now();
        deltaTime = currentTime - THIS[this.hash].lastZoomTime;
        adjustedFactor = Math.pow(THIS[this.hash].zoomFactor, deltaTime / 1000);
        this.viewport.zoomBy(adjustedFactor);
        this.viewport.applyConstraints();
        THIS[this.hash].lastZoomTime = currentTime;
        scheduleZoom(this);
      }
    }
    function doSingleZoomIn() {
      if (this.viewport) {
        THIS[this.hash].zooming = false;
        this.viewport.zoomBy(this.zoomPerClick / 1);
        this.viewport.applyConstraints();
      }
    }
    function doSingleZoomOut() {
      if (this.viewport) {
        THIS[this.hash].zooming = false;
        this.viewport.zoomBy(1 / this.zoomPerClick);
        this.viewport.applyConstraints();
      }
    }
    function lightUp() {
      if (this.buttonGroup) {
        this.buttonGroup.emulateEnter();
        this.buttonGroup.emulateLeave();
      }
    }
    function onHome() {
      if (this.viewport) {
        this.viewport.goHome();
      }
    }
    function onFullScreen() {
      if (this.isFullPage() && !$.isFullScreen()) {
        this.setFullPage(false);
      } else {
        this.setFullScreen(!this.isFullPage());
      }
      if (this.buttonGroup) {
        this.buttonGroup.emulateLeave();
      }
      this.fullPageButton.element.focus();
      if (this.viewport) {
        this.viewport.applyConstraints();
      }
    }
    function onRotateLeft() {
      if (this.viewport) {
        var currRotation = this.viewport.getRotation();
        if (this.viewport.flipped) {
          currRotation += this.rotationIncrement;
        } else {
          currRotation -= this.rotationIncrement;
        }
        this.viewport.setRotation(currRotation);
      }
    }
    function onRotateRight() {
      if (this.viewport) {
        var currRotation = this.viewport.getRotation();
        if (this.viewport.flipped) {
          currRotation -= this.rotationIncrement;
        } else {
          currRotation += this.rotationIncrement;
        }
        this.viewport.setRotation(currRotation);
      }
    }
    function onFlip() {
      this.viewport.toggleFlip();
    }
    $.determineDrawer = function(id) {
      for (let property in OpenSeadragon) {
        const drawer = OpenSeadragon[property], proto = drawer.prototype;
        if (proto && proto instanceof OpenSeadragon.DrawerBase && $.isFunction(proto.getType) && proto.getType.call(drawer) === id) {
          return drawer;
        }
      }
      return null;
    };
  })(OpenSeadragon);
  (function($) {
    $.Navigator = function(options) {
      var viewer = options.viewer, _this = this, viewerSize, navigatorSize;
      if (options.element || options.id) {
        if (options.element) {
          if (options.id) {
            $.console.warn("Given option.id for Navigator was ignored since option.element was provided and is being used instead.");
          }
          if (options.element.id) {
            options.id = options.element.id;
          } else {
            options.id = "navigator-" + $.now();
          }
          this.element = options.element;
        } else {
          this.element = document.getElementById(options.id);
        }
        options.controlOptions = {
          anchor: $.ControlAnchor.NONE,
          attachToViewer: false,
          autoFade: false
        };
      } else {
        options.id = "navigator-" + $.now();
        this.element = $.makeNeutralElement("div");
        options.controlOptions = {
          anchor: $.ControlAnchor.TOP_RIGHT,
          attachToViewer: true,
          autoFade: options.autoFade
        };
        if (options.position) {
          if (options.position === "BOTTOM_RIGHT") {
            options.controlOptions.anchor = $.ControlAnchor.BOTTOM_RIGHT;
          } else if (options.position === "BOTTOM_LEFT") {
            options.controlOptions.anchor = $.ControlAnchor.BOTTOM_LEFT;
          } else if (options.position === "TOP_RIGHT") {
            options.controlOptions.anchor = $.ControlAnchor.TOP_RIGHT;
          } else if (options.position === "TOP_LEFT") {
            options.controlOptions.anchor = $.ControlAnchor.TOP_LEFT;
          } else if (options.position === "ABSOLUTE") {
            options.controlOptions.anchor = $.ControlAnchor.ABSOLUTE;
            options.controlOptions.top = options.top;
            options.controlOptions.left = options.left;
            options.controlOptions.height = options.height;
            options.controlOptions.width = options.width;
          }
        }
      }
      this.element.id = options.id;
      this.element.className += " navigator";
      options = $.extend(true, {
        sizeRatio: $.DEFAULT_SETTINGS.navigatorSizeRatio
      }, options, {
        element: this.element,
        tabIndex: -1,
        showNavigator: false,
        mouseNavEnabled: false,
        showNavigationControl: false,
        showSequenceControl: false,
        immediateRender: true,
        blendTime: 0,
        animationTime: options.animationTime,
        autoResize: false,
        minZoomImageRatio: 1,
        background: options.background,
        opacity: options.opacity,
        borderColor: options.borderColor,
        displayRegionColor: options.displayRegionColor
      });
      options.minPixelRatio = this.minPixelRatio = viewer.minPixelRatio;
      $.setElementTouchActionNone(this.element);
      this.borderWidth = 2;
      this.fudge = new $.Point(1, 1);
      this.totalBorderWidths = new $.Point(this.borderWidth * 2, this.borderWidth * 2).minus(this.fudge);
      if (options.controlOptions.anchor !== $.ControlAnchor.NONE) {
        (function(style, borderWidth) {
          style.margin = "0px";
          style.border = borderWidth + "px solid " + options.borderColor;
          style.padding = "0px";
          style.background = options.background;
          style.opacity = options.opacity;
          style.overflow = "hidden";
        })(this.element.style, this.borderWidth);
      }
      this.displayRegion = $.makeNeutralElement("div");
      this.displayRegion.id = this.element.id + "-displayregion";
      this.displayRegion.className = "displayregion";
      (function(style, borderWidth) {
        style.position = "relative";
        style.top = "0px";
        style.left = "0px";
        style.fontSize = "0px";
        style.overflow = "hidden";
        style.border = borderWidth + "px solid " + options.displayRegionColor;
        style.margin = "0px";
        style.padding = "0px";
        style.background = "transparent";
        style["float"] = "left";
        style.cssFloat = "left";
        style.zIndex = 999999999;
        style.cursor = "default";
        style.boxSizing = "content-box";
      })(this.displayRegion.style, this.borderWidth);
      $.setElementPointerEventsNone(this.displayRegion);
      $.setElementTouchActionNone(this.displayRegion);
      this.displayRegionContainer = $.makeNeutralElement("div");
      this.displayRegionContainer.id = this.element.id + "-displayregioncontainer";
      this.displayRegionContainer.className = "displayregioncontainer";
      this.displayRegionContainer.style.width = "100%";
      this.displayRegionContainer.style.height = "100%";
      $.setElementPointerEventsNone(this.displayRegionContainer);
      $.setElementTouchActionNone(this.displayRegionContainer);
      viewer.addControl(this.element, options.controlOptions);
      this._resizeWithViewer = options.controlOptions.anchor !== $.ControlAnchor.ABSOLUTE && options.controlOptions.anchor !== $.ControlAnchor.NONE;
      if (options.width && options.height) {
        this.setWidth(options.width);
        this.setHeight(options.height);
      } else if (this._resizeWithViewer) {
        viewerSize = $.getElementSize(viewer.element);
        this.element.style.height = Math.round(viewerSize.y * options.sizeRatio) + "px";
        this.element.style.width = Math.round(viewerSize.x * options.sizeRatio) + "px";
        this.oldViewerSize = viewerSize;
        navigatorSize = $.getElementSize(this.element);
        this.elementArea = navigatorSize.x * navigatorSize.y;
      }
      this.oldContainerSize = new $.Point(0, 0);
      $.Viewer.apply(this, [options]);
      this.displayRegionContainer.appendChild(this.displayRegion);
      this.element.getElementsByTagName("div")[0].appendChild(this.displayRegionContainer);
      function rotate(degrees2, immediately) {
        _setTransformRotate(_this.displayRegionContainer, degrees2);
        _setTransformRotate(_this.displayRegion, -degrees2);
        _this.viewport.setRotation(degrees2, immediately);
      }
      if (options.navigatorRotate) {
        var degrees = options.viewer.viewport ? options.viewer.viewport.getRotation() : options.viewer.degrees || 0;
        rotate(degrees, true);
        options.viewer.addHandler("rotate", function(args) {
          rotate(args.degrees, args.immediately);
        });
      }
      this.innerTracker.destroy();
      this.innerTracker = new $.MouseTracker({
        userData: "Navigator.innerTracker",
        element: this.element,
        dragHandler: $.delegate(this, onCanvasDrag),
        clickHandler: $.delegate(this, onCanvasClick),
        releaseHandler: $.delegate(this, onCanvasRelease),
        scrollHandler: $.delegate(this, onCanvasScroll),
        preProcessEventHandler: function(eventInfo) {
          if (eventInfo.eventType === "wheel") {
            eventInfo.preventDefault = true;
          }
        }
      });
      this.outerTracker.userData = "Navigator.outerTracker";
      $.setElementPointerEventsNone(this.canvas);
      $.setElementPointerEventsNone(this.container);
      this.addHandler("reset-size", function() {
        if (_this.viewport) {
          _this.viewport.goHome(true);
        }
      });
      viewer.world.addHandler("item-index-change", function(event) {
        window.setTimeout(function() {
          var item = _this.world.getItemAt(event.previousIndex);
          _this.world.setItemIndex(item, event.newIndex);
        }, 1);
      });
      viewer.world.addHandler("remove-item", function(event) {
        var theirItem = event.item;
        var myItem = _this._getMatchingItem(theirItem);
        if (myItem) {
          _this.world.removeItem(myItem);
        }
      });
      this.update(viewer.viewport);
    };
    $.extend($.Navigator.prototype, $.EventSource.prototype, $.Viewer.prototype, {
      updateSize: function() {
        if (this.viewport) {
          var containerSize = new $.Point(this.container.clientWidth === 0 ? 1 : this.container.clientWidth, this.container.clientHeight === 0 ? 1 : this.container.clientHeight);
          if (!containerSize.equals(this.oldContainerSize)) {
            this.viewport.resize(containerSize, true);
            this.viewport.goHome(true);
            this.oldContainerSize = containerSize;
            this.world.update();
            this.world.draw();
            this.update(this.viewer.viewport);
          }
        }
      },
      setWidth: function(width) {
        this.width = width;
        this.element.style.width = typeof width === "number" ? width + "px" : width;
        this._resizeWithViewer = false;
        this.updateSize();
      },
      setHeight: function(height) {
        this.height = height;
        this.element.style.height = typeof height === "number" ? height + "px" : height;
        this._resizeWithViewer = false;
        this.updateSize();
      },
      setFlip: function(state) {
        this.viewport.setFlip(state);
        this.setDisplayTransform(this.viewer.viewport.getFlip() ? "scale(-1,1)" : "scale(1,1)");
        return this;
      },
      setDisplayTransform: function(rule) {
        setElementTransform(this.canvas, rule);
        setElementTransform(this.element, rule);
      },
      update: function(viewport) {
        var viewerSize, newWidth, newHeight, bounds, topleft, bottomright;
        if (!viewport) {
          viewport = this.viewer.viewport;
        }
        viewerSize = $.getElementSize(this.viewer.element);
        if (this._resizeWithViewer && viewerSize.x && viewerSize.y && !viewerSize.equals(this.oldViewerSize)) {
          this.oldViewerSize = viewerSize;
          if (this.maintainSizeRatio || !this.elementArea) {
            newWidth = viewerSize.x * this.sizeRatio;
            newHeight = viewerSize.y * this.sizeRatio;
          } else {
            newWidth = Math.sqrt(this.elementArea * (viewerSize.x / viewerSize.y));
            newHeight = this.elementArea / newWidth;
          }
          this.element.style.width = Math.round(newWidth) + "px";
          this.element.style.height = Math.round(newHeight) + "px";
          if (!this.elementArea) {
            this.elementArea = newWidth * newHeight;
          }
          this.updateSize();
        }
        if (viewport && this.viewport) {
          bounds = viewport.getBoundsNoRotate(true);
          topleft = this.viewport.pixelFromPointNoRotate(bounds.getTopLeft(), false);
          bottomright = this.viewport.pixelFromPointNoRotate(bounds.getBottomRight(), false).minus(this.totalBorderWidths);
          if (!this.navigatorRotate) {
            var degrees = viewport.getRotation(true);
            _setTransformRotate(this.displayRegion, -degrees);
          }
          var style = this.displayRegion.style;
          style.display = this.world.getItemCount() ? "block" : "none";
          style.top = topleft.y.toFixed(2) + "px";
          style.left = topleft.x.toFixed(2) + "px";
          var width = bottomright.x - topleft.x;
          var height = bottomright.y - topleft.y;
          style.width = Math.round(Math.max(width, 0)) + "px";
          style.height = Math.round(Math.max(height, 0)) + "px";
        }
      },
      addTiledImage: function(options) {
        var _this = this;
        var original = options.originalTiledImage;
        delete options.original;
        var optionsClone = $.extend({}, options, {
          success: function(event) {
            var myItem = event.item;
            myItem._originalForNavigator = original;
            _this._matchBounds(myItem, original, true);
            _this._matchOpacity(myItem, original);
            _this._matchCompositeOperation(myItem, original);
            function matchBounds() {
              _this._matchBounds(myItem, original);
            }
            function matchOpacity() {
              _this._matchOpacity(myItem, original);
            }
            function matchCompositeOperation() {
              _this._matchCompositeOperation(myItem, original);
            }
            original.addHandler("bounds-change", matchBounds);
            original.addHandler("clip-change", matchBounds);
            original.addHandler("opacity-change", matchOpacity);
            original.addHandler("composite-operation-change", matchCompositeOperation);
          }
        });
        return $.Viewer.prototype.addTiledImage.apply(this, [optionsClone]);
      },
      destroy: function() {
        return $.Viewer.prototype.destroy.apply(this);
      },
      _getMatchingItem: function(theirItem) {
        var count = this.world.getItemCount();
        var item;
        for (var i = 0;i < count; i++) {
          item = this.world.getItemAt(i);
          if (item._originalForNavigator === theirItem) {
            return item;
          }
        }
        return null;
      },
      _matchBounds: function(myItem, theirItem, immediately) {
        var bounds = theirItem.getBoundsNoRotate();
        myItem.setPosition(bounds.getTopLeft(), immediately);
        myItem.setWidth(bounds.width, immediately);
        myItem.setRotation(theirItem.getRotation(), immediately);
        myItem.setClip(theirItem.getClip());
        myItem.setFlip(theirItem.getFlip());
      },
      _matchOpacity: function(myItem, theirItem) {
        myItem.setOpacity(theirItem.opacity);
      },
      _matchCompositeOperation: function(myItem, theirItem) {
        myItem.setCompositeOperation(theirItem.compositeOperation);
      }
    });
    function onCanvasClick(event) {
      var canvasClickEventArgs = {
        tracker: event.eventSource,
        position: event.position,
        quick: event.quick,
        shift: event.shift,
        originalEvent: event.originalEvent,
        preventDefaultAction: false
      };
      this.viewer.raiseEvent("navigator-click", canvasClickEventArgs);
      if (!canvasClickEventArgs.preventDefaultAction && event.quick && this.viewer.viewport && (this.panVertical || this.panHorizontal)) {
        if (this.viewer.viewport.flipped) {
          event.position.x = this.viewport.getContainerSize().x - event.position.x;
        }
        var target = this.viewport.pointFromPixel(event.position);
        if (!this.panVertical) {
          target.y = this.viewer.viewport.getCenter(true).y;
        } else if (!this.panHorizontal) {
          target.x = this.viewer.viewport.getCenter(true).x;
        }
        this.viewer.viewport.panTo(target);
        this.viewer.viewport.applyConstraints();
      }
    }
    function onCanvasDrag(event) {
      var canvasDragEventArgs = {
        tracker: event.eventSource,
        position: event.position,
        delta: event.delta,
        speed: event.speed,
        direction: event.direction,
        shift: event.shift,
        originalEvent: event.originalEvent,
        preventDefaultAction: false
      };
      this.viewer.raiseEvent("navigator-drag", canvasDragEventArgs);
      if (!canvasDragEventArgs.preventDefaultAction && this.viewer.viewport) {
        if (!this.panHorizontal) {
          event.delta.x = 0;
        }
        if (!this.panVertical) {
          event.delta.y = 0;
        }
        if (this.viewer.viewport.flipped) {
          event.delta.x = -event.delta.x;
        }
        this.viewer.viewport.panBy(this.viewport.deltaPointsFromPixels(event.delta));
        if (this.viewer.constrainDuringPan) {
          this.viewer.viewport.applyConstraints();
        }
      }
    }
    function onCanvasRelease(event) {
      if (event.insideElementPressed && this.viewer.viewport) {
        this.viewer.viewport.applyConstraints();
      }
    }
    function onCanvasScroll(event) {
      var eventArgs = {
        tracker: event.eventSource,
        position: event.position,
        scroll: event.scroll,
        shift: event.shift,
        originalEvent: event.originalEvent,
        preventDefault: event.preventDefault
      };
      this.viewer.raiseEvent("navigator-scroll", eventArgs);
      event.preventDefault = eventArgs.preventDefault;
    }
    function _setTransformRotate(element, degrees) {
      setElementTransform(element, "rotate(" + degrees + "deg)");
    }
    function setElementTransform(element, rule) {
      element.style.webkitTransform = rule;
      element.style.mozTransform = rule;
      element.style.msTransform = rule;
      element.style.oTransform = rule;
      element.style.transform = rule;
    }
  })(OpenSeadragon);
  (function($) {
    var I18N = {
      Errors: {
        Dzc: "Sorry, we don't support Deep Zoom Collections!",
        Dzi: "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
        Xml: "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
        ImageFormat: "Sorry, we don't support {0}-based Deep Zoom Images.",
        Security: "It looks like a security restriction stopped us from " + "loading this Deep Zoom Image.",
        Status: "This space unintentionally left blank ({0} {1}).",
        OpenFailed: "Unable to open {0}: {1}"
      },
      Tooltips: {
        FullPage: "Toggle full page",
        Home: "Go home",
        ZoomIn: "Zoom in",
        ZoomOut: "Zoom out",
        NextPage: "Next page",
        PreviousPage: "Previous page",
        RotateLeft: "Rotate left",
        RotateRight: "Rotate right",
        Flip: "Flip Horizontally"
      }
    };
    $.extend($, {
      getString: function(prop) {
        var props = prop.split("."), string = null, args = arguments, container = I18N, i;
        for (i = 0;i < props.length - 1; i++) {
          container = container[props[i]] || {};
        }
        string = container[props[i]];
        if (typeof string !== "string") {
          $.console.error("Untranslated source string:", prop);
          string = "";
        }
        return string.replace(/\{\d+\}/g, function(capture) {
          var i2 = parseInt(capture.match(/\d+/), 10) + 1;
          return i2 < args.length ? args[i2] : "";
        });
      },
      setString: function(prop, value) {
        var props = prop.split("."), container = I18N, i;
        for (i = 0;i < props.length - 1; i++) {
          if (!container[props[i]]) {
            container[props[i]] = {};
          }
          container = container[props[i]];
        }
        container[props[i]] = value;
      }
    });
  })(OpenSeadragon);
  (function($) {
    $.Point = function(x, y) {
      this.x = typeof x === "number" ? x : 0;
      this.y = typeof y === "number" ? y : 0;
    };
    $.Point.prototype = {
      clone: function() {
        return new $.Point(this.x, this.y);
      },
      plus: function(point) {
        return new $.Point(this.x + point.x, this.y + point.y);
      },
      minus: function(point) {
        return new $.Point(this.x - point.x, this.y - point.y);
      },
      times: function(factor) {
        return new $.Point(this.x * factor, this.y * factor);
      },
      divide: function(factor) {
        return new $.Point(this.x / factor, this.y / factor);
      },
      negate: function() {
        return new $.Point(-this.x, -this.y);
      },
      distanceTo: function(point) {
        return Math.sqrt(Math.pow(this.x - point.x, 2) + Math.pow(this.y - point.y, 2));
      },
      squaredDistanceTo: function(point) {
        return Math.pow(this.x - point.x, 2) + Math.pow(this.y - point.y, 2);
      },
      apply: function(func) {
        return new $.Point(func(this.x), func(this.y));
      },
      equals: function(point) {
        return point instanceof $.Point && this.x === point.x && this.y === point.y;
      },
      rotate: function(degrees, pivot) {
        pivot = pivot || new $.Point(0, 0);
        var cos;
        var sin;
        if (degrees % 90 === 0) {
          var d = $.positiveModulo(degrees, 360);
          switch (d) {
            case 0:
              cos = 1;
              sin = 0;
              break;
            case 90:
              cos = 0;
              sin = 1;
              break;
            case 180:
              cos = -1;
              sin = 0;
              break;
            case 270:
              cos = 0;
              sin = -1;
              break;
          }
        } else {
          var angle = degrees * Math.PI / 180;
          cos = Math.cos(angle);
          sin = Math.sin(angle);
        }
        var x = cos * (this.x - pivot.x) - sin * (this.y - pivot.y) + pivot.x;
        var y = sin * (this.x - pivot.x) + cos * (this.y - pivot.y) + pivot.y;
        return new $.Point(x, y);
      },
      toString: function() {
        return "(" + Math.round(this.x * 100) / 100 + "," + Math.round(this.y * 100) / 100 + ")";
      }
    };
  })(OpenSeadragon);
  (function($) {
    $.TileSource = function(width, height, tileSize, tileOverlap, minLevel, maxLevel) {
      var _this = this;
      var args = arguments, options, i;
      if ($.isPlainObject(width)) {
        options = width;
      } else {
        options = {
          width: args[0],
          height: args[1],
          tileSize: args[2],
          tileOverlap: args[3],
          minLevel: args[4],
          maxLevel: args[5]
        };
      }
      $.EventSource.call(this);
      $.extend(true, this, options);
      if (!this.success) {
        for (i = 0;i < arguments.length; i++) {
          if ($.isFunction(arguments[i])) {
            this.success = arguments[i];
            break;
          }
        }
      }
      if (this.success) {
        this.addHandler("ready", function(event) {
          _this.success(event);
        });
      }
      if ($.type(arguments[0]) === "string") {
        this.url = arguments[0];
      }
      if (this.url) {
        this.aspectRatio = 1;
        this.dimensions = new $.Point(10, 10);
        this._tileWidth = 0;
        this._tileHeight = 0;
        this.tileOverlap = 0;
        this.minLevel = 0;
        this.maxLevel = 0;
        this.ready = false;
        this.getImageInfo(this.url);
      } else {
        this.ready = true;
        this.aspectRatio = options.width && options.height ? options.width / options.height : 1;
        this.dimensions = new $.Point(options.width, options.height);
        if (this.tileSize) {
          this._tileWidth = this._tileHeight = this.tileSize;
          delete this.tileSize;
        } else {
          if (this.tileWidth) {
            this._tileWidth = this.tileWidth;
            delete this.tileWidth;
          } else {
            this._tileWidth = 0;
          }
          if (this.tileHeight) {
            this._tileHeight = this.tileHeight;
            delete this.tileHeight;
          } else {
            this._tileHeight = 0;
          }
        }
        this.tileOverlap = options.tileOverlap ? options.tileOverlap : 0;
        this.minLevel = options.minLevel ? options.minLevel : 0;
        this.maxLevel = options.maxLevel !== undefined && options.maxLevel !== null ? options.maxLevel : options.width && options.height ? Math.ceil(Math.log(Math.max(options.width, options.height)) / Math.log(2)) : 0;
        if (this.success && $.isFunction(this.success)) {
          this.success(this);
        }
      }
    };
    $.TileSource.prototype = {
      getTileSize: function(level) {
        $.console.error("[TileSource.getTileSize] is deprecated. " + "Use TileSource.getTileWidth() and TileSource.getTileHeight() instead");
        return this._tileWidth;
      },
      getTileWidth: function(level) {
        if (!this._tileWidth) {
          return this.getTileSize(level);
        }
        return this._tileWidth;
      },
      getTileHeight: function(level) {
        if (!this._tileHeight) {
          return this.getTileSize(level);
        }
        return this._tileHeight;
      },
      setMaxLevel: function(level) {
        this.maxLevel = level;
        this._memoizeLevelScale();
      },
      getLevelScale: function(level) {
        this._memoizeLevelScale();
        return this.getLevelScale(level);
      },
      _memoizeLevelScale: function() {
        var levelScaleCache = {}, i;
        for (i = 0;i <= this.maxLevel; i++) {
          levelScaleCache[i] = 1 / Math.pow(2, this.maxLevel - i);
        }
        this.getLevelScale = function(_level) {
          return levelScaleCache[_level];
        };
      },
      getNumTiles: function(level) {
        var scale = this.getLevelScale(level), x = Math.ceil(scale * this.dimensions.x / this.getTileWidth(level)), y = Math.ceil(scale * this.dimensions.y / this.getTileHeight(level));
        return new $.Point(x, y);
      },
      getPixelRatio: function(level) {
        var imageSizeScaled = this.dimensions.times(this.getLevelScale(level)), rx = 1 / imageSizeScaled.x * $.pixelDensityRatio, ry = 1 / imageSizeScaled.y * $.pixelDensityRatio;
        return new $.Point(rx, ry);
      },
      getClosestLevel: function() {
        var i, tiles;
        for (i = this.minLevel + 1;i <= this.maxLevel; i++) {
          tiles = this.getNumTiles(i);
          if (tiles.x > 1 || tiles.y > 1) {
            break;
          }
        }
        return i - 1;
      },
      getTileAtPoint: function(level, point) {
        var validPoint = point.x >= 0 && point.x <= 1 && point.y >= 0 && point.y <= 1 / this.aspectRatio;
        $.console.assert(validPoint, "[TileSource.getTileAtPoint] must be called with a valid point.");
        var widthScaled = this.dimensions.x * this.getLevelScale(level);
        var pixelX = point.x * widthScaled;
        var pixelY = point.y * widthScaled;
        var x = Math.floor(pixelX / this.getTileWidth(level));
        var y = Math.floor(pixelY / this.getTileHeight(level));
        if (point.x >= 1) {
          x = this.getNumTiles(level).x - 1;
        }
        var EPSILON = 0.000000000000001;
        if (point.y >= 1 / this.aspectRatio - EPSILON) {
          y = this.getNumTiles(level).y - 1;
        }
        return new $.Point(x, y);
      },
      getTileBounds: function(level, x, y, isSource) {
        var dimensionsScaled = this.dimensions.times(this.getLevelScale(level)), tileWidth = this.getTileWidth(level), tileHeight = this.getTileHeight(level), px = x === 0 ? 0 : tileWidth * x - this.tileOverlap, py = y === 0 ? 0 : tileHeight * y - this.tileOverlap, sx = tileWidth + (x === 0 ? 1 : 2) * this.tileOverlap, sy = tileHeight + (y === 0 ? 1 : 2) * this.tileOverlap, scale = 1 / dimensionsScaled.x;
        sx = Math.min(sx, dimensionsScaled.x - px);
        sy = Math.min(sy, dimensionsScaled.y - py);
        if (isSource) {
          return new $.Rect(0, 0, sx, sy);
        }
        return new $.Rect(px * scale, py * scale, sx * scale, sy * scale);
      },
      getImageInfo: function(url) {
        var _this = this, callbackName, callback, readySource, options, urlParts, filename, lastDot;
        if (url) {
          urlParts = url.split("/");
          filename = urlParts[urlParts.length - 1];
          lastDot = filename.lastIndexOf(".");
          if (lastDot > -1) {
            urlParts[urlParts.length - 1] = filename.slice(0, lastDot);
          }
        }
        var postData = null;
        if (this.splitHashDataForPost) {
          var hashIdx = url.indexOf("#");
          if (hashIdx !== -1) {
            postData = url.substring(hashIdx + 1);
            url = url.substr(0, hashIdx);
          }
        }
        callback = function(data) {
          if (typeof data === "string") {
            data = $.parseXml(data);
          }
          var $TileSource = $.TileSource.determineType(_this, data, url);
          if (!$TileSource) {
            _this.raiseEvent("open-failed", { message: "Unable to load TileSource", source: url });
            return;
          }
          options = $TileSource.prototype.configure.apply(_this, [data, url, postData]);
          if (options.ajaxWithCredentials === undefined) {
            options.ajaxWithCredentials = _this.ajaxWithCredentials;
          }
          readySource = new $TileSource(options);
          _this.ready = true;
          _this.raiseEvent("ready", { tileSource: readySource });
        };
        if (url.match(/\.js$/)) {
          callbackName = url.split("/").pop().replace(".js", "");
          $.jsonp({
            url,
            async: false,
            callbackName,
            callback
          });
        } else {
          $.makeAjaxRequest({
            url,
            postData,
            withCredentials: this.ajaxWithCredentials,
            headers: this.ajaxHeaders,
            success: function(xhr) {
              var data = processResponse(xhr);
              callback(data);
            },
            error: function(xhr, exc) {
              var msg;
              try {
                msg = "HTTP " + xhr.status + " attempting to load TileSource: " + url;
              } catch (e) {
                var formattedExc;
                if (typeof exc === "undefined" || !exc.toString) {
                  formattedExc = "Unknown error";
                } else {
                  formattedExc = exc.toString();
                }
                msg = formattedExc + " attempting to load TileSource: " + url;
              }
              $.console.error(msg);
              _this.raiseEvent("open-failed", {
                message: msg,
                source: url,
                postData
              });
            }
          });
        }
      },
      supports: function(data, url) {
        return false;
      },
      configure: function(data, url, postData) {
        throw new Error("Method not implemented.");
      },
      getTileUrl: function(level, x, y) {
        throw new Error("Method not implemented.");
      },
      getTilePostData: function(level, x, y) {
        return null;
      },
      getTileAjaxHeaders: function(level, x, y) {
        return {};
      },
      getTileHashKey: function(level, x, y, url, ajaxHeaders, postData) {
        function withHeaders(hash) {
          return ajaxHeaders ? hash + "+" + JSON.stringify(ajaxHeaders) : hash;
        }
        if (typeof url !== "string") {
          return withHeaders(level + "/" + x + "_" + y);
        }
        return withHeaders(url);
      },
      tileExists: function(level, x, y) {
        var numTiles = this.getNumTiles(level);
        return level >= this.minLevel && level <= this.maxLevel && x >= 0 && y >= 0 && x < numTiles.x && y < numTiles.y;
      },
      hasTransparency: function(context2D, url, ajaxHeaders, post) {
        return !!context2D || url.match(".png");
      },
      downloadTileStart: function(context) {
        var dataStore = context.userData, image = new Image;
        dataStore.image = image;
        dataStore.request = null;
        var finish = function(error) {
          if (!image) {
            context.finish(null, dataStore.request, "Image load failed: undefined Image instance.");
            return;
          }
          image.onload = image.onerror = image.onabort = null;
          context.finish(error ? null : image, dataStore.request, error);
        };
        image.onload = function() {
          finish();
        };
        image.onabort = image.onerror = function() {
          finish("Image load aborted.");
        };
        if (context.loadWithAjax) {
          dataStore.request = $.makeAjaxRequest({
            url: context.src,
            withCredentials: context.ajaxWithCredentials,
            headers: context.ajaxHeaders,
            responseType: "arraybuffer",
            postData: context.postData,
            success: function(request) {
              var blb;
              try {
                blb = new window.Blob([request.response]);
              } catch (e) {
                var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
                if (e.name === "TypeError" && BlobBuilder) {
                  var bb = new BlobBuilder;
                  bb.append(request.response);
                  blb = bb.getBlob();
                }
              }
              if (blb.size === 0) {
                finish("Empty image response.");
              } else {
                image.src = (window.URL || window.webkitURL).createObjectURL(blb);
              }
            },
            error: function(request) {
              finish("Image load aborted - XHR error");
            }
          });
        } else {
          if (context.crossOriginPolicy !== false) {
            image.crossOrigin = context.crossOriginPolicy;
          }
          image.src = context.src;
        }
      },
      downloadTileAbort: function(context) {
        if (context.userData.request) {
          context.userData.request.abort();
        }
        var image = context.userData.image;
        if (context.userData.image) {
          image.onload = image.onerror = image.onabort = null;
        }
      },
      createTileCache: function(cacheObject, data, tile) {
        cacheObject._data = data;
      },
      destroyTileCache: function(cacheObject) {
        cacheObject._data = null;
        cacheObject._renderedContext = null;
      },
      getTileCacheData: function(cacheObject) {
        return cacheObject._data;
      },
      getTileCacheDataAsImage: function(cacheObject) {
        return cacheObject._data;
      },
      getTileCacheDataAsContext2D: function(cacheObject) {
        if (!cacheObject._renderedContext) {
          var canvas = document.createElement("canvas");
          canvas.width = cacheObject._data.width;
          canvas.height = cacheObject._data.height;
          cacheObject._renderedContext = canvas.getContext("2d");
          cacheObject._renderedContext.drawImage(cacheObject._data, 0, 0);
          cacheObject._data = null;
        }
        return cacheObject._renderedContext;
      }
    };
    $.extend(true, $.TileSource.prototype, $.EventSource.prototype);
    function processResponse(xhr) {
      var { responseText, status } = xhr, statusText, data;
      if (!xhr) {
        throw new Error($.getString("Errors.Security"));
      } else if (xhr.status !== 200 && xhr.status !== 0) {
        status = xhr.status;
        statusText = status === 404 ? "Not Found" : xhr.statusText;
        throw new Error($.getString("Errors.Status", status, statusText));
      }
      if (responseText.match(/^\s*<.*/)) {
        try {
          data = xhr.responseXML && xhr.responseXML.documentElement ? xhr.responseXML : $.parseXml(responseText);
        } catch (e) {
          data = xhr.responseText;
        }
      } else if (responseText.match(/\s*[{[].*/)) {
        try {
          data = $.parseJSON(responseText);
        } catch (e) {
          data = responseText;
        }
      } else {
        data = responseText;
      }
      return data;
    }
    $.TileSource.determineType = function(tileSource, data, url) {
      var property;
      for (property in OpenSeadragon) {
        if (property.match(/.+TileSource$/) && $.isFunction(OpenSeadragon[property]) && $.isFunction(OpenSeadragon[property].prototype.supports) && OpenSeadragon[property].prototype.supports.call(tileSource, data, url)) {
          return OpenSeadragon[property];
        }
      }
      $.console.error("No TileSource was able to open %s %s", url, data);
      return null;
    };
  })(OpenSeadragon);
  (function($) {
    $.DziTileSource = function(width, height, tileSize, tileOverlap, tilesUrl, fileFormat, displayRects, minLevel, maxLevel) {
      var i, rect, level, options;
      if ($.isPlainObject(width)) {
        options = width;
      } else {
        options = {
          width: arguments[0],
          height: arguments[1],
          tileSize: arguments[2],
          tileOverlap: arguments[3],
          tilesUrl: arguments[4],
          fileFormat: arguments[5],
          displayRects: arguments[6],
          minLevel: arguments[7],
          maxLevel: arguments[8]
        };
      }
      this._levelRects = {};
      this.tilesUrl = options.tilesUrl;
      this.fileFormat = options.fileFormat;
      this.displayRects = options.displayRects;
      if (this.displayRects) {
        for (i = this.displayRects.length - 1;i >= 0; i--) {
          rect = this.displayRects[i];
          for (level = rect.minLevel;level <= rect.maxLevel; level++) {
            if (!this._levelRects[level]) {
              this._levelRects[level] = [];
            }
            this._levelRects[level].push(rect);
          }
        }
      }
      $.TileSource.apply(this, [options]);
    };
    $.extend($.DziTileSource.prototype, $.TileSource.prototype, {
      supports: function(data, url) {
        var ns;
        if (data.Image) {
          ns = data.Image.xmlns;
        } else if (data.documentElement) {
          if (data.documentElement.localName === "Image" || data.documentElement.tagName === "Image") {
            ns = data.documentElement.namespaceURI;
          }
        }
        ns = (ns || "").toLowerCase();
        return ns.indexOf("schemas.microsoft.com/deepzoom/2008") !== -1 || ns.indexOf("schemas.microsoft.com/deepzoom/2009") !== -1;
      },
      configure: function(data, url, postData) {
        var options;
        if (!$.isPlainObject(data)) {
          options = configureFromXML(this, data);
        } else {
          options = configureFromObject(this, data);
        }
        if (url && !options.tilesUrl) {
          options.tilesUrl = url.replace(/([^/]+?)(\.(dzi|xml|js)?(\?[^/]*)?)?\/?$/, "$1_files/");
          if (url.search(/\.(dzi|xml|js)\?/) !== -1) {
            options.queryParams = url.match(/\?.*/);
          } else {
            options.queryParams = "";
          }
        }
        return options;
      },
      getTileUrl: function(level, x, y) {
        return [this.tilesUrl, level, "/", x, "_", y, ".", this.fileFormat, this.queryParams].join("");
      },
      tileExists: function(level, x, y) {
        var rects = this._levelRects[level], rect, scale, xMin, yMin, xMax, yMax, i;
        if (this.minLevel && level < this.minLevel || this.maxLevel && level > this.maxLevel) {
          return false;
        }
        if (!rects || !rects.length) {
          return true;
        }
        for (i = rects.length - 1;i >= 0; i--) {
          rect = rects[i];
          if (level < rect.minLevel || level > rect.maxLevel) {
            continue;
          }
          scale = this.getLevelScale(level);
          xMin = rect.x * scale;
          yMin = rect.y * scale;
          xMax = xMin + rect.width * scale;
          yMax = yMin + rect.height * scale;
          xMin = Math.floor(xMin / this._tileWidth);
          yMin = Math.floor(yMin / this._tileWidth);
          xMax = Math.ceil(xMax / this._tileWidth);
          yMax = Math.ceil(yMax / this._tileWidth);
          if (xMin <= x && x < xMax && yMin <= y && y < yMax) {
            return true;
          }
        }
        return false;
      }
    });
    function configureFromXML(tileSource, xmlDoc) {
      if (!xmlDoc || !xmlDoc.documentElement) {
        throw new Error($.getString("Errors.Xml"));
      }
      var root = xmlDoc.documentElement, rootName = root.localName || root.tagName, ns = xmlDoc.documentElement.namespaceURI, configuration = null, displayRects = [], dispRectNodes, dispRectNode, rectNode, sizeNode, i;
      if (rootName === "Image") {
        try {
          sizeNode = root.getElementsByTagName("Size")[0];
          if (sizeNode === undefined) {
            sizeNode = root.getElementsByTagNameNS(ns, "Size")[0];
          }
          configuration = {
            Image: {
              xmlns: "http://schemas.microsoft.com/deepzoom/2008",
              Url: root.getAttribute("Url"),
              Format: root.getAttribute("Format"),
              DisplayRect: null,
              Overlap: parseInt(root.getAttribute("Overlap"), 10),
              TileSize: parseInt(root.getAttribute("TileSize"), 10),
              Size: {
                Height: parseInt(sizeNode.getAttribute("Height"), 10),
                Width: parseInt(sizeNode.getAttribute("Width"), 10)
              }
            }
          };
          if (!$.imageFormatSupported(configuration.Image.Format)) {
            throw new Error($.getString("Errors.ImageFormat", configuration.Image.Format.toUpperCase()));
          }
          dispRectNodes = root.getElementsByTagName("DisplayRect");
          if (dispRectNodes === undefined) {
            dispRectNodes = root.getElementsByTagNameNS(ns, "DisplayRect")[0];
          }
          for (i = 0;i < dispRectNodes.length; i++) {
            dispRectNode = dispRectNodes[i];
            rectNode = dispRectNode.getElementsByTagName("Rect")[0];
            if (rectNode === undefined) {
              rectNode = dispRectNode.getElementsByTagNameNS(ns, "Rect")[0];
            }
            displayRects.push({
              Rect: {
                X: parseInt(rectNode.getAttribute("X"), 10),
                Y: parseInt(rectNode.getAttribute("Y"), 10),
                Width: parseInt(rectNode.getAttribute("Width"), 10),
                Height: parseInt(rectNode.getAttribute("Height"), 10),
                MinLevel: parseInt(dispRectNode.getAttribute("MinLevel"), 10),
                MaxLevel: parseInt(dispRectNode.getAttribute("MaxLevel"), 10)
              }
            });
          }
          if (displayRects.length) {
            configuration.Image.DisplayRect = displayRects;
          }
          return configureFromObject(tileSource, configuration);
        } catch (e) {
          throw e instanceof Error ? e : new Error($.getString("Errors.Dzi"));
        }
      } else if (rootName === "Collection") {
        throw new Error($.getString("Errors.Dzc"));
      } else if (rootName === "Error") {
        var messageNode = root.getElementsByTagName("Message")[0];
        var message = messageNode.firstChild.nodeValue;
        throw new Error(message);
      }
      throw new Error($.getString("Errors.Dzi"));
    }
    function configureFromObject(tileSource, configuration) {
      var imageData = configuration.Image, tilesUrl = imageData.Url, fileFormat = imageData.Format, sizeData = imageData.Size, dispRectData = imageData.DisplayRect || [], width = parseInt(sizeData.Width, 10), height = parseInt(sizeData.Height, 10), tileSize = parseInt(imageData.TileSize, 10), tileOverlap = parseInt(imageData.Overlap, 10), displayRects = [], rectData, i;
      for (i = 0;i < dispRectData.length; i++) {
        rectData = dispRectData[i].Rect;
        displayRects.push(new $.DisplayRect(parseInt(rectData.X, 10), parseInt(rectData.Y, 10), parseInt(rectData.Width, 10), parseInt(rectData.Height, 10), parseInt(rectData.MinLevel, 10), parseInt(rectData.MaxLevel, 10)));
      }
      return $.extend(true, {
        width,
        height,
        tileSize,
        tileOverlap,
        minLevel: null,
        maxLevel: null,
        tilesUrl,
        fileFormat,
        displayRects
      }, configuration);
    }
  })(OpenSeadragon);
  (function($) {
    $.IIIFTileSource = function(options) {
      $.extend(true, this, options);
      this._id = this["@id"] || this["id"] || this["identifier"] || null;
      if (!(this.height && this.width && this._id)) {
        throw new Error("IIIF required parameters (width, height, or id) not provided.");
      }
      options.tileSizePerScaleFactor = {};
      this.tileFormat = this.tileFormat || "jpg";
      this.version = options.version;
      if (this.tile_width && this.tile_height) {
        options.tileWidth = this.tile_width;
        options.tileHeight = this.tile_height;
      } else if (this.tile_width) {
        options.tileSize = this.tile_width;
      } else if (this.tile_height) {
        options.tileSize = this.tile_height;
      } else if (this.tiles) {
        if (this.tiles.length === 1) {
          options.tileWidth = this.tiles[0].width;
          options.tileHeight = this.tiles[0].height || this.tiles[0].width;
          this.scale_factors = this.tiles[0].scaleFactors;
        } else {
          this.scale_factors = [];
          for (var t = 0;t < this.tiles.length; t++) {
            for (var sf = 0;sf < this.tiles[t].scaleFactors.length; sf++) {
              var scaleFactor = this.tiles[t].scaleFactors[sf];
              this.scale_factors.push(scaleFactor);
              options.tileSizePerScaleFactor[scaleFactor] = {
                width: this.tiles[t].width,
                height: this.tiles[t].height || this.tiles[t].width
              };
            }
          }
        }
      } else if (canBeTiled(options)) {
        var shortDim = Math.min(this.height, this.width), tileOptions = [256, 512, 1024], smallerTiles = [];
        for (var c = 0;c < tileOptions.length; c++) {
          if (tileOptions[c] <= shortDim) {
            smallerTiles.push(tileOptions[c]);
          }
        }
        if (smallerTiles.length > 0) {
          options.tileSize = Math.max.apply(null, smallerTiles);
        } else {
          options.tileSize = shortDim;
        }
      } else if (this.sizes && this.sizes.length > 0) {
        this.emulateLegacyImagePyramid = true;
        options.levels = constructLevels(this);
        $.extend(true, options, {
          width: options.levels[options.levels.length - 1].width,
          height: options.levels[options.levels.length - 1].height,
          tileSize: Math.max(options.height, options.width),
          tileOverlap: 0,
          minLevel: 0,
          maxLevel: options.levels.length - 1
        });
        this.levels = options.levels;
      } else {
        $.console.error("Nothing in the info.json to construct image pyramids from");
      }
      if (!options.maxLevel && !this.emulateLegacyImagePyramid) {
        if (!this.scale_factors) {
          options.maxLevel = Number(Math.round(Math.log(Math.max(this.width, this.height), 2)));
        } else {
          var maxScaleFactor = Math.max.apply(null, this.scale_factors);
          options.maxLevel = Math.round(Math.log(maxScaleFactor) * Math.LOG2E);
        }
      }
      if (this.sizes) {
        var sizeLength = this.sizes.length;
        if (sizeLength === options.maxLevel || sizeLength === options.maxLevel + 1) {
          this.levelSizes = this.sizes.slice().sort((size1, size2) => size1.width - size2.width);
          if (sizeLength === options.maxLevel) {
            this.levelSizes.push({ width: this.width, height: this.height });
          }
        }
      }
      $.TileSource.apply(this, [options]);
    };
    $.extend($.IIIFTileSource.prototype, $.TileSource.prototype, {
      supports: function(data, url) {
        if (data.protocol && data.protocol === "http://iiif.io/api/image") {
          return true;
        } else if (data["@context"] && (data["@context"] === "http://library.stanford.edu/iiif/image-api/1.1/context.json" || data["@context"] === "http://iiif.io/api/image/1/context.json")) {
          return true;
        } else if (data.profile && data.profile.indexOf("http://library.stanford.edu/iiif/image-api/compliance.html") === 0) {
          return true;
        } else if (data.identifier && data.width && data.height) {
          return true;
        } else if (data.documentElement && data.documentElement.tagName === "info" && data.documentElement.namespaceURI === "http://library.stanford.edu/iiif/image-api/ns/") {
          return true;
        } else {
          return false;
        }
      },
      configure: function(data, url, postData) {
        if (!$.isPlainObject(data)) {
          var options = configureFromXml10(data);
          options["@context"] = "http://iiif.io/api/image/1.0/context.json";
          options["@id"] = url.replace("/info.xml", "");
          options.version = 1;
          return options;
        } else {
          if (!data["@context"]) {
            data["@context"] = "http://iiif.io/api/image/1.0/context.json";
            data["@id"] = url.replace("/info.json", "");
            data.version = 1;
          } else {
            var context = data["@context"];
            if (Array.isArray(context)) {
              for (var i = 0;i < context.length; i++) {
                if (typeof context[i] === "string" && (/^http:\/\/iiif\.io\/api\/image\/[1-3]\/context\.json$/.test(context[i]) || context[i] === "http://library.stanford.edu/iiif/image-api/1.1/context.json")) {
                  context = context[i];
                  break;
                }
              }
            }
            switch (context) {
              case "http://iiif.io/api/image/1/context.json":
              case "http://library.stanford.edu/iiif/image-api/1.1/context.json":
                data.version = 1;
                break;
              case "http://iiif.io/api/image/2/context.json":
                data.version = 2;
                break;
              case "http://iiif.io/api/image/3/context.json":
                data.version = 3;
                break;
              default:
                $.console.error("Data has a @context property which contains no known IIIF context URI.");
            }
          }
          if (data.preferredFormats) {
            for (var f = 0;f < data.preferredFormats.length; f++) {
              if (OpenSeadragon.imageFormatSupported(data.preferredFormats[f])) {
                data.tileFormat = data.preferredFormats[f];
                break;
              }
            }
          }
          return data;
        }
      },
      getTileWidth: function(level) {
        if (this.emulateLegacyImagePyramid) {
          return $.TileSource.prototype.getTileWidth.call(this, level);
        }
        var scaleFactor = Math.pow(2, this.maxLevel - level);
        if (this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[scaleFactor]) {
          return this.tileSizePerScaleFactor[scaleFactor].width;
        }
        return this._tileWidth;
      },
      getTileHeight: function(level) {
        if (this.emulateLegacyImagePyramid) {
          return $.TileSource.prototype.getTileHeight.call(this, level);
        }
        var scaleFactor = Math.pow(2, this.maxLevel - level);
        if (this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[scaleFactor]) {
          return this.tileSizePerScaleFactor[scaleFactor].height;
        }
        return this._tileHeight;
      },
      getLevelScale: function(level) {
        if (this.emulateLegacyImagePyramid) {
          var levelScale = NaN;
          if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) {
            levelScale = this.levels[level].width / this.levels[this.maxLevel].width;
          }
          return levelScale;
        }
        return $.TileSource.prototype.getLevelScale.call(this, level);
      },
      getNumTiles: function(level) {
        if (this.emulateLegacyImagePyramid) {
          var scale = this.getLevelScale(level);
          if (scale) {
            return new $.Point(1, 1);
          } else {
            return new $.Point(0, 0);
          }
        }
        if (this.levelSizes) {
          var levelSize = this.levelSizes[level];
          var x = Math.ceil(levelSize.width / this.getTileWidth(level)), y = Math.ceil(levelSize.height / this.getTileHeight(level));
          return new $.Point(x, y);
        } else {
          return $.TileSource.prototype.getNumTiles.call(this, level);
        }
      },
      getTileAtPoint: function(level, point) {
        if (this.emulateLegacyImagePyramid) {
          return new $.Point(0, 0);
        }
        if (this.levelSizes) {
          var validPoint = point.x >= 0 && point.x <= 1 && point.y >= 0 && point.y <= 1 / this.aspectRatio;
          $.console.assert(validPoint, "[TileSource.getTileAtPoint] must be called with a valid point.");
          var widthScaled = this.levelSizes[level].width;
          var pixelX = point.x * widthScaled;
          var pixelY = point.y * widthScaled;
          var x = Math.floor(pixelX / this.getTileWidth(level));
          var y = Math.floor(pixelY / this.getTileHeight(level));
          if (point.x >= 1) {
            x = this.getNumTiles(level).x - 1;
          }
          var EPSILON = 0.000000000000001;
          if (point.y >= 1 / this.aspectRatio - EPSILON) {
            y = this.getNumTiles(level).y - 1;
          }
          return new $.Point(x, y);
        }
        return $.TileSource.prototype.getTileAtPoint.call(this, level, point);
      },
      getTileUrl: function(level, x, y) {
        if (this.emulateLegacyImagePyramid) {
          var url = null;
          if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) {
            url = this.levels[level].url;
          }
          return url;
        }
        var IIIF_ROTATION = "0", scale = Math.pow(0.5, this.maxLevel - level), levelWidth, levelHeight, tileWidth, tileHeight, iiifTileSizeWidth, iiifTileSizeHeight, iiifRegion, iiifTileX, iiifTileY, iiifTileW, iiifTileH, iiifSize, iiifSizeW, iiifSizeH, iiifQuality, uri;
        if (this.levelSizes) {
          levelWidth = this.levelSizes[level].width;
          levelHeight = this.levelSizes[level].height;
        } else {
          levelWidth = Math.ceil(this.width * scale);
          levelHeight = Math.ceil(this.height * scale);
        }
        tileWidth = this.getTileWidth(level);
        tileHeight = this.getTileHeight(level);
        iiifTileSizeWidth = Math.round(tileWidth / scale);
        iiifTileSizeHeight = Math.round(tileHeight / scale);
        if (this.version === 1) {
          iiifQuality = "native." + this.tileFormat;
        } else {
          iiifQuality = "default." + this.tileFormat;
        }
        if (levelWidth < tileWidth && levelHeight < tileHeight) {
          if (this.version === 2 && levelWidth === this.width) {
            iiifSize = "full";
          } else if (this.version === 3 && levelWidth === this.width && levelHeight === this.height) {
            iiifSize = "max";
          } else if (this.version === 3) {
            iiifSize = levelWidth + "," + levelHeight;
          } else {
            iiifSize = levelWidth + ",";
          }
          iiifRegion = "full";
        } else {
          iiifTileX = x * iiifTileSizeWidth;
          iiifTileY = y * iiifTileSizeHeight;
          iiifTileW = Math.min(iiifTileSizeWidth, this.width - iiifTileX);
          iiifTileH = Math.min(iiifTileSizeHeight, this.height - iiifTileY);
          if (x === 0 && y === 0 && iiifTileW === this.width && iiifTileH === this.height) {
            iiifRegion = "full";
          } else {
            iiifRegion = [iiifTileX, iiifTileY, iiifTileW, iiifTileH].join(",");
          }
          iiifSizeW = Math.min(tileWidth, levelWidth - x * tileWidth);
          iiifSizeH = Math.min(tileHeight, levelHeight - y * tileHeight);
          if (this.version === 2 && iiifSizeW === this.width) {
            iiifSize = "full";
          } else if (this.version === 3 && iiifSizeW === this.width && iiifSizeH === this.height) {
            iiifSize = "max";
          } else if (this.version === 3) {
            iiifSize = iiifSizeW + "," + iiifSizeH;
          } else {
            iiifSize = iiifSizeW + ",";
          }
        }
        uri = [this._id, iiifRegion, iiifSize, IIIF_ROTATION, iiifQuality].join("/");
        return uri;
      },
      __testonly__: {
        canBeTiled,
        constructLevels
      }
    });
    function canBeTiled(options) {
      var level0Profiles = [
        "http://library.stanford.edu/iiif/image-api/compliance.html#level0",
        "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0",
        "http://iiif.io/api/image/2/level0.json",
        "level0",
        "https://iiif.io/api/image/3/level0.json"
      ];
      var profileLevel = Array.isArray(options.profile) ? options.profile[0] : options.profile;
      var isLevel0 = level0Profiles.indexOf(profileLevel) !== -1;
      var hasCanoncicalSizeFeature = false;
      if (options.version === 2 && options.profile.length > 1 && options.profile[1].supports) {
        hasCanoncicalSizeFeature = options.profile[1].supports.indexOf("sizeByW") !== -1;
      }
      if (options.version === 3 && options.extraFeatures) {
        hasCanoncicalSizeFeature = options.extraFeatures.indexOf("sizeByWh") !== -1;
      }
      return !isLevel0 || hasCanoncicalSizeFeature;
    }
    function constructLevels(options) {
      var levels = [];
      for (var i = 0;i < options.sizes.length; i++) {
        levels.push({
          url: options._id + "/full/" + options.sizes[i].width + "," + (options.version === 3 ? options.sizes[i].height : "") + "/0/default." + options.tileFormat,
          width: options.sizes[i].width,
          height: options.sizes[i].height
        });
      }
      return levels.sort(function(a, b) {
        return a.width - b.width;
      });
    }
    function configureFromXml10(xmlDoc) {
      if (!xmlDoc || !xmlDoc.documentElement) {
        throw new Error($.getString("Errors.Xml"));
      }
      var root = xmlDoc.documentElement, rootName = root.tagName, configuration = null;
      if (rootName === "info") {
        try {
          configuration = {};
          parseXML10(root, configuration);
          return configuration;
        } catch (e) {
          throw e instanceof Error ? e : new Error($.getString("Errors.IIIF"));
        }
      }
      throw new Error($.getString("Errors.IIIF"));
    }
    function parseXML10(node, configuration, property) {
      var i, value;
      if (node.nodeType === 3 && property) {
        value = node.nodeValue.trim();
        if (value.match(/^\d*$/)) {
          value = Number(value);
        }
        if (!configuration[property]) {
          configuration[property] = value;
        } else {
          if (!$.isArray(configuration[property])) {
            configuration[property] = [configuration[property]];
          }
          configuration[property].push(value);
        }
      } else if (node.nodeType === 1) {
        for (i = 0;i < node.childNodes.length; i++) {
          parseXML10(node.childNodes[i], configuration, node.nodeName);
        }
      }
    }
  })(OpenSeadragon);
  (function($) {
    $.OsmTileSource = function(width, height, tileSize, tileOverlap, tilesUrl) {
      var options;
      if ($.isPlainObject(width)) {
        options = width;
      } else {
        options = {
          width: arguments[0],
          height: arguments[1],
          tileSize: arguments[2],
          tileOverlap: arguments[3],
          tilesUrl: arguments[4]
        };
      }
      if (!options.width || !options.height) {
        options.width = 65572864;
        options.height = 65572864;
      }
      if (!options.tileSize) {
        options.tileSize = 256;
        options.tileOverlap = 0;
      }
      if (!options.tilesUrl) {
        options.tilesUrl = "http://tile.openstreetmap.org/";
      }
      options.minLevel = 8;
      $.TileSource.apply(this, [options]);
    };
    $.extend($.OsmTileSource.prototype, $.TileSource.prototype, {
      supports: function(data, url) {
        return data.type && data.type === "openstreetmaps";
      },
      configure: function(data, url, postData) {
        return data;
      },
      getTileUrl: function(level, x, y) {
        return this.tilesUrl + (level - 8) + "/" + x + "/" + y + ".png";
      }
    });
  })(OpenSeadragon);
  (function($) {
    $.TmsTileSource = function(width, height, tileSize, tileOverlap, tilesUrl) {
      var options;
      if ($.isPlainObject(width)) {
        options = width;
      } else {
        options = {
          width: arguments[0],
          height: arguments[1],
          tileSize: arguments[2],
          tileOverlap: arguments[3],
          tilesUrl: arguments[4]
        };
      }
      var bufferedWidth = Math.ceil(options.width / 256) * 256, bufferedHeight = Math.ceil(options.height / 256) * 256, max;
      if (bufferedWidth > bufferedHeight) {
        max = bufferedWidth / 256;
      } else {
        max = bufferedHeight / 256;
      }
      options.maxLevel = Math.ceil(Math.log(max) / Math.log(2)) - 1;
      options.tileSize = 256;
      options.width = bufferedWidth;
      options.height = bufferedHeight;
      $.TileSource.apply(this, [options]);
    };
    $.extend($.TmsTileSource.prototype, $.TileSource.prototype, {
      supports: function(data, url) {
        return data.type && data.type === "tiledmapservice";
      },
      configure: function(data, url, postData) {
        return data;
      },
      getTileUrl: function(level, x, y) {
        var yTiles = this.getNumTiles(level).y - 1;
        return this.tilesUrl + level + "/" + x + "/" + (yTiles - y) + ".png";
      }
    });
  })(OpenSeadragon);
  (function($) {
    $.ZoomifyTileSource = function(options) {
      if (typeof options.tileSize === "undefined") {
        options.tileSize = 256;
      }
      if (typeof options.fileFormat === "undefined") {
        options.fileFormat = "jpg";
        this.fileFormat = options.fileFormat;
      }
      var currentImageSize = {
        x: options.width,
        y: options.height
      };
      options.imageSizes = [{
        x: options.width,
        y: options.height
      }];
      options.gridSize = [this._getGridSize(options.width, options.height, options.tileSize)];
      while (parseInt(currentImageSize.x, 10) > options.tileSize || parseInt(currentImageSize.y, 10) > options.tileSize) {
        currentImageSize.x = Math.floor(currentImageSize.x / 2);
        currentImageSize.y = Math.floor(currentImageSize.y / 2);
        options.imageSizes.push({
          x: currentImageSize.x,
          y: currentImageSize.y
        });
        options.gridSize.push(this._getGridSize(currentImageSize.x, currentImageSize.y, options.tileSize));
      }
      options.imageSizes.reverse();
      options.gridSize.reverse();
      options.minLevel = 0;
      options.maxLevel = options.gridSize.length - 1;
      OpenSeadragon.TileSource.apply(this, [options]);
    };
    $.extend($.ZoomifyTileSource.prototype, $.TileSource.prototype, {
      _getGridSize: function(width, height, tileSize) {
        return {
          x: Math.ceil(width / tileSize),
          y: Math.ceil(height / tileSize)
        };
      },
      _calculateAbsoluteTileNumber: function(level, x, y) {
        var num = 0;
        var size = {};
        for (var z = 0;z < level; z++) {
          size = this.gridSize[z];
          num += size.x * size.y;
        }
        size = this.gridSize[level];
        num += size.x * y + x;
        return num;
      },
      supports: function(data, url) {
        return data.type && data.type === "zoomifytileservice";
      },
      configure: function(data, url, postData) {
        return data;
      },
      getTileUrl: function(level, x, y) {
        var result = 0;
        var num = this._calculateAbsoluteTileNumber(level, x, y);
        result = Math.floor(num / 256);
        return this.tilesUrl + "TileGroup" + result + "/" + level + "-" + x + "-" + y + "." + this.fileFormat;
      }
    });
  })(OpenSeadragon);
  (function($) {
    $.LegacyTileSource = function(levels) {
      var options, width, height;
      if ($.isArray(levels)) {
        options = {
          type: "legacy-image-pyramid",
          levels
        };
      }
      options.levels = filterFiles(options.levels);
      if (options.levels.length > 0) {
        width = options.levels[options.levels.length - 1].width;
        height = options.levels[options.levels.length - 1].height;
      } else {
        width = 0;
        height = 0;
        $.console.error("No supported image formats found");
      }
      $.extend(true, options, {
        width,
        height,
        tileSize: Math.max(height, width),
        tileOverlap: 0,
        minLevel: 0,
        maxLevel: options.levels.length > 0 ? options.levels.length - 1 : 0
      });
      $.TileSource.apply(this, [options]);
      this.levels = options.levels;
    };
    $.extend($.LegacyTileSource.prototype, $.TileSource.prototype, {
      supports: function(data, url) {
        return data.type && data.type === "legacy-image-pyramid" || data.documentElement && data.documentElement.getAttribute("type") === "legacy-image-pyramid";
      },
      configure: function(configuration, dataUrl, postData) {
        var options;
        if (!$.isPlainObject(configuration)) {
          options = configureFromXML(this, configuration);
        } else {
          options = configureFromObject(this, configuration);
        }
        return options;
      },
      getLevelScale: function(level) {
        var levelScale = NaN;
        if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) {
          levelScale = this.levels[level].width / this.levels[this.maxLevel].width;
        }
        return levelScale;
      },
      getNumTiles: function(level) {
        var scale = this.getLevelScale(level);
        if (scale) {
          return new $.Point(1, 1);
        } else {
          return new $.Point(0, 0);
        }
      },
      getTileUrl: function(level, x, y) {
        var url = null;
        if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) {
          url = this.levels[level].url;
        }
        return url;
      }
    });
    function filterFiles(files) {
      var filtered = [], file, i;
      for (i = 0;i < files.length; i++) {
        file = files[i];
        if (file.height && file.width && file.url) {
          filtered.push({
            url: file.url,
            width: Number(file.width),
            height: Number(file.height)
          });
        } else {
          $.console.error("Unsupported image format: %s", file.url ? file.url : "<no URL>");
        }
      }
      return filtered.sort(function(a, b) {
        return a.height - b.height;
      });
    }
    function configureFromXML(tileSource, xmlDoc) {
      if (!xmlDoc || !xmlDoc.documentElement) {
        throw new Error($.getString("Errors.Xml"));
      }
      var root = xmlDoc.documentElement, rootName = root.tagName, conf = null, levels = [], level, i;
      if (rootName === "image") {
        try {
          conf = {
            type: root.getAttribute("type"),
            levels: []
          };
          levels = root.getElementsByTagName("level");
          for (i = 0;i < levels.length; i++) {
            level = levels[i];
            conf.levels.push({
              url: level.getAttribute("url"),
              width: parseInt(level.getAttribute("width"), 10),
              height: parseInt(level.getAttribute("height"), 10)
            });
          }
          return configureFromObject(tileSource, conf);
        } catch (e) {
          throw e instanceof Error ? e : new Error("Unknown error parsing Legacy Image Pyramid XML.");
        }
      } else if (rootName === "collection") {
        throw new Error("Legacy Image Pyramid Collections not yet supported.");
      } else if (rootName === "error") {
        throw new Error("Error: " + xmlDoc);
      }
      throw new Error("Unknown element " + rootName);
    }
    function configureFromObject(tileSource, configuration) {
      return configuration.levels;
    }
  })(OpenSeadragon);
  (function($) {
    $.ImageTileSource = function(options) {
      options = $.extend({
        buildPyramid: true,
        crossOriginPolicy: false,
        ajaxWithCredentials: false
      }, options);
      $.TileSource.apply(this, [options]);
    };
    $.extend($.ImageTileSource.prototype, $.TileSource.prototype, {
      supports: function(data, url) {
        return data.type && data.type === "image";
      },
      configure: function(options, dataUrl, postData) {
        return options;
      },
      getImageInfo: function(url) {
        var image = this._image = new Image;
        var _this = this;
        if (this.crossOriginPolicy) {
          image.crossOrigin = this.crossOriginPolicy;
        }
        if (this.ajaxWithCredentials) {
          image.useCredentials = this.ajaxWithCredentials;
        }
        $.addEvent(image, "load", function() {
          _this.width = image.naturalWidth;
          _this.height = image.naturalHeight;
          _this.aspectRatio = _this.width / _this.height;
          _this.dimensions = new $.Point(_this.width, _this.height);
          _this._tileWidth = _this.width;
          _this._tileHeight = _this.height;
          _this.tileOverlap = 0;
          _this.minLevel = 0;
          _this.levels = _this._buildLevels();
          _this.maxLevel = _this.levels.length - 1;
          _this.ready = true;
          _this.raiseEvent("ready", { tileSource: _this });
        });
        $.addEvent(image, "error", function() {
          _this.raiseEvent("open-failed", {
            message: "Error loading image at " + url,
            source: url
          });
        });
        image.src = url;
      },
      getLevelScale: function(level) {
        var levelScale = NaN;
        if (level >= this.minLevel && level <= this.maxLevel) {
          levelScale = this.levels[level].width / this.levels[this.maxLevel].width;
        }
        return levelScale;
      },
      getNumTiles: function(level) {
        var scale = this.getLevelScale(level);
        if (scale) {
          return new $.Point(1, 1);
        } else {
          return new $.Point(0, 0);
        }
      },
      getTileUrl: function(level, x, y) {
        var url = null;
        if (level >= this.minLevel && level <= this.maxLevel) {
          url = this.levels[level].url;
        }
        return url;
      },
      getContext2D: function(level, x, y) {
        var context = null;
        if (level >= this.minLevel && level <= this.maxLevel) {
          context = this.levels[level].context2D;
        }
        return context;
      },
      destroy: function(viewer) {
        this._freeupCanvasMemory(viewer);
      },
      _buildLevels: function() {
        var levels = [{
          url: this._image.src,
          width: this._image.naturalWidth,
          height: this._image.naturalHeight
        }];
        if (!this.buildPyramid || !$.supportsCanvas) {
          delete this._image;
          return levels;
        }
        var currentWidth = this._image.naturalWidth;
        var currentHeight = this._image.naturalHeight;
        var bigCanvas = document.createElement("canvas");
        var bigContext = bigCanvas.getContext("2d");
        bigCanvas.width = currentWidth;
        bigCanvas.height = currentHeight;
        bigContext.drawImage(this._image, 0, 0, currentWidth, currentHeight);
        levels[0].context2D = bigContext;
        delete this._image;
        if ($.isCanvasTainted(bigCanvas)) {
          return levels;
        }
        while (currentWidth >= 2 && currentHeight >= 2) {
          currentWidth = Math.floor(currentWidth / 2);
          currentHeight = Math.floor(currentHeight / 2);
          var smallCanvas = document.createElement("canvas");
          var smallContext = smallCanvas.getContext("2d");
          smallCanvas.width = currentWidth;
          smallCanvas.height = currentHeight;
          smallContext.drawImage(bigCanvas, 0, 0, currentWidth, currentHeight);
          levels.splice(0, 0, {
            context2D: smallContext,
            width: currentWidth,
            height: currentHeight
          });
          bigCanvas = smallCanvas;
          bigContext = smallContext;
        }
        return levels;
      },
      _freeupCanvasMemory: function(viewer) {
        for (var i = 0;i < this.levels.length; i++) {
          if (this.levels[i].context2D) {
            this.levels[i].context2D.canvas.height = 0;
            this.levels[i].context2D.canvas.width = 0;
            if (viewer) {
              viewer.raiseEvent("image-unloaded", {
                context2D: this.levels[i].context2D
              });
            }
          }
        }
      }
    });
  })(OpenSeadragon);
  (function($) {
    $.TileSourceCollection = function(tileSize, tileSources, rows, layout) {
      $.console.error("TileSourceCollection is deprecated; use World instead");
    };
  })(OpenSeadragon);
  (function($) {
    $.ButtonState = {
      REST: 0,
      GROUP: 1,
      HOVER: 2,
      DOWN: 3
    };
    $.Button = function(options) {
      var _this = this;
      $.EventSource.call(this);
      $.extend(true, this, {
        tooltip: null,
        srcRest: null,
        srcGroup: null,
        srcHover: null,
        srcDown: null,
        clickTimeThreshold: $.DEFAULT_SETTINGS.clickTimeThreshold,
        clickDistThreshold: $.DEFAULT_SETTINGS.clickDistThreshold,
        fadeDelay: 0,
        fadeLength: 2000,
        onPress: null,
        onRelease: null,
        onClick: null,
        onEnter: null,
        onExit: null,
        onFocus: null,
        onBlur: null,
        userData: null
      }, options);
      this.element = options.element || $.makeNeutralElement("div");
      if (!options.element) {
        this.imgRest = $.makeTransparentImage(this.srcRest);
        this.imgGroup = $.makeTransparentImage(this.srcGroup);
        this.imgHover = $.makeTransparentImage(this.srcHover);
        this.imgDown = $.makeTransparentImage(this.srcDown);
        this.imgRest.alt = this.imgGroup.alt = this.imgHover.alt = this.imgDown.alt = this.tooltip;
        $.setElementPointerEventsNone(this.imgRest);
        $.setElementPointerEventsNone(this.imgGroup);
        $.setElementPointerEventsNone(this.imgHover);
        $.setElementPointerEventsNone(this.imgDown);
        this.element.style.position = "relative";
        $.setElementTouchActionNone(this.element);
        this.imgGroup.style.position = this.imgHover.style.position = this.imgDown.style.position = "absolute";
        this.imgGroup.style.top = this.imgHover.style.top = this.imgDown.style.top = "0px";
        this.imgGroup.style.left = this.imgHover.style.left = this.imgDown.style.left = "0px";
        this.imgHover.style.visibility = this.imgDown.style.visibility = "hidden";
        this.element.appendChild(this.imgRest);
        this.element.appendChild(this.imgGroup);
        this.element.appendChild(this.imgHover);
        this.element.appendChild(this.imgDown);
      }
      this.addHandler("press", this.onPress);
      this.addHandler("release", this.onRelease);
      this.addHandler("click", this.onClick);
      this.addHandler("enter", this.onEnter);
      this.addHandler("exit", this.onExit);
      this.addHandler("focus", this.onFocus);
      this.addHandler("blur", this.onBlur);
      this.currentState = $.ButtonState.GROUP;
      this.fadeBeginTime = null;
      this.shouldFade = false;
      this.element.style.display = "inline-block";
      this.element.style.position = "relative";
      this.element.title = this.tooltip;
      this.tracker = new $.MouseTracker({
        userData: "Button.tracker",
        element: this.element,
        clickTimeThreshold: this.clickTimeThreshold,
        clickDistThreshold: this.clickDistThreshold,
        enterHandler: function(event) {
          if (event.insideElementPressed) {
            inTo(_this, $.ButtonState.DOWN);
            _this.raiseEvent("enter", { originalEvent: event.originalEvent });
          } else if (!event.buttonDownAny) {
            inTo(_this, $.ButtonState.HOVER);
          }
        },
        focusHandler: function(event) {
          _this.tracker.enterHandler(event);
          _this.raiseEvent("focus", { originalEvent: event.originalEvent });
        },
        leaveHandler: function(event) {
          outTo(_this, $.ButtonState.GROUP);
          if (event.insideElementPressed) {
            _this.raiseEvent("exit", { originalEvent: event.originalEvent });
          }
        },
        blurHandler: function(event) {
          _this.tracker.leaveHandler(event);
          _this.raiseEvent("blur", { originalEvent: event.originalEvent });
        },
        pressHandler: function(event) {
          inTo(_this, $.ButtonState.DOWN);
          _this.raiseEvent("press", { originalEvent: event.originalEvent });
        },
        releaseHandler: function(event) {
          if (event.insideElementPressed && event.insideElementReleased) {
            outTo(_this, $.ButtonState.HOVER);
            _this.raiseEvent("release", { originalEvent: event.originalEvent });
          } else if (event.insideElementPressed) {
            outTo(_this, $.ButtonState.GROUP);
          } else {
            inTo(_this, $.ButtonState.HOVER);
          }
        },
        clickHandler: function(event) {
          if (event.quick) {
            _this.raiseEvent("click", { originalEvent: event.originalEvent });
          }
        },
        keyHandler: function(event) {
          if (event.keyCode === 13) {
            _this.raiseEvent("click", { originalEvent: event.originalEvent });
            _this.raiseEvent("release", { originalEvent: event.originalEvent });
            event.preventDefault = true;
          } else {
            event.preventDefault = false;
          }
        }
      });
      outTo(this, $.ButtonState.REST);
    };
    $.extend($.Button.prototype, $.EventSource.prototype, {
      notifyGroupEnter: function() {
        inTo(this, $.ButtonState.GROUP);
      },
      notifyGroupExit: function() {
        outTo(this, $.ButtonState.REST);
      },
      disable: function() {
        this.notifyGroupExit();
        this.element.disabled = true;
        this.tracker.setTracking(false);
        $.setElementOpacity(this.element, 0.2, true);
      },
      enable: function() {
        this.element.disabled = false;
        this.tracker.setTracking(true);
        $.setElementOpacity(this.element, 1, true);
        this.notifyGroupEnter();
      },
      destroy: function() {
        if (this.imgRest) {
          this.element.removeChild(this.imgRest);
          this.imgRest = null;
        }
        if (this.imgGroup) {
          this.element.removeChild(this.imgGroup);
          this.imgGroup = null;
        }
        if (this.imgHover) {
          this.element.removeChild(this.imgHover);
          this.imgHover = null;
        }
        if (this.imgDown) {
          this.element.removeChild(this.imgDown);
          this.imgDown = null;
        }
        this.removeAllHandlers();
        this.tracker.destroy();
        this.element = null;
      }
    });
    function scheduleFade(button) {
      $.requestAnimationFrame(function() {
        updateFade(button);
      });
    }
    function updateFade(button) {
      var currentTime, deltaTime, opacity;
      if (button.shouldFade) {
        currentTime = $.now();
        deltaTime = currentTime - button.fadeBeginTime;
        opacity = 1 - deltaTime / button.fadeLength;
        opacity = Math.min(1, opacity);
        opacity = Math.max(0, opacity);
        if (button.imgGroup) {
          $.setElementOpacity(button.imgGroup, opacity, true);
        }
        if (opacity > 0) {
          scheduleFade(button);
        }
      }
    }
    function beginFading(button) {
      button.shouldFade = true;
      button.fadeBeginTime = $.now() + button.fadeDelay;
      window.setTimeout(function() {
        scheduleFade(button);
      }, button.fadeDelay);
    }
    function stopFading(button) {
      button.shouldFade = false;
      if (button.imgGroup) {
        $.setElementOpacity(button.imgGroup, 1, true);
      }
    }
    function inTo(button, newState) {
      if (button.element.disabled) {
        return;
      }
      if (newState >= $.ButtonState.GROUP && button.currentState === $.ButtonState.REST) {
        stopFading(button);
        button.currentState = $.ButtonState.GROUP;
      }
      if (newState >= $.ButtonState.HOVER && button.currentState === $.ButtonState.GROUP) {
        if (button.imgHover) {
          button.imgHover.style.visibility = "";
        }
        button.currentState = $.ButtonState.HOVER;
      }
      if (newState >= $.ButtonState.DOWN && button.currentState === $.ButtonState.HOVER) {
        if (button.imgDown) {
          button.imgDown.style.visibility = "";
        }
        button.currentState = $.ButtonState.DOWN;
      }
    }
    function outTo(button, newState) {
      if (button.element.disabled) {
        return;
      }
      if (newState <= $.ButtonState.HOVER && button.currentState === $.ButtonState.DOWN) {
        if (button.imgDown) {
          button.imgDown.style.visibility = "hidden";
        }
        button.currentState = $.ButtonState.HOVER;
      }
      if (newState <= $.ButtonState.GROUP && button.currentState === $.ButtonState.HOVER) {
        if (button.imgHover) {
          button.imgHover.style.visibility = "hidden";
        }
        button.currentState = $.ButtonState.GROUP;
      }
      if (newState <= $.ButtonState.REST && button.currentState === $.ButtonState.GROUP) {
        beginFading(button);
        button.currentState = $.ButtonState.REST;
      }
    }
  })(OpenSeadragon);
  (function($) {
    $.ButtonGroup = function(options) {
      $.extend(true, this, {
        buttons: [],
        clickTimeThreshold: $.DEFAULT_SETTINGS.clickTimeThreshold,
        clickDistThreshold: $.DEFAULT_SETTINGS.clickDistThreshold,
        labelText: ""
      }, options);
      var buttons = this.buttons.concat([]), _this = this, i;
      this.element = options.element || $.makeNeutralElement("div");
      if (!options.group) {
        this.element.style.display = "inline-block";
        for (i = 0;i < buttons.length; i++) {
          this.element.appendChild(buttons[i].element);
        }
      }
      $.setElementTouchActionNone(this.element);
      this.tracker = new $.MouseTracker({
        userData: "ButtonGroup.tracker",
        element: this.element,
        clickTimeThreshold: this.clickTimeThreshold,
        clickDistThreshold: this.clickDistThreshold,
        enterHandler: function(event) {
          var i2;
          for (i2 = 0;i2 < _this.buttons.length; i2++) {
            _this.buttons[i2].notifyGroupEnter();
          }
        },
        leaveHandler: function(event) {
          var i2;
          if (!event.insideElementPressed) {
            for (i2 = 0;i2 < _this.buttons.length; i2++) {
              _this.buttons[i2].notifyGroupExit();
            }
          }
        }
      });
    };
    $.ButtonGroup.prototype = {
      addButton: function(button) {
        this.buttons.push(button);
        this.element.appendChild(button.element);
      },
      emulateEnter: function() {
        this.tracker.enterHandler({ eventSource: this.tracker });
      },
      emulateLeave: function() {
        this.tracker.leaveHandler({ eventSource: this.tracker });
      },
      destroy: function() {
        while (this.buttons.length) {
          var button = this.buttons.pop();
          this.element.removeChild(button.element);
          button.destroy();
        }
        this.tracker.destroy();
        this.element = null;
      }
    };
  })(OpenSeadragon);
  (function($) {
    $.Rect = function(x, y, width, height, degrees) {
      this.x = typeof x === "number" ? x : 0;
      this.y = typeof y === "number" ? y : 0;
      this.width = typeof width === "number" ? width : 0;
      this.height = typeof height === "number" ? height : 0;
      this.degrees = typeof degrees === "number" ? degrees : 0;
      this.degrees = $.positiveModulo(this.degrees, 360);
      var newTopLeft, newWidth;
      if (this.degrees >= 270) {
        newTopLeft = this.getTopRight();
        this.x = newTopLeft.x;
        this.y = newTopLeft.y;
        newWidth = this.height;
        this.height = this.width;
        this.width = newWidth;
        this.degrees -= 270;
      } else if (this.degrees >= 180) {
        newTopLeft = this.getBottomRight();
        this.x = newTopLeft.x;
        this.y = newTopLeft.y;
        this.degrees -= 180;
      } else if (this.degrees >= 90) {
        newTopLeft = this.getBottomLeft();
        this.x = newTopLeft.x;
        this.y = newTopLeft.y;
        newWidth = this.height;
        this.height = this.width;
        this.width = newWidth;
        this.degrees -= 90;
      }
    };
    $.Rect.fromSummits = function(topLeft, topRight, bottomLeft) {
      var width = topLeft.distanceTo(topRight);
      var height = topLeft.distanceTo(bottomLeft);
      var diff = topRight.minus(topLeft);
      var radians = Math.atan(diff.y / diff.x);
      if (diff.x < 0) {
        radians += Math.PI;
      } else if (diff.y < 0) {
        radians += 2 * Math.PI;
      }
      return new $.Rect(topLeft.x, topLeft.y, width, height, radians / Math.PI * 180);
    };
    $.Rect.prototype = {
      clone: function() {
        return new $.Rect(this.x, this.y, this.width, this.height, this.degrees);
      },
      getAspectRatio: function() {
        return this.width / this.height;
      },
      getTopLeft: function() {
        return new $.Point(this.x, this.y);
      },
      getBottomRight: function() {
        return new $.Point(this.x + this.width, this.y + this.height).rotate(this.degrees, this.getTopLeft());
      },
      getTopRight: function() {
        return new $.Point(this.x + this.width, this.y).rotate(this.degrees, this.getTopLeft());
      },
      getBottomLeft: function() {
        return new $.Point(this.x, this.y + this.height).rotate(this.degrees, this.getTopLeft());
      },
      getCenter: function() {
        return new $.Point(this.x + this.width / 2, this.y + this.height / 2).rotate(this.degrees, this.getTopLeft());
      },
      getSize: function() {
        return new $.Point(this.width, this.height);
      },
      equals: function(other) {
        return other instanceof $.Rect && this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height && this.degrees === other.degrees;
      },
      times: function(factor) {
        return new $.Rect(this.x * factor, this.y * factor, this.width * factor, this.height * factor, this.degrees);
      },
      translate: function(delta) {
        return new $.Rect(this.x + delta.x, this.y + delta.y, this.width, this.height, this.degrees);
      },
      union: function(rect) {
        var thisBoundingBox = this.getBoundingBox();
        var otherBoundingBox = rect.getBoundingBox();
        var left = Math.min(thisBoundingBox.x, otherBoundingBox.x);
        var top = Math.min(thisBoundingBox.y, otherBoundingBox.y);
        var right = Math.max(thisBoundingBox.x + thisBoundingBox.width, otherBoundingBox.x + otherBoundingBox.width);
        var bottom = Math.max(thisBoundingBox.y + thisBoundingBox.height, otherBoundingBox.y + otherBoundingBox.height);
        return new $.Rect(left, top, right - left, bottom - top);
      },
      intersection: function(rect) {
        var EPSILON = 0.0000000001;
        var intersectionPoints = [];
        var thisTopLeft = this.getTopLeft();
        if (rect.containsPoint(thisTopLeft, EPSILON)) {
          intersectionPoints.push(thisTopLeft);
        }
        var thisTopRight = this.getTopRight();
        if (rect.containsPoint(thisTopRight, EPSILON)) {
          intersectionPoints.push(thisTopRight);
        }
        var thisBottomLeft = this.getBottomLeft();
        if (rect.containsPoint(thisBottomLeft, EPSILON)) {
          intersectionPoints.push(thisBottomLeft);
        }
        var thisBottomRight = this.getBottomRight();
        if (rect.containsPoint(thisBottomRight, EPSILON)) {
          intersectionPoints.push(thisBottomRight);
        }
        var rectTopLeft = rect.getTopLeft();
        if (this.containsPoint(rectTopLeft, EPSILON)) {
          intersectionPoints.push(rectTopLeft);
        }
        var rectTopRight = rect.getTopRight();
        if (this.containsPoint(rectTopRight, EPSILON)) {
          intersectionPoints.push(rectTopRight);
        }
        var rectBottomLeft = rect.getBottomLeft();
        if (this.containsPoint(rectBottomLeft, EPSILON)) {
          intersectionPoints.push(rectBottomLeft);
        }
        var rectBottomRight = rect.getBottomRight();
        if (this.containsPoint(rectBottomRight, EPSILON)) {
          intersectionPoints.push(rectBottomRight);
        }
        var thisSegments = this._getSegments();
        var rectSegments = rect._getSegments();
        for (var i = 0;i < thisSegments.length; i++) {
          var thisSegment = thisSegments[i];
          for (var j = 0;j < rectSegments.length; j++) {
            var rectSegment = rectSegments[j];
            var intersect = getIntersection(thisSegment[0], thisSegment[1], rectSegment[0], rectSegment[1]);
            if (intersect) {
              intersectionPoints.push(intersect);
            }
          }
        }
        function getIntersection(a, b, c, d) {
          var abVector = b.minus(a);
          var cdVector = d.minus(c);
          var denom = -cdVector.x * abVector.y + abVector.x * cdVector.y;
          if (denom === 0) {
            return null;
          }
          var s = (abVector.x * (a.y - c.y) - abVector.y * (a.x - c.x)) / denom;
          var t = (cdVector.x * (a.y - c.y) - cdVector.y * (a.x - c.x)) / denom;
          if (-EPSILON <= s && s <= 1 - EPSILON && -EPSILON <= t && t <= 1 - EPSILON) {
            return new $.Point(a.x + t * abVector.x, a.y + t * abVector.y);
          }
          return null;
        }
        if (intersectionPoints.length === 0) {
          return null;
        }
        var minX = intersectionPoints[0].x;
        var maxX = intersectionPoints[0].x;
        var minY = intersectionPoints[0].y;
        var maxY = intersectionPoints[0].y;
        for (var k = 1;k < intersectionPoints.length; k++) {
          var point = intersectionPoints[k];
          if (point.x < minX) {
            minX = point.x;
          }
          if (point.x > maxX) {
            maxX = point.x;
          }
          if (point.y < minY) {
            minY = point.y;
          }
          if (point.y > maxY) {
            maxY = point.y;
          }
        }
        return new $.Rect(minX, minY, maxX - minX, maxY - minY);
      },
      _getSegments: function() {
        var topLeft = this.getTopLeft();
        var topRight = this.getTopRight();
        var bottomLeft = this.getBottomLeft();
        var bottomRight = this.getBottomRight();
        return [
          [topLeft, topRight],
          [topRight, bottomRight],
          [bottomRight, bottomLeft],
          [bottomLeft, topLeft]
        ];
      },
      rotate: function(degrees, pivot) {
        degrees = $.positiveModulo(degrees, 360);
        if (degrees === 0) {
          return this.clone();
        }
        pivot = pivot || this.getCenter();
        var newTopLeft = this.getTopLeft().rotate(degrees, pivot);
        var newTopRight = this.getTopRight().rotate(degrees, pivot);
        var diff = newTopRight.minus(newTopLeft);
        diff = diff.apply(function(x) {
          var EPSILON = 0.000000000000001;
          return Math.abs(x) < EPSILON ? 0 : x;
        });
        var radians = Math.atan(diff.y / diff.x);
        if (diff.x < 0) {
          radians += Math.PI;
        } else if (diff.y < 0) {
          radians += 2 * Math.PI;
        }
        return new $.Rect(newTopLeft.x, newTopLeft.y, this.width, this.height, radians / Math.PI * 180);
      },
      getBoundingBox: function() {
        if (this.degrees === 0) {
          return this.clone();
        }
        var topLeft = this.getTopLeft();
        var topRight = this.getTopRight();
        var bottomLeft = this.getBottomLeft();
        var bottomRight = this.getBottomRight();
        var minX = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
        var maxX = Math.max(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
        var minY = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
        var maxY = Math.max(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
        return new $.Rect(minX, minY, maxX - minX, maxY - minY);
      },
      getIntegerBoundingBox: function() {
        var boundingBox = this.getBoundingBox();
        var x = Math.floor(boundingBox.x);
        var y = Math.floor(boundingBox.y);
        var width = Math.ceil(boundingBox.width + boundingBox.x - x);
        var height = Math.ceil(boundingBox.height + boundingBox.y - y);
        return new $.Rect(x, y, width, height);
      },
      containsPoint: function(point, epsilon) {
        epsilon = epsilon || 0;
        var topLeft = this.getTopLeft();
        var topRight = this.getTopRight();
        var bottomLeft = this.getBottomLeft();
        var topDiff = topRight.minus(topLeft);
        var leftDiff = bottomLeft.minus(topLeft);
        return (point.x - topLeft.x) * topDiff.x + (point.y - topLeft.y) * topDiff.y >= -epsilon && (point.x - topRight.x) * topDiff.x + (point.y - topRight.y) * topDiff.y <= epsilon && (point.x - topLeft.x) * leftDiff.x + (point.y - topLeft.y) * leftDiff.y >= -epsilon && (point.x - bottomLeft.x) * leftDiff.x + (point.y - bottomLeft.y) * leftDiff.y <= epsilon;
      },
      toString: function() {
        return "[" + Math.round(this.x * 100) / 100 + ", " + Math.round(this.y * 100) / 100 + ", " + Math.round(this.width * 100) / 100 + "x" + Math.round(this.height * 100) / 100 + ", " + Math.round(this.degrees * 100) / 100 + "deg" + "]";
      }
    };
  })(OpenSeadragon);
  (function($) {
    var THIS = {};
    $.ReferenceStrip = function(options) {
      var _this = this, viewer = options.viewer, viewerSize = $.getElementSize(viewer.element), element, style, i;
      if (!options.id) {
        options.id = "referencestrip-" + $.now();
        this.element = $.makeNeutralElement("div");
        this.element.id = options.id;
        this.element.className = "referencestrip";
      }
      options = $.extend(true, {
        sizeRatio: $.DEFAULT_SETTINGS.referenceStripSizeRatio,
        position: $.DEFAULT_SETTINGS.referenceStripPosition,
        scroll: $.DEFAULT_SETTINGS.referenceStripScroll,
        clickTimeThreshold: $.DEFAULT_SETTINGS.clickTimeThreshold
      }, options, {
        element: this.element
      });
      $.extend(this, options);
      THIS[this.id] = {
        animating: false
      };
      this.minPixelRatio = this.viewer.minPixelRatio;
      this.element.tabIndex = 0;
      style = this.element.style;
      style.marginTop = "0px";
      style.marginRight = "0px";
      style.marginBottom = "0px";
      style.marginLeft = "0px";
      style.left = "0px";
      style.bottom = "0px";
      style.border = "0px";
      style.background = "#000";
      style.position = "relative";
      $.setElementTouchActionNone(this.element);
      $.setElementOpacity(this.element, 0.8);
      this.viewer = viewer;
      this.tracker = new $.MouseTracker({
        userData: "ReferenceStrip.tracker",
        element: this.element,
        clickHandler: $.delegate(this, onStripClick),
        dragHandler: $.delegate(this, onStripDrag),
        scrollHandler: $.delegate(this, onStripScroll),
        enterHandler: $.delegate(this, onStripEnter),
        leaveHandler: $.delegate(this, onStripLeave),
        keyDownHandler: $.delegate(this, onKeyDown),
        keyHandler: $.delegate(this, onKeyPress),
        preProcessEventHandler: function(eventInfo) {
          if (eventInfo.eventType === "wheel") {
            eventInfo.preventDefault = true;
          }
        }
      });
      if (options.width && options.height) {
        this.element.style.width = options.width + "px";
        this.element.style.height = options.height + "px";
        viewer.addControl(this.element, { anchor: $.ControlAnchor.BOTTOM_LEFT });
      } else {
        if (options.scroll === "horizontal") {
          this.element.style.width = viewerSize.x * options.sizeRatio * viewer.tileSources.length + 12 * viewer.tileSources.length + "px";
          this.element.style.height = viewerSize.y * options.sizeRatio + "px";
          viewer.addControl(this.element, { anchor: $.ControlAnchor.BOTTOM_LEFT });
        } else {
          this.element.style.height = viewerSize.y * options.sizeRatio * viewer.tileSources.length + 12 * viewer.tileSources.length + "px";
          this.element.style.width = viewerSize.x * options.sizeRatio + "px";
          viewer.addControl(this.element, { anchor: $.ControlAnchor.TOP_LEFT });
        }
      }
      this.panelWidth = viewerSize.x * this.sizeRatio + 8;
      this.panelHeight = viewerSize.y * this.sizeRatio + 8;
      this.panels = [];
      this.miniViewers = {};
      for (i = 0;i < viewer.tileSources.length; i++) {
        element = $.makeNeutralElement("div");
        element.id = this.element.id + "-" + i;
        element.style.width = _this.panelWidth + "px";
        element.style.height = _this.panelHeight + "px";
        element.style.display = "inline";
        element.style["float"] = "left";
        element.style.cssFloat = "left";
        element.style.padding = "2px";
        $.setElementTouchActionNone(element);
        $.setElementPointerEventsNone(element);
        this.element.appendChild(element);
        element.activePanel = false;
        this.panels.push(element);
      }
      loadPanels(this, this.scroll === "vertical" ? viewerSize.y : viewerSize.x, 0);
      this.setFocus(0);
    };
    $.ReferenceStrip.prototype = {
      setFocus: function(page) {
        var element = this.element.querySelector("#" + this.element.id + "-" + page), viewerSize = $.getElementSize(this.viewer.canvas), scrollWidth = Number(this.element.style.width.replace("px", "")), scrollHeight = Number(this.element.style.height.replace("px", "")), offsetLeft = -Number(this.element.style.marginLeft.replace("px", "")), offsetTop = -Number(this.element.style.marginTop.replace("px", "")), offset;
        if (this.currentSelected !== element) {
          if (this.currentSelected) {
            this.currentSelected.style.background = "#000";
          }
          this.currentSelected = element;
          this.currentSelected.style.background = "#999";
          if (this.scroll === "horizontal") {
            offset = Number(page) * (this.panelWidth + 3);
            if (offset > offsetLeft + viewerSize.x - this.panelWidth) {
              offset = Math.min(offset, scrollWidth - viewerSize.x);
              this.element.style.marginLeft = -offset + "px";
              loadPanels(this, viewerSize.x, -offset);
            } else if (offset < offsetLeft) {
              offset = Math.max(0, offset - viewerSize.x / 2);
              this.element.style.marginLeft = -offset + "px";
              loadPanels(this, viewerSize.x, -offset);
            }
          } else {
            offset = Number(page) * (this.panelHeight + 3);
            if (offset > offsetTop + viewerSize.y - this.panelHeight) {
              offset = Math.min(offset, scrollHeight - viewerSize.y);
              this.element.style.marginTop = -offset + "px";
              loadPanels(this, viewerSize.y, -offset);
            } else if (offset < offsetTop) {
              offset = Math.max(0, offset - viewerSize.y / 2);
              this.element.style.marginTop = -offset + "px";
              loadPanels(this, viewerSize.y, -offset);
            }
          }
          this.currentPage = page;
          onStripEnter.call(this, { eventSource: this.tracker });
        }
      },
      update: function() {
        if (THIS[this.id].animating) {
          return true;
        }
        return false;
      },
      destroy: function() {
        if (this.miniViewers) {
          for (var key in this.miniViewers) {
            this.miniViewers[key].destroy();
          }
        }
        this.tracker.destroy();
        if (this.element) {
          this.viewer.removeControl(this.element);
        }
      }
    };
    function onStripClick(event) {
      if (event.quick) {
        var page;
        if (this.scroll === "horizontal") {
          page = Math.floor(event.position.x / (this.panelWidth + 4));
        } else {
          page = Math.floor(event.position.y / this.panelHeight);
        }
        this.viewer.goToPage(page);
      }
      this.element.focus();
    }
    function onStripDrag(event) {
      this.dragging = true;
      if (this.element) {
        var offsetLeft = Number(this.element.style.marginLeft.replace("px", "")), offsetTop = Number(this.element.style.marginTop.replace("px", "")), scrollWidth = Number(this.element.style.width.replace("px", "")), scrollHeight = Number(this.element.style.height.replace("px", "")), viewerSize = $.getElementSize(this.viewer.canvas);
        if (this.scroll === "horizontal") {
          if (-event.delta.x > 0) {
            if (offsetLeft > -(scrollWidth - viewerSize.x)) {
              this.element.style.marginLeft = offsetLeft + event.delta.x * 2 + "px";
              loadPanels(this, viewerSize.x, offsetLeft + event.delta.x * 2);
            }
          } else if (-event.delta.x < 0) {
            if (offsetLeft < 0) {
              this.element.style.marginLeft = offsetLeft + event.delta.x * 2 + "px";
              loadPanels(this, viewerSize.x, offsetLeft + event.delta.x * 2);
            }
          }
        } else {
          if (-event.delta.y > 0) {
            if (offsetTop > -(scrollHeight - viewerSize.y)) {
              this.element.style.marginTop = offsetTop + event.delta.y * 2 + "px";
              loadPanels(this, viewerSize.y, offsetTop + event.delta.y * 2);
            }
          } else if (-event.delta.y < 0) {
            if (offsetTop < 0) {
              this.element.style.marginTop = offsetTop + event.delta.y * 2 + "px";
              loadPanels(this, viewerSize.y, offsetTop + event.delta.y * 2);
            }
          }
        }
      }
    }
    function onStripScroll(event) {
      if (this.element) {
        var offsetLeft = Number(this.element.style.marginLeft.replace("px", "")), offsetTop = Number(this.element.style.marginTop.replace("px", "")), scrollWidth = Number(this.element.style.width.replace("px", "")), scrollHeight = Number(this.element.style.height.replace("px", "")), viewerSize = $.getElementSize(this.viewer.canvas);
        if (this.scroll === "horizontal") {
          if (event.scroll > 0) {
            if (offsetLeft > -(scrollWidth - viewerSize.x)) {
              this.element.style.marginLeft = offsetLeft - event.scroll * 60 + "px";
              loadPanels(this, viewerSize.x, offsetLeft - event.scroll * 60);
            }
          } else if (event.scroll < 0) {
            if (offsetLeft < 0) {
              this.element.style.marginLeft = offsetLeft - event.scroll * 60 + "px";
              loadPanels(this, viewerSize.x, offsetLeft - event.scroll * 60);
            }
          }
        } else {
          if (event.scroll < 0) {
            if (offsetTop > viewerSize.y - scrollHeight) {
              this.element.style.marginTop = offsetTop + event.scroll * 60 + "px";
              loadPanels(this, viewerSize.y, offsetTop + event.scroll * 60);
            }
          } else if (event.scroll > 0) {
            if (offsetTop < 0) {
              this.element.style.marginTop = offsetTop + event.scroll * 60 + "px";
              loadPanels(this, viewerSize.y, offsetTop + event.scroll * 60);
            }
          }
        }
        event.preventDefault = true;
      }
    }
    function loadPanels(strip, viewerSize, scroll) {
      var panelSize, activePanelsStart, activePanelsEnd, miniViewer, i, element;
      if (strip.scroll === "horizontal") {
        panelSize = strip.panelWidth;
      } else {
        panelSize = strip.panelHeight;
      }
      activePanelsStart = Math.ceil(viewerSize / panelSize) + 5;
      activePanelsEnd = Math.ceil((Math.abs(scroll) + viewerSize) / panelSize) + 1;
      activePanelsStart = activePanelsEnd - activePanelsStart;
      activePanelsStart = activePanelsStart < 0 ? 0 : activePanelsStart;
      for (i = activePanelsStart;i < activePanelsEnd && i < strip.panels.length; i++) {
        element = strip.panels[i];
        if (!element.activePanel) {
          var miniTileSource;
          var originalTileSource = strip.viewer.tileSources[i];
          if (originalTileSource.referenceStripThumbnailUrl) {
            miniTileSource = {
              type: "image",
              url: originalTileSource.referenceStripThumbnailUrl
            };
          } else {
            miniTileSource = originalTileSource;
          }
          miniViewer = new $.Viewer({
            id: element.id,
            tileSources: [miniTileSource],
            element,
            navigatorSizeRatio: strip.sizeRatio,
            showNavigator: false,
            mouseNavEnabled: false,
            showNavigationControl: false,
            showSequenceControl: false,
            immediateRender: true,
            blendTime: 0,
            animationTime: 0,
            loadTilesWithAjax: strip.viewer.loadTilesWithAjax,
            ajaxHeaders: strip.viewer.ajaxHeaders,
            drawer: "canvas"
          });
          $.setElementPointerEventsNone(miniViewer.canvas);
          $.setElementPointerEventsNone(miniViewer.container);
          miniViewer.innerTracker.setTracking(false);
          miniViewer.outerTracker.setTracking(false);
          strip.miniViewers[element.id] = miniViewer;
          element.activePanel = true;
        }
      }
    }
    function onStripEnter(event) {
      var element = event.eventSource.element;
      if (this.scroll === "horizontal") {
        element.style.marginBottom = "0px";
      } else {
        element.style.marginLeft = "0px";
      }
    }
    function onStripLeave(event) {
      var element = event.eventSource.element;
      if (this.scroll === "horizontal") {
        element.style.marginBottom = "-" + $.getElementSize(element).y / 2 + "px";
      } else {
        element.style.marginLeft = "-" + $.getElementSize(element).x / 2 + "px";
      }
    }
    function onKeyDown(event) {
      if (!event.ctrl && !event.alt && !event.meta) {
        switch (event.keyCode) {
          case 38:
            onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null });
            event.preventDefault = true;
            break;
          case 40:
            onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null });
            event.preventDefault = true;
            break;
          case 37:
            onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null });
            event.preventDefault = true;
            break;
          case 39:
            onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null });
            event.preventDefault = true;
            break;
          default:
            event.preventDefault = false;
            break;
        }
      } else {
        event.preventDefault = false;
      }
    }
    function onKeyPress(event) {
      if (!event.ctrl && !event.alt && !event.meta) {
        switch (event.keyCode) {
          case 61:
            onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null });
            event.preventDefault = true;
            break;
          case 45:
            onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null });
            event.preventDefault = true;
            break;
          case 48:
          case 119:
          case 87:
            onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null });
            event.preventDefault = true;
            break;
          case 115:
          case 83:
            onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null });
            event.preventDefault = true;
            break;
          case 97:
            onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null });
            event.preventDefault = true;
            break;
          case 100:
            onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null });
            event.preventDefault = true;
            break;
          default:
            event.preventDefault = false;
            break;
        }
      } else {
        event.preventDefault = false;
      }
    }
  })(OpenSeadragon);
  (function($) {
    $.DisplayRect = function(x, y, width, height, minLevel, maxLevel) {
      $.Rect.apply(this, [x, y, width, height]);
      this.minLevel = minLevel;
      this.maxLevel = maxLevel;
    };
    $.extend($.DisplayRect.prototype, $.Rect.prototype);
  })(OpenSeadragon);
  (function($) {
    $.Spring = function(options) {
      var args = arguments;
      if (typeof options !== "object") {
        options = {
          initial: args.length && typeof args[0] === "number" ? args[0] : undefined,
          springStiffness: args.length > 1 ? args[1].springStiffness : 5,
          animationTime: args.length > 1 ? args[1].animationTime : 1.5
        };
      }
      $.console.assert(typeof options.springStiffness === "number" && options.springStiffness !== 0, "[OpenSeadragon.Spring] options.springStiffness must be a non-zero number");
      $.console.assert(typeof options.animationTime === "number" && options.animationTime >= 0, "[OpenSeadragon.Spring] options.animationTime must be a number greater than or equal to 0");
      if (options.exponential) {
        this._exponential = true;
        delete options.exponential;
      }
      $.extend(true, this, options);
      this.current = {
        value: typeof this.initial === "number" ? this.initial : this._exponential ? 0 : 1,
        time: $.now()
      };
      $.console.assert(!this._exponential || this.current.value !== 0, "[OpenSeadragon.Spring] value must be non-zero for exponential springs");
      this.start = {
        value: this.current.value,
        time: this.current.time
      };
      this.target = {
        value: this.current.value,
        time: this.current.time
      };
      if (this._exponential) {
        this.start._logValue = Math.log(this.start.value);
        this.target._logValue = Math.log(this.target.value);
        this.current._logValue = Math.log(this.current.value);
      }
    };
    $.Spring.prototype = {
      resetTo: function(target) {
        $.console.assert(!this._exponential || target !== 0, "[OpenSeadragon.Spring.resetTo] target must be non-zero for exponential springs");
        this.start.value = this.target.value = this.current.value = target;
        this.start.time = this.target.time = this.current.time = $.now();
        if (this._exponential) {
          this.start._logValue = Math.log(this.start.value);
          this.target._logValue = Math.log(this.target.value);
          this.current._logValue = Math.log(this.current.value);
        }
      },
      springTo: function(target) {
        $.console.assert(!this._exponential || target !== 0, "[OpenSeadragon.Spring.springTo] target must be non-zero for exponential springs");
        this.start.value = this.current.value;
        this.start.time = this.current.time;
        this.target.value = target;
        this.target.time = this.start.time + 1000 * this.animationTime;
        if (this._exponential) {
          this.start._logValue = Math.log(this.start.value);
          this.target._logValue = Math.log(this.target.value);
        }
      },
      shiftBy: function(delta) {
        this.start.value += delta;
        this.target.value += delta;
        if (this._exponential) {
          $.console.assert(this.target.value !== 0 && this.start.value !== 0, "[OpenSeadragon.Spring.shiftBy] spring value must be non-zero for exponential springs");
          this.start._logValue = Math.log(this.start.value);
          this.target._logValue = Math.log(this.target.value);
        }
      },
      setExponential: function(value) {
        this._exponential = value;
        if (this._exponential) {
          $.console.assert(this.current.value !== 0 && this.target.value !== 0 && this.start.value !== 0, "[OpenSeadragon.Spring.setExponential] spring value must be non-zero for exponential springs");
          this.start._logValue = Math.log(this.start.value);
          this.target._logValue = Math.log(this.target.value);
          this.current._logValue = Math.log(this.current.value);
        }
      },
      update: function() {
        this.current.time = $.now();
        let startValue, targetValue;
        if (this._exponential) {
          startValue = this.start._logValue;
          targetValue = this.target._logValue;
        } else {
          startValue = this.start.value;
          targetValue = this.target.value;
        }
        if (this.current.time >= this.target.time) {
          this.current.value = this.target.value;
        } else {
          let currentValue = startValue + (targetValue - startValue) * transform(this.springStiffness, (this.current.time - this.start.time) / (this.target.time - this.start.time));
          if (this._exponential) {
            this.current.value = Math.exp(currentValue);
          } else {
            this.current.value = currentValue;
          }
        }
        return this.current.value !== this.target.value;
      },
      isAtTargetValue: function() {
        return this.current.value === this.target.value;
      }
    };
    function transform(stiffness, x) {
      return (1 - Math.exp(stiffness * -x)) / (1 - Math.exp(-stiffness));
    }
  })(OpenSeadragon);
  (function($) {
    $.ImageJob = function(options) {
      $.extend(true, this, {
        timeout: $.DEFAULT_SETTINGS.timeout,
        jobId: null,
        tries: 0
      }, options);
      this.data = null;
      this.userData = {};
      this.errorMsg = null;
    };
    $.ImageJob.prototype = {
      start: function() {
        this.tries++;
        var self2 = this;
        var selfAbort = this.abort;
        this.jobId = window.setTimeout(function() {
          self2.finish(null, null, "Image load exceeded timeout (" + self2.timeout + " ms)");
        }, this.timeout);
        this.abort = function() {
          self2.source.downloadTileAbort(self2);
          if (typeof selfAbort === "function") {
            selfAbort();
          }
        };
        this.source.downloadTileStart(this);
      },
      finish: function(data, request, errorMessage) {
        this.data = data;
        this.request = request;
        this.errorMsg = errorMessage;
        if (this.jobId) {
          window.clearTimeout(this.jobId);
        }
        this.callback(this);
      }
    };
    $.ImageLoader = function(options) {
      $.extend(true, this, {
        jobLimit: $.DEFAULT_SETTINGS.imageLoaderLimit,
        timeout: $.DEFAULT_SETTINGS.timeout,
        jobQueue: [],
        failedTiles: [],
        jobsInProgress: 0
      }, options);
    };
    $.ImageLoader.prototype = {
      addJob: function(options) {
        if (!options.source) {
          $.console.error("ImageLoader.prototype.addJob() requires [options.source]. " + "TileSource since new API defines how images are fetched. Creating a dummy TileSource.");
          var implementation = $.TileSource.prototype;
          options.source = {
            downloadTileStart: implementation.downloadTileStart,
            downloadTileAbort: implementation.downloadTileAbort
          };
        }
        var _this = this, complete = function(job) {
          completeJob(_this, job, options.callback);
        }, jobOptions = {
          src: options.src,
          tile: options.tile || {},
          source: options.source,
          loadWithAjax: options.loadWithAjax,
          ajaxHeaders: options.loadWithAjax ? options.ajaxHeaders : null,
          crossOriginPolicy: options.crossOriginPolicy,
          ajaxWithCredentials: options.ajaxWithCredentials,
          postData: options.postData,
          callback: complete,
          abort: options.abort,
          timeout: this.timeout
        }, newJob = new $.ImageJob(jobOptions);
        if (!this.jobLimit || this.jobsInProgress < this.jobLimit) {
          newJob.start();
          this.jobsInProgress++;
        } else {
          this.jobQueue.push(newJob);
        }
      },
      clear: function() {
        for (var i = 0;i < this.jobQueue.length; i++) {
          var job = this.jobQueue[i];
          if (typeof job.abort === "function") {
            job.abort();
          }
        }
        this.jobQueue = [];
      }
    };
    function completeJob(loader, job, callback) {
      if (job.errorMsg !== "" && (job.data === null || job.data === undefined) && job.tries < 1 + loader.tileRetryMax) {
        loader.failedTiles.push(job);
      }
      var nextJob;
      loader.jobsInProgress--;
      if ((!loader.jobLimit || loader.jobsInProgress < loader.jobLimit) && loader.jobQueue.length > 0) {
        nextJob = loader.jobQueue.shift();
        nextJob.start();
        loader.jobsInProgress++;
      }
      if (loader.tileRetryMax > 0 && loader.jobQueue.length === 0) {
        if ((!loader.jobLimit || loader.jobsInProgress < loader.jobLimit) && loader.failedTiles.length > 0) {
          nextJob = loader.failedTiles.shift();
          setTimeout(function() {
            nextJob.start();
          }, loader.tileRetryDelay);
          loader.jobsInProgress++;
        }
      }
      callback(job.data, job.errorMsg, job.request);
    }
  })(OpenSeadragon);
  (function($) {
    $.Tile = function(level, x, y, bounds, exists, url, context2D, loadWithAjax, ajaxHeaders, sourceBounds, postData, cacheKey) {
      this.level = level;
      this.x = x;
      this.y = y;
      this.bounds = bounds;
      this.positionedBounds = new OpenSeadragon.Rect(bounds.x, bounds.y, bounds.width, bounds.height);
      this.sourceBounds = sourceBounds;
      this.exists = exists;
      this._url = url;
      this.postData = postData;
      this.context2D = context2D;
      this.loadWithAjax = loadWithAjax;
      this.ajaxHeaders = ajaxHeaders;
      if (cacheKey === undefined) {
        $.console.warn("Tile constructor needs 'cacheKey' variable: creation tile cache" + " in Tile class is deprecated. TileSource.prototype.getTileHashKey will be used.");
        cacheKey = $.TileSource.prototype.getTileHashKey(level, x, y, url, ajaxHeaders, postData);
      }
      this.cacheKey = cacheKey;
      this.loaded = false;
      this.loading = false;
      this.element = null;
      this.imgElement = null;
      this.style = null;
      this.position = null;
      this.size = null;
      this.flipped = false;
      this.blendStart = null;
      this.opacity = null;
      this.squaredDistance = null;
      this.visibility = null;
      this.hasTransparency = false;
      this.beingDrawn = false;
      this.lastTouchTime = 0;
      this.isRightMost = false;
      this.isBottomMost = false;
    };
    $.Tile.prototype = {
      toString: function() {
        return this.level + "/" + this.x + "_" + this.y;
      },
      _hasTransparencyChannel: function() {
        console.warn("Tile.prototype._hasTransparencyChannel() has been " + "deprecated and will be removed in the future. Use TileSource.prototype.hasTransparency() instead.");
        return !!this.context2D || this.getUrl().match(".png");
      },
      get image() {
        $.console.error("[Tile.image] property has been deprecated. Use [Tile.prototype.getImage] instead.");
        return this.getImage();
      },
      get url() {
        $.console.error("[Tile.url] property has been deprecated. Use [Tile.prototype.getUrl] instead.");
        return this.getUrl();
      },
      getImage: function() {
        return this.cacheImageRecord.getImage();
      },
      getUrl: function() {
        if (typeof this._url === "function") {
          return this._url();
        }
        return this._url;
      },
      getCanvasContext: function() {
        return this.context2D || this.cacheImageRecord && this.cacheImageRecord.getRenderedContext();
      },
      getScaleForEdgeSmoothing: function() {
        var context;
        if (this.cacheImageRecord) {
          context = this.cacheImageRecord.getRenderedContext();
        } else if (this.context2D) {
          context = this.context2D;
        } else {
          $.console.warn("[Tile.drawCanvas] attempting to get tile scale %s when tile's not cached", this.toString());
          return 1;
        }
        return context.canvas.width / (this.size.x * $.pixelDensityRatio);
      },
      getTranslationForEdgeSmoothing: function(scale, canvasSize, sketchCanvasSize) {
        var x = Math.max(1, Math.ceil((sketchCanvasSize.x - canvasSize.x) / 2));
        var y = Math.max(1, Math.ceil((sketchCanvasSize.y - canvasSize.y) / 2));
        return new $.Point(x, y).minus(this.position.times($.pixelDensityRatio).times(scale || 1).apply(function(x2) {
          return x2 % 1;
        }));
      },
      unload: function() {
        if (this.imgElement && this.imgElement.parentNode) {
          this.imgElement.parentNode.removeChild(this.imgElement);
        }
        if (this.element && this.element.parentNode) {
          this.element.parentNode.removeChild(this.element);
        }
        this.element = null;
        this.imgElement = null;
        this.loaded = false;
        this.loading = false;
      }
    };
  })(OpenSeadragon);
  (function($) {
    $.OverlayPlacement = $.Placement;
    $.OverlayRotationMode = $.freezeObject({
      NO_ROTATION: 1,
      EXACT: 2,
      BOUNDING_BOX: 3
    });
    $.Overlay = function(element, location, placement) {
      var options;
      if ($.isPlainObject(element)) {
        options = element;
      } else {
        options = {
          element,
          location,
          placement
        };
      }
      this.elementWrapper = document.createElement("div");
      this.element = options.element;
      this.elementWrapper.appendChild(this.element);
      if (this.element.id) {
        this.elementWrapper.id = "overlay-wrapper-" + this.element.id;
      } else {
        this.elementWrapper.id = "overlay-wrapper";
      }
      this.style = this.elementWrapper.style;
      this._init(options);
    };
    $.Overlay.prototype = {
      _init: function(options) {
        this.location = options.location;
        this.placement = options.placement === undefined ? $.Placement.TOP_LEFT : options.placement;
        this.onDraw = options.onDraw;
        this.checkResize = options.checkResize === undefined ? true : options.checkResize;
        this.width = options.width === undefined ? null : options.width;
        this.height = options.height === undefined ? null : options.height;
        this.rotationMode = options.rotationMode || $.OverlayRotationMode.EXACT;
        if (this.location instanceof $.Rect) {
          this.width = this.location.width;
          this.height = this.location.height;
          this.location = this.location.getTopLeft();
          this.placement = $.Placement.TOP_LEFT;
        }
        this.scales = this.width !== null && this.height !== null;
        this.bounds = new $.Rect(this.location.x, this.location.y, this.width, this.height);
        this.position = this.location;
      },
      adjust: function(position, size) {
        var properties = $.Placement.properties[this.placement];
        if (!properties) {
          return;
        }
        if (properties.isHorizontallyCentered) {
          position.x -= size.x / 2;
        } else if (properties.isRight) {
          position.x -= size.x;
        }
        if (properties.isVerticallyCentered) {
          position.y -= size.y / 2;
        } else if (properties.isBottom) {
          position.y -= size.y;
        }
      },
      destroy: function() {
        var element = this.elementWrapper;
        var style = this.style;
        if (element.parentNode) {
          element.parentNode.removeChild(element);
          if (element.prevElementParent) {
            style.display = "none";
            document.body.appendChild(element);
          }
        }
        this.onDraw = null;
        style.top = "";
        style.left = "";
        style.position = "";
        if (this.width !== null) {
          style.width = "";
        }
        if (this.height !== null) {
          style.height = "";
        }
        var transformOriginProp = $.getCssPropertyWithVendorPrefix("transformOrigin");
        var transformProp = $.getCssPropertyWithVendorPrefix("transform");
        if (transformOriginProp && transformProp) {
          style[transformOriginProp] = "";
          style[transformProp] = "";
        }
      },
      drawHTML: function(container, viewport) {
        var element = this.elementWrapper;
        if (element.parentNode !== container) {
          element.prevElementParent = element.parentNode;
          element.prevNextSibling = element.nextSibling;
          container.appendChild(element);
          this.style.position = "absolute";
          this.size = $.getElementSize(this.elementWrapper);
        }
        var positionAndSize = this._getOverlayPositionAndSize(viewport);
        var position = positionAndSize.position;
        var size = this.size = positionAndSize.size;
        var outerScale = "";
        if (viewport.overlayPreserveContentDirection) {
          outerScale = viewport.flipped ? " scaleX(-1)" : " scaleX(1)";
        }
        var rotate = viewport.flipped ? -positionAndSize.rotate : positionAndSize.rotate;
        var scale = viewport.flipped ? " scaleX(-1)" : "";
        if (this.onDraw) {
          this.onDraw(position, size, this.element);
        } else {
          var style = this.style;
          var innerStyle = this.element.style;
          innerStyle.display = "block";
          style.left = position.x + "px";
          style.top = position.y + "px";
          if (this.width !== null) {
            innerStyle.width = size.x + "px";
          }
          if (this.height !== null) {
            innerStyle.height = size.y + "px";
          }
          var transformOriginProp = $.getCssPropertyWithVendorPrefix("transformOrigin");
          var transformProp = $.getCssPropertyWithVendorPrefix("transform");
          if (transformOriginProp && transformProp) {
            if (rotate && !viewport.flipped) {
              innerStyle[transformProp] = "";
              style[transformOriginProp] = this._getTransformOrigin();
              style[transformProp] = "rotate(" + rotate + "deg)";
            } else if (!rotate && viewport.flipped) {
              innerStyle[transformProp] = outerScale;
              style[transformOriginProp] = this._getTransformOrigin();
              style[transformProp] = scale;
            } else if (rotate && viewport.flipped) {
              innerStyle[transformProp] = outerScale;
              style[transformOriginProp] = this._getTransformOrigin();
              style[transformProp] = "rotate(" + rotate + "deg)" + scale;
            } else {
              innerStyle[transformProp] = "";
              style[transformOriginProp] = "";
              style[transformProp] = "";
            }
          }
          style.display = "flex";
        }
      },
      _getOverlayPositionAndSize: function(viewport) {
        var position = viewport.pixelFromPoint(this.location, true);
        var size = this._getSizeInPixels(viewport);
        this.adjust(position, size);
        var rotate = 0;
        if (viewport.getRotation(true) && this.rotationMode !== $.OverlayRotationMode.NO_ROTATION) {
          if (this.rotationMode === $.OverlayRotationMode.BOUNDING_BOX && this.width !== null && this.height !== null) {
            var rect = new $.Rect(position.x, position.y, size.x, size.y);
            var boundingBox = this._getBoundingBox(rect, viewport.getRotation(true));
            position = boundingBox.getTopLeft();
            size = boundingBox.getSize();
          } else {
            rotate = viewport.getRotation(true);
          }
        }
        if (viewport.flipped) {
          position.x = viewport.getContainerSize().x - position.x;
        }
        return {
          position,
          size,
          rotate
        };
      },
      _getSizeInPixels: function(viewport) {
        var width = this.size.x;
        var height = this.size.y;
        if (this.width !== null || this.height !== null) {
          var scaledSize = viewport.deltaPixelsFromPointsNoRotate(new $.Point(this.width || 0, this.height || 0), true);
          if (this.width !== null) {
            width = scaledSize.x;
          }
          if (this.height !== null) {
            height = scaledSize.y;
          }
        }
        if (this.checkResize && (this.width === null || this.height === null)) {
          var eltSize = this.size = $.getElementSize(this.elementWrapper);
          if (this.width === null) {
            width = eltSize.x;
          }
          if (this.height === null) {
            height = eltSize.y;
          }
        }
        return new $.Point(width, height);
      },
      _getBoundingBox: function(rect, degrees) {
        var refPoint = this._getPlacementPoint(rect);
        return rect.rotate(degrees, refPoint).getBoundingBox();
      },
      _getPlacementPoint: function(rect) {
        var result = new $.Point(rect.x, rect.y);
        var properties = $.Placement.properties[this.placement];
        if (properties) {
          if (properties.isHorizontallyCentered) {
            result.x += rect.width / 2;
          } else if (properties.isRight) {
            result.x += rect.width;
          }
          if (properties.isVerticallyCentered) {
            result.y += rect.height / 2;
          } else if (properties.isBottom) {
            result.y += rect.height;
          }
        }
        return result;
      },
      _getTransformOrigin: function() {
        var result = "";
        var properties = $.Placement.properties[this.placement];
        if (!properties) {
          return result;
        }
        if (properties.isLeft) {
          result = "left";
        } else if (properties.isRight) {
          result = "right";
        }
        if (properties.isTop) {
          result += " top";
        } else if (properties.isBottom) {
          result += " bottom";
        }
        return result;
      },
      update: function(location, placement) {
        var options = $.isPlainObject(location) ? location : {
          location,
          placement
        };
        this._init({
          location: options.location || this.location,
          placement: options.placement !== undefined ? options.placement : this.placement,
          onDraw: options.onDraw || this.onDraw,
          checkResize: options.checkResize || this.checkResize,
          width: options.width !== undefined ? options.width : this.width,
          height: options.height !== undefined ? options.height : this.height,
          rotationMode: options.rotationMode || this.rotationMode
        });
      },
      getBounds: function(viewport) {
        $.console.assert(viewport, "A viewport must now be passed to Overlay.getBounds.");
        var width = this.width;
        var height = this.height;
        if (width === null || height === null) {
          var size = viewport.deltaPointsFromPixelsNoRotate(this.size, true);
          if (width === null) {
            width = size.x;
          }
          if (height === null) {
            height = size.y;
          }
        }
        var location = this.location.clone();
        this.adjust(location, new $.Point(width, height));
        return this._adjustBoundsForRotation(viewport, new $.Rect(location.x, location.y, width, height));
      },
      _adjustBoundsForRotation: function(viewport, bounds) {
        if (!viewport || viewport.getRotation(true) === 0 || this.rotationMode === $.OverlayRotationMode.EXACT) {
          return bounds;
        }
        if (this.rotationMode === $.OverlayRotationMode.BOUNDING_BOX) {
          if (this.width === null || this.height === null) {
            return bounds;
          }
          var positionAndSize = this._getOverlayPositionAndSize(viewport);
          return viewport.viewerElementToViewportRectangle(new $.Rect(positionAndSize.position.x, positionAndSize.position.y, positionAndSize.size.x, positionAndSize.size.y));
        }
        return bounds.rotate(-viewport.getRotation(true), this._getPlacementPoint(bounds));
      }
    };
  })(OpenSeadragon);
  (function($) {
    const OpenSeadragon2 = $;
    OpenSeadragon2.DrawerBase = class DrawerBase {
      constructor(options) {
        $.console.assert(options.viewer, "[Drawer] options.viewer is required");
        $.console.assert(options.viewport, "[Drawer] options.viewport is required");
        $.console.assert(options.element, "[Drawer] options.element is required");
        this.viewer = options.viewer;
        this.viewport = options.viewport;
        this.debugGridColor = typeof options.debugGridColor === "string" ? [options.debugGridColor] : options.debugGridColor || $.DEFAULT_SETTINGS.debugGridColor;
        this.options = options.options || {};
        this.container = $.getElement(options.element);
        this._renderingTarget = this._createDrawingElement();
        this.canvas.style.width = "100%";
        this.canvas.style.height = "100%";
        this.canvas.style.position = "absolute";
        this.canvas.style.left = "0";
        $.setElementOpacity(this.canvas, this.viewer.opacity, true);
        $.setElementPointerEventsNone(this.canvas);
        $.setElementTouchActionNone(this.canvas);
        this.container.style.textAlign = "left";
        this.container.appendChild(this.canvas);
        this._checkForAPIOverrides();
      }
      get canvas() {
        return this._renderingTarget;
      }
      get element() {
        $.console.error("Drawer.element is deprecated. Use Drawer.container instead.");
        return this.container;
      }
      getType() {
        $.console.error("Drawer.getType must be implemented by child class");
        return;
      }
      static isSupported() {
        $.console.error("Drawer.isSupported must be implemented by child class");
      }
      _createDrawingElement() {
        $.console.error("Drawer._createDrawingElement must be implemented by child class");
        return null;
      }
      draw(tiledImages) {
        $.console.error("Drawer.draw must be implemented by child class");
      }
      canRotate() {
        $.console.error("Drawer.canRotate must be implemented by child class");
      }
      destroy() {
        $.console.error("Drawer.destroy must be implemented by child class");
      }
      minimumOverlapRequired(tiledImage) {
        return false;
      }
      setImageSmoothingEnabled(imageSmoothingEnabled) {
        $.console.error("Drawer.setImageSmoothingEnabled must be implemented by child class");
      }
      drawDebuggingRect(rect) {
        $.console.warn("[drawer].drawDebuggingRect is not implemented by this drawer");
      }
      clear() {
        $.console.warn("[drawer].clear() is deprecated. The drawer is responsible for clearing itself as needed before drawing tiles.");
      }
      _checkForAPIOverrides() {
        if (this._createDrawingElement === $.DrawerBase.prototype._createDrawingElement) {
          throw new Error("[drawer]._createDrawingElement must be implemented by child class");
        }
        if (this.draw === $.DrawerBase.prototype.draw) {
          throw new Error("[drawer].draw must be implemented by child class");
        }
        if (this.canRotate === $.DrawerBase.prototype.canRotate) {
          throw new Error("[drawer].canRotate must be implemented by child class");
        }
        if (this.destroy === $.DrawerBase.prototype.destroy) {
          throw new Error("[drawer].destroy must be implemented by child class");
        }
        if (this.setImageSmoothingEnabled === $.DrawerBase.prototype.setImageSmoothingEnabled) {
          throw new Error("[drawer].setImageSmoothingEnabled must be implemented by child class");
        }
      }
      viewportToDrawerRectangle(rectangle) {
        var topLeft = this.viewport.pixelFromPointNoRotate(rectangle.getTopLeft(), true);
        var size = this.viewport.deltaPixelsFromPointsNoRotate(rectangle.getSize(), true);
        return new $.Rect(topLeft.x * $.pixelDensityRatio, topLeft.y * $.pixelDensityRatio, size.x * $.pixelDensityRatio, size.y * $.pixelDensityRatio);
      }
      viewportCoordToDrawerCoord(point) {
        var vpPoint = this.viewport.pixelFromPointNoRotate(point, true);
        return new $.Point(vpPoint.x * $.pixelDensityRatio, vpPoint.y * $.pixelDensityRatio);
      }
      _calculateCanvasSize() {
        var pixelDensityRatio = $.pixelDensityRatio;
        var viewportSize = this.viewport.getContainerSize();
        return new OpenSeadragon2.Point(Math.round(viewportSize.x * pixelDensityRatio), Math.round(viewportSize.y * pixelDensityRatio));
      }
      _raiseTiledImageDrawnEvent(tiledImage, tiles) {
        if (!this.viewer) {
          return;
        }
        this.viewer.raiseEvent("tiled-image-drawn", {
          tiledImage,
          tiles
        });
      }
      _raiseDrawerErrorEvent(tiledImage, errorMessage) {
        if (!this.viewer) {
          return;
        }
        this.viewer.raiseEvent("drawer-error", {
          tiledImage,
          drawer: this,
          error: errorMessage
        });
      }
    };
  })(OpenSeadragon);
  (function($) {
    const OpenSeadragon2 = $;

    class HTMLDrawer extends OpenSeadragon2.DrawerBase {
      constructor(options) {
        super(options);
        this.viewer.rejectEventHandler("tile-drawing", "The HTMLDrawer does not raise the tile-drawing event");
        this.viewer.allowEventHandler("tile-drawn");
      }
      static isSupported() {
        return true;
      }
      getType() {
        return "html";
      }
      minimumOverlapRequired(tiledImage) {
        return true;
      }
      _createDrawingElement() {
        let canvas = $.makeNeutralElement("div");
        return canvas;
      }
      draw(tiledImages) {
        var _this = this;
        this._prepareNewFrame();
        tiledImages.forEach(function(tiledImage) {
          if (tiledImage.opacity !== 0) {
            _this._drawTiles(tiledImage);
          }
        });
      }
      canRotate() {
        return false;
      }
      destroy() {
        this.container.removeChild(this.canvas);
      }
      setImageSmoothingEnabled() {}
      _prepareNewFrame() {
        this.canvas.innerHTML = "";
      }
      _drawTiles(tiledImage) {
        var lastDrawn = tiledImage.getTilesToDraw().map((info) => info.tile);
        if (tiledImage.opacity === 0 || lastDrawn.length === 0 && !tiledImage.placeholderFillStyle) {
          return;
        }
        for (var i = lastDrawn.length - 1;i >= 0; i--) {
          var tile = lastDrawn[i];
          this._drawTile(tile);
          if (this.viewer) {
            this.viewer.raiseEvent("tile-drawn", {
              tiledImage,
              tile
            });
          }
        }
      }
      _drawTile(tile) {
        $.console.assert(tile, "[Drawer._drawTile] tile is required");
        let container = this.canvas;
        if (!tile.cacheImageRecord) {
          $.console.warn("[Drawer._drawTileToHTML] attempting to draw tile %s when it's not cached", tile.toString());
          return;
        }
        if (!tile.loaded) {
          $.console.warn("Attempting to draw tile %s when it's not yet loaded.", tile.toString());
          return;
        }
        if (!tile.element) {
          var image = tile.getImage();
          if (!image) {
            return;
          }
          tile.element = $.makeNeutralElement("div");
          tile.imgElement = image.cloneNode();
          tile.imgElement.style.msInterpolationMode = "nearest-neighbor";
          tile.imgElement.style.width = "100%";
          tile.imgElement.style.height = "100%";
          tile.style = tile.element.style;
          tile.style.position = "absolute";
        }
        if (tile.element.parentNode !== container) {
          container.appendChild(tile.element);
        }
        if (tile.imgElement.parentNode !== tile.element) {
          tile.element.appendChild(tile.imgElement);
        }
        tile.style.top = tile.position.y + "px";
        tile.style.left = tile.position.x + "px";
        tile.style.height = tile.size.y + "px";
        tile.style.width = tile.size.x + "px";
        if (tile.flipped) {
          tile.style.transform = "scaleX(-1)";
        }
        $.setElementOpacity(tile.element, tile.opacity);
      }
    }
    $.HTMLDrawer = HTMLDrawer;
  })(OpenSeadragon);
  (function($) {
    const OpenSeadragon2 = $;

    class CanvasDrawer extends OpenSeadragon2.DrawerBase {
      constructor(options) {
        super(options);
        this.context = this.canvas.getContext("2d");
        this.sketchCanvas = null;
        this.sketchContext = null;
        this._imageSmoothingEnabled = true;
        this.viewer.allowEventHandler("tile-drawn");
        this.viewer.allowEventHandler("tile-drawing");
      }
      static isSupported() {
        return $.supportsCanvas;
      }
      getType() {
        return "canvas";
      }
      _createDrawingElement() {
        let canvas = $.makeNeutralElement("canvas");
        let viewportSize = this._calculateCanvasSize();
        canvas.width = viewportSize.x;
        canvas.height = viewportSize.y;
        return canvas;
      }
      draw(tiledImages) {
        this._prepareNewFrame();
        if (this.viewer.viewport.getFlip() !== this._viewportFlipped) {
          this._flip();
        }
        for (const tiledImage of tiledImages) {
          if (tiledImage.opacity !== 0) {
            this._drawTiles(tiledImage);
          }
        }
      }
      canRotate() {
        return true;
      }
      destroy() {
        this.canvas.width = 1;
        this.canvas.height = 1;
        this.sketchCanvas = null;
        this.sketchContext = null;
        this.container.removeChild(this.canvas);
      }
      minimumOverlapRequired(tiledImage) {
        return true;
      }
      setImageSmoothingEnabled(imageSmoothingEnabled) {
        this._imageSmoothingEnabled = !!imageSmoothingEnabled;
        this._updateImageSmoothingEnabled(this.context);
        this.viewer.forceRedraw();
      }
      drawDebuggingRect(rect) {
        var context = this.context;
        context.save();
        context.lineWidth = 2 * $.pixelDensityRatio;
        context.strokeStyle = this.debugGridColor[0];
        context.fillStyle = this.debugGridColor[0];
        context.strokeRect(rect.x * $.pixelDensityRatio, rect.y * $.pixelDensityRatio, rect.width * $.pixelDensityRatio, rect.height * $.pixelDensityRatio);
        context.restore();
      }
      get _viewportFlipped() {
        return this.context.getTransform().a < 0;
      }
      _raiseTileDrawingEvent(tiledImage, context, tile, rendered) {
        this.viewer.raiseEvent("tile-drawing", {
          tiledImage,
          context,
          tile,
          rendered
        });
      }
      _prepareNewFrame() {
        var viewportSize = this._calculateCanvasSize();
        if (this.canvas.width !== viewportSize.x || this.canvas.height !== viewportSize.y) {
          this.canvas.width = viewportSize.x;
          this.canvas.height = viewportSize.y;
          this._updateImageSmoothingEnabled(this.context);
          if (this.sketchCanvas !== null) {
            var sketchCanvasSize = this._calculateSketchCanvasSize();
            this.sketchCanvas.width = sketchCanvasSize.x;
            this.sketchCanvas.height = sketchCanvasSize.y;
            this._updateImageSmoothingEnabled(this.sketchContext);
          }
        }
        this._clear();
      }
      _clear(useSketch, bounds) {
        var context = this._getContext(useSketch);
        if (bounds) {
          context.clearRect(bounds.x, bounds.y, bounds.width, bounds.height);
        } else {
          var canvas = context.canvas;
          context.clearRect(0, 0, canvas.width, canvas.height);
        }
      }
      _drawTiles(tiledImage) {
        var lastDrawn = tiledImage.getTilesToDraw().map((info) => info.tile);
        if (tiledImage.opacity === 0 || lastDrawn.length === 0 && !tiledImage.placeholderFillStyle) {
          return;
        }
        var tile = lastDrawn[0];
        var useSketch;
        if (tile) {
          useSketch = tiledImage.opacity < 1 || tiledImage.compositeOperation && tiledImage.compositeOperation !== "source-over" || !tiledImage._isBottomItem() && tiledImage.source.hasTransparency(tile.context2D, tile.getUrl(), tile.ajaxHeaders, tile.postData);
        }
        var sketchScale;
        var sketchTranslate;
        var zoom = this.viewport.getZoom(true);
        var imageZoom = tiledImage.viewportToImageZoom(zoom);
        if (lastDrawn.length > 1 && imageZoom > tiledImage.smoothTileEdgesMinZoom && !tiledImage.iOSDevice && tiledImage.getRotation(true) % 360 === 0) {
          useSketch = true;
          sketchScale = tile.getScaleForEdgeSmoothing();
          sketchTranslate = tile.getTranslationForEdgeSmoothing(sketchScale, this._getCanvasSize(false), this._getCanvasSize(true));
        }
        var bounds;
        if (useSketch) {
          if (!sketchScale) {
            bounds = this.viewport.viewportToViewerElementRectangle(tiledImage.getClippedBounds(true)).getIntegerBoundingBox();
            bounds = bounds.times($.pixelDensityRatio);
          }
          this._clear(true, bounds);
        }
        if (!sketchScale) {
          this._setRotations(tiledImage, useSketch);
        }
        var usedClip = false;
        if (tiledImage._clip) {
          this._saveContext(useSketch);
          var box = tiledImage.imageToViewportRectangle(tiledImage._clip, true);
          box = box.rotate(-tiledImage.getRotation(true), tiledImage._getRotationPoint(true));
          var clipRect = this.viewportToDrawerRectangle(box);
          if (sketchScale) {
            clipRect = clipRect.times(sketchScale);
          }
          if (sketchTranslate) {
            clipRect = clipRect.translate(sketchTranslate);
          }
          this._setClip(clipRect, useSketch);
          usedClip = true;
        }
        if (tiledImage._croppingPolygons) {
          var self2 = this;
          if (!usedClip) {
            this._saveContext(useSketch);
          }
          try {
            var polygons = tiledImage._croppingPolygons.map(function(polygon) {
              return polygon.map(function(coord) {
                var point = tiledImage.imageToViewportCoordinates(coord.x, coord.y, true).rotate(-tiledImage.getRotation(true), tiledImage._getRotationPoint(true));
                var clipPoint = self2.viewportCoordToDrawerCoord(point);
                if (sketchScale) {
                  clipPoint = clipPoint.times(sketchScale);
                }
                if (sketchTranslate) {
                  clipPoint = clipPoint.plus(sketchTranslate);
                }
                return clipPoint;
              });
            });
            this._clipWithPolygons(polygons, useSketch);
          } catch (e) {
            $.console.error(e);
          }
          usedClip = true;
        }
        tiledImage._hasOpaqueTile = false;
        if (tiledImage.placeholderFillStyle && tiledImage._hasOpaqueTile === false) {
          let placeholderRect = this.viewportToDrawerRectangle(tiledImage.getBoundsNoRotate(true));
          if (sketchScale) {
            placeholderRect = placeholderRect.times(sketchScale);
          }
          if (sketchTranslate) {
            placeholderRect = placeholderRect.translate(sketchTranslate);
          }
          let fillStyle = null;
          if (typeof tiledImage.placeholderFillStyle === "function") {
            fillStyle = tiledImage.placeholderFillStyle(tiledImage, this.context);
          } else {
            fillStyle = tiledImage.placeholderFillStyle;
          }
          this._drawRectangle(placeholderRect, fillStyle, useSketch);
        }
        var subPixelRoundingRule = determineSubPixelRoundingRule(tiledImage.subPixelRoundingForTransparency);
        var shouldRoundPositionAndSize = false;
        if (subPixelRoundingRule === $.SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS) {
          shouldRoundPositionAndSize = true;
        } else if (subPixelRoundingRule === $.SUBPIXEL_ROUNDING_OCCURRENCES.ONLY_AT_REST) {
          var isAnimating = this.viewer && this.viewer.isAnimating();
          shouldRoundPositionAndSize = !isAnimating;
        }
        for (var i = 0;i < lastDrawn.length; i++) {
          tile = lastDrawn[i];
          this._drawTile(tile, tiledImage, useSketch, sketchScale, sketchTranslate, shouldRoundPositionAndSize, tiledImage.source);
          if (this.viewer) {
            this.viewer.raiseEvent("tile-drawn", {
              tiledImage,
              tile
            });
          }
        }
        if (usedClip) {
          this._restoreContext(useSketch);
        }
        if (!sketchScale) {
          if (tiledImage.getRotation(true) % 360 !== 0) {
            this._restoreRotationChanges(useSketch);
          }
          if (this.viewport.getRotation(true) % 360 !== 0) {
            this._restoreRotationChanges(useSketch);
          }
        }
        if (useSketch) {
          if (sketchScale) {
            this._setRotations(tiledImage);
          }
          this.blendSketch({
            opacity: tiledImage.opacity,
            scale: sketchScale,
            translate: sketchTranslate,
            compositeOperation: tiledImage.compositeOperation,
            bounds
          });
          if (sketchScale) {
            if (tiledImage.getRotation(true) % 360 !== 0) {
              this._restoreRotationChanges(false);
            }
            if (this.viewport.getRotation(true) % 360 !== 0) {
              this._restoreRotationChanges(false);
            }
          }
        }
        this._drawDebugInfo(tiledImage, lastDrawn);
        this._raiseTiledImageDrawnEvent(tiledImage, lastDrawn);
      }
      _drawDebugInfo(tiledImage, lastDrawn) {
        if (tiledImage.debugMode) {
          for (var i = lastDrawn.length - 1;i >= 0; i--) {
            var tile = lastDrawn[i];
            try {
              this._drawDebugInfoOnTile(tile, lastDrawn.length, i, tiledImage);
            } catch (e) {
              $.console.error(e);
            }
          }
        }
      }
      _clipWithPolygons(polygons, useSketch) {
        var context = this._getContext(useSketch);
        context.beginPath();
        for (const polygon of polygons) {
          for (const [i, coord] of polygon.entries()) {
            context[i === 0 ? "moveTo" : "lineTo"](coord.x, coord.y);
          }
        }
        context.clip();
      }
      _drawTile(tile, tiledImage, useSketch, scale, translate, shouldRoundPositionAndSize, source) {
        $.console.assert(tile, "[Drawer._drawTile] tile is required");
        $.console.assert(tiledImage, "[Drawer._drawTile] drawingHandler is required");
        var context = this._getContext(useSketch);
        scale = scale || 1;
        this._drawTileToCanvas(tile, context, tiledImage, scale, translate, shouldRoundPositionAndSize, source);
      }
      _drawTileToCanvas(tile, context, tiledImage, scale, translate, shouldRoundPositionAndSize, source) {
        var position = tile.position.times($.pixelDensityRatio), size = tile.size.times($.pixelDensityRatio), rendered;
        if (!tile.context2D && !tile.cacheImageRecord) {
          $.console.warn("[Drawer._drawTileToCanvas] attempting to draw tile %s when it's not cached", tile.toString());
          return;
        }
        rendered = tile.getCanvasContext();
        if (!tile.loaded || !rendered) {
          $.console.warn("Attempting to draw tile %s when it's not yet loaded.", tile.toString());
          return;
        }
        context.save();
        if (typeof scale === "number" && scale !== 1) {
          position = position.times(scale);
          size = size.times(scale);
        }
        if (translate instanceof $.Point) {
          position = position.plus(translate);
        }
        if (context.globalAlpha === 1 && tile.hasTransparency) {
          if (shouldRoundPositionAndSize) {
            position.x = Math.round(position.x);
            position.y = Math.round(position.y);
            size.x = Math.round(size.x);
            size.y = Math.round(size.y);
          }
          context.clearRect(position.x, position.y, size.x, size.y);
        }
        this._raiseTileDrawingEvent(tiledImage, context, tile, rendered);
        var sourceWidth, sourceHeight;
        if (tile.sourceBounds) {
          sourceWidth = Math.min(tile.sourceBounds.width, rendered.canvas.width);
          sourceHeight = Math.min(tile.sourceBounds.height, rendered.canvas.height);
        } else {
          sourceWidth = rendered.canvas.width;
          sourceHeight = rendered.canvas.height;
        }
        context.translate(position.x + size.x / 2, 0);
        if (tile.flipped) {
          context.scale(-1, 1);
        }
        context.drawImage(rendered.canvas, 0, 0, sourceWidth, sourceHeight, -size.x / 2, position.y, size.x, size.y);
        context.restore();
      }
      _getContext(useSketch) {
        var context = this.context;
        if (useSketch) {
          if (this.sketchCanvas === null) {
            this.sketchCanvas = document.createElement("canvas");
            var sketchCanvasSize = this._calculateSketchCanvasSize();
            this.sketchCanvas.width = sketchCanvasSize.x;
            this.sketchCanvas.height = sketchCanvasSize.y;
            this.sketchContext = this.sketchCanvas.getContext("2d");
            if (this.viewport.getRotation() === 0) {
              var self2 = this;
              this.viewer.addHandler("rotate", function resizeSketchCanvas() {
                if (self2.viewport.getRotation() === 0) {
                  return;
                }
                self2.viewer.removeHandler("rotate", resizeSketchCanvas);
                var sketchCanvasSize2 = self2._calculateSketchCanvasSize();
                self2.sketchCanvas.width = sketchCanvasSize2.x;
                self2.sketchCanvas.height = sketchCanvasSize2.y;
              });
            }
            this._updateImageSmoothingEnabled(this.sketchContext);
          }
          context = this.sketchContext;
        }
        return context;
      }
      _saveContext(useSketch) {
        this._getContext(useSketch).save();
      }
      _restoreContext(useSketch) {
        this._getContext(useSketch).restore();
      }
      _setClip(rect, useSketch) {
        var context = this._getContext(useSketch);
        context.beginPath();
        context.rect(rect.x, rect.y, rect.width, rect.height);
        context.clip();
      }
      _drawRectangle(rect, fillStyle, useSketch) {
        var context = this._getContext(useSketch);
        context.save();
        context.fillStyle = fillStyle;
        context.fillRect(rect.x, rect.y, rect.width, rect.height);
        context.restore();
      }
      blendSketch(opacity, scale, translate, compositeOperation) {
        var options = opacity;
        if (!$.isPlainObject(options)) {
          options = {
            opacity,
            scale,
            translate,
            compositeOperation
          };
        }
        opacity = options.opacity;
        compositeOperation = options.compositeOperation;
        var bounds = options.bounds;
        this.context.save();
        this.context.globalAlpha = opacity;
        if (compositeOperation) {
          this.context.globalCompositeOperation = compositeOperation;
        }
        if (bounds) {
          if (bounds.x < 0) {
            bounds.width += bounds.x;
            bounds.x = 0;
          }
          if (bounds.x + bounds.width > this.canvas.width) {
            bounds.width = this.canvas.width - bounds.x;
          }
          if (bounds.y < 0) {
            bounds.height += bounds.y;
            bounds.y = 0;
          }
          if (bounds.y + bounds.height > this.canvas.height) {
            bounds.height = this.canvas.height - bounds.y;
          }
          this.context.drawImage(this.sketchCanvas, bounds.x, bounds.y, bounds.width, bounds.height, bounds.x, bounds.y, bounds.width, bounds.height);
        } else {
          scale = options.scale || 1;
          translate = options.translate;
          var position = translate instanceof $.Point ? translate : new $.Point(0, 0);
          var widthExt = 0;
          var heightExt = 0;
          if (translate) {
            var widthDiff = this.sketchCanvas.width - this.canvas.width;
            var heightDiff = this.sketchCanvas.height - this.canvas.height;
            widthExt = Math.round(widthDiff / 2);
            heightExt = Math.round(heightDiff / 2);
          }
          this.context.drawImage(this.sketchCanvas, position.x - widthExt * scale, position.y - heightExt * scale, (this.canvas.width + 2 * widthExt) * scale, (this.canvas.height + 2 * heightExt) * scale, -widthExt, -heightExt, this.canvas.width + 2 * widthExt, this.canvas.height + 2 * heightExt);
        }
        this.context.restore();
      }
      _drawDebugInfoOnTile(tile, count, i, tiledImage) {
        var colorIndex = this.viewer.world.getIndexOfItem(tiledImage) % this.debugGridColor.length;
        var context = this.context;
        context.save();
        context.lineWidth = 2 * $.pixelDensityRatio;
        context.font = "small-caps bold " + 13 * $.pixelDensityRatio + "px arial";
        context.strokeStyle = this.debugGridColor[colorIndex];
        context.fillStyle = this.debugGridColor[colorIndex];
        this._setRotations(tiledImage);
        if (this._viewportFlipped) {
          this._flip({ point: tile.position.plus(tile.size.divide(2)) });
        }
        context.strokeRect(tile.position.x * $.pixelDensityRatio, tile.position.y * $.pixelDensityRatio, tile.size.x * $.pixelDensityRatio, tile.size.y * $.pixelDensityRatio);
        var tileCenterX = (tile.position.x + tile.size.x / 2) * $.pixelDensityRatio;
        var tileCenterY = (tile.position.y + tile.size.y / 2) * $.pixelDensityRatio;
        context.translate(tileCenterX, tileCenterY);
        const angleInDegrees = this.viewport.getRotation(true);
        context.rotate(Math.PI / 180 * -angleInDegrees);
        context.translate(-tileCenterX, -tileCenterY);
        if (tile.x === 0 && tile.y === 0) {
          context.fillText("Zoom: " + this.viewport.getZoom(), tile.position.x * $.pixelDensityRatio, (tile.position.y - 30) * $.pixelDensityRatio);
          context.fillText("Pan: " + this.viewport.getBounds().toString(), tile.position.x * $.pixelDensityRatio, (tile.position.y - 20) * $.pixelDensityRatio);
        }
        context.fillText("Level: " + tile.level, (tile.position.x + 10) * $.pixelDensityRatio, (tile.position.y + 20) * $.pixelDensityRatio);
        context.fillText("Column: " + tile.x, (tile.position.x + 10) * $.pixelDensityRatio, (tile.position.y + 30) * $.pixelDensityRatio);
        context.fillText("Row: " + tile.y, (tile.position.x + 10) * $.pixelDensityRatio, (tile.position.y + 40) * $.pixelDensityRatio);
        context.fillText("Order: " + i + " of " + count, (tile.position.x + 10) * $.pixelDensityRatio, (tile.position.y + 50) * $.pixelDensityRatio);
        context.fillText("Size: " + tile.size.toString(), (tile.position.x + 10) * $.pixelDensityRatio, (tile.position.y + 60) * $.pixelDensityRatio);
        context.fillText("Position: " + tile.position.toString(), (tile.position.x + 10) * $.pixelDensityRatio, (tile.position.y + 70) * $.pixelDensityRatio);
        if (this.viewport.getRotation(true) % 360 !== 0) {
          this._restoreRotationChanges();
        }
        if (tiledImage.getRotation(true) % 360 !== 0) {
          this._restoreRotationChanges();
        }
        context.restore();
      }
      _updateImageSmoothingEnabled(context) {
        context.msImageSmoothingEnabled = this._imageSmoothingEnabled;
        context.imageSmoothingEnabled = this._imageSmoothingEnabled;
      }
      _getCanvasSize(sketch) {
        var canvas = this._getContext(sketch).canvas;
        return new $.Point(canvas.width, canvas.height);
      }
      _getCanvasCenter() {
        return new $.Point(this.canvas.width / 2, this.canvas.height / 2);
      }
      _setRotations(tiledImage, useSketch = false) {
        var saveContext = false;
        if (this.viewport.getRotation(true) % 360 !== 0) {
          this._offsetForRotation({
            degrees: this.viewport.getRotation(true),
            useSketch,
            saveContext
          });
          saveContext = false;
        }
        if (tiledImage.getRotation(true) % 360 !== 0) {
          this._offsetForRotation({
            degrees: tiledImage.getRotation(true),
            point: this.viewport.pixelFromPointNoRotate(tiledImage._getRotationPoint(true), true),
            useSketch,
            saveContext
          });
        }
      }
      _offsetForRotation(options) {
        var point = options.point ? options.point.times($.pixelDensityRatio) : this._getCanvasCenter();
        var context = this._getContext(options.useSketch);
        context.save();
        context.translate(point.x, point.y);
        context.rotate(Math.PI / 180 * options.degrees);
        context.translate(-point.x, -point.y);
      }
      _flip(options) {
        options = options || {};
        var point = options.point ? options.point.times($.pixelDensityRatio) : this._getCanvasCenter();
        var context = this._getContext(options.useSketch);
        context.translate(point.x, 0);
        context.scale(-1, 1);
        context.translate(-point.x, 0);
      }
      _restoreRotationChanges(useSketch) {
        var context = this._getContext(useSketch);
        context.restore();
      }
      _calculateCanvasSize() {
        var pixelDensityRatio = $.pixelDensityRatio;
        var viewportSize = this.viewport.getContainerSize();
        return {
          x: Math.round(viewportSize.x * pixelDensityRatio),
          y: Math.round(viewportSize.y * pixelDensityRatio)
        };
      }
      _calculateSketchCanvasSize() {
        var canvasSize = this._calculateCanvasSize();
        if (this.viewport.getRotation() === 0) {
          return canvasSize;
        }
        var sketchCanvasSize = Math.ceil(Math.sqrt(canvasSize.x * canvasSize.x + canvasSize.y * canvasSize.y));
        return {
          x: sketchCanvasSize,
          y: sketchCanvasSize
        };
      }
    }
    $.CanvasDrawer = CanvasDrawer;
    var DEFAULT_SUBPIXEL_ROUNDING_RULE = $.SUBPIXEL_ROUNDING_OCCURRENCES.NEVER;
    function isSubPixelRoundingRuleUnknown(value) {
      return value !== $.SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS && value !== $.SUBPIXEL_ROUNDING_OCCURRENCES.ONLY_AT_REST && value !== $.SUBPIXEL_ROUNDING_OCCURRENCES.NEVER;
    }
    function normalizeSubPixelRoundingRule(value) {
      if (isSubPixelRoundingRuleUnknown(value)) {
        return DEFAULT_SUBPIXEL_ROUNDING_RULE;
      }
      return value;
    }
    function determineSubPixelRoundingRule(subPixelRoundingRules) {
      if (typeof subPixelRoundingRules === "number") {
        return normalizeSubPixelRoundingRule(subPixelRoundingRules);
      }
      if (!subPixelRoundingRules || !$.Browser) {
        return DEFAULT_SUBPIXEL_ROUNDING_RULE;
      }
      var subPixelRoundingRule = subPixelRoundingRules[$.Browser.vendor];
      if (isSubPixelRoundingRuleUnknown(subPixelRoundingRule)) {
        subPixelRoundingRule = subPixelRoundingRules["*"];
      }
      return normalizeSubPixelRoundingRule(subPixelRoundingRule);
    }
  })(OpenSeadragon);
  (function($) {
    const OpenSeadragon2 = $;
    OpenSeadragon2.WebGLDrawer = class WebGLDrawer extends OpenSeadragon2.DrawerBase {
      constructor(options) {
        super(options);
        this._destroyed = false;
        this._TextureMap = new Map;
        this._TileMap = new Map;
        this._gl = null;
        this._firstPass = null;
        this._secondPass = null;
        this._glFrameBuffer = null;
        this._renderToTexture = null;
        this._glFramebufferToCanvasTransform = null;
        this._outputCanvas = null;
        this._outputContext = null;
        this._clippingCanvas = null;
        this._clippingContext = null;
        this._renderingCanvas = null;
        this._backupCanvasDrawer = null;
        this._imageSmoothingEnabled = true;
        this._boundToTileReady = (ev) => this._tileReadyHandler(ev);
        this._boundToImageUnloaded = (ev) => this._imageUnloadedHandler(ev);
        this.viewer.addHandler("tile-ready", this._boundToTileReady);
        this.viewer.addHandler("image-unloaded", this._boundToImageUnloaded);
        this.viewer.rejectEventHandler("tile-drawn", "The WebGLDrawer does not raise the tile-drawn event");
        this.viewer.rejectEventHandler("tile-drawing", "The WebGLDrawer does not raise the tile-drawing event");
        this._setupCanvases();
        this._setupRenderer();
        this.context = this._outputContext;
      }
      destroy() {
        if (this._destroyed) {
          return;
        }
        let gl = this._gl;
        var numTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        for (let unit = 0;unit < numTextureUnits; ++unit) {
          gl.activeTexture(gl.TEXTURE0 + unit);
          gl.bindTexture(gl.TEXTURE_2D, null);
          gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        this._unloadTextures();
        gl.deleteBuffer(this._secondPass.bufferOutputPosition);
        gl.deleteFramebuffer(this._glFrameBuffer);
        this._renderingCanvas.width = this._renderingCanvas.height = 1;
        this._clippingCanvas.width = this._clippingCanvas.height = 1;
        this._outputCanvas.width = this._outputCanvas.height = 1;
        this._renderingCanvas = null;
        this._clippingCanvas = this._clippingContext = null;
        this._outputCanvas = this._outputContext = null;
        let ext = gl.getExtension("WEBGL_lose_context");
        if (ext) {
          ext.loseContext();
        }
        this.viewer.removeHandler("tile-ready", this._boundToTileReady);
        this.viewer.removeHandler("image-unloaded", this._boundToImageUnloaded);
        this.viewer.removeHandler("resize", this._resizeHandler);
        this._gl = null;
        if (this._backupCanvasDrawer) {
          this._backupCanvasDrawer.destroy();
          this._backupCanvasDrawer = null;
        }
        this.container.removeChild(this.canvas);
        if (this.viewer.drawer === this) {
          this.viewer.drawer = null;
        }
        this._destroyed = true;
      }
      canRotate() {
        return true;
      }
      static isSupported() {
        let canvasElement = document.createElement("canvas");
        let webglContext = $.isFunction(canvasElement.getContext) && canvasElement.getContext("webgl");
        let ext = webglContext && webglContext.getExtension("WEBGL_lose_context");
        if (ext) {
          ext.loseContext();
        }
        return !!webglContext;
      }
      getType() {
        return "webgl";
      }
      minimumOverlapRequired(tiledImage) {
        return tiledImage.isTainted();
      }
      _createDrawingElement() {
        let canvas = $.makeNeutralElement("canvas");
        let viewportSize = this._calculateCanvasSize();
        canvas.width = viewportSize.x;
        canvas.height = viewportSize.y;
        return canvas;
      }
      _getBackupCanvasDrawer() {
        if (!this._backupCanvasDrawer) {
          this._backupCanvasDrawer = this.viewer.requestDrawer("canvas", { mainDrawer: false });
          this._backupCanvasDrawer.canvas.style.setProperty("visibility", "hidden");
        }
        return this._backupCanvasDrawer;
      }
      draw(tiledImages) {
        let gl = this._gl;
        const bounds = this.viewport.getBoundsNoRotateWithMargins(true);
        let view = {
          bounds,
          center: new OpenSeadragon2.Point(bounds.x + bounds.width / 2, bounds.y + bounds.height / 2),
          rotation: this.viewport.getRotation(true) * Math.PI / 180
        };
        let flipMultiplier = this.viewport.flipped ? -1 : 1;
        let posMatrix = $.Mat3.makeTranslation(-view.center.x, -view.center.y);
        let scaleMatrix = $.Mat3.makeScaling(2 / view.bounds.width * flipMultiplier, -2 / view.bounds.height);
        let rotMatrix = $.Mat3.makeRotation(-view.rotation);
        let viewMatrix = scaleMatrix.multiply(rotMatrix).multiply(posMatrix);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.clear(gl.COLOR_BUFFER_BIT);
        this._outputContext.clearRect(0, 0, this._outputCanvas.width, this._outputCanvas.height);
        let renderingBufferHasImageData = false;
        tiledImages.forEach((tiledImage, tiledImageIndex) => {
          if (tiledImage.isTainted()) {
            if (renderingBufferHasImageData) {
              this._outputContext.drawImage(this._renderingCanvas, 0, 0);
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              gl.clear(gl.COLOR_BUFFER_BIT);
              renderingBufferHasImageData = false;
            }
            const canvasDrawer = this._getBackupCanvasDrawer();
            canvasDrawer.draw([tiledImage]);
            this._outputContext.drawImage(canvasDrawer.canvas, 0, 0);
          } else {
            let tilesToDraw = tiledImage.getTilesToDraw();
            if (tiledImage.placeholderFillStyle && tiledImage._hasOpaqueTile === false) {
              this._drawPlaceholder(tiledImage);
            }
            if (tilesToDraw.length === 0 || tiledImage.getOpacity() === 0) {
              return;
            }
            let firstTile = tilesToDraw[0];
            let useContext2dPipeline = tiledImage.compositeOperation || this.viewer.compositeOperation || tiledImage._clip || tiledImage._croppingPolygons || tiledImage.debugMode;
            let useTwoPassRendering = useContext2dPipeline || tiledImage.opacity < 1 || firstTile.hasTransparency;
            if (useContext2dPipeline) {
              if (renderingBufferHasImageData) {
                this._outputContext.drawImage(this._renderingCanvas, 0, 0);
              }
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              gl.clear(gl.COLOR_BUFFER_BIT);
            }
            gl.useProgram(this._firstPass.shaderProgram);
            if (useTwoPassRendering) {
              gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFrameBuffer);
              gl.clear(gl.COLOR_BUFFER_BIT);
            } else {
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
            let overallMatrix = viewMatrix;
            let imageRotation = tiledImage.getRotation(true);
            if (imageRotation % 360 !== 0) {
              let imageRotationMatrix = $.Mat3.makeRotation(-imageRotation * Math.PI / 180);
              let imageCenter = tiledImage.getBoundsNoRotate(true).getCenter();
              let t1 = $.Mat3.makeTranslation(imageCenter.x, imageCenter.y);
              let t2 = $.Mat3.makeTranslation(-imageCenter.x, -imageCenter.y);
              let localMatrix = t1.multiply(imageRotationMatrix).multiply(t2);
              overallMatrix = viewMatrix.multiply(localMatrix);
            }
            let maxTextures = this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS);
            if (maxTextures <= 0) {
              throw new Error(`WegGL error: bad value for gl parameter MAX_TEXTURE_IMAGE_UNITS (${maxTextures}). This could happen
                        if too many contexts have been created and not released, or there is another problem with the graphics card.`);
            }
            let texturePositionArray = new Float32Array(maxTextures * 12);
            let textureDataArray = new Array(maxTextures);
            let matrixArray = new Array(maxTextures);
            let opacityArray = new Array(maxTextures);
            for (let tileIndex = 0;tileIndex < tilesToDraw.length; tileIndex++) {
              let tile = tilesToDraw[tileIndex].tile;
              let indexInDrawArray = tileIndex % maxTextures;
              let numTilesToDraw = indexInDrawArray + 1;
              let tileContext = tile.getCanvasContext();
              let textureInfo = tileContext ? this._TextureMap.get(tileContext.canvas) : null;
              if (!textureInfo) {
                this._tileReadyHandler({ tile, tiledImage });
                textureInfo = tileContext ? this._TextureMap.get(tileContext.canvas) : null;
              }
              if (textureInfo) {
                this._getTileData(tile, tiledImage, textureInfo, overallMatrix, indexInDrawArray, texturePositionArray, textureDataArray, matrixArray, opacityArray);
              } else {}
              if (numTilesToDraw === maxTextures || tileIndex === tilesToDraw.length - 1) {
                for (let i = 0;i <= numTilesToDraw; i++) {
                  gl.activeTexture(gl.TEXTURE0 + i);
                  gl.bindTexture(gl.TEXTURE_2D, textureDataArray[i]);
                }
                gl.bindBuffer(gl.ARRAY_BUFFER, this._firstPass.bufferTexturePosition);
                gl.bufferData(gl.ARRAY_BUFFER, texturePositionArray, gl.DYNAMIC_DRAW);
                matrixArray.forEach((matrix, index) => {
                  gl.uniformMatrix3fv(this._firstPass.uTransformMatrices[index], false, matrix);
                });
                gl.uniform1fv(this._firstPass.uOpacities, new Float32Array(opacityArray));
                gl.bindBuffer(gl.ARRAY_BUFFER, this._firstPass.bufferOutputPosition);
                gl.vertexAttribPointer(this._firstPass.aOutputPosition, 2, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, this._firstPass.bufferTexturePosition);
                gl.vertexAttribPointer(this._firstPass.aTexturePosition, 2, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, this._firstPass.bufferIndex);
                gl.vertexAttribPointer(this._firstPass.aIndex, 1, gl.FLOAT, false, 0, 0);
                gl.drawArrays(gl.TRIANGLES, 0, 6 * numTilesToDraw);
              }
            }
            if (useTwoPassRendering) {
              gl.useProgram(this._secondPass.shaderProgram);
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              gl.activeTexture(gl.TEXTURE0);
              gl.bindTexture(gl.TEXTURE_2D, this._renderToTexture);
              this._gl.uniform1f(this._secondPass.uOpacityMultiplier, tiledImage.opacity);
              gl.bindBuffer(gl.ARRAY_BUFFER, this._secondPass.bufferTexturePosition);
              gl.vertexAttribPointer(this._secondPass.aTexturePosition, 2, gl.FLOAT, false, 0, 0);
              gl.bindBuffer(gl.ARRAY_BUFFER, this._secondPass.bufferOutputPosition);
              gl.vertexAttribPointer(this._secondPass.aOutputPosition, 2, gl.FLOAT, false, 0, 0);
              gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
            renderingBufferHasImageData = true;
            if (useContext2dPipeline) {
              this._applyContext2dPipeline(tiledImage, tilesToDraw, tiledImageIndex);
              renderingBufferHasImageData = false;
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              gl.clear(gl.COLOR_BUFFER_BIT);
            }
            if (tiledImageIndex === 0) {
              this._raiseTiledImageDrawnEvent(tiledImage, tilesToDraw.map((info) => info.tile));
            }
          }
        });
        if (renderingBufferHasImageData) {
          this._outputContext.drawImage(this._renderingCanvas, 0, 0);
        }
      }
      setImageSmoothingEnabled(enabled) {
        if (this._imageSmoothingEnabled !== enabled) {
          this._imageSmoothingEnabled = enabled;
          this._unloadTextures();
          this.viewer.world.draw();
        }
      }
      drawDebuggingRect(rect) {
        let context = this._outputContext;
        context.save();
        context.lineWidth = 2 * $.pixelDensityRatio;
        context.strokeStyle = this.debugGridColor[0];
        context.fillStyle = this.debugGridColor[0];
        context.strokeRect(rect.x * $.pixelDensityRatio, rect.y * $.pixelDensityRatio, rect.width * $.pixelDensityRatio, rect.height * $.pixelDensityRatio);
        context.restore();
      }
      _getTextureDataFromTile(tile) {
        return tile.getCanvasContext().canvas;
      }
      _applyContext2dPipeline(tiledImage, tilesToDraw, tiledImageIndex) {
        this._outputContext.save();
        this._outputContext.globalCompositeOperation = tiledImageIndex === 0 ? null : tiledImage.compositeOperation || this.viewer.compositeOperation;
        if (tiledImage._croppingPolygons || tiledImage._clip) {
          this._renderToClippingCanvas(tiledImage);
          this._outputContext.drawImage(this._clippingCanvas, 0, 0);
        } else {
          this._outputContext.drawImage(this._renderingCanvas, 0, 0);
        }
        this._outputContext.restore();
        if (tiledImage.debugMode) {
          const flipped = this.viewer.viewport.getFlip();
          if (flipped) {
            this._flip();
          }
          this._drawDebugInfo(tilesToDraw, tiledImage, flipped);
          if (flipped) {
            this._flip();
          }
        }
      }
      _getTileData(tile, tiledImage, textureInfo, viewMatrix, index, texturePositionArray, textureDataArray, matrixArray, opacityArray) {
        let texture = textureInfo.texture;
        let textureQuad = textureInfo.position;
        texturePositionArray.set(textureQuad, index * 12);
        let overlapFraction = this._calculateOverlapFraction(tile, tiledImage);
        let xOffset = tile.positionedBounds.width * overlapFraction.x;
        let yOffset = tile.positionedBounds.height * overlapFraction.y;
        let x = tile.positionedBounds.x + (tile.x === 0 ? 0 : xOffset);
        let y = tile.positionedBounds.y + (tile.y === 0 ? 0 : yOffset);
        let right = tile.positionedBounds.x + tile.positionedBounds.width - (tile.isRightMost ? 0 : xOffset);
        let bottom = tile.positionedBounds.y + tile.positionedBounds.height - (tile.isBottomMost ? 0 : yOffset);
        let w = right - x;
        let h = bottom - y;
        let matrix = new $.Mat3([
          w,
          0,
          0,
          0,
          h,
          0,
          x,
          y,
          1
        ]);
        if (tile.flipped) {
          let t1 = $.Mat3.makeTranslation(0.5, 0);
          let t2 = $.Mat3.makeTranslation(-0.5, 0);
          let localMatrix = t1.multiply($.Mat3.makeScaling(-1, 1)).multiply(t2);
          matrix = matrix.multiply(localMatrix);
        }
        let overallMatrix = viewMatrix.multiply(matrix);
        opacityArray[index] = tile.opacity;
        textureDataArray[index] = texture;
        matrixArray[index] = overallMatrix.values;
      }
      _textureFilter() {
        return this._imageSmoothingEnabled ? this._gl.LINEAR : this._gl.NEAREST;
      }
      _setupRenderer() {
        let gl = this._gl;
        if (!gl) {
          $.console.error("_setupCanvases must be called before _setupRenderer");
        }
        this._unitQuad = this._makeQuadVertexBuffer(0, 1, 0, 1);
        this._makeFirstPassShaderProgram();
        this._makeSecondPassShaderProgram();
        this._renderToTexture = gl.createTexture();
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this._renderToTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this._renderingCanvas.width, this._renderingCanvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._textureFilter());
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        this._glFrameBuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFrameBuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._renderToTexture, 0);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      }
      _makeFirstPassShaderProgram() {
        let numTextures = this._glNumTextures = this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS);
        let makeMatrixUniforms = () => {
          return [...Array(numTextures).keys()].map((index) => `uniform mat3 u_matrix_${index};`).join(`
`);
        };
        let makeConditionals = () => {
          return [...Array(numTextures).keys()].map((index) => `${index > 0 ? "else " : ""}if(int(a_index) == ${index}) { transform_matrix = u_matrix_${index}; }`).join(`
`);
        };
        const vertexShaderProgram = `
            attribute vec2 a_output_position;
            attribute vec2 a_texture_position;
            attribute float a_index;

            ${makeMatrixUniforms()} // create a uniform mat3 for each potential tile to draw

            varying vec2 v_texture_position;
            varying float v_image_index;

            void main() {

                mat3 transform_matrix; // value will be set by the if/elses in makeConditional()

                ${makeConditionals()}

                gl_Position = vec4(transform_matrix * vec3(a_output_position, 1), 1);

                v_texture_position = a_texture_position;
                v_image_index = a_index;
            }
            `;
        const fragmentShaderProgram = `
            precision mediump float;

            // our textures
            uniform sampler2D u_images[${numTextures}];
            // our opacities
            uniform float u_opacities[${numTextures}];

            // the varyings passed in from the vertex shader.
            varying vec2 v_texture_position;
            varying float v_image_index;

            void main() {
                // can't index directly with a variable, need to use a loop iterator hack
                for(int i = 0; i < ${numTextures}; ++i){
                    if(i == int(v_image_index)){
                        gl_FragColor = texture2D(u_images[i], v_texture_position) * u_opacities[i];
                    }
                }
            }
            `;
        let gl = this._gl;
        let program = this.constructor.initShaderProgram(gl, vertexShaderProgram, fragmentShaderProgram);
        gl.useProgram(program);
        this._firstPass = {
          shaderProgram: program,
          aOutputPosition: gl.getAttribLocation(program, "a_output_position"),
          aTexturePosition: gl.getAttribLocation(program, "a_texture_position"),
          aIndex: gl.getAttribLocation(program, "a_index"),
          uTransformMatrices: [...Array(this._glNumTextures).keys()].map((i) => gl.getUniformLocation(program, `u_matrix_${i}`)),
          uImages: gl.getUniformLocation(program, "u_images"),
          uOpacities: gl.getUniformLocation(program, "u_opacities"),
          bufferOutputPosition: gl.createBuffer(),
          bufferTexturePosition: gl.createBuffer(),
          bufferIndex: gl.createBuffer()
        };
        gl.uniform1iv(this._firstPass.uImages, [...Array(numTextures).keys()]);
        let outputQuads = new Float32Array(numTextures * 12);
        for (let i = 0;i < numTextures; ++i) {
          outputQuads.set(Float32Array.from(this._unitQuad), i * 12);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, this._firstPass.bufferOutputPosition);
        gl.bufferData(gl.ARRAY_BUFFER, outputQuads, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(this._firstPass.aOutputPosition);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._firstPass.bufferTexturePosition);
        gl.enableVertexAttribArray(this._firstPass.aTexturePosition);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._firstPass.bufferIndex);
        let indices = [...Array(this._glNumTextures).keys()].map((i) => Array(6).fill(i)).flat();
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(indices), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(this._firstPass.aIndex);
      }
      _makeSecondPassShaderProgram() {
        const vertexShaderProgram = `
            attribute vec2 a_output_position;
            attribute vec2 a_texture_position;

            uniform mat3 u_matrix;

            varying vec2 v_texture_position;

            void main() {
                gl_Position = vec4(u_matrix * vec3(a_output_position, 1), 1);

                v_texture_position = a_texture_position;
            }
            `;
        const fragmentShaderProgram = `
            precision mediump float;

            // our texture
            uniform sampler2D u_image;

            // the texCoords passed in from the vertex shader.
            varying vec2 v_texture_position;

            // the opacity multiplier for the image
            uniform float u_opacity_multiplier;

            void main() {
                gl_FragColor = texture2D(u_image, v_texture_position);
                gl_FragColor *= u_opacity_multiplier;
            }
            `;
        let gl = this._gl;
        let program = this.constructor.initShaderProgram(gl, vertexShaderProgram, fragmentShaderProgram);
        gl.useProgram(program);
        this._secondPass = {
          shaderProgram: program,
          aOutputPosition: gl.getAttribLocation(program, "a_output_position"),
          aTexturePosition: gl.getAttribLocation(program, "a_texture_position"),
          uMatrix: gl.getUniformLocation(program, "u_matrix"),
          uImage: gl.getUniformLocation(program, "u_image"),
          uOpacityMultiplier: gl.getUniformLocation(program, "u_opacity_multiplier"),
          bufferOutputPosition: gl.createBuffer(),
          bufferTexturePosition: gl.createBuffer()
        };
        gl.bindBuffer(gl.ARRAY_BUFFER, this._secondPass.bufferOutputPosition);
        gl.bufferData(gl.ARRAY_BUFFER, this._unitQuad, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(this._secondPass.aOutputPosition);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._secondPass.bufferTexturePosition);
        gl.bufferData(gl.ARRAY_BUFFER, this._unitQuad, gl.DYNAMIC_DRAW);
        gl.enableVertexAttribArray(this._secondPass.aTexturePosition);
        let matrix = $.Mat3.makeScaling(2, 2).multiply($.Mat3.makeTranslation(-0.5, -0.5));
        gl.uniformMatrix3fv(this._secondPass.uMatrix, false, matrix.values);
      }
      _resizeRenderer() {
        let gl = this._gl;
        let w = this._renderingCanvas.width;
        let h = this._renderingCanvas.height;
        gl.viewport(0, 0, w, h);
        gl.deleteTexture(this._renderToTexture);
        this._renderToTexture = gl.createTexture();
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this._renderToTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._textureFilter());
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFrameBuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._renderToTexture, 0);
      }
      _setupCanvases() {
        let _this = this;
        this._outputCanvas = this.canvas;
        this._outputContext = this._outputCanvas.getContext("2d");
        this._renderingCanvas = document.createElement("canvas");
        this._clippingCanvas = document.createElement("canvas");
        this._clippingContext = this._clippingCanvas.getContext("2d");
        this._renderingCanvas.width = this._clippingCanvas.width = this._outputCanvas.width;
        this._renderingCanvas.height = this._clippingCanvas.height = this._outputCanvas.height;
        this._gl = this._renderingCanvas.getContext("webgl");
        this._resizeHandler = function() {
          if (_this._outputCanvas !== _this.viewer.drawer.canvas) {
            _this._outputCanvas.style.width = _this.viewer.drawer.canvas.clientWidth + "px";
            _this._outputCanvas.style.height = _this.viewer.drawer.canvas.clientHeight + "px";
          }
          let viewportSize = _this._calculateCanvasSize();
          if (_this._outputCanvas.width !== viewportSize.x || _this._outputCanvas.height !== viewportSize.y) {
            _this._outputCanvas.width = viewportSize.x;
            _this._outputCanvas.height = viewportSize.y;
          }
          _this._renderingCanvas.style.width = _this._outputCanvas.clientWidth + "px";
          _this._renderingCanvas.style.height = _this._outputCanvas.clientHeight + "px";
          _this._renderingCanvas.width = _this._clippingCanvas.width = _this._outputCanvas.width;
          _this._renderingCanvas.height = _this._clippingCanvas.height = _this._outputCanvas.height;
          _this._resizeRenderer();
        };
        this.viewer.addHandler("resize", this._resizeHandler);
      }
      _makeQuadVertexBuffer(left, right, top, bottom) {
        return new Float32Array([
          left,
          bottom,
          right,
          bottom,
          left,
          top,
          left,
          top,
          right,
          bottom,
          right,
          top
        ]);
      }
      _tileReadyHandler(event) {
        let tile = event.tile;
        let tiledImage = event.tiledImage;
        if (tiledImage.isTainted()) {
          return;
        }
        let tileContext = tile.getCanvasContext();
        let canvas = tileContext && tileContext.canvas;
        if (!canvas || $.isCanvasTainted(canvas)) {
          const wasTainted = tiledImage.isTainted();
          if (!wasTainted) {
            tiledImage.setTainted(true);
            $.console.warn("WebGL cannot be used to draw this TiledImage because it has tainted data. Does crossOriginPolicy need to be set?");
            this._raiseDrawerErrorEvent(tiledImage, "Tainted data cannot be used by the WebGLDrawer. Falling back to CanvasDrawer for this TiledImage.");
          }
          return;
        }
        let textureInfo = this._TextureMap.get(canvas);
        if (!textureInfo) {
          let gl = this._gl;
          let texture = gl.createTexture();
          let position;
          let overlap = tiledImage.source.tileOverlap;
          let sourceWidthFraction, sourceHeightFraction;
          if (tile.sourceBounds) {
            sourceWidthFraction = Math.min(tile.sourceBounds.width, canvas.width) / canvas.width;
            sourceHeightFraction = Math.min(tile.sourceBounds.height, canvas.height) / canvas.height;
          } else {
            sourceWidthFraction = 1;
            sourceHeightFraction = 1;
          }
          if (overlap > 0) {
            let overlapFraction = this._calculateOverlapFraction(tile, tiledImage);
            let left = (tile.x === 0 ? 0 : overlapFraction.x) * sourceWidthFraction;
            let top = (tile.y === 0 ? 0 : overlapFraction.y) * sourceHeightFraction;
            let right = (tile.isRightMost ? 1 : 1 - overlapFraction.x) * sourceWidthFraction;
            let bottom = (tile.isBottomMost ? 1 : 1 - overlapFraction.y) * sourceHeightFraction;
            position = this._makeQuadVertexBuffer(left, right, top, bottom);
          } else if (sourceWidthFraction === 1 && sourceHeightFraction === 1) {
            position = this._unitQuad;
          } else {
            position = this._makeQuadVertexBuffer(0, sourceWidthFraction, 0, sourceHeightFraction);
          }
          let textureInfo2 = {
            texture,
            position
          };
          this._TextureMap.set(canvas, textureInfo2);
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._textureFilter());
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this._textureFilter());
          this._uploadImageData(tileContext);
        }
      }
      _calculateOverlapFraction(tile, tiledImage) {
        let overlap = tiledImage.source.tileOverlap;
        let nativeWidth = tile.sourceBounds.width;
        let nativeHeight = tile.sourceBounds.height;
        let overlapWidth = (tile.x === 0 ? 0 : overlap) + (tile.isRightMost ? 0 : overlap);
        let overlapHeight = (tile.y === 0 ? 0 : overlap) + (tile.isBottomMost ? 0 : overlap);
        let widthOverlapFraction = overlap / (nativeWidth + overlapWidth);
        let heightOverlapFraction = overlap / (nativeHeight + overlapHeight);
        return {
          x: widthOverlapFraction,
          y: heightOverlapFraction
        };
      }
      _unloadTextures() {
        let canvases = Array.from(this._TextureMap.keys());
        canvases.forEach((canvas) => {
          this._cleanupImageData(canvas);
        });
      }
      _uploadImageData(tileContext) {
        let gl = this._gl;
        let canvas = tileContext.canvas;
        try {
          if (!canvas) {
            throw "Tile context does not have a canvas", tileContext;
          }
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
        } catch (e) {
          $.console.error("Error uploading image data to WebGL", e);
        }
      }
      _imageUnloadedHandler(event) {
        let canvas = event.context2D.canvas;
        this._cleanupImageData(canvas);
      }
      _cleanupImageData(tileCanvas) {
        let textureInfo = this._TextureMap.get(tileCanvas);
        this._TextureMap.delete(tileCanvas);
        if (textureInfo) {
          this._gl.deleteTexture(textureInfo.texture);
        }
      }
      _setClip() {}
      _renderToClippingCanvas(item) {
        this._clippingContext.clearRect(0, 0, this._clippingCanvas.width, this._clippingCanvas.height);
        this._clippingContext.save();
        if (this.viewer.viewport.getFlip()) {
          const point = new $.Point(this.canvas.width / 2, this.canvas.height / 2);
          this._clippingContext.translate(point.x, 0);
          this._clippingContext.scale(-1, 1);
          this._clippingContext.translate(-point.x, 0);
        }
        if (item._clip) {
          const polygon = [
            { x: item._clip.x, y: item._clip.y },
            { x: item._clip.x + item._clip.width, y: item._clip.y },
            { x: item._clip.x + item._clip.width, y: item._clip.y + item._clip.height },
            { x: item._clip.x, y: item._clip.y + item._clip.height }
          ];
          let clipPoints = polygon.map((coord) => {
            let point = item.imageToViewportCoordinates(coord.x, coord.y, true).rotate(this.viewer.viewport.getRotation(true), this.viewer.viewport.getCenter(true));
            let clipPoint = this.viewportCoordToDrawerCoord(point);
            return clipPoint;
          });
          this._clippingContext.beginPath();
          clipPoints.forEach((coord, i) => {
            this._clippingContext[i === 0 ? "moveTo" : "lineTo"](coord.x, coord.y);
          });
          this._clippingContext.clip();
          this._setClip();
        }
        if (item._croppingPolygons) {
          let polygons = item._croppingPolygons.map((polygon) => {
            return polygon.map((coord) => {
              let point = item.imageToViewportCoordinates(coord.x, coord.y, true).rotate(this.viewer.viewport.getRotation(true), this.viewer.viewport.getCenter(true));
              let clipPoint = this.viewportCoordToDrawerCoord(point);
              return clipPoint;
            });
          });
          this._clippingContext.beginPath();
          polygons.forEach((polygon) => {
            polygon.forEach((coord, i) => {
              this._clippingContext[i === 0 ? "moveTo" : "lineTo"](coord.x, coord.y);
            });
          });
          this._clippingContext.clip();
        }
        if (this.viewer.viewport.getFlip()) {
          const point = new $.Point(this.canvas.width / 2, this.canvas.height / 2);
          this._clippingContext.translate(point.x, 0);
          this._clippingContext.scale(-1, 1);
          this._clippingContext.translate(-point.x, 0);
        }
        this._clippingContext.drawImage(this._renderingCanvas, 0, 0);
        this._clippingContext.restore();
      }
      _setRotations(tiledImage) {
        var saveContext = false;
        if (this.viewport.getRotation(true) % 360 !== 0) {
          this._offsetForRotation({
            degrees: this.viewport.getRotation(true),
            saveContext
          });
          saveContext = false;
        }
        if (tiledImage.getRotation(true) % 360 !== 0) {
          this._offsetForRotation({
            degrees: tiledImage.getRotation(true),
            point: this.viewport.pixelFromPointNoRotate(tiledImage._getRotationPoint(true), true),
            saveContext
          });
        }
      }
      _offsetForRotation(options) {
        var point = options.point ? options.point.times($.pixelDensityRatio) : this._getCanvasCenter();
        var context = this._outputContext;
        context.save();
        context.translate(point.x, point.y);
        context.rotate(Math.PI / 180 * options.degrees);
        context.translate(-point.x, -point.y);
      }
      _flip(options) {
        options = options || {};
        var point = options.point ? options.point.times($.pixelDensityRatio) : this._getCanvasCenter();
        var context = this._outputContext;
        context.translate(point.x, 0);
        context.scale(-1, 1);
        context.translate(-point.x, 0);
      }
      _drawDebugInfo(tilesToDraw, tiledImage, flipped) {
        for (var i = tilesToDraw.length - 1;i >= 0; i--) {
          var tile = tilesToDraw[i].tile;
          try {
            this._drawDebugInfoOnTile(tile, tilesToDraw.length, i, tiledImage, flipped);
          } catch (e) {
            $.console.error(e);
          }
        }
      }
      _drawDebugInfoOnTile(tile, count, i, tiledImage, flipped) {
        var colorIndex = this.viewer.world.getIndexOfItem(tiledImage) % this.debugGridColor.length;
        var context = this.context;
        context.save();
        context.lineWidth = 2 * $.pixelDensityRatio;
        context.font = "small-caps bold " + 13 * $.pixelDensityRatio + "px arial";
        context.strokeStyle = this.debugGridColor[colorIndex];
        context.fillStyle = this.debugGridColor[colorIndex];
        this._setRotations(tiledImage);
        if (flipped) {
          this._flip({ point: tile.position.plus(tile.size.divide(2)) });
        }
        context.strokeRect(tile.position.x * $.pixelDensityRatio, tile.position.y * $.pixelDensityRatio, tile.size.x * $.pixelDensityRatio, tile.size.y * $.pixelDensityRatio);
        var tileCenterX = (tile.position.x + tile.size.x / 2) * $.pixelDensityRatio;
        var tileCenterY = (tile.position.y + tile.size.y / 2) * $.pixelDensityRatio;
        context.translate(tileCenterX, tileCenterY);
        const angleInDegrees = this.viewport.getRotation(true);
        context.rotate(Math.PI / 180 * -angleInDegrees);
        context.translate(-tileCenterX, -tileCenterY);
        if (tile.x === 0 && tile.y === 0) {
          context.fillText("Zoom: " + this.viewport.getZoom(), tile.position.x * $.pixelDensityRatio, (tile.position.y - 30) * $.pixelDensityRatio);
          context.fillText("Pan: " + this.viewport.getBounds().toString(), tile.position.x * $.pixelDensityRatio, (tile.position.y - 20) * $.pixelDensityRatio);
        }
        context.fillText("Level: " + tile.level, (tile.position.x + 10) * $.pixelDensityRatio, (tile.position.y + 20) * $.pixelDensityRatio);
        context.fillText("Column: " + tile.x, (tile.position.x + 10) * $.pixelDensityRatio, (tile.position.y + 30) * $.pixelDensityRatio);
        context.fillText("Row: " + tile.y, (tile.position.x + 10) * $.pixelDensityRatio, (tile.position.y + 40) * $.pixelDensityRatio);
        context.fillText("Order: " + i + " of " + count, (tile.position.x + 10) * $.pixelDensityRatio, (tile.position.y + 50) * $.pixelDensityRatio);
        context.fillText("Size: " + tile.size.toString(), (tile.position.x + 10) * $.pixelDensityRatio, (tile.position.y + 60) * $.pixelDensityRatio);
        context.fillText("Position: " + tile.position.toString(), (tile.position.x + 10) * $.pixelDensityRatio, (tile.position.y + 70) * $.pixelDensityRatio);
        if (this.viewport.getRotation(true) % 360 !== 0) {
          this._restoreRotationChanges();
        }
        if (tiledImage.getRotation(true) % 360 !== 0) {
          this._restoreRotationChanges();
        }
        context.restore();
      }
      _drawPlaceholder(tiledImage) {
        const bounds = tiledImage.getBounds(true);
        const rect = this.viewportToDrawerRectangle(tiledImage.getBounds(true));
        const context = this._outputContext;
        let fillStyle;
        if (typeof tiledImage.placeholderFillStyle === "function") {
          fillStyle = tiledImage.placeholderFillStyle(tiledImage, context);
        } else {
          fillStyle = tiledImage.placeholderFillStyle;
        }
        this._offsetForRotation({ degrees: this.viewer.viewport.getRotation(true) });
        context.fillStyle = fillStyle;
        context.translate(rect.x, rect.y);
        context.rotate(Math.PI / 180 * bounds.degrees);
        context.translate(-rect.x, -rect.y);
        context.fillRect(rect.x, rect.y, rect.width, rect.height);
        this._restoreRotationChanges();
      }
      _getCanvasCenter() {
        return new $.Point(this.canvas.width / 2, this.canvas.height / 2);
      }
      _restoreRotationChanges() {
        var context = this._outputContext;
        context.restore();
      }
      static initShaderProgram(gl, vsSource, fsSource) {
        function loadShader(gl2, type, source) {
          const shader = gl2.createShader(type);
          gl2.shaderSource(shader, source);
          gl2.compileShader(shader);
          if (!gl2.getShaderParameter(shader, gl2.COMPILE_STATUS)) {
            $.console.error(`An error occurred compiling the shaders: ${gl2.getShaderInfoLog(shader)}`);
            gl2.deleteShader(shader);
            return null;
          }
          return shader;
        }
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
          $.console.error(`Unable to initialize the shader program: ${gl.getProgramInfoLog(shaderProgram)}`);
          return null;
        }
        return shaderProgram;
      }
    };
  })(OpenSeadragon);
  (function($) {
    $.Viewport = function(options) {
      var args = arguments;
      if (args.length && args[0] instanceof $.Point) {
        options = {
          containerSize: args[0],
          contentSize: args[1],
          config: args[2]
        };
      }
      if (options.config) {
        $.extend(true, options, options.config);
        delete options.config;
      }
      this._margins = $.extend({
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      }, options.margins || {});
      delete options.margins;
      options.initialDegrees = options.degrees;
      delete options.degrees;
      $.extend(true, this, {
        containerSize: null,
        contentSize: null,
        zoomPoint: null,
        rotationPivot: null,
        viewer: null,
        springStiffness: $.DEFAULT_SETTINGS.springStiffness,
        animationTime: $.DEFAULT_SETTINGS.animationTime,
        minZoomImageRatio: $.DEFAULT_SETTINGS.minZoomImageRatio,
        maxZoomPixelRatio: $.DEFAULT_SETTINGS.maxZoomPixelRatio,
        visibilityRatio: $.DEFAULT_SETTINGS.visibilityRatio,
        wrapHorizontal: $.DEFAULT_SETTINGS.wrapHorizontal,
        wrapVertical: $.DEFAULT_SETTINGS.wrapVertical,
        defaultZoomLevel: $.DEFAULT_SETTINGS.defaultZoomLevel,
        minZoomLevel: $.DEFAULT_SETTINGS.minZoomLevel,
        maxZoomLevel: $.DEFAULT_SETTINGS.maxZoomLevel,
        initialDegrees: $.DEFAULT_SETTINGS.degrees,
        flipped: $.DEFAULT_SETTINGS.flipped,
        homeFillsViewer: $.DEFAULT_SETTINGS.homeFillsViewer,
        silenceMultiImageWarnings: $.DEFAULT_SETTINGS.silenceMultiImageWarnings
      }, options);
      this._updateContainerInnerSize();
      this.centerSpringX = new $.Spring({
        initial: 0,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime
      });
      this.centerSpringY = new $.Spring({
        initial: 0,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime
      });
      this.zoomSpring = new $.Spring({
        exponential: true,
        initial: 1,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime
      });
      this.degreesSpring = new $.Spring({
        initial: options.initialDegrees,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime
      });
      this._oldCenterX = this.centerSpringX.current.value;
      this._oldCenterY = this.centerSpringY.current.value;
      this._oldZoom = this.zoomSpring.current.value;
      this._oldDegrees = this.degreesSpring.current.value;
      this._setContentBounds(new $.Rect(0, 0, 1, 1), 1);
      this.goHome(true);
      this.update();
    };
    $.Viewport.prototype = {
      get degrees() {
        $.console.warn("Accessing [Viewport.degrees] is deprecated. Use viewport.getRotation instead.");
        return this.getRotation();
      },
      set degrees(degrees) {
        $.console.warn("Setting [Viewport.degrees] is deprecated. Use viewport.rotateTo, viewport.rotateBy, or viewport.setRotation instead.");
        this.rotateTo(degrees);
      },
      resetContentSize: function(contentSize) {
        $.console.assert(contentSize, "[Viewport.resetContentSize] contentSize is required");
        $.console.assert(contentSize instanceof $.Point, "[Viewport.resetContentSize] contentSize must be an OpenSeadragon.Point");
        $.console.assert(contentSize.x > 0, "[Viewport.resetContentSize] contentSize.x must be greater than 0");
        $.console.assert(contentSize.y > 0, "[Viewport.resetContentSize] contentSize.y must be greater than 0");
        this._setContentBounds(new $.Rect(0, 0, 1, contentSize.y / contentSize.x), contentSize.x);
        return this;
      },
      setHomeBounds: function(bounds, contentFactor) {
        $.console.error("[Viewport.setHomeBounds] this function is deprecated; The content bounds should not be set manually.");
        this._setContentBounds(bounds, contentFactor);
      },
      _setContentBounds: function(bounds, contentFactor) {
        $.console.assert(bounds, "[Viewport._setContentBounds] bounds is required");
        $.console.assert(bounds instanceof $.Rect, "[Viewport._setContentBounds] bounds must be an OpenSeadragon.Rect");
        $.console.assert(bounds.width > 0, "[Viewport._setContentBounds] bounds.width must be greater than 0");
        $.console.assert(bounds.height > 0, "[Viewport._setContentBounds] bounds.height must be greater than 0");
        this._contentBoundsNoRotate = bounds.clone();
        this._contentSizeNoRotate = this._contentBoundsNoRotate.getSize().times(contentFactor);
        this._contentBounds = bounds.rotate(this.getRotation()).getBoundingBox();
        this._contentSize = this._contentBounds.getSize().times(contentFactor);
        this._contentAspectRatio = this._contentSize.x / this._contentSize.y;
        if (this.viewer) {
          this.viewer.raiseEvent("reset-size", {
            contentSize: this._contentSizeNoRotate.clone(),
            contentFactor,
            homeBounds: this._contentBoundsNoRotate.clone(),
            contentBounds: this._contentBounds.clone()
          });
        }
      },
      getHomeZoom: function() {
        if (this.defaultZoomLevel) {
          return this.defaultZoomLevel;
        }
        var aspectFactor = this._contentAspectRatio / this.getAspectRatio();
        var output;
        if (this.homeFillsViewer) {
          output = aspectFactor >= 1 ? aspectFactor : 1;
        } else {
          output = aspectFactor >= 1 ? 1 : aspectFactor;
        }
        return output / this._contentBounds.width;
      },
      getHomeBounds: function() {
        return this.getHomeBoundsNoRotate().rotate(-this.getRotation());
      },
      getHomeBoundsNoRotate: function() {
        var center = this._contentBounds.getCenter();
        var width = 1 / this.getHomeZoom();
        var height = width / this.getAspectRatio();
        return new $.Rect(center.x - width / 2, center.y - height / 2, width, height);
      },
      goHome: function(immediately) {
        if (this.viewer) {
          this.viewer.raiseEvent("home", {
            immediately
          });
        }
        return this.fitBounds(this.getHomeBounds(), immediately);
      },
      getMinZoom: function() {
        var homeZoom = this.getHomeZoom(), zoom = this.minZoomLevel ? this.minZoomLevel : this.minZoomImageRatio * homeZoom;
        return zoom;
      },
      getMaxZoom: function() {
        var zoom = this.maxZoomLevel;
        if (!zoom) {
          zoom = this._contentSize.x * this.maxZoomPixelRatio / this._containerInnerSize.x;
          zoom /= this._contentBounds.width;
        }
        return Math.max(zoom, this.getHomeZoom());
      },
      getAspectRatio: function() {
        return this._containerInnerSize.x / this._containerInnerSize.y;
      },
      getContainerSize: function() {
        return new $.Point(this.containerSize.x, this.containerSize.y);
      },
      getMargins: function() {
        return $.extend({}, this._margins);
      },
      setMargins: function(margins) {
        $.console.assert($.type(margins) === "object", "[Viewport.setMargins] margins must be an object");
        this._margins = $.extend({
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        }, margins);
        this._updateContainerInnerSize();
        if (this.viewer) {
          this.viewer.forceRedraw();
        }
      },
      getBounds: function(current) {
        return this.getBoundsNoRotate(current).rotate(-this.getRotation(current));
      },
      getBoundsNoRotate: function(current) {
        var center = this.getCenter(current);
        var width = 1 / this.getZoom(current);
        var height = width / this.getAspectRatio();
        return new $.Rect(center.x - width / 2, center.y - height / 2, width, height);
      },
      getBoundsWithMargins: function(current) {
        return this.getBoundsNoRotateWithMargins(current).rotate(-this.getRotation(current), this.getCenter(current));
      },
      getBoundsNoRotateWithMargins: function(current) {
        var bounds = this.getBoundsNoRotate(current);
        var factor = this._containerInnerSize.x * this.getZoom(current);
        bounds.x -= this._margins.left / factor;
        bounds.y -= this._margins.top / factor;
        bounds.width += (this._margins.left + this._margins.right) / factor;
        bounds.height += (this._margins.top + this._margins.bottom) / factor;
        return bounds;
      },
      getCenter: function(current) {
        var centerCurrent = new $.Point(this.centerSpringX.current.value, this.centerSpringY.current.value), centerTarget = new $.Point(this.centerSpringX.target.value, this.centerSpringY.target.value), oldZoomPixel, zoom, width, height, bounds, newZoomPixel, deltaZoomPixels, deltaZoomPoints;
        if (current) {
          return centerCurrent;
        } else if (!this.zoomPoint) {
          return centerTarget;
        }
        oldZoomPixel = this.pixelFromPoint(this.zoomPoint, true);
        zoom = this.getZoom();
        width = 1 / zoom;
        height = width / this.getAspectRatio();
        bounds = new $.Rect(centerCurrent.x - width / 2, centerCurrent.y - height / 2, width, height);
        newZoomPixel = this._pixelFromPoint(this.zoomPoint, bounds);
        deltaZoomPixels = newZoomPixel.minus(oldZoomPixel).rotate(-this.getRotation(true));
        deltaZoomPoints = deltaZoomPixels.divide(this._containerInnerSize.x * zoom);
        return centerTarget.plus(deltaZoomPoints);
      },
      getZoom: function(current) {
        if (current) {
          return this.zoomSpring.current.value;
        } else {
          return this.zoomSpring.target.value;
        }
      },
      _applyZoomConstraints: function(zoom) {
        return Math.max(Math.min(zoom, this.getMaxZoom()), this.getMinZoom());
      },
      _applyBoundaryConstraints: function(bounds) {
        var newBounds = this.viewportToViewerElementRectangle(bounds).getBoundingBox();
        var cb = this.viewportToViewerElementRectangle(this._contentBoundsNoRotate).getBoundingBox();
        var xConstrained = false;
        var yConstrained = false;
        if (this.wrapHorizontal) {} else {
          var boundsRight = newBounds.x + newBounds.width;
          var contentRight = cb.x + cb.width;
          var horizontalThreshold, leftDx, rightDx;
          if (newBounds.width > cb.width) {
            horizontalThreshold = this.visibilityRatio * cb.width;
          } else {
            horizontalThreshold = this.visibilityRatio * newBounds.width;
          }
          leftDx = cb.x - boundsRight + horizontalThreshold;
          rightDx = contentRight - newBounds.x - horizontalThreshold;
          if (horizontalThreshold > cb.width) {
            newBounds.x += (leftDx + rightDx) / 2;
            xConstrained = true;
          } else if (rightDx < 0) {
            newBounds.x += rightDx;
            xConstrained = true;
          } else if (leftDx > 0) {
            newBounds.x += leftDx;
            xConstrained = true;
          }
        }
        if (this.wrapVertical) {} else {
          var boundsBottom = newBounds.y + newBounds.height;
          var contentBottom = cb.y + cb.height;
          var verticalThreshold, topDy, bottomDy;
          if (newBounds.height > cb.height) {
            verticalThreshold = this.visibilityRatio * cb.height;
          } else {
            verticalThreshold = this.visibilityRatio * newBounds.height;
          }
          topDy = cb.y - boundsBottom + verticalThreshold;
          bottomDy = contentBottom - newBounds.y - verticalThreshold;
          if (verticalThreshold > cb.height) {
            newBounds.y += (topDy + bottomDy) / 2;
            yConstrained = true;
          } else if (bottomDy < 0) {
            newBounds.y += bottomDy;
            yConstrained = true;
          } else if (topDy > 0) {
            newBounds.y += topDy;
            yConstrained = true;
          }
        }
        var constraintApplied = xConstrained || yConstrained;
        var newViewportBounds = constraintApplied ? this.viewerElementToViewportRectangle(newBounds) : bounds.clone();
        newViewportBounds.xConstrained = xConstrained;
        newViewportBounds.yConstrained = yConstrained;
        newViewportBounds.constraintApplied = constraintApplied;
        return newViewportBounds;
      },
      _raiseConstraintsEvent: function(immediately) {
        if (this.viewer) {
          this.viewer.raiseEvent("constrain", {
            immediately
          });
        }
      },
      applyConstraints: function(immediately) {
        var actualZoom = this.getZoom();
        var constrainedZoom = this._applyZoomConstraints(actualZoom);
        if (actualZoom !== constrainedZoom) {
          this.zoomTo(constrainedZoom, this.zoomPoint, immediately);
        }
        var constrainedBounds = this.getConstrainedBounds(false);
        if (constrainedBounds.constraintApplied) {
          this.fitBounds(constrainedBounds, immediately);
          this._raiseConstraintsEvent(immediately);
        }
        return this;
      },
      ensureVisible: function(immediately) {
        return this.applyConstraints(immediately);
      },
      _fitBounds: function(bounds, options) {
        options = options || {};
        var immediately = options.immediately || false;
        var constraints = options.constraints || false;
        var aspect = this.getAspectRatio();
        var center = bounds.getCenter();
        var newBounds = new $.Rect(bounds.x, bounds.y, bounds.width, bounds.height, bounds.degrees + this.getRotation()).getBoundingBox();
        if (newBounds.getAspectRatio() >= aspect) {
          newBounds.height = newBounds.width / aspect;
        } else {
          newBounds.width = newBounds.height * aspect;
        }
        newBounds.x = center.x - newBounds.width / 2;
        newBounds.y = center.y - newBounds.height / 2;
        var newZoom = 1 / newBounds.width;
        if (immediately) {
          this.panTo(center, true);
          this.zoomTo(newZoom, null, true);
          if (constraints) {
            this.applyConstraints(true);
          }
          return this;
        }
        var currentCenter = this.getCenter(true);
        var currentZoom = this.getZoom(true);
        this.panTo(currentCenter, true);
        this.zoomTo(currentZoom, null, true);
        var oldBounds = this.getBounds();
        var oldZoom = this.getZoom();
        if (oldZoom === 0 || Math.abs(newZoom / oldZoom - 1) < 0.00000001) {
          this.zoomTo(newZoom, null, true);
          this.panTo(center, immediately);
          if (constraints) {
            this.applyConstraints(false);
          }
          return this;
        }
        if (constraints) {
          this.panTo(center, false);
          newZoom = this._applyZoomConstraints(newZoom);
          this.zoomTo(newZoom, null, false);
          var constrainedBounds = this.getConstrainedBounds();
          this.panTo(currentCenter, true);
          this.zoomTo(currentZoom, null, true);
          this.fitBounds(constrainedBounds);
        } else {
          var rotatedNewBounds = newBounds.rotate(-this.getRotation());
          var referencePoint = rotatedNewBounds.getTopLeft().times(newZoom).minus(oldBounds.getTopLeft().times(oldZoom)).divide(newZoom - oldZoom);
          this.zoomTo(newZoom, referencePoint, immediately);
        }
        return this;
      },
      fitBounds: function(bounds, immediately) {
        return this._fitBounds(bounds, {
          immediately,
          constraints: false
        });
      },
      fitBoundsWithConstraints: function(bounds, immediately) {
        return this._fitBounds(bounds, {
          immediately,
          constraints: true
        });
      },
      fitVertically: function(immediately) {
        var box = new $.Rect(this._contentBounds.x + this._contentBounds.width / 2, this._contentBounds.y, 0, this._contentBounds.height);
        return this.fitBounds(box, immediately);
      },
      fitHorizontally: function(immediately) {
        var box = new $.Rect(this._contentBounds.x, this._contentBounds.y + this._contentBounds.height / 2, this._contentBounds.width, 0);
        return this.fitBounds(box, immediately);
      },
      getConstrainedBounds: function(current) {
        var bounds, constrainedBounds;
        bounds = this.getBounds(current);
        constrainedBounds = this._applyBoundaryConstraints(bounds);
        return constrainedBounds;
      },
      panBy: function(delta, immediately) {
        var center = new $.Point(this.centerSpringX.target.value, this.centerSpringY.target.value);
        return this.panTo(center.plus(delta), immediately);
      },
      panTo: function(center, immediately) {
        if (immediately) {
          this.centerSpringX.resetTo(center.x);
          this.centerSpringY.resetTo(center.y);
        } else {
          this.centerSpringX.springTo(center.x);
          this.centerSpringY.springTo(center.y);
        }
        if (this.viewer) {
          this.viewer.raiseEvent("pan", {
            center,
            immediately
          });
        }
        return this;
      },
      zoomBy: function(factor, refPoint, immediately) {
        return this.zoomTo(this.zoomSpring.target.value * factor, refPoint, immediately);
      },
      zoomTo: function(zoom, refPoint, immediately) {
        var _this = this;
        this.zoomPoint = refPoint instanceof $.Point && !isNaN(refPoint.x) && !isNaN(refPoint.y) ? refPoint : null;
        if (immediately) {
          this._adjustCenterSpringsForZoomPoint(function() {
            _this.zoomSpring.resetTo(zoom);
          });
        } else {
          this.zoomSpring.springTo(zoom);
        }
        if (this.viewer) {
          this.viewer.raiseEvent("zoom", {
            zoom,
            refPoint,
            immediately
          });
        }
        return this;
      },
      setRotation: function(degrees, immediately) {
        return this.rotateTo(degrees, null, immediately);
      },
      getRotation: function(current) {
        return current ? this.degreesSpring.current.value : this.degreesSpring.target.value;
      },
      setRotationWithPivot: function(degrees, pivot, immediately) {
        return this.rotateTo(degrees, pivot, immediately);
      },
      rotateTo: function(degrees, pivot, immediately) {
        if (!this.viewer || !this.viewer.drawer.canRotate()) {
          return this;
        }
        if (this.degreesSpring.target.value === degrees && this.degreesSpring.isAtTargetValue()) {
          return this;
        }
        this.rotationPivot = pivot instanceof $.Point && !isNaN(pivot.x) && !isNaN(pivot.y) ? pivot : null;
        if (immediately) {
          if (this.rotationPivot) {
            var changeInDegrees = degrees - this._oldDegrees;
            if (!changeInDegrees) {
              this.rotationPivot = null;
              return this;
            }
            this._rotateAboutPivot(degrees);
          } else {
            this.degreesSpring.resetTo(degrees);
          }
        } else {
          var normalizedFrom = $.positiveModulo(this.degreesSpring.current.value, 360);
          var normalizedTo = $.positiveModulo(degrees, 360);
          var diff = normalizedTo - normalizedFrom;
          if (diff > 180) {
            normalizedTo -= 360;
          } else if (diff < -180) {
            normalizedTo += 360;
          }
          var reverseDiff = normalizedFrom - normalizedTo;
          this.degreesSpring.resetTo(degrees + reverseDiff);
          this.degreesSpring.springTo(degrees);
        }
        this._setContentBounds(this.viewer.world.getHomeBounds(), this.viewer.world.getContentFactor());
        this.viewer.forceRedraw();
        this.viewer.raiseEvent("rotate", { degrees, immediately: !!immediately, pivot: this.rotationPivot || this.getCenter() });
        return this;
      },
      rotateBy: function(degrees, pivot, immediately) {
        return this.rotateTo(this.degreesSpring.target.value + degrees, pivot, immediately);
      },
      resize: function(newContainerSize, maintain) {
        var oldBounds = this.getBoundsNoRotate(), newBounds = oldBounds, widthDeltaFactor;
        this.containerSize.x = newContainerSize.x;
        this.containerSize.y = newContainerSize.y;
        this._updateContainerInnerSize();
        if (maintain) {
          widthDeltaFactor = newContainerSize.x / this.containerSize.x;
          newBounds.width = oldBounds.width * widthDeltaFactor;
          newBounds.height = newBounds.width / this.getAspectRatio();
        }
        if (this.viewer) {
          this.viewer.raiseEvent("resize", {
            newContainerSize,
            maintain
          });
        }
        var output = this.fitBounds(newBounds, true);
        if (this.viewer) {
          this.viewer.raiseEvent("after-resize", {
            newContainerSize,
            maintain
          });
        }
        return output;
      },
      _updateContainerInnerSize: function() {
        this._containerInnerSize = new $.Point(Math.max(1, this.containerSize.x - (this._margins.left + this._margins.right)), Math.max(1, this.containerSize.y - (this._margins.top + this._margins.bottom)));
      },
      update: function() {
        var _this = this;
        this._adjustCenterSpringsForZoomPoint(function() {
          _this.zoomSpring.update();
        });
        if (this.degreesSpring.isAtTargetValue()) {
          this.rotationPivot = null;
        }
        this.centerSpringX.update();
        this.centerSpringY.update();
        if (this.rotationPivot) {
          this._rotateAboutPivot(true);
        } else {
          this.degreesSpring.update();
        }
        var changed = this.centerSpringX.current.value !== this._oldCenterX || this.centerSpringY.current.value !== this._oldCenterY || this.zoomSpring.current.value !== this._oldZoom || this.degreesSpring.current.value !== this._oldDegrees;
        this._oldCenterX = this.centerSpringX.current.value;
        this._oldCenterY = this.centerSpringY.current.value;
        this._oldZoom = this.zoomSpring.current.value;
        this._oldDegrees = this.degreesSpring.current.value;
        var isAnimating = changed || !this.zoomSpring.isAtTargetValue() || !this.centerSpringX.isAtTargetValue() || !this.centerSpringY.isAtTargetValue() || !this.degreesSpring.isAtTargetValue();
        return isAnimating;
      },
      _rotateAboutPivot: function(degreesOrUseSpring) {
        var useSpring = degreesOrUseSpring === true;
        var delta = this.rotationPivot.minus(this.getCenter());
        this.centerSpringX.shiftBy(delta.x);
        this.centerSpringY.shiftBy(delta.y);
        if (useSpring) {
          this.degreesSpring.update();
        } else {
          this.degreesSpring.resetTo(degreesOrUseSpring);
        }
        var changeInDegrees = this.degreesSpring.current.value - this._oldDegrees;
        var rdelta = delta.rotate(changeInDegrees * -1).times(-1);
        this.centerSpringX.shiftBy(rdelta.x);
        this.centerSpringY.shiftBy(rdelta.y);
      },
      _adjustCenterSpringsForZoomPoint: function(zoomSpringHandler) {
        if (this.zoomPoint) {
          var oldZoomPixel = this.pixelFromPoint(this.zoomPoint, true);
          zoomSpringHandler();
          var newZoomPixel = this.pixelFromPoint(this.zoomPoint, true);
          var deltaZoomPixels = newZoomPixel.minus(oldZoomPixel);
          var deltaZoomPoints = this.deltaPointsFromPixels(deltaZoomPixels, true);
          this.centerSpringX.shiftBy(deltaZoomPoints.x);
          this.centerSpringY.shiftBy(deltaZoomPoints.y);
          if (this.zoomSpring.isAtTargetValue()) {
            this.zoomPoint = null;
          }
        } else {
          zoomSpringHandler();
        }
      },
      deltaPixelsFromPointsNoRotate: function(deltaPoints, current) {
        return deltaPoints.times(this._containerInnerSize.x * this.getZoom(current));
      },
      deltaPixelsFromPoints: function(deltaPoints, current) {
        return this.deltaPixelsFromPointsNoRotate(deltaPoints.rotate(this.getRotation(current)), current);
      },
      deltaPointsFromPixelsNoRotate: function(deltaPixels, current) {
        return deltaPixels.divide(this._containerInnerSize.x * this.getZoom(current));
      },
      deltaPointsFromPixels: function(deltaPixels, current) {
        return this.deltaPointsFromPixelsNoRotate(deltaPixels, current).rotate(-this.getRotation(current));
      },
      pixelFromPointNoRotate: function(point, current) {
        return this._pixelFromPointNoRotate(point, this.getBoundsNoRotate(current));
      },
      pixelFromPoint: function(point, current) {
        return this._pixelFromPoint(point, this.getBoundsNoRotate(current));
      },
      _pixelFromPointNoRotate: function(point, bounds) {
        return point.minus(bounds.getTopLeft()).times(this._containerInnerSize.x / bounds.width).plus(new $.Point(this._margins.left, this._margins.top));
      },
      _pixelFromPoint: function(point, bounds) {
        return this._pixelFromPointNoRotate(point.rotate(this.getRotation(true), this.getCenter(true)), bounds);
      },
      pointFromPixelNoRotate: function(pixel, current) {
        var bounds = this.getBoundsNoRotate(current);
        return pixel.minus(new $.Point(this._margins.left, this._margins.top)).divide(this._containerInnerSize.x / bounds.width).plus(bounds.getTopLeft());
      },
      pointFromPixel: function(pixel, current) {
        return this.pointFromPixelNoRotate(pixel, current).rotate(-this.getRotation(current), this.getCenter(current));
      },
      _viewportToImageDelta: function(viewerX, viewerY) {
        var scale = this._contentBoundsNoRotate.width;
        return new $.Point(viewerX * this._contentSizeNoRotate.x / scale, viewerY * this._contentSizeNoRotate.x / scale);
      },
      viewportToImageCoordinates: function(viewerX, viewerY) {
        if (viewerX instanceof $.Point) {
          return this.viewportToImageCoordinates(viewerX.x, viewerX.y);
        }
        if (this.viewer) {
          var count = this.viewer.world.getItemCount();
          if (count > 1) {
            if (!this.silenceMultiImageWarnings) {
              $.console.error("[Viewport.viewportToImageCoordinates] is not accurate " + "with multi-image; use TiledImage.viewportToImageCoordinates instead.");
            }
          } else if (count === 1) {
            var item = this.viewer.world.getItemAt(0);
            return item.viewportToImageCoordinates(viewerX, viewerY, true);
          }
        }
        return this._viewportToImageDelta(viewerX - this._contentBoundsNoRotate.x, viewerY - this._contentBoundsNoRotate.y);
      },
      _imageToViewportDelta: function(imageX, imageY) {
        var scale = this._contentBoundsNoRotate.width;
        return new $.Point(imageX / this._contentSizeNoRotate.x * scale, imageY / this._contentSizeNoRotate.x * scale);
      },
      imageToViewportCoordinates: function(imageX, imageY) {
        if (imageX instanceof $.Point) {
          return this.imageToViewportCoordinates(imageX.x, imageX.y);
        }
        if (this.viewer) {
          var count = this.viewer.world.getItemCount();
          if (count > 1) {
            if (!this.silenceMultiImageWarnings) {
              $.console.error("[Viewport.imageToViewportCoordinates] is not accurate " + "with multi-image; use TiledImage.imageToViewportCoordinates instead.");
            }
          } else if (count === 1) {
            var item = this.viewer.world.getItemAt(0);
            return item.imageToViewportCoordinates(imageX, imageY, true);
          }
        }
        var point = this._imageToViewportDelta(imageX, imageY);
        point.x += this._contentBoundsNoRotate.x;
        point.y += this._contentBoundsNoRotate.y;
        return point;
      },
      imageToViewportRectangle: function(imageX, imageY, pixelWidth, pixelHeight) {
        var rect = imageX;
        if (!(rect instanceof $.Rect)) {
          rect = new $.Rect(imageX, imageY, pixelWidth, pixelHeight);
        }
        if (this.viewer) {
          var count = this.viewer.world.getItemCount();
          if (count > 1) {
            if (!this.silenceMultiImageWarnings) {
              $.console.error("[Viewport.imageToViewportRectangle] is not accurate " + "with multi-image; use TiledImage.imageToViewportRectangle instead.");
            }
          } else if (count === 1) {
            var item = this.viewer.world.getItemAt(0);
            return item.imageToViewportRectangle(imageX, imageY, pixelWidth, pixelHeight, true);
          }
        }
        var coordA = this.imageToViewportCoordinates(rect.x, rect.y);
        var coordB = this._imageToViewportDelta(rect.width, rect.height);
        return new $.Rect(coordA.x, coordA.y, coordB.x, coordB.y, rect.degrees);
      },
      viewportToImageRectangle: function(viewerX, viewerY, pointWidth, pointHeight) {
        var rect = viewerX;
        if (!(rect instanceof $.Rect)) {
          rect = new $.Rect(viewerX, viewerY, pointWidth, pointHeight);
        }
        if (this.viewer) {
          var count = this.viewer.world.getItemCount();
          if (count > 1) {
            if (!this.silenceMultiImageWarnings) {
              $.console.error("[Viewport.viewportToImageRectangle] is not accurate " + "with multi-image; use TiledImage.viewportToImageRectangle instead.");
            }
          } else if (count === 1) {
            var item = this.viewer.world.getItemAt(0);
            return item.viewportToImageRectangle(viewerX, viewerY, pointWidth, pointHeight, true);
          }
        }
        var coordA = this.viewportToImageCoordinates(rect.x, rect.y);
        var coordB = this._viewportToImageDelta(rect.width, rect.height);
        return new $.Rect(coordA.x, coordA.y, coordB.x, coordB.y, rect.degrees);
      },
      viewerElementToImageCoordinates: function(pixel) {
        var point = this.pointFromPixel(pixel, true);
        return this.viewportToImageCoordinates(point);
      },
      imageToViewerElementCoordinates: function(pixel) {
        var point = this.imageToViewportCoordinates(pixel);
        return this.pixelFromPoint(point, true);
      },
      windowToImageCoordinates: function(pixel) {
        $.console.assert(this.viewer, "[Viewport.windowToImageCoordinates] the viewport must have a viewer.");
        var viewerCoordinates = pixel.minus($.getElementPosition(this.viewer.element));
        return this.viewerElementToImageCoordinates(viewerCoordinates);
      },
      imageToWindowCoordinates: function(pixel) {
        $.console.assert(this.viewer, "[Viewport.imageToWindowCoordinates] the viewport must have a viewer.");
        var viewerCoordinates = this.imageToViewerElementCoordinates(pixel);
        return viewerCoordinates.plus($.getElementPosition(this.viewer.element));
      },
      viewerElementToViewportCoordinates: function(pixel) {
        return this.pointFromPixel(pixel, true);
      },
      viewportToViewerElementCoordinates: function(point) {
        return this.pixelFromPoint(point, true);
      },
      viewerElementToViewportRectangle: function(rectangle) {
        return $.Rect.fromSummits(this.pointFromPixel(rectangle.getTopLeft(), true), this.pointFromPixel(rectangle.getTopRight(), true), this.pointFromPixel(rectangle.getBottomLeft(), true));
      },
      viewportToViewerElementRectangle: function(rectangle) {
        return $.Rect.fromSummits(this.pixelFromPoint(rectangle.getTopLeft(), true), this.pixelFromPoint(rectangle.getTopRight(), true), this.pixelFromPoint(rectangle.getBottomLeft(), true));
      },
      windowToViewportCoordinates: function(pixel) {
        $.console.assert(this.viewer, "[Viewport.windowToViewportCoordinates] the viewport must have a viewer.");
        var viewerCoordinates = pixel.minus($.getElementPosition(this.viewer.element));
        return this.viewerElementToViewportCoordinates(viewerCoordinates);
      },
      viewportToWindowCoordinates: function(point) {
        $.console.assert(this.viewer, "[Viewport.viewportToWindowCoordinates] the viewport must have a viewer.");
        var viewerCoordinates = this.viewportToViewerElementCoordinates(point);
        return viewerCoordinates.plus($.getElementPosition(this.viewer.element));
      },
      viewportToImageZoom: function(viewportZoom) {
        if (this.viewer) {
          var count = this.viewer.world.getItemCount();
          if (count > 1) {
            if (!this.silenceMultiImageWarnings) {
              $.console.error("[Viewport.viewportToImageZoom] is not " + "accurate with multi-image.");
            }
          } else if (count === 1) {
            var item = this.viewer.world.getItemAt(0);
            return item.viewportToImageZoom(viewportZoom);
          }
        }
        var imageWidth = this._contentSizeNoRotate.x;
        var containerWidth = this._containerInnerSize.x;
        var scale = this._contentBoundsNoRotate.width;
        var viewportToImageZoomRatio = containerWidth / imageWidth * scale;
        return viewportZoom * viewportToImageZoomRatio;
      },
      imageToViewportZoom: function(imageZoom) {
        if (this.viewer) {
          var count = this.viewer.world.getItemCount();
          if (count > 1) {
            if (!this.silenceMultiImageWarnings) {
              $.console.error("[Viewport.imageToViewportZoom] is not accurate " + "with multi-image. Instead, use [TiledImage.imageToViewportZoom] for the specific image of interest");
            }
          } else if (count === 1) {
            var item = this.viewer.world.getItemAt(0);
            return item.imageToViewportZoom(imageZoom);
          }
        }
        var imageWidth = this._contentSizeNoRotate.x;
        var containerWidth = this._containerInnerSize.x;
        var scale = this._contentBoundsNoRotate.width;
        var viewportToImageZoomRatio = imageWidth / containerWidth / scale;
        return imageZoom * viewportToImageZoomRatio;
      },
      toggleFlip: function() {
        this.setFlip(!this.getFlip());
        return this;
      },
      getFlip: function() {
        return this.flipped;
      },
      setFlip: function(state) {
        if (this.flipped === state) {
          return this;
        }
        this.flipped = state;
        if (this.viewer.navigator) {
          this.viewer.navigator.setFlip(this.getFlip());
        }
        this.viewer.forceRedraw();
        this.viewer.raiseEvent("flip", { flipped: state });
        return this;
      },
      getMaxZoomPixelRatio: function() {
        return this.maxZoomPixelRatio;
      },
      setMaxZoomPixelRatio: function(ratio, applyConstraints = true, immediately = false) {
        $.console.assert(!isNaN(ratio), "[Viewport.setMaxZoomPixelRatio] ratio must be a number");
        if (isNaN(ratio)) {
          return;
        }
        this.maxZoomPixelRatio = ratio;
        if (applyConstraints) {
          if (this.getZoom() > this.getMaxZoom()) {
            this.applyConstraints(immediately);
          }
        }
      }
    };
  })(OpenSeadragon);
  (function($) {
    $.TiledImage = function(options) {
      this._initialized = false;
      $.console.assert(options.tileCache, "[TiledImage] options.tileCache is required");
      $.console.assert(options.drawer, "[TiledImage] options.drawer is required");
      $.console.assert(options.viewer, "[TiledImage] options.viewer is required");
      $.console.assert(options.imageLoader, "[TiledImage] options.imageLoader is required");
      $.console.assert(options.source, "[TiledImage] options.source is required");
      $.console.assert(!options.clip || options.clip instanceof $.Rect, "[TiledImage] options.clip must be an OpenSeadragon.Rect if present");
      $.EventSource.call(this);
      this._tileCache = options.tileCache;
      delete options.tileCache;
      this._drawer = options.drawer;
      delete options.drawer;
      this._imageLoader = options.imageLoader;
      delete options.imageLoader;
      if (options.clip instanceof $.Rect) {
        this._clip = options.clip.clone();
      }
      delete options.clip;
      var x = options.x || 0;
      delete options.x;
      var y = options.y || 0;
      delete options.y;
      this.normHeight = options.source.dimensions.y / options.source.dimensions.x;
      this.contentAspectX = options.source.dimensions.x / options.source.dimensions.y;
      var scale = 1;
      if (options.width) {
        scale = options.width;
        delete options.width;
        if (options.height) {
          $.console.error("specifying both width and height to a tiledImage is not supported");
          delete options.height;
        }
      } else if (options.height) {
        scale = options.height / this.normHeight;
        delete options.height;
      }
      var fitBounds = options.fitBounds;
      delete options.fitBounds;
      var fitBoundsPlacement = options.fitBoundsPlacement || OpenSeadragon.Placement.CENTER;
      delete options.fitBoundsPlacement;
      var degrees = options.degrees || 0;
      delete options.degrees;
      var ajaxHeaders = options.ajaxHeaders;
      delete options.ajaxHeaders;
      $.extend(true, this, {
        viewer: null,
        tilesMatrix: {},
        coverage: {},
        loadingCoverage: {},
        lastDrawn: [],
        lastResetTime: 0,
        _needsDraw: true,
        _needsUpdate: true,
        _hasOpaqueTile: false,
        _tilesLoading: 0,
        _tilesToDraw: [],
        _lastDrawn: [],
        _isBlending: false,
        _wasBlending: false,
        _isTainted: false,
        springStiffness: $.DEFAULT_SETTINGS.springStiffness,
        animationTime: $.DEFAULT_SETTINGS.animationTime,
        minZoomImageRatio: $.DEFAULT_SETTINGS.minZoomImageRatio,
        wrapHorizontal: $.DEFAULT_SETTINGS.wrapHorizontal,
        wrapVertical: $.DEFAULT_SETTINGS.wrapVertical,
        immediateRender: $.DEFAULT_SETTINGS.immediateRender,
        blendTime: $.DEFAULT_SETTINGS.blendTime,
        alwaysBlend: $.DEFAULT_SETTINGS.alwaysBlend,
        minPixelRatio: $.DEFAULT_SETTINGS.minPixelRatio,
        smoothTileEdgesMinZoom: $.DEFAULT_SETTINGS.smoothTileEdgesMinZoom,
        iOSDevice: $.DEFAULT_SETTINGS.iOSDevice,
        debugMode: $.DEFAULT_SETTINGS.debugMode,
        crossOriginPolicy: $.DEFAULT_SETTINGS.crossOriginPolicy,
        ajaxWithCredentials: $.DEFAULT_SETTINGS.ajaxWithCredentials,
        placeholderFillStyle: $.DEFAULT_SETTINGS.placeholderFillStyle,
        opacity: $.DEFAULT_SETTINGS.opacity,
        preload: $.DEFAULT_SETTINGS.preload,
        compositeOperation: $.DEFAULT_SETTINGS.compositeOperation,
        subPixelRoundingForTransparency: $.DEFAULT_SETTINGS.subPixelRoundingForTransparency,
        maxTilesPerFrame: $.DEFAULT_SETTINGS.maxTilesPerFrame
      }, options);
      this._preload = this.preload;
      delete this.preload;
      this._fullyLoaded = false;
      this._xSpring = new $.Spring({
        initial: x,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime
      });
      this._ySpring = new $.Spring({
        initial: y,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime
      });
      this._scaleSpring = new $.Spring({
        initial: scale,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime
      });
      this._degreesSpring = new $.Spring({
        initial: degrees,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime
      });
      this._updateForScale();
      if (fitBounds) {
        this.fitBounds(fitBounds, fitBoundsPlacement, true);
      }
      this._ownAjaxHeaders = {};
      this.setAjaxHeaders(ajaxHeaders, false);
      this._initialized = true;
    };
    $.extend($.TiledImage.prototype, $.EventSource.prototype, {
      needsDraw: function() {
        return this._needsDraw;
      },
      redraw: function() {
        this._needsDraw = true;
      },
      getFullyLoaded: function() {
        return this._fullyLoaded;
      },
      _setFullyLoaded: function(flag) {
        if (flag === this._fullyLoaded) {
          return;
        }
        this._fullyLoaded = flag;
        this.raiseEvent("fully-loaded-change", {
          fullyLoaded: this._fullyLoaded
        });
      },
      reset: function() {
        this._tileCache.clearTilesFor(this);
        this.lastResetTime = $.now();
        this._needsDraw = true;
      },
      update: function(viewportChanged) {
        let xUpdated = this._xSpring.update();
        let yUpdated = this._ySpring.update();
        let scaleUpdated = this._scaleSpring.update();
        let degreesUpdated = this._degreesSpring.update();
        let updated = xUpdated || yUpdated || scaleUpdated || degreesUpdated || this._needsUpdate;
        if (updated || viewportChanged || !this._fullyLoaded) {
          let fullyLoadedFlag = this._updateLevelsForViewport();
          this._setFullyLoaded(fullyLoadedFlag);
        }
        this._needsUpdate = false;
        if (updated) {
          this._updateForScale();
          this._raiseBoundsChange();
          this._needsDraw = true;
          return true;
        }
        return false;
      },
      setDrawn: function() {
        this._needsDraw = this._isBlending || this._wasBlending;
        return this._needsDraw;
      },
      setTainted(isTainted) {
        this._isTainted = isTainted;
      },
      isTainted() {
        return this._isTainted;
      },
      destroy: function() {
        this.reset();
        if (this.source.destroy) {
          this.source.destroy(this.viewer);
        }
      },
      getBounds: function(current) {
        return this.getBoundsNoRotate(current).rotate(this.getRotation(current), this._getRotationPoint(current));
      },
      getBoundsNoRotate: function(current) {
        return current ? new $.Rect(this._xSpring.current.value, this._ySpring.current.value, this._worldWidthCurrent, this._worldHeightCurrent) : new $.Rect(this._xSpring.target.value, this._ySpring.target.value, this._worldWidthTarget, this._worldHeightTarget);
      },
      getWorldBounds: function() {
        $.console.error("[TiledImage.getWorldBounds] is deprecated; use TiledImage.getBounds instead");
        return this.getBounds();
      },
      getClippedBounds: function(current) {
        var bounds = this.getBoundsNoRotate(current);
        if (this._clip) {
          var worldWidth = current ? this._worldWidthCurrent : this._worldWidthTarget;
          var ratio = worldWidth / this.source.dimensions.x;
          var clip = this._clip.times(ratio);
          bounds = new $.Rect(bounds.x + clip.x, bounds.y + clip.y, clip.width, clip.height);
        }
        return bounds.rotate(this.getRotation(current), this._getRotationPoint(current));
      },
      getTileBounds: function(level, x, y) {
        var numTiles = this.source.getNumTiles(level);
        var xMod = (numTiles.x + x % numTiles.x) % numTiles.x;
        var yMod = (numTiles.y + y % numTiles.y) % numTiles.y;
        var bounds = this.source.getTileBounds(level, xMod, yMod);
        if (this.getFlip()) {
          bounds.x = Math.max(0, 1 - bounds.x - bounds.width);
        }
        bounds.x += (x - xMod) / numTiles.x;
        bounds.y += this._worldHeightCurrent / this._worldWidthCurrent * ((y - yMod) / numTiles.y);
        return bounds;
      },
      getContentSize: function() {
        return new $.Point(this.source.dimensions.x, this.source.dimensions.y);
      },
      getSizeInWindowCoordinates: function() {
        var topLeft = this.imageToWindowCoordinates(new $.Point(0, 0));
        var bottomRight = this.imageToWindowCoordinates(this.getContentSize());
        return new $.Point(bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
      },
      _viewportToImageDelta: function(viewerX, viewerY, current) {
        var scale = current ? this._scaleSpring.current.value : this._scaleSpring.target.value;
        return new $.Point(viewerX * (this.source.dimensions.x / scale), viewerY * (this.source.dimensions.y * this.contentAspectX / scale));
      },
      viewportToImageCoordinates: function(viewerX, viewerY, current) {
        var point;
        if (viewerX instanceof $.Point) {
          current = viewerY;
          point = viewerX;
        } else {
          point = new $.Point(viewerX, viewerY);
        }
        point = point.rotate(-this.getRotation(current), this._getRotationPoint(current));
        return current ? this._viewportToImageDelta(point.x - this._xSpring.current.value, point.y - this._ySpring.current.value) : this._viewportToImageDelta(point.x - this._xSpring.target.value, point.y - this._ySpring.target.value);
      },
      _imageToViewportDelta: function(imageX, imageY, current) {
        var scale = current ? this._scaleSpring.current.value : this._scaleSpring.target.value;
        return new $.Point(imageX / this.source.dimensions.x * scale, imageY / this.source.dimensions.y / this.contentAspectX * scale);
      },
      imageToViewportCoordinates: function(imageX, imageY, current) {
        if (imageX instanceof $.Point) {
          current = imageY;
          imageY = imageX.y;
          imageX = imageX.x;
        }
        var point = this._imageToViewportDelta(imageX, imageY, current);
        if (current) {
          point.x += this._xSpring.current.value;
          point.y += this._ySpring.current.value;
        } else {
          point.x += this._xSpring.target.value;
          point.y += this._ySpring.target.value;
        }
        return point.rotate(this.getRotation(current), this._getRotationPoint(current));
      },
      imageToViewportRectangle: function(imageX, imageY, pixelWidth, pixelHeight, current) {
        var rect = imageX;
        if (rect instanceof $.Rect) {
          current = imageY;
        } else {
          rect = new $.Rect(imageX, imageY, pixelWidth, pixelHeight);
        }
        var coordA = this.imageToViewportCoordinates(rect.getTopLeft(), current);
        var coordB = this._imageToViewportDelta(rect.width, rect.height, current);
        return new $.Rect(coordA.x, coordA.y, coordB.x, coordB.y, rect.degrees + this.getRotation(current));
      },
      viewportToImageRectangle: function(viewerX, viewerY, pointWidth, pointHeight, current) {
        var rect = viewerX;
        if (viewerX instanceof $.Rect) {
          current = viewerY;
        } else {
          rect = new $.Rect(viewerX, viewerY, pointWidth, pointHeight);
        }
        var coordA = this.viewportToImageCoordinates(rect.getTopLeft(), current);
        var coordB = this._viewportToImageDelta(rect.width, rect.height, current);
        return new $.Rect(coordA.x, coordA.y, coordB.x, coordB.y, rect.degrees - this.getRotation(current));
      },
      viewerElementToImageCoordinates: function(pixel) {
        var point = this.viewport.pointFromPixel(pixel, true);
        return this.viewportToImageCoordinates(point);
      },
      imageToViewerElementCoordinates: function(pixel) {
        var point = this.imageToViewportCoordinates(pixel);
        return this.viewport.pixelFromPoint(point, true);
      },
      windowToImageCoordinates: function(pixel) {
        var viewerCoordinates = pixel.minus(OpenSeadragon.getElementPosition(this.viewer.element));
        return this.viewerElementToImageCoordinates(viewerCoordinates);
      },
      imageToWindowCoordinates: function(pixel) {
        var viewerCoordinates = this.imageToViewerElementCoordinates(pixel);
        return viewerCoordinates.plus(OpenSeadragon.getElementPosition(this.viewer.element));
      },
      _viewportToTiledImageRectangle: function(rect) {
        var scale = this._scaleSpring.current.value;
        rect = rect.rotate(-this.getRotation(true), this._getRotationPoint(true));
        return new $.Rect((rect.x - this._xSpring.current.value) / scale, (rect.y - this._ySpring.current.value) / scale, rect.width / scale, rect.height / scale, rect.degrees);
      },
      viewportToImageZoom: function(viewportZoom) {
        var ratio = this._scaleSpring.current.value * this.viewport._containerInnerSize.x / this.source.dimensions.x;
        return ratio * viewportZoom;
      },
      imageToViewportZoom: function(imageZoom) {
        var ratio = this._scaleSpring.current.value * this.viewport._containerInnerSize.x / this.source.dimensions.x;
        return imageZoom / ratio;
      },
      setPosition: function(position, immediately) {
        var sameTarget = this._xSpring.target.value === position.x && this._ySpring.target.value === position.y;
        if (immediately) {
          if (sameTarget && this._xSpring.current.value === position.x && this._ySpring.current.value === position.y) {
            return;
          }
          this._xSpring.resetTo(position.x);
          this._ySpring.resetTo(position.y);
          this._needsDraw = true;
          this._needsUpdate = true;
        } else {
          if (sameTarget) {
            return;
          }
          this._xSpring.springTo(position.x);
          this._ySpring.springTo(position.y);
          this._needsDraw = true;
          this._needsUpdate = true;
        }
        if (!sameTarget) {
          this._raiseBoundsChange();
        }
      },
      setWidth: function(width, immediately) {
        this._setScale(width, immediately);
      },
      setHeight: function(height, immediately) {
        this._setScale(height / this.normHeight, immediately);
      },
      setCroppingPolygons: function(polygons) {
        var isXYObject = function(obj) {
          return obj instanceof $.Point || typeof obj.x === "number" && typeof obj.y === "number";
        };
        var objectToSimpleXYObject = function(objs) {
          return objs.map(function(obj) {
            try {
              if (isXYObject(obj)) {
                return { x: obj.x, y: obj.y };
              } else {
                throw new Error;
              }
            } catch (e) {
              throw new Error("A Provided cropping polygon point is not supported");
            }
          });
        };
        try {
          if (!$.isArray(polygons)) {
            throw new Error("Provided cropping polygon is not an array");
          }
          this._croppingPolygons = polygons.map(function(polygon) {
            return objectToSimpleXYObject(polygon);
          });
          this._needsDraw = true;
        } catch (e) {
          $.console.error("[TiledImage.setCroppingPolygons] Cropping polygon format not supported");
          $.console.error(e);
          this.resetCroppingPolygons();
        }
      },
      resetCroppingPolygons: function() {
        this._croppingPolygons = null;
        this._needsDraw = true;
      },
      fitBounds: function(bounds, anchor, immediately) {
        anchor = anchor || $.Placement.CENTER;
        var anchorProperties = $.Placement.properties[anchor];
        var aspectRatio = this.contentAspectX;
        var xOffset = 0;
        var yOffset = 0;
        var displayedWidthRatio = 1;
        var displayedHeightRatio = 1;
        if (this._clip) {
          aspectRatio = this._clip.getAspectRatio();
          displayedWidthRatio = this._clip.width / this.source.dimensions.x;
          displayedHeightRatio = this._clip.height / this.source.dimensions.y;
          if (bounds.getAspectRatio() > aspectRatio) {
            xOffset = this._clip.x / this._clip.height * bounds.height;
            yOffset = this._clip.y / this._clip.height * bounds.height;
          } else {
            xOffset = this._clip.x / this._clip.width * bounds.width;
            yOffset = this._clip.y / this._clip.width * bounds.width;
          }
        }
        if (bounds.getAspectRatio() > aspectRatio) {
          var height = bounds.height / displayedHeightRatio;
          var marginLeft = 0;
          if (anchorProperties.isHorizontallyCentered) {
            marginLeft = (bounds.width - bounds.height * aspectRatio) / 2;
          } else if (anchorProperties.isRight) {
            marginLeft = bounds.width - bounds.height * aspectRatio;
          }
          this.setPosition(new $.Point(bounds.x - xOffset + marginLeft, bounds.y - yOffset), immediately);
          this.setHeight(height, immediately);
        } else {
          var width = bounds.width / displayedWidthRatio;
          var marginTop = 0;
          if (anchorProperties.isVerticallyCentered) {
            marginTop = (bounds.height - bounds.width / aspectRatio) / 2;
          } else if (anchorProperties.isBottom) {
            marginTop = bounds.height - bounds.width / aspectRatio;
          }
          this.setPosition(new $.Point(bounds.x - xOffset, bounds.y - yOffset + marginTop), immediately);
          this.setWidth(width, immediately);
        }
      },
      getClip: function() {
        if (this._clip) {
          return this._clip.clone();
        }
        return null;
      },
      setClip: function(newClip) {
        $.console.assert(!newClip || newClip instanceof $.Rect, "[TiledImage.setClip] newClip must be an OpenSeadragon.Rect or null");
        if (newClip instanceof $.Rect) {
          this._clip = newClip.clone();
        } else {
          this._clip = null;
        }
        this._needsUpdate = true;
        this._needsDraw = true;
        this.raiseEvent("clip-change");
      },
      getFlip: function() {
        return this.flipped;
      },
      setFlip: function(flip) {
        this.flipped = flip;
      },
      get flipped() {
        return this._flipped;
      },
      set flipped(flipped) {
        let changed = this._flipped !== !!flipped;
        this._flipped = !!flipped;
        if (changed) {
          this.update(true);
          this._needsDraw = true;
          this._raiseBoundsChange();
        }
      },
      get wrapHorizontal() {
        return this._wrapHorizontal;
      },
      set wrapHorizontal(wrap) {
        let changed = this._wrapHorizontal !== !!wrap;
        this._wrapHorizontal = !!wrap;
        if (this._initialized && changed) {
          this.update(true);
          this._needsDraw = true;
        }
      },
      get wrapVertical() {
        return this._wrapVertical;
      },
      set wrapVertical(wrap) {
        let changed = this._wrapVertical !== !!wrap;
        this._wrapVertical = !!wrap;
        if (this._initialized && changed) {
          this.update(true);
          this._needsDraw = true;
        }
      },
      get debugMode() {
        return this._debugMode;
      },
      set debugMode(debug) {
        this._debugMode = !!debug;
        this._needsDraw = true;
      },
      getOpacity: function() {
        return this.opacity;
      },
      setOpacity: function(opacity) {
        this.opacity = opacity;
      },
      get opacity() {
        return this._opacity;
      },
      set opacity(opacity) {
        if (opacity === this.opacity) {
          return;
        }
        this._opacity = opacity;
        this._needsDraw = true;
        this.raiseEvent("opacity-change", {
          opacity: this.opacity
        });
      },
      getPreload: function() {
        return this._preload;
      },
      setPreload: function(preload) {
        this._preload = !!preload;
        this._needsDraw = true;
      },
      getRotation: function(current) {
        return current ? this._degreesSpring.current.value : this._degreesSpring.target.value;
      },
      setRotation: function(degrees, immediately) {
        if (this._degreesSpring.target.value === degrees && this._degreesSpring.isAtTargetValue()) {
          return;
        }
        if (immediately) {
          this._degreesSpring.resetTo(degrees);
        } else {
          this._degreesSpring.springTo(degrees);
        }
        this._needsDraw = true;
        this._needsUpdate = true;
        this._raiseBoundsChange();
      },
      getDrawArea: function() {
        if (this._opacity === 0 && !this._preload) {
          return false;
        }
        var drawArea = this._viewportToTiledImageRectangle(this.viewport.getBoundsWithMargins(true));
        if (!this.wrapHorizontal && !this.wrapVertical) {
          var tiledImageBounds = this._viewportToTiledImageRectangle(this.getClippedBounds(true));
          drawArea = drawArea.intersection(tiledImageBounds);
        }
        return drawArea;
      },
      getTilesToDraw: function() {
        let tileArray = this._tilesToDraw.flat();
        this._updateTilesInViewport(tileArray);
        tileArray = this._tilesToDraw.flat();
        tileArray.forEach((tileInfo) => {
          tileInfo.tile.beingDrawn = true;
        });
        this._lastDrawn = tileArray;
        return tileArray;
      },
      _getRotationPoint: function(current) {
        return this.getBoundsNoRotate(current).getCenter();
      },
      get compositeOperation() {
        return this._compositeOperation;
      },
      set compositeOperation(compositeOperation) {
        if (compositeOperation === this._compositeOperation) {
          return;
        }
        this._compositeOperation = compositeOperation;
        this._needsDraw = true;
        this.raiseEvent("composite-operation-change", {
          compositeOperation: this._compositeOperation
        });
      },
      getCompositeOperation: function() {
        return this._compositeOperation;
      },
      setCompositeOperation: function(compositeOperation) {
        this.compositeOperation = compositeOperation;
      },
      setAjaxHeaders: function(ajaxHeaders, propagate) {
        if (ajaxHeaders === null) {
          ajaxHeaders = {};
        }
        if (!$.isPlainObject(ajaxHeaders)) {
          console.error("[TiledImage.setAjaxHeaders] Ignoring invalid headers, must be a plain object");
          return;
        }
        this._ownAjaxHeaders = ajaxHeaders;
        this._updateAjaxHeaders(propagate);
      },
      _updateAjaxHeaders: function(propagate) {
        if (propagate === undefined) {
          propagate = true;
        }
        if ($.isPlainObject(this.viewer.ajaxHeaders)) {
          this.ajaxHeaders = $.extend({}, this.viewer.ajaxHeaders, this._ownAjaxHeaders);
        } else {
          this.ajaxHeaders = this._ownAjaxHeaders;
        }
        if (propagate) {
          var numTiles, xMod, yMod, tile;
          for (var level in this.tilesMatrix) {
            numTiles = this.source.getNumTiles(level);
            for (var x in this.tilesMatrix[level]) {
              xMod = (numTiles.x + x % numTiles.x) % numTiles.x;
              for (var y in this.tilesMatrix[level][x]) {
                yMod = (numTiles.y + y % numTiles.y) % numTiles.y;
                tile = this.tilesMatrix[level][x][y];
                tile.loadWithAjax = this.loadTilesWithAjax;
                if (tile.loadWithAjax) {
                  var tileAjaxHeaders = this.source.getTileAjaxHeaders(level, xMod, yMod);
                  tile.ajaxHeaders = $.extend({}, this.ajaxHeaders, tileAjaxHeaders);
                } else {
                  tile.ajaxHeaders = null;
                }
              }
            }
          }
          for (var i = 0;i < this._imageLoader.jobQueue.length; i++) {
            var job = this._imageLoader.jobQueue[i];
            job.loadWithAjax = job.tile.loadWithAjax;
            job.ajaxHeaders = job.tile.loadWithAjax ? job.tile.ajaxHeaders : null;
          }
        }
      },
      _setScale: function(scale, immediately) {
        var sameTarget = this._scaleSpring.target.value === scale;
        if (immediately) {
          if (sameTarget && this._scaleSpring.current.value === scale) {
            return;
          }
          this._scaleSpring.resetTo(scale);
          this._updateForScale();
          this._needsDraw = true;
          this._needsUpdate = true;
        } else {
          if (sameTarget) {
            return;
          }
          this._scaleSpring.springTo(scale);
          this._updateForScale();
          this._needsDraw = true;
          this._needsUpdate = true;
        }
        if (!sameTarget) {
          this._raiseBoundsChange();
        }
      },
      _updateForScale: function() {
        this._worldWidthTarget = this._scaleSpring.target.value;
        this._worldHeightTarget = this.normHeight * this._scaleSpring.target.value;
        this._worldWidthCurrent = this._scaleSpring.current.value;
        this._worldHeightCurrent = this.normHeight * this._scaleSpring.current.value;
      },
      _raiseBoundsChange: function() {
        this.raiseEvent("bounds-change");
      },
      _isBottomItem: function() {
        return this.viewer.world.getItemAt(0) === this;
      },
      _getLevelsInterval: function() {
        var lowestLevel = Math.max(this.source.minLevel, Math.floor(Math.log(this.minZoomImageRatio) / Math.log(2)));
        var currentZeroRatio = this.viewport.deltaPixelsFromPointsNoRotate(this.source.getPixelRatio(0), true).x * this._scaleSpring.current.value;
        var highestLevel = Math.min(Math.abs(this.source.maxLevel), Math.abs(Math.floor(Math.log(currentZeroRatio / this.minPixelRatio) / Math.log(2))));
        highestLevel = Math.max(highestLevel, this.source.minLevel || 0);
        lowestLevel = Math.min(lowestLevel, highestLevel);
        return {
          lowestLevel,
          highestLevel
        };
      },
      _updateLevelsForViewport: function() {
        var levelsInterval = this._getLevelsInterval();
        var lowestLevel = levelsInterval.lowestLevel;
        var highestLevel = levelsInterval.highestLevel;
        var bestTiles = [];
        var drawArea = this.getDrawArea();
        var currentTime = $.now();
        this._lastDrawn.forEach((tileinfo) => {
          tileinfo.tile.beingDrawn = false;
        });
        this._tilesToDraw = [];
        this._tilesLoading = 0;
        this.loadingCoverage = {};
        if (!drawArea) {
          this._needsDraw = false;
          return this._fullyLoaded;
        }
        var levelList = new Array(highestLevel - lowestLevel + 1);
        for (let i = 0, level = highestLevel;level >= lowestLevel; level--, i++) {
          levelList[i] = level;
        }
        for (let level = highestLevel + 1;level <= this.source.maxLevel; level++) {
          var tile = this.tilesMatrix[level] && this.tilesMatrix[level][0] && this.tilesMatrix[level][0][0];
          if (tile && tile.isBottomMost && tile.isRightMost && tile.loaded) {
            levelList.push(level);
            break;
          }
        }
        let useLevel = false;
        for (let i = 0;i < levelList.length; i++) {
          let level = levelList[i];
          var currentRenderPixelRatio = this.viewport.deltaPixelsFromPointsNoRotate(this.source.getPixelRatio(level), true).x * this._scaleSpring.current.value;
          if (i === levelList.length - 1 || currentRenderPixelRatio >= this.minPixelRatio) {
            useLevel = true;
          } else if (!useLevel) {
            continue;
          }
          var targetRenderPixelRatio = this.viewport.deltaPixelsFromPointsNoRotate(this.source.getPixelRatio(level), false).x * this._scaleSpring.current.value;
          var targetZeroRatio = this.viewport.deltaPixelsFromPointsNoRotate(this.source.getPixelRatio(Math.max(this.source.getClosestLevel(), 0)), false).x * this._scaleSpring.current.value;
          var optimalRatio = this.immediateRender ? 1 : targetZeroRatio;
          var levelOpacity = Math.min(1, (currentRenderPixelRatio - 0.5) / 0.5);
          var levelVisibility = optimalRatio / Math.abs(optimalRatio - targetRenderPixelRatio);
          var result = this._updateLevel(level, levelOpacity, levelVisibility, drawArea, currentTime, bestTiles);
          bestTiles = result.bestTiles;
          var tiles = result.updatedTiles.filter((tile2) => tile2.loaded);
          var makeTileInfoObject = function(level2, levelOpacity2, currentTime2) {
            return function(tile2) {
              return {
                tile: tile2,
                level: level2,
                levelOpacity: levelOpacity2,
                currentTime: currentTime2
              };
            };
          }(level, levelOpacity, currentTime);
          this._tilesToDraw[level] = tiles.map(makeTileInfoObject);
          if (this._providesCoverage(this.coverage, level)) {
            break;
          }
        }
        if (bestTiles && bestTiles.length > 0) {
          bestTiles.forEach(function(tile2) {
            if (tile2 && !tile2.context2D) {
              this._loadTile(tile2, currentTime);
            }
          }, this);
          this._needsDraw = true;
          return false;
        } else {
          return this._tilesLoading === 0;
        }
      },
      _updateTilesInViewport: function(tiles) {
        let currentTime = $.now();
        let _this = this;
        this._tilesLoading = 0;
        this._wasBlending = this._isBlending;
        this._isBlending = false;
        this.loadingCoverage = {};
        let lowestLevel = tiles.length ? tiles[0].level : 0;
        let drawArea = this.getDrawArea();
        if (!drawArea) {
          return;
        }
        function updateTile(info) {
          let tile = info.tile;
          if (tile && tile.loaded) {
            let tileIsBlending = _this._blendTile(tile, tile.x, tile.y, info.level, info.levelOpacity, currentTime, lowestLevel);
            _this._isBlending = _this._isBlending || tileIsBlending;
            _this._needsDraw = _this._needsDraw || tileIsBlending || _this._wasBlending;
          }
        }
        let level = 0;
        for (let i = 0;i < tiles.length; i++) {
          let tile = tiles[i];
          updateTile(tile);
          if (this._providesCoverage(this.coverage, tile.level)) {
            level = Math.max(level, tile.level);
          }
        }
        if (level > 0) {
          for (let levelKey in this._tilesToDraw) {
            if (levelKey < level) {
              delete this._tilesToDraw[levelKey];
            }
          }
        }
      },
      _blendTile: function(tile, x, y, level, levelOpacity, currentTime, lowestLevel) {
        let blendTimeMillis = 1000 * this.blendTime, deltaTime, opacity;
        if (!tile.blendStart) {
          tile.blendStart = currentTime;
        }
        deltaTime = currentTime - tile.blendStart;
        opacity = blendTimeMillis ? Math.min(1, deltaTime / blendTimeMillis) : 1;
        if (level === lowestLevel) {
          opacity = 1;
          deltaTime = blendTimeMillis;
        }
        if (this.alwaysBlend) {
          opacity *= levelOpacity;
        }
        tile.opacity = opacity;
        if (opacity === 1) {
          this._setCoverage(this.coverage, level, x, y, true);
          this._hasOpaqueTile = true;
        }
        return deltaTime < blendTimeMillis;
      },
      _updateLevel: function(level, levelOpacity, levelVisibility, drawArea, currentTime, best) {
        var topLeftBound = drawArea.getBoundingBox().getTopLeft();
        var bottomRightBound = drawArea.getBoundingBox().getBottomRight();
        if (this.viewer) {
          this.viewer.raiseEvent("update-level", {
            tiledImage: this,
            havedrawn: true,
            level,
            opacity: levelOpacity,
            visibility: levelVisibility,
            drawArea,
            topleft: topLeftBound,
            bottomright: bottomRightBound,
            currenttime: currentTime,
            best
          });
        }
        this._resetCoverage(this.coverage, level);
        this._resetCoverage(this.loadingCoverage, level);
        var cornerTiles = this._getCornerTiles(level, topLeftBound, bottomRightBound);
        var topLeftTile = cornerTiles.topLeft;
        var bottomRightTile = cornerTiles.bottomRight;
        var numberOfTiles = this.source.getNumTiles(level);
        var viewportCenter = this.viewport.pixelFromPoint(this.viewport.getCenter());
        if (this.getFlip()) {
          bottomRightTile.x += 1;
          if (!this.wrapHorizontal) {
            bottomRightTile.x = Math.min(bottomRightTile.x, numberOfTiles.x - 1);
          }
        }
        var numTiles = Math.max(0, (bottomRightTile.x - topLeftTile.x) * (bottomRightTile.y - topLeftTile.y));
        var tiles = new Array(numTiles);
        var tileIndex = 0;
        for (var x = topLeftTile.x;x <= bottomRightTile.x; x++) {
          for (var y = topLeftTile.y;y <= bottomRightTile.y; y++) {
            var flippedX;
            if (this.getFlip()) {
              var xMod = (numberOfTiles.x + x % numberOfTiles.x) % numberOfTiles.x;
              flippedX = x + numberOfTiles.x - xMod - xMod - 1;
            } else {
              flippedX = x;
            }
            if (drawArea.intersection(this.getTileBounds(level, flippedX, y)) === null) {
              continue;
            }
            var result = this._updateTile(flippedX, y, level, levelVisibility, viewportCenter, numberOfTiles, currentTime, best);
            best = result.bestTiles;
            tiles[tileIndex] = result.tile;
            tileIndex += 1;
          }
        }
        return {
          bestTiles: best,
          updatedTiles: tiles
        };
      },
      _positionTile: function(tile, overlap, viewport, viewportCenter, levelVisibility) {
        var boundsTL = tile.bounds.getTopLeft();
        boundsTL.x *= this._scaleSpring.current.value;
        boundsTL.y *= this._scaleSpring.current.value;
        boundsTL.x += this._xSpring.current.value;
        boundsTL.y += this._ySpring.current.value;
        var boundsSize = tile.bounds.getSize();
        boundsSize.x *= this._scaleSpring.current.value;
        boundsSize.y *= this._scaleSpring.current.value;
        tile.positionedBounds.x = boundsTL.x;
        tile.positionedBounds.y = boundsTL.y;
        tile.positionedBounds.width = boundsSize.x;
        tile.positionedBounds.height = boundsSize.y;
        var positionC = viewport.pixelFromPointNoRotate(boundsTL, true), positionT = viewport.pixelFromPointNoRotate(boundsTL, false), sizeC = viewport.deltaPixelsFromPointsNoRotate(boundsSize, true), sizeT = viewport.deltaPixelsFromPointsNoRotate(boundsSize, false), tileCenter = positionT.plus(sizeT.divide(2)), tileSquaredDistance = viewportCenter.squaredDistanceTo(tileCenter);
        if (this.viewer.drawer.minimumOverlapRequired(this)) {
          if (!overlap) {
            sizeC = sizeC.plus(new $.Point(1, 1));
          }
          if (tile.isRightMost && this.wrapHorizontal) {
            sizeC.x += 0.75;
          }
          if (tile.isBottomMost && this.wrapVertical) {
            sizeC.y += 0.75;
          }
        }
        tile.position = positionC;
        tile.size = sizeC;
        tile.squaredDistance = tileSquaredDistance;
        tile.visibility = levelVisibility;
      },
      _updateTile: function(x, y, level, levelVisibility, viewportCenter, numberOfTiles, currentTime, best) {
        var tile = this._getTile(x, y, level, currentTime, numberOfTiles);
        if (this.viewer) {
          this.viewer.raiseEvent("update-tile", {
            tiledImage: this,
            tile
          });
        }
        this._setCoverage(this.coverage, level, x, y, false);
        var loadingCoverage = tile.loaded || tile.loading || this._isCovered(this.loadingCoverage, level, x, y);
        this._setCoverage(this.loadingCoverage, level, x, y, loadingCoverage);
        if (!tile.exists) {
          return {
            bestTiles: best,
            tile
          };
        }
        if (tile.loaded && tile.opacity === 1) {
          this._setCoverage(this.coverage, level, x, y, true);
        }
        this._positionTile(tile, this.source.tileOverlap, this.viewport, viewportCenter, levelVisibility);
        if (!tile.loaded) {
          if (tile.context2D) {
            this._setTileLoaded(tile);
          } else {
            var imageRecord = this._tileCache.getImageRecord(tile.cacheKey);
            if (imageRecord) {
              this._setTileLoaded(tile, imageRecord.getData());
            }
          }
        }
        if (tile.loading) {
          this._tilesLoading++;
        } else if (!loadingCoverage) {
          best = this._compareTiles(best, tile, this.maxTilesPerFrame);
        }
        return {
          bestTiles: best,
          tile
        };
      },
      _getCornerTiles: function(level, topLeftBound, bottomRightBound) {
        var leftX;
        var rightX;
        if (this.wrapHorizontal) {
          leftX = $.positiveModulo(topLeftBound.x, 1);
          rightX = $.positiveModulo(bottomRightBound.x, 1);
        } else {
          leftX = Math.max(0, topLeftBound.x);
          rightX = Math.min(1, bottomRightBound.x);
        }
        var topY;
        var bottomY;
        var aspectRatio = 1 / this.source.aspectRatio;
        if (this.wrapVertical) {
          topY = $.positiveModulo(topLeftBound.y, aspectRatio);
          bottomY = $.positiveModulo(bottomRightBound.y, aspectRatio);
        } else {
          topY = Math.max(0, topLeftBound.y);
          bottomY = Math.min(aspectRatio, bottomRightBound.y);
        }
        var topLeftTile = this.source.getTileAtPoint(level, new $.Point(leftX, topY));
        var bottomRightTile = this.source.getTileAtPoint(level, new $.Point(rightX, bottomY));
        var numTiles = this.source.getNumTiles(level);
        if (this.wrapHorizontal) {
          topLeftTile.x += numTiles.x * Math.floor(topLeftBound.x);
          bottomRightTile.x += numTiles.x * Math.floor(bottomRightBound.x);
        }
        if (this.wrapVertical) {
          topLeftTile.y += numTiles.y * Math.floor(topLeftBound.y / aspectRatio);
          bottomRightTile.y += numTiles.y * Math.floor(bottomRightBound.y / aspectRatio);
        }
        return {
          topLeft: topLeftTile,
          bottomRight: bottomRightTile
        };
      },
      _getTile: function(x, y, level, time, numTiles) {
        var xMod, yMod, bounds, sourceBounds, exists, urlOrGetter, post, ajaxHeaders, context2D, tile, tilesMatrix = this.tilesMatrix, tileSource = this.source;
        if (!tilesMatrix[level]) {
          tilesMatrix[level] = {};
        }
        if (!tilesMatrix[level][x]) {
          tilesMatrix[level][x] = {};
        }
        if (!tilesMatrix[level][x][y] || !tilesMatrix[level][x][y].flipped !== !this.flipped) {
          xMod = (numTiles.x + x % numTiles.x) % numTiles.x;
          yMod = (numTiles.y + y % numTiles.y) % numTiles.y;
          bounds = this.getTileBounds(level, x, y);
          sourceBounds = tileSource.getTileBounds(level, xMod, yMod, true);
          exists = tileSource.tileExists(level, xMod, yMod);
          urlOrGetter = tileSource.getTileUrl(level, xMod, yMod);
          post = tileSource.getTilePostData(level, xMod, yMod);
          if (this.loadTilesWithAjax) {
            ajaxHeaders = tileSource.getTileAjaxHeaders(level, xMod, yMod);
            if ($.isPlainObject(this.ajaxHeaders)) {
              ajaxHeaders = $.extend({}, this.ajaxHeaders, ajaxHeaders);
            }
          } else {
            ajaxHeaders = null;
          }
          context2D = tileSource.getContext2D ? tileSource.getContext2D(level, xMod, yMod) : undefined;
          tile = new $.Tile(level, x, y, bounds, exists, urlOrGetter, context2D, this.loadTilesWithAjax, ajaxHeaders, sourceBounds, post, tileSource.getTileHashKey(level, xMod, yMod, urlOrGetter, ajaxHeaders, post));
          if (this.getFlip()) {
            if (xMod === 0) {
              tile.isRightMost = true;
            }
          } else {
            if (xMod === numTiles.x - 1) {
              tile.isRightMost = true;
            }
          }
          if (yMod === numTiles.y - 1) {
            tile.isBottomMost = true;
          }
          tile.flipped = this.flipped;
          tilesMatrix[level][x][y] = tile;
        }
        tile = tilesMatrix[level][x][y];
        tile.lastTouchTime = time;
        return tile;
      },
      _loadTile: function(tile, time) {
        var _this = this;
        tile.loading = true;
        this._imageLoader.addJob({
          src: tile.getUrl(),
          tile,
          source: this.source,
          postData: tile.postData,
          loadWithAjax: tile.loadWithAjax,
          ajaxHeaders: tile.ajaxHeaders,
          crossOriginPolicy: this.crossOriginPolicy,
          ajaxWithCredentials: this.ajaxWithCredentials,
          callback: function(data, errorMsg, tileRequest) {
            _this._onTileLoad(tile, time, data, errorMsg, tileRequest);
          },
          abort: function() {
            tile.loading = false;
          }
        });
      },
      _onTileLoad: function(tile, time, data, errorMsg, tileRequest) {
        if (!data) {
          $.console.error("Tile %s failed to load: %s - error: %s", tile, tile.getUrl(), errorMsg);
          this.viewer.raiseEvent("tile-load-failed", {
            tile,
            tiledImage: this,
            time,
            message: errorMsg,
            tileRequest
          });
          tile.loading = false;
          tile.exists = false;
          return;
        } else {
          tile.exists = true;
        }
        if (time < this.lastResetTime) {
          $.console.warn("Ignoring tile %s loaded before reset: %s", tile, tile.getUrl());
          tile.loading = false;
          return;
        }
        var _this = this, finish = function() {
          var ccc = _this.source;
          var cutoff = ccc.getClosestLevel();
          _this._setTileLoaded(tile, data, cutoff, tileRequest);
        };
        finish();
      },
      _setTileLoaded: function(tile, data, cutoff, tileRequest) {
        var increment = 0, eventFinished = false, _this = this;
        function getCompletionCallback() {
          if (eventFinished) {
            $.console.error("Event 'tile-loaded' argument getCompletionCallback must be called synchronously. " + "Its return value should be called asynchronously.");
          }
          increment++;
          return completionCallback;
        }
        function completionCallback() {
          increment--;
          if (increment === 0) {
            tile.loading = false;
            tile.loaded = true;
            tile.hasTransparency = _this.source.hasTransparency(tile.context2D, tile.getUrl(), tile.ajaxHeaders, tile.postData);
            if (!tile.context2D) {
              _this._tileCache.cacheTile({
                data,
                tile,
                cutoff,
                tiledImage: _this
              });
            }
            _this.viewer.raiseEvent("tile-ready", {
              tile,
              tiledImage: _this,
              tileRequest
            });
            _this._needsDraw = true;
          }
        }
        var fallbackCompletion = getCompletionCallback();
        this.viewer.raiseEvent("tile-loaded", {
          tile,
          tiledImage: this,
          tileRequest,
          get image() {
            $.console.error("[tile-loaded] event 'image' has been deprecated. Use 'data' property instead.");
            return data;
          },
          data,
          getCompletionCallback
        });
        eventFinished = true;
        fallbackCompletion();
      },
      _compareTiles: function(previousBest, tile, maxNTiles) {
        if (!previousBest) {
          return [tile];
        }
        previousBest.push(tile);
        this._sortTiles(previousBest);
        if (previousBest.length > maxNTiles) {
          previousBest.pop();
        }
        return previousBest;
      },
      _sortTiles: function(tiles) {
        tiles.sort(function(a, b) {
          if (a === null) {
            return 1;
          }
          if (b === null) {
            return -1;
          }
          if (a.visibility === b.visibility) {
            return a.squaredDistance - b.squaredDistance;
          } else {
            return b.visibility - a.visibility;
          }
        });
      },
      _providesCoverage: function(coverage, level, x, y) {
        var rows, cols, i, j;
        if (!coverage[level]) {
          return false;
        }
        if (x === undefined || y === undefined) {
          rows = coverage[level];
          for (i in rows) {
            if (Object.prototype.hasOwnProperty.call(rows, i)) {
              cols = rows[i];
              for (j in cols) {
                if (Object.prototype.hasOwnProperty.call(cols, j) && !cols[j]) {
                  return false;
                }
              }
            }
          }
          return true;
        }
        return coverage[level][x] === undefined || coverage[level][x][y] === undefined || coverage[level][x][y] === true;
      },
      _isCovered: function(coverage, level, x, y) {
        if (x === undefined || y === undefined) {
          return this._providesCoverage(coverage, level + 1);
        } else {
          return this._providesCoverage(coverage, level + 1, 2 * x, 2 * y) && this._providesCoverage(coverage, level + 1, 2 * x, 2 * y + 1) && this._providesCoverage(coverage, level + 1, 2 * x + 1, 2 * y) && this._providesCoverage(coverage, level + 1, 2 * x + 1, 2 * y + 1);
        }
      },
      _setCoverage: function(coverage, level, x, y, covers) {
        if (!coverage[level]) {
          $.console.warn("Setting coverage for a tile before its level's coverage has been reset: %s", level);
          return;
        }
        if (!coverage[level][x]) {
          coverage[level][x] = {};
        }
        coverage[level][x][y] = covers;
      },
      _resetCoverage: function(coverage, level) {
        coverage[level] = {};
      }
    });
  })(OpenSeadragon);
  (function($) {
    var TileRecord = function(options) {
      $.console.assert(options, "[TileCache.cacheTile] options is required");
      $.console.assert(options.tile, "[TileCache.cacheTile] options.tile is required");
      $.console.assert(options.tiledImage, "[TileCache.cacheTile] options.tiledImage is required");
      this.tile = options.tile;
      this.tiledImage = options.tiledImage;
    };
    var ImageRecord = function(options) {
      $.console.assert(options, "[ImageRecord] options is required");
      $.console.assert(options.data, "[ImageRecord] options.data is required");
      this._tiles = [];
      options.create.apply(null, [this, options.data, options.ownerTile]);
      this._destroyImplementation = options.destroy.bind(null, this);
      this.getImage = options.getImage.bind(null, this);
      this.getData = options.getData.bind(null, this);
      this.getRenderedContext = options.getRenderedContext.bind(null, this);
    };
    ImageRecord.prototype = {
      destroy: function() {
        this._destroyImplementation();
        this._tiles = null;
      },
      addTile: function(tile) {
        $.console.assert(tile, "[ImageRecord.addTile] tile is required");
        this._tiles.push(tile);
      },
      removeTile: function(tile) {
        for (var i = 0;i < this._tiles.length; i++) {
          if (this._tiles[i] === tile) {
            this._tiles.splice(i, 1);
            return;
          }
        }
        $.console.warn("[ImageRecord.removeTile] trying to remove unknown tile", tile);
      },
      getTileCount: function() {
        return this._tiles.length;
      }
    };
    $.TileCache = function(options) {
      options = options || {};
      this._maxImageCacheCount = options.maxImageCacheCount || $.DEFAULT_SETTINGS.maxImageCacheCount;
      this._tilesLoaded = [];
      this._imagesLoaded = [];
      this._imagesLoadedCount = 0;
    };
    $.TileCache.prototype = {
      numTilesLoaded: function() {
        return this._tilesLoaded.length;
      },
      cacheTile: function(options) {
        $.console.assert(options, "[TileCache.cacheTile] options is required");
        $.console.assert(options.tile, "[TileCache.cacheTile] options.tile is required");
        $.console.assert(options.tile.cacheKey, "[TileCache.cacheTile] options.tile.cacheKey is required");
        $.console.assert(options.tiledImage, "[TileCache.cacheTile] options.tiledImage is required");
        var cutoff = options.cutoff || 0;
        var insertionIndex = this._tilesLoaded.length;
        var imageRecord = this._imagesLoaded[options.tile.cacheKey];
        if (!imageRecord) {
          if (!options.data) {
            $.console.error("[TileCache.cacheTile] options.image was renamed to options.data. '.image' attribute " + "has been deprecated and will be removed in the future.");
            options.data = options.image;
          }
          $.console.assert(options.data, "[TileCache.cacheTile] options.data is required to create an ImageRecord");
          imageRecord = this._imagesLoaded[options.tile.cacheKey] = new ImageRecord({
            data: options.data,
            ownerTile: options.tile,
            create: options.tiledImage.source.createTileCache,
            destroy: options.tiledImage.source.destroyTileCache,
            getImage: options.tiledImage.source.getTileCacheDataAsImage,
            getData: options.tiledImage.source.getTileCacheData,
            getRenderedContext: options.tiledImage.source.getTileCacheDataAsContext2D
          });
          this._imagesLoadedCount++;
        }
        imageRecord.addTile(options.tile);
        options.tile.cacheImageRecord = imageRecord;
        if (this._imagesLoadedCount > this._maxImageCacheCount) {
          var worstTile = null;
          var worstTileIndex = -1;
          var worstTileRecord = null;
          var prevTile, worstTime, worstLevel, prevTime, prevLevel, prevTileRecord;
          for (var i = this._tilesLoaded.length - 1;i >= 0; i--) {
            prevTileRecord = this._tilesLoaded[i];
            prevTile = prevTileRecord.tile;
            if (prevTile.level <= cutoff || prevTile.beingDrawn) {
              continue;
            } else if (!worstTile) {
              worstTile = prevTile;
              worstTileIndex = i;
              worstTileRecord = prevTileRecord;
              continue;
            }
            prevTime = prevTile.lastTouchTime;
            worstTime = worstTile.lastTouchTime;
            prevLevel = prevTile.level;
            worstLevel = worstTile.level;
            if (prevTime < worstTime || prevTime === worstTime && prevLevel > worstLevel) {
              worstTile = prevTile;
              worstTileIndex = i;
              worstTileRecord = prevTileRecord;
            }
          }
          if (worstTile && worstTileIndex >= 0) {
            this._unloadTile(worstTileRecord);
            insertionIndex = worstTileIndex;
          }
        }
        this._tilesLoaded[insertionIndex] = new TileRecord({
          tile: options.tile,
          tiledImage: options.tiledImage
        });
      },
      clearTilesFor: function(tiledImage) {
        $.console.assert(tiledImage, "[TileCache.clearTilesFor] tiledImage is required");
        var tileRecord;
        for (var i = 0;i < this._tilesLoaded.length; ++i) {
          tileRecord = this._tilesLoaded[i];
          if (tileRecord.tiledImage === tiledImage) {
            this._unloadTile(tileRecord);
            this._tilesLoaded.splice(i, 1);
            i--;
          }
        }
      },
      getImageRecord: function(cacheKey) {
        $.console.assert(cacheKey, "[TileCache.getImageRecord] cacheKey is required");
        return this._imagesLoaded[cacheKey];
      },
      _unloadTile: function(tileRecord) {
        $.console.assert(tileRecord, "[TileCache._unloadTile] tileRecord is required");
        var tile = tileRecord.tile;
        var tiledImage = tileRecord.tiledImage;
        let context2D = tile.getCanvasContext && tile.getCanvasContext();
        tile.unload();
        tile.cacheImageRecord = null;
        var imageRecord = this._imagesLoaded[tile.cacheKey];
        if (!imageRecord) {
          return;
        }
        imageRecord.removeTile(tile);
        if (!imageRecord.getTileCount()) {
          imageRecord.destroy();
          delete this._imagesLoaded[tile.cacheKey];
          this._imagesLoadedCount--;
          if (context2D) {
            context2D.canvas.width = 0;
            context2D.canvas.height = 0;
            tiledImage.viewer.raiseEvent("image-unloaded", {
              context2D,
              tile
            });
          }
        }
        tiledImage.viewer.raiseEvent("tile-unloaded", {
          tile,
          tiledImage
        });
      }
    };
  })(OpenSeadragon);
  (function($) {
    $.World = function(options) {
      var _this = this;
      $.console.assert(options.viewer, "[World] options.viewer is required");
      $.EventSource.call(this);
      this.viewer = options.viewer;
      this._items = [];
      this._needsDraw = false;
      this._autoRefigureSizes = true;
      this._needsSizesFigured = false;
      this._delegatedFigureSizes = function(event) {
        if (_this._autoRefigureSizes) {
          _this._figureSizes();
        } else {
          _this._needsSizesFigured = true;
        }
      };
      this._figureSizes();
    };
    $.extend($.World.prototype, $.EventSource.prototype, {
      addItem: function(item, options) {
        $.console.assert(item, "[World.addItem] item is required");
        $.console.assert(item instanceof $.TiledImage, "[World.addItem] only TiledImages supported at this time");
        options = options || {};
        if (options.index !== undefined) {
          var index = Math.max(0, Math.min(this._items.length, options.index));
          this._items.splice(index, 0, item);
        } else {
          this._items.push(item);
        }
        if (this._autoRefigureSizes) {
          this._figureSizes();
        } else {
          this._needsSizesFigured = true;
        }
        this._needsDraw = true;
        item.addHandler("bounds-change", this._delegatedFigureSizes);
        item.addHandler("clip-change", this._delegatedFigureSizes);
        this.raiseEvent("add-item", {
          item
        });
      },
      getItemAt: function(index) {
        $.console.assert(index !== undefined, "[World.getItemAt] index is required");
        return this._items[index];
      },
      getIndexOfItem: function(item) {
        $.console.assert(item, "[World.getIndexOfItem] item is required");
        return $.indexOf(this._items, item);
      },
      getItemCount: function() {
        return this._items.length;
      },
      setItemIndex: function(item, index) {
        $.console.assert(item, "[World.setItemIndex] item is required");
        $.console.assert(index !== undefined, "[World.setItemIndex] index is required");
        var oldIndex = this.getIndexOfItem(item);
        if (index >= this._items.length) {
          throw new Error("Index bigger than number of layers.");
        }
        if (index === oldIndex || oldIndex === -1) {
          return;
        }
        this._items.splice(oldIndex, 1);
        this._items.splice(index, 0, item);
        this._needsDraw = true;
        this.raiseEvent("item-index-change", {
          item,
          previousIndex: oldIndex,
          newIndex: index
        });
      },
      removeItem: function(item) {
        $.console.assert(item, "[World.removeItem] item is required");
        var index = $.indexOf(this._items, item);
        if (index === -1) {
          return;
        }
        item.removeHandler("bounds-change", this._delegatedFigureSizes);
        item.removeHandler("clip-change", this._delegatedFigureSizes);
        item.destroy();
        this._items.splice(index, 1);
        this._figureSizes();
        this._needsDraw = true;
        this._raiseRemoveItem(item);
      },
      removeAll: function() {
        this.viewer._cancelPendingImages();
        var item;
        var i;
        for (i = 0;i < this._items.length; i++) {
          item = this._items[i];
          item.removeHandler("bounds-change", this._delegatedFigureSizes);
          item.removeHandler("clip-change", this._delegatedFigureSizes);
          item.destroy();
        }
        var removedItems = this._items;
        this._items = [];
        this._figureSizes();
        this._needsDraw = true;
        for (i = 0;i < removedItems.length; i++) {
          item = removedItems[i];
          this._raiseRemoveItem(item);
        }
      },
      resetItems: function() {
        for (var i = 0;i < this._items.length; i++) {
          this._items[i].reset();
        }
      },
      update: function(viewportChanged) {
        var animated = false;
        for (var i = 0;i < this._items.length; i++) {
          animated = this._items[i].update(viewportChanged) || animated;
        }
        return animated;
      },
      draw: function() {
        this.viewer.drawer.draw(this._items);
        this._needsDraw = false;
        this._items.forEach((item) => {
          this._needsDraw = item.setDrawn() || this._needsDraw;
        });
      },
      needsDraw: function() {
        for (var i = 0;i < this._items.length; i++) {
          if (this._items[i].needsDraw()) {
            return true;
          }
        }
        return this._needsDraw;
      },
      getHomeBounds: function() {
        return this._homeBounds.clone();
      },
      getContentFactor: function() {
        return this._contentFactor;
      },
      setAutoRefigureSizes: function(value) {
        this._autoRefigureSizes = value;
        if (value & this._needsSizesFigured) {
          this._figureSizes();
          this._needsSizesFigured = false;
        }
      },
      arrange: function(options) {
        options = options || {};
        var immediately = options.immediately || false;
        var layout = options.layout || $.DEFAULT_SETTINGS.collectionLayout;
        var rows = options.rows || $.DEFAULT_SETTINGS.collectionRows;
        var columns = options.columns || $.DEFAULT_SETTINGS.collectionColumns;
        var tileSize = options.tileSize || $.DEFAULT_SETTINGS.collectionTileSize;
        var tileMargin = options.tileMargin || $.DEFAULT_SETTINGS.collectionTileMargin;
        var increment = tileSize + tileMargin;
        var wrap;
        if (!options.rows && columns) {
          wrap = columns;
        } else {
          wrap = Math.ceil(this._items.length / rows);
        }
        var x = 0;
        var y = 0;
        var item, box, width, height, position;
        this.setAutoRefigureSizes(false);
        for (var i = 0;i < this._items.length; i++) {
          if (i && i % wrap === 0) {
            if (layout === "horizontal") {
              y += increment;
              x = 0;
            } else {
              x += increment;
              y = 0;
            }
          }
          item = this._items[i];
          box = item.getBounds();
          if (box.width > box.height) {
            width = tileSize;
          } else {
            width = tileSize * (box.width / box.height);
          }
          height = width * (box.height / box.width);
          position = new $.Point(x + (tileSize - width) / 2, y + (tileSize - height) / 2);
          item.setPosition(position, immediately);
          item.setWidth(width, immediately);
          if (layout === "horizontal") {
            x += increment;
          } else {
            y += increment;
          }
        }
        this.setAutoRefigureSizes(true);
      },
      _figureSizes: function() {
        var oldHomeBounds = this._homeBounds ? this._homeBounds.clone() : null;
        var oldContentSize = this._contentSize ? this._contentSize.clone() : null;
        var oldContentFactor = this._contentFactor || 0;
        if (!this._items.length) {
          this._homeBounds = new $.Rect(0, 0, 1, 1);
          this._contentSize = new $.Point(1, 1);
          this._contentFactor = 1;
        } else {
          var item = this._items[0];
          var bounds = item.getBounds();
          this._contentFactor = item.getContentSize().x / bounds.width;
          var clippedBounds = item.getClippedBounds().getBoundingBox();
          var left = clippedBounds.x;
          var top = clippedBounds.y;
          var right = clippedBounds.x + clippedBounds.width;
          var bottom = clippedBounds.y + clippedBounds.height;
          for (var i = 1;i < this._items.length; i++) {
            item = this._items[i];
            bounds = item.getBounds();
            this._contentFactor = Math.max(this._contentFactor, item.getContentSize().x / bounds.width);
            clippedBounds = item.getClippedBounds().getBoundingBox();
            left = Math.min(left, clippedBounds.x);
            top = Math.min(top, clippedBounds.y);
            right = Math.max(right, clippedBounds.x + clippedBounds.width);
            bottom = Math.max(bottom, clippedBounds.y + clippedBounds.height);
          }
          this._homeBounds = new $.Rect(left, top, right - left, bottom - top);
          this._contentSize = new $.Point(this._homeBounds.width * this._contentFactor, this._homeBounds.height * this._contentFactor);
        }
        if (this._contentFactor !== oldContentFactor || !this._homeBounds.equals(oldHomeBounds) || !this._contentSize.equals(oldContentSize)) {
          this.raiseEvent("metrics-change", {});
        }
      },
      _raiseRemoveItem: function(item) {
        this.raiseEvent("remove-item", { item });
      }
    });
  })(OpenSeadragon);
});

// node_modules/geotiff-tilesource/dist/basedecoder-DHcBySSe.js
function l(o, n) {
  let t = o.length - n, r = 0;
  do {
    for (let a = n;a > 0; a--)
      o[r + n] += o[r], r++;
    t -= n;
  } while (t > 0);
}
function d(o, n, t) {
  let r = 0, a = o.length;
  const i = a / t;
  for (;a > n; ) {
    for (let e = n;e > 0; --e)
      o[r + n] += o[r], ++r;
    a -= n;
  }
  const s = o.slice();
  for (let e = 0;e < i; ++e)
    for (let c = 0;c < t; ++c)
      o[t * e + c] = s[(t - c - 1) * i + e];
}
function f(o, n, t, r, a, i) {
  if (!n || n === 1)
    return o;
  for (let c = 0;c < a.length; ++c) {
    if (a[c] % 8 !== 0)
      throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");
    if (a[c] !== a[0])
      throw new Error("When decoding with predictor, all samples must have the same size.");
  }
  const s = a[0] / 8, e = i === 2 ? 1 : a.length;
  for (let c = 0;c < r && !(c * e * t * s >= o.byteLength); ++c) {
    let h;
    if (n === 2) {
      switch (a[0]) {
        case 8:
          h = new Uint8Array(o, c * e * t * s, e * t * s);
          break;
        case 16:
          h = new Uint16Array(o, c * e * t * s, e * t * s / 2);
          break;
        case 32:
          h = new Uint32Array(o, c * e * t * s, e * t * s / 4);
          break;
        default:
          throw new Error(`Predictor 2 not allowed with ${a[0]} bits per sample.`);
      }
      l(h, e);
    } else
      n === 3 && (h = new Uint8Array(o, c * e * t * s, e * t * s), d(h, e, s));
  }
  return o;
}

class g {
  async decode(n, t) {
    const r = await this.decodeBlock(t), a = n.Predictor || 1;
    if (a !== 1) {
      const i = !n.StripOffsets, s = i ? n.TileWidth : n.ImageWidth, e = i ? n.TileLength : n.RowsPerStrip || n.ImageLength;
      return f(r, a, s, e, n.BitsPerSample, n.PlanarConfiguration);
    }
    return r;
  }
}
var init_basedecoder_DHcBySSe = () => {};

// node_modules/geotiff-tilesource/dist/raw-CMGvRjfu.js
var exports_raw_CMGvRjfu = {};
__export(exports_raw_CMGvRjfu, {
  default: () => d2
});
var d2;
var init_raw_CMGvRjfu = __esm(() => {
  init_basedecoder_DHcBySSe();
  d2 = class d2 extends g {
    decodeBlock(e) {
      return e;
    }
  };
});

// node_modules/geotiff-tilesource/dist/lzw-LAGDNbSC.js
var exports_lzw_LAGDNbSC = {};
__export(exports_lzw_LAGDNbSC, {
  default: () => m
});
function x(c, o, r) {
  const i = o % 8, n = Math.floor(o / 8), h = 8 - i, g2 = o + r - (n + 1) * 8;
  let l2 = 8 * (n + 2) - (o + r);
  const w = (n + 2) * 8 - o;
  if (l2 = Math.max(0, l2), n >= c.length)
    return console.warn("ran off the end of the buffer before finding EOI_CODE (end on input code)"), p;
  let u = c[n] & 2 ** (8 - i) - 1;
  u <<= r - h;
  let s = u;
  if (n + 1 < c.length) {
    let f2 = c[n + 1] >>> l2;
    f2 <<= Math.max(0, r - w), s += f2;
  }
  if (g2 > 8 && n + 2 < c.length) {
    const f2 = (n + 3) * 8 - (o + r), t = c[n + 2] >>> f2;
    s += t;
  }
  return s;
}
function D(c, o) {
  for (let r = o.length - 1;r >= 0; r--)
    c.push(o[r]);
  return c;
}
function A(c) {
  const o = new Uint16Array(4093), r = new Uint8Array(4093);
  for (let e = 0;e <= 257; e++)
    o[e] = 4096, r[e] = e;
  let i = 258, n = B, h = 0;
  function g2() {
    i = 258, n = B;
  }
  function l2(e) {
    const a = x(e, h, n);
    return h += n, a;
  }
  function w(e, a) {
    return r[i] = a, o[i] = e, i++, i - 1;
  }
  function u(e) {
    const a = [];
    for (let y = e;y !== 4096; y = o[y])
      a.push(r[y]);
    return a;
  }
  const s = [];
  g2();
  const f2 = new Uint8Array(c);
  let t = l2(f2), d3;
  for (;t !== p; ) {
    if (t === E) {
      for (g2(), t = l2(f2);t === E; )
        t = l2(f2);
      if (t === p)
        break;
      if (t > E)
        throw new Error(`corrupted code at scanline ${t}`);
      {
        const e = u(t);
        D(s, e), d3 = t;
      }
    } else if (t < i) {
      const e = u(t);
      D(s, e), w(d3, e[e.length - 1]), d3 = t;
    } else {
      const e = u(d3);
      if (!e)
        throw new Error(`Bogus entry. Not in dictionary, ${d3} / ${i}, position: ${h}`);
      D(s, e), s.push(e[e.length - 1]), w(d3, e[e.length - 1]), d3 = t;
    }
    i + 1 >= 2 ** n && (n === k ? d3 = undefined : n++), t = l2(f2);
  }
  return new Uint8Array(s);
}
var B = 9, E = 256, p = 257, k = 12, m;
var init_lzw_LAGDNbSC = __esm(() => {
  init_basedecoder_DHcBySSe();
  m = class m extends g {
    decodeBlock(o) {
      return A(o).buffer;
    }
  };
});

// node_modules/geotiff-tilesource/dist/jpeg-BAgeD1d3.js
var exports_jpeg_BAgeD1d3 = {};
__export(exports_jpeg_BAgeD1d3, {
  default: () => fe
});
function ne(q, l2) {
  let o = 0;
  const u = [];
  let T = 16;
  for (;T > 0 && !q[T - 1]; )
    --T;
  u.push({ children: [], index: 0 });
  let w = u[0], C;
  for (let t = 0;t < T; t++) {
    for (let h = 0;h < q[t]; h++) {
      for (w = u.pop(), w.children[w.index] = l2[o];w.index > 0; )
        w = u.pop();
      for (w.index++, u.push(w);u.length <= t; )
        u.push(C = { children: [], index: 0 }), w.children[w.index] = C.children, w = C;
      o++;
    }
    t + 1 < T && (u.push(C = { children: [], index: 0 }), w.children[w.index] = C.children, w = C);
  }
  return u[0].children;
}
function ce(q, l2, o, u, T, w, C, t, h) {
  const { mcusPerLine: F, progressive: c } = o, r = l2;
  let b = l2, i = 0, d3 = 0;
  function m2() {
    if (d3 > 0)
      return d3--, i >> d3 & 1;
    if (i = q[b++], i === 255) {
      const a = q[b++];
      if (a)
        throw new Error(`unexpected marker: ${(i << 8 | a).toString(16)}`);
    }
    return d3 = 7, i >>> 7;
  }
  function x2(a) {
    let f2 = a, p2;
    for (;(p2 = m2()) !== null; ) {
      if (f2 = f2[p2], typeof f2 == "number")
        return f2;
      if (typeof f2 != "object")
        throw new Error("invalid huffman sequence");
    }
    return null;
  }
  function E2(a) {
    let f2 = a, p2 = 0;
    for (;f2 > 0; ) {
      const L = m2();
      if (L === null)
        return;
      p2 = p2 << 1 | L, --f2;
    }
    return p2;
  }
  function k2(a) {
    const f2 = E2(a);
    return f2 >= 1 << a - 1 ? f2 : f2 + (-1 << a) + 1;
  }
  function A2(a, f2) {
    const p2 = x2(a.huffmanTableDC), L = p2 === 0 ? 0 : k2(p2);
    a.pred += L, f2[0] = a.pred;
    let D2 = 1;
    for (;D2 < 64; ) {
      const P = x2(a.huffmanTableAC), y = P & 15, S = P >> 4;
      if (y === 0) {
        if (S < 15)
          break;
        D2 += 16;
      } else {
        D2 += S;
        const I = O[D2];
        f2[I] = k2(y), D2++;
      }
    }
  }
  function v(a, f2) {
    const p2 = x2(a.huffmanTableDC), L = p2 === 0 ? 0 : k2(p2) << h;
    a.pred += L, f2[0] = a.pred;
  }
  function s(a, f2) {
    f2[0] |= m2() << h;
  }
  let n = 0;
  function g2(a, f2) {
    if (n > 0) {
      n--;
      return;
    }
    let p2 = w;
    const L = C;
    for (;p2 <= L; ) {
      const D2 = x2(a.huffmanTableAC), P = D2 & 15, y = D2 >> 4;
      if (P === 0) {
        if (y < 15) {
          n = E2(y) + (1 << y) - 1;
          break;
        }
        p2 += 16;
      } else {
        p2 += y;
        const S = O[p2];
        f2[S] = k2(P) * (1 << h), p2++;
      }
    }
  }
  let e = 0, _;
  function te(a, f2) {
    let p2 = w;
    const L = C;
    let D2 = 0;
    for (;p2 <= L; ) {
      const P = O[p2], y = f2[P] < 0 ? -1 : 1;
      switch (e) {
        case 0: {
          const S = x2(a.huffmanTableAC), I = S & 15;
          if (D2 = S >> 4, I === 0)
            D2 < 15 ? (n = E2(D2) + (1 << D2), e = 4) : (D2 = 16, e = 1);
          else {
            if (I !== 1)
              throw new Error("invalid ACn encoding");
            _ = k2(I), e = D2 ? 2 : 3;
          }
          continue;
        }
        case 1:
        case 2:
          f2[P] ? f2[P] += (m2() << h) * y : (D2--, D2 === 0 && (e = e === 2 ? 3 : 0));
          break;
        case 3:
          f2[P] ? f2[P] += (m2() << h) * y : (f2[P] = _ << h, e = 0);
          break;
        case 4:
          f2[P] && (f2[P] += (m2() << h) * y);
          break;
      }
      p2++;
    }
    e === 4 && (n--, n === 0 && (e = 0));
  }
  function se(a, f2, p2, L, D2) {
    const P = p2 / F | 0, y = p2 % F, S = P * a.v + L, I = y * a.h + D2;
    f2(a, a.blocks[S][I]);
  }
  function oe(a, f2, p2) {
    const L = p2 / a.blocksPerLine | 0, D2 = p2 % a.blocksPerLine;
    f2(a, a.blocks[L][D2]);
  }
  const V = u.length;
  let U, j, G, X, B2, H;
  c ? w === 0 ? H = t === 0 ? v : s : H = t === 0 ? g2 : te : H = A2;
  let M = 0, z, J;
  V === 1 ? J = u[0].blocksPerLine * u[0].blocksPerColumn : J = F * o.mcusPerColumn;
  const ee = T || J;
  for (;M < J; ) {
    for (j = 0;j < V; j++)
      u[j].pred = 0;
    if (n = 0, V === 1)
      for (U = u[0], B2 = 0;B2 < ee; B2++)
        oe(U, H, M), M++;
    else
      for (B2 = 0;B2 < ee; B2++) {
        for (j = 0;j < V; j++) {
          U = u[j];
          const { h: a, v: f2 } = U;
          for (G = 0;G < f2; G++)
            for (X = 0;X < a; X++)
              se(U, H, M, G, X);
        }
        if (M++, M === J)
          break;
      }
    if (d3 = 0, z = q[b] << 8 | q[b + 1], z < 65280)
      throw new Error("marker was not found");
    if (z >= 65488 && z <= 65495)
      b += 2;
    else
      break;
  }
  return b - r;
}
function ie(q, l2) {
  const o = [], { blocksPerLine: u, blocksPerColumn: T } = l2, w = u << 3, C = new Int32Array(64), t = new Uint8Array(64);
  function h(F, c, r) {
    const b = l2.quantizationTable;
    let i, d3, m2, x2, E2, k2, A2, v, s;
    const n = r;
    let g2;
    for (g2 = 0;g2 < 64; g2++)
      n[g2] = F[g2] * b[g2];
    for (g2 = 0;g2 < 8; ++g2) {
      const e = 8 * g2;
      if (n[1 + e] === 0 && n[2 + e] === 0 && n[3 + e] === 0 && n[4 + e] === 0 && n[5 + e] === 0 && n[6 + e] === 0 && n[7 + e] === 0) {
        s = R * n[0 + e] + 512 >> 10, n[0 + e] = s, n[1 + e] = s, n[2 + e] = s, n[3 + e] = s, n[4 + e] = s, n[5 + e] = s, n[6 + e] = s, n[7 + e] = s;
        continue;
      }
      i = R * n[0 + e] + 128 >> 8, d3 = R * n[4 + e] + 128 >> 8, m2 = n[2 + e], x2 = n[6 + e], E2 = K * (n[1 + e] - n[7 + e]) + 128 >> 8, v = K * (n[1 + e] + n[7 + e]) + 128 >> 8, k2 = n[3 + e] << 4, A2 = n[5 + e] << 4, s = i - d3 + 1 >> 1, i = i + d3 + 1 >> 1, d3 = s, s = m2 * W + x2 * Q + 128 >> 8, m2 = m2 * Q - x2 * W + 128 >> 8, x2 = s, s = E2 - A2 + 1 >> 1, E2 = E2 + A2 + 1 >> 1, A2 = s, s = v + k2 + 1 >> 1, k2 = v - k2 + 1 >> 1, v = s, s = i - x2 + 1 >> 1, i = i + x2 + 1 >> 1, x2 = s, s = d3 - m2 + 1 >> 1, d3 = d3 + m2 + 1 >> 1, m2 = s, s = E2 * N + v * $ + 2048 >> 12, E2 = E2 * $ - v * N + 2048 >> 12, v = s, s = k2 * Z + A2 * Y + 2048 >> 12, k2 = k2 * Y - A2 * Z + 2048 >> 12, A2 = s, n[0 + e] = i + v, n[7 + e] = i - v, n[1 + e] = d3 + A2, n[6 + e] = d3 - A2, n[2 + e] = m2 + k2, n[5 + e] = m2 - k2, n[3 + e] = x2 + E2, n[4 + e] = x2 - E2;
    }
    for (g2 = 0;g2 < 8; ++g2) {
      const e = g2;
      if (n[1 * 8 + e] === 0 && n[2 * 8 + e] === 0 && n[3 * 8 + e] === 0 && n[4 * 8 + e] === 0 && n[5 * 8 + e] === 0 && n[6 * 8 + e] === 0 && n[7 * 8 + e] === 0) {
        s = R * r[g2 + 0] + 8192 >> 14, n[0 * 8 + e] = s, n[1 * 8 + e] = s, n[2 * 8 + e] = s, n[3 * 8 + e] = s, n[4 * 8 + e] = s, n[5 * 8 + e] = s, n[6 * 8 + e] = s, n[7 * 8 + e] = s;
        continue;
      }
      i = R * n[0 * 8 + e] + 2048 >> 12, d3 = R * n[4 * 8 + e] + 2048 >> 12, m2 = n[2 * 8 + e], x2 = n[6 * 8 + e], E2 = K * (n[1 * 8 + e] - n[7 * 8 + e]) + 2048 >> 12, v = K * (n[1 * 8 + e] + n[7 * 8 + e]) + 2048 >> 12, k2 = n[3 * 8 + e], A2 = n[5 * 8 + e], s = i - d3 + 1 >> 1, i = i + d3 + 1 >> 1, d3 = s, s = m2 * W + x2 * Q + 2048 >> 12, m2 = m2 * Q - x2 * W + 2048 >> 12, x2 = s, s = E2 - A2 + 1 >> 1, E2 = E2 + A2 + 1 >> 1, A2 = s, s = v + k2 + 1 >> 1, k2 = v - k2 + 1 >> 1, v = s, s = i - x2 + 1 >> 1, i = i + x2 + 1 >> 1, x2 = s, s = d3 - m2 + 1 >> 1, d3 = d3 + m2 + 1 >> 1, m2 = s, s = E2 * N + v * $ + 2048 >> 12, E2 = E2 * $ - v * N + 2048 >> 12, v = s, s = k2 * Z + A2 * Y + 2048 >> 12, k2 = k2 * Y - A2 * Z + 2048 >> 12, A2 = s, n[0 * 8 + e] = i + v, n[7 * 8 + e] = i - v, n[1 * 8 + e] = d3 + A2, n[6 * 8 + e] = d3 - A2, n[2 * 8 + e] = m2 + k2, n[5 * 8 + e] = m2 - k2, n[3 * 8 + e] = x2 + E2, n[4 * 8 + e] = x2 - E2;
    }
    for (g2 = 0;g2 < 64; ++g2) {
      const e = 128 + (n[g2] + 8 >> 4);
      e < 0 ? c[g2] = 0 : e > 255 ? c[g2] = 255 : c[g2] = e;
    }
  }
  for (let F = 0;F < T; F++) {
    const c = F << 3;
    for (let r = 0;r < 8; r++)
      o.push(new Uint8Array(w));
    for (let r = 0;r < u; r++) {
      h(l2.blocks[F][r], t, C);
      let b = 0;
      const i = r << 3;
      for (let d3 = 0;d3 < 8; d3++) {
        const m2 = o[c + d3];
        for (let x2 = 0;x2 < 8; x2++)
          m2[i + x2] = t[b++];
      }
    }
  }
  return o;
}

class le {
  constructor() {
    this.jfif = null, this.adobe = null, this.quantizationTables = [], this.huffmanTablesAC = [], this.huffmanTablesDC = [], this.resetFrames();
  }
  resetFrames() {
    this.frames = [];
  }
  parse(l2) {
    let o = 0;
    function u() {
      const t = l2[o] << 8 | l2[o + 1];
      return o += 2, t;
    }
    function T() {
      const t = u(), h = l2.subarray(o, o + t - 2);
      return o += h.length, h;
    }
    function w(t) {
      let h = 0, F = 0, c, r;
      for (r in t.components)
        t.components.hasOwnProperty(r) && (c = t.components[r], h < c.h && (h = c.h), F < c.v && (F = c.v));
      const b = Math.ceil(t.samplesPerLine / 8 / h), i = Math.ceil(t.scanLines / 8 / F);
      for (r in t.components)
        if (t.components.hasOwnProperty(r)) {
          c = t.components[r];
          const d3 = Math.ceil(Math.ceil(t.samplesPerLine / 8) * c.h / h), m2 = Math.ceil(Math.ceil(t.scanLines / 8) * c.v / F), x2 = b * c.h, E2 = i * c.v, k2 = [];
          for (let A2 = 0;A2 < E2; A2++) {
            const v = [];
            for (let s = 0;s < x2; s++)
              v.push(new Int32Array(64));
            k2.push(v);
          }
          c.blocksPerLine = d3, c.blocksPerColumn = m2, c.blocks = k2;
        }
      t.maxH = h, t.maxV = F, t.mcusPerLine = b, t.mcusPerColumn = i;
    }
    let C = u();
    if (C !== 65496)
      throw new Error("SOI not found");
    for (C = u();C !== 65497; ) {
      switch (C) {
        case 65280:
          break;
        case 65504:
        case 65505:
        case 65506:
        case 65507:
        case 65508:
        case 65509:
        case 65510:
        case 65511:
        case 65512:
        case 65513:
        case 65514:
        case 65515:
        case 65516:
        case 65517:
        case 65518:
        case 65519:
        case 65534: {
          const t = T();
          C === 65504 && t[0] === 74 && t[1] === 70 && t[2] === 73 && t[3] === 70 && t[4] === 0 && (this.jfif = {
            version: { major: t[5], minor: t[6] },
            densityUnits: t[7],
            xDensity: t[8] << 8 | t[9],
            yDensity: t[10] << 8 | t[11],
            thumbWidth: t[12],
            thumbHeight: t[13],
            thumbData: t.subarray(14, 14 + 3 * t[12] * t[13])
          }), C === 65518 && t[0] === 65 && t[1] === 100 && t[2] === 111 && t[3] === 98 && t[4] === 101 && t[5] === 0 && (this.adobe = {
            version: t[6],
            flags0: t[7] << 8 | t[8],
            flags1: t[9] << 8 | t[10],
            transformCode: t[11]
          });
          break;
        }
        case 65499: {
          const h = u() + o - 2;
          for (;o < h; ) {
            const F = l2[o++], c = new Int32Array(64);
            if (F >> 4)
              if (F >> 4 === 1)
                for (let r = 0;r < 64; r++) {
                  const b = O[r];
                  c[b] = u();
                }
              else
                throw new Error("DQT: invalid table spec");
            else
              for (let r = 0;r < 64; r++) {
                const b = O[r];
                c[b] = l2[o++];
              }
            this.quantizationTables[F & 15] = c;
          }
          break;
        }
        case 65472:
        case 65473:
        case 65474: {
          u();
          const t = {
            extended: C === 65473,
            progressive: C === 65474,
            precision: l2[o++],
            scanLines: u(),
            samplesPerLine: u(),
            components: {},
            componentsOrder: []
          }, h = l2[o++];
          let F;
          for (let c = 0;c < h; c++) {
            F = l2[o];
            const r = l2[o + 1] >> 4, b = l2[o + 1] & 15, i = l2[o + 2];
            t.componentsOrder.push(F), t.components[F] = {
              h: r,
              v: b,
              quantizationIdx: i
            }, o += 3;
          }
          w(t), this.frames.push(t);
          break;
        }
        case 65476: {
          const t = u();
          for (let h = 2;h < t; ) {
            const F = l2[o++], c = new Uint8Array(16);
            let r = 0;
            for (let i = 0;i < 16; i++, o++)
              c[i] = l2[o], r += c[i];
            const b = new Uint8Array(r);
            for (let i = 0;i < r; i++, o++)
              b[i] = l2[o];
            h += 17 + r, F >> 4 ? this.huffmanTablesAC[F & 15] = ne(c, b) : this.huffmanTablesDC[F & 15] = ne(c, b);
          }
          break;
        }
        case 65501:
          u(), this.resetInterval = u();
          break;
        case 65498: {
          u();
          const t = l2[o++], h = [], F = this.frames[0];
          for (let d3 = 0;d3 < t; d3++) {
            const m2 = F.components[l2[o++]], x2 = l2[o++];
            m2.huffmanTableDC = this.huffmanTablesDC[x2 >> 4], m2.huffmanTableAC = this.huffmanTablesAC[x2 & 15], h.push(m2);
          }
          const c = l2[o++], r = l2[o++], b = l2[o++], i = ce(l2, o, F, h, this.resetInterval, c, r, b >> 4, b & 15);
          o += i;
          break;
        }
        case 65535:
          l2[o] !== 255 && o--;
          break;
        default:
          if (l2[o - 3] === 255 && l2[o - 2] >= 192 && l2[o - 2] <= 254) {
            o -= 3;
            break;
          }
          throw new Error(`unknown JPEG marker ${C.toString(16)}`);
      }
      C = u();
    }
  }
  getResult() {
    const { frames: l2 } = this;
    if (this.frames.length === 0)
      throw new Error("no frames were decoded");
    this.frames.length > 1 && console.warn("more than one frame is not supported");
    for (let c = 0;c < this.frames.length; c++) {
      const r = this.frames[c].components;
      for (const b of Object.keys(r))
        r[b].quantizationTable = this.quantizationTables[r[b].quantizationIdx], delete r[b].quantizationIdx;
    }
    const o = l2[0], { components: u, componentsOrder: T } = o, w = [], C = o.samplesPerLine, t = o.scanLines;
    for (let c = 0;c < T.length; c++) {
      const r = u[T[c]];
      w.push({
        lines: ie(o, r),
        scaleX: r.h / o.maxH,
        scaleY: r.v / o.maxV
      });
    }
    const h = new Uint8Array(C * t * w.length);
    let F = 0;
    for (let c = 0;c < t; ++c)
      for (let r = 0;r < C; ++r)
        for (let b = 0;b < w.length; ++b) {
          const i = w[b];
          h[F] = i.lines[0 | c * i.scaleY][0 | r * i.scaleX], ++F;
        }
    return h;
  }
}
var O, Y = 4017, Z = 799, $ = 3406, N = 2276, Q = 1567, W = 3784, R = 5793, K = 2896, fe;
var init_jpeg_BAgeD1d3 = __esm(() => {
  init_basedecoder_DHcBySSe();
  O = new Int32Array([
    0,
    1,
    8,
    16,
    9,
    2,
    3,
    10,
    17,
    24,
    32,
    25,
    18,
    11,
    4,
    5,
    12,
    19,
    26,
    33,
    40,
    48,
    41,
    34,
    27,
    20,
    13,
    6,
    7,
    14,
    21,
    28,
    35,
    42,
    49,
    56,
    57,
    50,
    43,
    36,
    29,
    22,
    15,
    23,
    30,
    37,
    44,
    51,
    58,
    59,
    52,
    45,
    38,
    31,
    39,
    46,
    53,
    60,
    61,
    54,
    47,
    55,
    62,
    63
  ]);
  fe = class fe extends g {
    constructor(l2) {
      super(), this.reader = new le, l2.JPEGTables && this.reader.parse(l2.JPEGTables);
    }
    decodeBlock(l2) {
      return this.reader.resetFrames(), this.reader.parse(new Uint8Array(l2)), this.reader.getResult().buffer;
    }
  };
});

// node_modules/geotiff-tilesource/dist/pako.esm-CB1uQYY0.js
function he(e) {
  let i = e.length;
  for (;--i >= 0; )
    e[i] = 0;
}
function Ye(e, i, t, n, r) {
  this.static_tree = e, this.extra_bits = i, this.extra_base = t, this.elems = n, this.max_length = r, this.has_stree = e && e.length;
}
function Ge(e, i) {
  this.dyn_tree = e, this.max_code = 0, this.stat_desc = i;
}
function F(e, i, t, n, r) {
  this.good_length = e, this.max_lazy = i, this.nice_length = t, this.max_chain = n, this.func = r;
}
function Kn() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Be, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(Nn * 2), this.dyn_dtree = new Uint16Array((2 * In + 1) * 2), this.bl_tree = new Uint16Array((2 * On + 1) * 2), Y2(this.dyn_ltree), Y2(this.dyn_dtree), Y2(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(Ln + 1), this.heap = new Uint16Array(2 * ft + 1), Y2(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * ft + 1), Y2(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
function da() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
}
function xt(e) {
  this.options = Ke.assign({
    level: ga,
    method: xa,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: pa
  }, e || {});
  let i = this.options;
  i.raw && i.windowBits > 0 ? i.windowBits = -i.windowBits : i.gzip && i.windowBits > 0 && i.windowBits < 16 && (i.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new zi, this.strm.avail_out = 0;
  let t = ge.deflateInit2(this.strm, i.level, i.method, i.windowBits, i.memLevel, i.strategy);
  if (t !== Me)
    throw new Error(oe[t]);
  if (i.header && ge.deflateSetHeader(this.strm, i.header), i.dictionary) {
    let n;
    if (typeof i.dictionary == "string" ? n = Se.string2buf(i.dictionary) : Ti.call(i.dictionary) === "[object ArrayBuffer]" ? n = new Uint8Array(i.dictionary) : n = i.dictionary, t = ge.deflateSetDictionary(this.strm, n), t !== Me)
      throw new Error(oe[t]);
    this._dict_set = true;
  }
}
function Ua() {
  this.strm = null, this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
function qa() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
}
function De(e) {
  this.options = Ke.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, e || {});
  const i = this.options;
  i.raw && i.windowBits >= 0 && i.windowBits < 16 && (i.windowBits = -i.windowBits, i.windowBits === 0 && (i.windowBits = -15)), i.windowBits >= 0 && i.windowBits < 16 && !(e && e.windowBits) && (i.windowBits += 32), i.windowBits > 15 && i.windowBits < 48 && (i.windowBits & 15 || (i.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new zi, this.strm.avail_out = 0;
  let t = X.inflateInit2(this.strm, i.windowBits);
  if (t !== Ae)
    throw new Error(oe[t]);
  if (this.header = new er, X.inflateGetHeader(this.strm, this.header), i.dictionary && (typeof i.dictionary == "string" ? i.dictionary = Se.string2buf(i.dictionary) : Mi.call(i.dictionary) === "[object ArrayBuffer]" && (i.dictionary = new Uint8Array(i.dictionary)), i.raw && (t = X.inflateSetDictionary(this.strm, i.dictionary), t !== Ae)))
    throw new Error(oe[t]);
}
function kt(e, i) {
  const t = new De(i);
  if (t.push(e), t.err)
    throw t.msg || oe[t.err];
  return t.result;
}
function rr(e, i) {
  return i = i || {}, i.raw = true, kt(e, i);
}
var Hi = 0, li = 1, Bi = 2, Ki = 3, Pi = 258, ut = 29, ze = 256, xe, le2 = 30, wt = 19, oi, Q2 = 15, Xe = 16, Xi = 7, bt = 256, fi = 16, _i = 17, hi = 18, rt, $e, Yi, di, Gi = 512, P, be, ke, ve, gt, Fe, si, ci, ui, wi = (e) => e < 256 ? ke[e] : ke[256 + (e >>> 7)], Ee = (e, i) => {
  e.pending_buf[e.pending++] = i & 255, e.pending_buf[e.pending++] = i >>> 8 & 255;
}, N2 = (e, i, t) => {
  e.bi_valid > Xe - t ? (e.bi_buf |= i << e.bi_valid & 65535, Ee(e, e.bi_buf), e.bi_buf = i >> Xe - e.bi_valid, e.bi_valid += t - Xe) : (e.bi_buf |= i << e.bi_valid & 65535, e.bi_valid += t);
}, M = (e, i, t) => {
  N2(e, t[i * 2], t[i * 2 + 1]);
}, bi = (e, i) => {
  let t = 0;
  do
    t |= e & 1, e >>>= 1, t <<= 1;
  while (--i > 0);
  return t >>> 1;
}, ji = (e) => {
  e.bi_valid === 16 ? (Ee(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = e.bi_buf & 255, e.bi_buf >>= 8, e.bi_valid -= 8);
}, Wi = (e, i) => {
  const { dyn_tree: t, max_code: n } = i, r = i.stat_desc.static_tree, a = i.stat_desc.has_stree, f2 = i.stat_desc.extra_bits, o = i.stat_desc.extra_base, c = i.stat_desc.max_length;
  let l2, _, y, s, h, u, R2 = 0;
  for (s = 0;s <= Q2; s++)
    e.bl_count[s] = 0;
  for (t[e.heap[e.heap_max] * 2 + 1] = 0, l2 = e.heap_max + 1;l2 < oi; l2++)
    _ = e.heap[l2], s = t[t[_ * 2 + 1] * 2 + 1] + 1, s > c && (s = c, R2++), t[_ * 2 + 1] = s, !(_ > n) && (e.bl_count[s]++, h = 0, _ >= o && (h = f2[_ - o]), u = t[_ * 2], e.opt_len += u * (s + h), a && (e.static_len += u * (r[_ * 2 + 1] + h)));
  if (R2 !== 0) {
    do {
      for (s = c - 1;e.bl_count[s] === 0; )
        s--;
      e.bl_count[s]--, e.bl_count[s + 1] += 2, e.bl_count[c]--, R2 -= 2;
    } while (R2 > 0);
    for (s = c;s !== 0; s--)
      for (_ = e.bl_count[s];_ !== 0; )
        y = e.heap[--l2], !(y > n) && (t[y * 2 + 1] !== s && (e.opt_len += (s - t[y * 2 + 1]) * t[y * 2], t[y * 2 + 1] = s), _--);
  }
}, gi = (e, i, t) => {
  const n = new Array(Q2 + 1);
  let r = 0, a, f2;
  for (a = 1;a <= Q2; a++)
    r = r + t[a - 1] << 1, n[a] = r;
  for (f2 = 0;f2 <= i; f2++) {
    let o = e[f2 * 2 + 1];
    o !== 0 && (e[f2 * 2] = bi(n[o]++, o));
  }
}, Vi = () => {
  let e, i, t, n, r;
  const a = new Array(Q2 + 1);
  for (t = 0, n = 0;n < ut - 1; n++)
    for (gt[n] = t, e = 0;e < 1 << rt[n]; e++)
      ve[t++] = n;
  for (ve[t - 1] = n, r = 0, n = 0;n < 16; n++)
    for (Fe[n] = r, e = 0;e < 1 << $e[n]; e++)
      ke[r++] = n;
  for (r >>= 7;n < le2; n++)
    for (Fe[n] = r << 7, e = 0;e < 1 << $e[n] - 7; e++)
      ke[256 + r++] = n;
  for (i = 0;i <= Q2; i++)
    a[i] = 0;
  for (e = 0;e <= 143; )
    P[e * 2 + 1] = 8, e++, a[8]++;
  for (;e <= 255; )
    P[e * 2 + 1] = 9, e++, a[9]++;
  for (;e <= 279; )
    P[e * 2 + 1] = 7, e++, a[7]++;
  for (;e <= 287; )
    P[e * 2 + 1] = 8, e++, a[8]++;
  for (gi(P, xe + 1, a), e = 0;e < le2; e++)
    be[e * 2 + 1] = 5, be[e * 2] = bi(e, 5);
  si = new Ye(P, rt, ze + 1, xe, Q2), ci = new Ye(be, $e, 0, le2, Q2), ui = new Ye(new Array(0), Yi, 0, wt, Xi);
}, pi = (e) => {
  let i;
  for (i = 0;i < xe; i++)
    e.dyn_ltree[i * 2] = 0;
  for (i = 0;i < le2; i++)
    e.dyn_dtree[i * 2] = 0;
  for (i = 0;i < wt; i++)
    e.bl_tree[i * 2] = 0;
  e.dyn_ltree[bt * 2] = 1, e.opt_len = e.static_len = 0, e.sym_next = e.matches = 0;
}, xi = (e) => {
  e.bi_valid > 8 ? Ee(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0;
}, Et = (e, i, t, n) => {
  const r = i * 2, a = t * 2;
  return e[r] < e[a] || e[r] === e[a] && n[i] <= n[t];
}, je = (e, i, t) => {
  const n = e.heap[t];
  let r = t << 1;
  for (;r <= e.heap_len && (r < e.heap_len && Et(i, e.heap[r + 1], e.heap[r], e.depth) && r++, !Et(i, n, e.heap[r], e.depth)); )
    e.heap[t] = e.heap[r], t = r, r <<= 1;
  e.heap[t] = n;
}, yt = (e, i, t) => {
  let n, r, a = 0, f2, o;
  if (e.sym_next !== 0)
    do
      n = e.pending_buf[e.sym_buf + a++] & 255, n += (e.pending_buf[e.sym_buf + a++] & 255) << 8, r = e.pending_buf[e.sym_buf + a++], n === 0 ? M(e, r, i) : (f2 = ve[r], M(e, f2 + ze + 1, i), o = rt[f2], o !== 0 && (r -= gt[f2], N2(e, r, o)), n--, f2 = wi(n), M(e, f2, t), o = $e[f2], o !== 0 && (n -= Fe[f2], N2(e, n, o)));
    while (a < e.sym_next);
  M(e, bt, i);
}, lt = (e, i) => {
  const t = i.dyn_tree, n = i.stat_desc.static_tree, r = i.stat_desc.has_stree, a = i.stat_desc.elems;
  let f2, o, c = -1, l2;
  for (e.heap_len = 0, e.heap_max = oi, f2 = 0;f2 < a; f2++)
    t[f2 * 2] !== 0 ? (e.heap[++e.heap_len] = c = f2, e.depth[f2] = 0) : t[f2 * 2 + 1] = 0;
  for (;e.heap_len < 2; )
    l2 = e.heap[++e.heap_len] = c < 2 ? ++c : 0, t[l2 * 2] = 1, e.depth[l2] = 0, e.opt_len--, r && (e.static_len -= n[l2 * 2 + 1]);
  for (i.max_code = c, f2 = e.heap_len >> 1;f2 >= 1; f2--)
    je(e, t, f2);
  l2 = a;
  do
    f2 = e.heap[1], e.heap[1] = e.heap[e.heap_len--], je(e, t, 1), o = e.heap[1], e.heap[--e.heap_max] = f2, e.heap[--e.heap_max] = o, t[l2 * 2] = t[f2 * 2] + t[o * 2], e.depth[l2] = (e.depth[f2] >= e.depth[o] ? e.depth[f2] : e.depth[o]) + 1, t[f2 * 2 + 1] = t[o * 2 + 1] = l2, e.heap[1] = l2++, je(e, t, 1);
  while (e.heap_len >= 2);
  e.heap[--e.heap_max] = e.heap[1], Wi(e, i), gi(t, c, e.bl_count);
}, mt = (e, i, t) => {
  let n, r = -1, a, f2 = i[0 * 2 + 1], o = 0, c = 7, l2 = 4;
  for (f2 === 0 && (c = 138, l2 = 3), i[(t + 1) * 2 + 1] = 65535, n = 0;n <= t; n++)
    a = f2, f2 = i[(n + 1) * 2 + 1], !(++o < c && a === f2) && (o < l2 ? e.bl_tree[a * 2] += o : a !== 0 ? (a !== r && e.bl_tree[a * 2]++, e.bl_tree[fi * 2]++) : o <= 10 ? e.bl_tree[_i * 2]++ : e.bl_tree[hi * 2]++, o = 0, r = a, f2 === 0 ? (c = 138, l2 = 3) : a === f2 ? (c = 6, l2 = 3) : (c = 7, l2 = 4));
}, St = (e, i, t) => {
  let n, r = -1, a, f2 = i[0 * 2 + 1], o = 0, c = 7, l2 = 4;
  for (f2 === 0 && (c = 138, l2 = 3), n = 0;n <= t; n++)
    if (a = f2, f2 = i[(n + 1) * 2 + 1], !(++o < c && a === f2)) {
      if (o < l2)
        do
          M(e, a, e.bl_tree);
        while (--o !== 0);
      else
        a !== 0 ? (a !== r && (M(e, a, e.bl_tree), o--), M(e, fi, e.bl_tree), N2(e, o - 3, 2)) : o <= 10 ? (M(e, _i, e.bl_tree), N2(e, o - 3, 3)) : (M(e, hi, e.bl_tree), N2(e, o - 11, 7));
      o = 0, r = a, f2 === 0 ? (c = 138, l2 = 3) : a === f2 ? (c = 6, l2 = 3) : (c = 7, l2 = 4);
    }
}, Ji = (e) => {
  let i;
  for (mt(e, e.dyn_ltree, e.l_desc.max_code), mt(e, e.dyn_dtree, e.d_desc.max_code), lt(e, e.bl_desc), i = wt - 1;i >= 3 && e.bl_tree[di[i] * 2 + 1] === 0; i--)
    ;
  return e.opt_len += 3 * (i + 1) + 5 + 5 + 4, i;
}, Qi = (e, i, t, n) => {
  let r;
  for (N2(e, i - 257, 5), N2(e, t - 1, 5), N2(e, n - 4, 4), r = 0;r < n; r++)
    N2(e, e.bl_tree[di[r] * 2 + 1], 3);
  St(e, e.dyn_ltree, i - 1), St(e, e.dyn_dtree, t - 1);
}, qi = (e) => {
  let i = 4093624447, t;
  for (t = 0;t <= 31; t++, i >>>= 1)
    if (i & 1 && e.dyn_ltree[t * 2] !== 0)
      return 0;
  if (e.dyn_ltree[9 * 2] !== 0 || e.dyn_ltree[10 * 2] !== 0 || e.dyn_ltree[13 * 2] !== 0)
    return 1;
  for (t = 32;t < ze; t++)
    if (e.dyn_ltree[t * 2] !== 0)
      return 1;
  return 0;
}, At = false, en = (e) => {
  At || (Vi(), At = true), e.l_desc = new Ge(e.dyn_ltree, si), e.d_desc = new Ge(e.dyn_dtree, ci), e.bl_desc = new Ge(e.bl_tree, ui), e.bi_buf = 0, e.bi_valid = 0, pi(e);
}, ki = (e, i, t, n) => {
  N2(e, (Hi << 1) + (n ? 1 : 0), 3), xi(e), Ee(e, t), Ee(e, ~t), t && e.pending_buf.set(e.window.subarray(i, i + t), e.pending), e.pending += t;
}, tn = (e) => {
  N2(e, li << 1, 3), M(e, bt, P), ji(e);
}, nn = (e, i, t, n) => {
  let r, a, f2 = 0;
  e.level > 0 ? (e.strm.data_type === 2 && (e.strm.data_type = qi(e)), lt(e, e.l_desc), lt(e, e.d_desc), f2 = Ji(e), r = e.opt_len + 3 + 7 >>> 3, a = e.static_len + 3 + 7 >>> 3, a <= r && (r = a)) : r = a = t + 5, t + 4 <= r && i !== -1 ? ki(e, i, t, n) : e.strategy === 4 || a === r ? (N2(e, (li << 1) + (n ? 1 : 0), 3), yt(e, P, be)) : (N2(e, (Bi << 1) + (n ? 1 : 0), 3), Qi(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, f2 + 1), yt(e, e.dyn_ltree, e.dyn_dtree)), pi(e), n && xi(e);
}, an = (e, i, t) => (e.pending_buf[e.sym_buf + e.sym_next++] = i, e.pending_buf[e.sym_buf + e.sym_next++] = i >> 8, e.pending_buf[e.sym_buf + e.sym_next++] = t, i === 0 ? e.dyn_ltree[t * 2]++ : (e.matches++, i--, e.dyn_ltree[(ve[t] + ze + 1) * 2]++, e.dyn_dtree[wi(i) * 2]++), e.sym_next === e.sym_end), rn, ln, on, fn, _n, hn, dn = (e, i, t, n) => {
  let r = e & 65535 | 0, a = e >>> 16 & 65535 | 0, f2 = 0;
  for (;t !== 0; ) {
    f2 = t > 2000 ? 2000 : t, t -= f2;
    do
      r = r + i[n++] | 0, a = a + r | 0;
    while (--f2);
    r %= 65521, a %= 65521;
  }
  return r | a << 16 | 0;
}, ye, sn = () => {
  let e, i = [];
  for (var t = 0;t < 256; t++) {
    e = t;
    for (var n = 0;n < 8; n++)
      e = e & 1 ? 3988292384 ^ e >>> 1 : e >>> 1;
    i[t] = e;
  }
  return i;
}, cn, un = (e, i, t, n) => {
  const r = cn, a = n + t;
  e ^= -1;
  for (let f2 = n;f2 < a; f2++)
    e = e >>> 8 ^ r[(e ^ i[f2]) & 255];
  return e ^ -1;
}, Z2, oe, Te, wn, ot, bn, j, gn, W2, pn, xn, C, zt, I, Tt, H, kn, We, vn, En, Oe, yn, mn, Sn, An, Be, zn = 9, Tn = 15, Rn = 8, Dn = 29, Zn = 256, ft, In = 30, On = 19, Nn, Ln = 15, k2 = 3, G = 258, B2, Un = 32, fe2 = 42, pt = 57, _t = 69, ht = 73, dt = 91, st = 103, q = 113, ue = 666, O2 = 1, de = 2, te = 3, se = 4, Cn = 3, ee = (e, i) => (e.msg = oe[i], i), Rt = (e) => e * 2 - (e > 4 ? 9 : 0), Y2 = (e) => {
  let i = e.length;
  for (;--i >= 0; )
    e[i] = 0;
}, $n = (e) => {
  let i, t, n, r = e.w_size;
  i = e.hash_size, n = i;
  do
    t = e.head[--n], e.head[n] = t >= r ? t - r : 0;
  while (--i);
  i = r, n = i;
  do
    t = e.prev[--n], e.prev[n] = t >= r ? t - r : 0;
  while (--i);
}, Fn = (e, i, t) => (i << e.hash_shift ^ t) & e.hash_mask, V, L = (e) => {
  const i = e.state;
  let t = i.pending;
  t > e.avail_out && (t = e.avail_out), t !== 0 && (e.output.set(i.pending_buf.subarray(i.pending_out, i.pending_out + t), e.next_out), e.next_out += t, i.pending_out += t, e.total_out += t, e.avail_out -= t, i.pending -= t, i.pending === 0 && (i.pending_out = 0));
}, U = (e, i) => {
  bn(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, i), e.block_start = e.strstart, L(e.strm);
}, S = (e, i) => {
  e.pending_buf[e.pending++] = i;
}, ce2 = (e, i) => {
  e.pending_buf[e.pending++] = i >>> 8 & 255, e.pending_buf[e.pending++] = i & 255;
}, ct = (e, i, t, n) => {
  let r = e.avail_in;
  return r > n && (r = n), r === 0 ? 0 : (e.avail_in -= r, i.set(e.input.subarray(e.next_in, e.next_in + r), t), e.state.wrap === 1 ? e.adler = ye(e.adler, i, r, t) : e.state.wrap === 2 && (e.adler = Z2(e.adler, i, r, t)), e.next_in += r, e.total_in += r, r);
}, vi = (e, i) => {
  let { max_chain_length: t, strstart: n } = e, r, a, f2 = e.prev_length, o = e.nice_match;
  const c = e.strstart > e.w_size - B2 ? e.strstart - (e.w_size - B2) : 0, l2 = e.window, _ = e.w_mask, y = e.prev, s = e.strstart + G;
  let h = l2[n + f2 - 1], u = l2[n + f2];
  e.prev_length >= e.good_match && (t >>= 2), o > e.lookahead && (o = e.lookahead);
  do
    if (r = i, !(l2[r + f2] !== u || l2[r + f2 - 1] !== h || l2[r] !== l2[n] || l2[++r] !== l2[n + 1])) {
      n += 2, r++;
      do
        ;
      while (l2[++n] === l2[++r] && l2[++n] === l2[++r] && l2[++n] === l2[++r] && l2[++n] === l2[++r] && l2[++n] === l2[++r] && l2[++n] === l2[++r] && l2[++n] === l2[++r] && l2[++n] === l2[++r] && n < s);
      if (a = G - (s - n), n = s - G, a > f2) {
        if (e.match_start = i, f2 = a, a >= o)
          break;
        h = l2[n + f2 - 1], u = l2[n + f2];
      }
    }
  while ((i = y[i & _]) > c && --t !== 0);
  return f2 <= e.lookahead ? f2 : e.lookahead;
}, _e = (e) => {
  const i = e.w_size;
  let t, n, r;
  do {
    if (n = e.window_size - e.lookahead - e.strstart, e.strstart >= i + (i - B2) && (e.window.set(e.window.subarray(i, i + i - n), 0), e.match_start -= i, e.strstart -= i, e.block_start -= i, e.insert > e.strstart && (e.insert = e.strstart), $n(e), n += i), e.strm.avail_in === 0)
      break;
    if (t = ct(e.strm, e.window, e.strstart + e.lookahead, n), e.lookahead += t, e.lookahead + e.insert >= k2)
      for (r = e.strstart - e.insert, e.ins_h = e.window[r], e.ins_h = V(e, e.ins_h, e.window[r + 1]);e.insert && (e.ins_h = V(e, e.ins_h, e.window[r + k2 - 1]), e.prev[r & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = r, r++, e.insert--, !(e.lookahead + e.insert < k2)); )
        ;
  } while (e.lookahead < B2 && e.strm.avail_in !== 0);
}, Ei = (e, i) => {
  let t = e.pending_buf_size - 5 > e.w_size ? e.w_size : e.pending_buf_size - 5, n, r, a, f2 = 0, o = e.strm.avail_in;
  do {
    if (n = 65535, a = e.bi_valid + 42 >> 3, e.strm.avail_out < a || (a = e.strm.avail_out - a, r = e.strstart - e.block_start, n > r + e.strm.avail_in && (n = r + e.strm.avail_in), n > a && (n = a), n < t && (n === 0 && i !== C || i === W2 || n !== r + e.strm.avail_in)))
      break;
    f2 = i === C && n === r + e.strm.avail_in ? 1 : 0, ot(e, 0, 0, f2), e.pending_buf[e.pending - 4] = n, e.pending_buf[e.pending - 3] = n >> 8, e.pending_buf[e.pending - 2] = ~n, e.pending_buf[e.pending - 1] = ~n >> 8, L(e.strm), r && (r > n && (r = n), e.strm.output.set(e.window.subarray(e.block_start, e.block_start + r), e.strm.next_out), e.strm.next_out += r, e.strm.avail_out -= r, e.strm.total_out += r, e.block_start += r, n -= r), n && (ct(e.strm, e.strm.output, e.strm.next_out, n), e.strm.next_out += n, e.strm.avail_out -= n, e.strm.total_out += n);
  } while (f2 === 0);
  return o -= e.strm.avail_in, o && (o >= e.w_size ? (e.matches = 2, e.window.set(e.strm.input.subarray(e.strm.next_in - e.w_size, e.strm.next_in), 0), e.strstart = e.w_size, e.insert = e.strstart) : (e.window_size - e.strstart <= o && (e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, e.insert > e.strstart && (e.insert = e.strstart)), e.window.set(e.strm.input.subarray(e.strm.next_in - o, e.strm.next_in), e.strstart), e.strstart += o, e.insert += o > e.w_size - e.insert ? e.w_size - e.insert : o), e.block_start = e.strstart), e.high_water < e.strstart && (e.high_water = e.strstart), f2 ? se : i !== W2 && i !== C && e.strm.avail_in === 0 && e.strstart === e.block_start ? de : (a = e.window_size - e.strstart, e.strm.avail_in > a && e.block_start >= e.w_size && (e.block_start -= e.w_size, e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, a += e.w_size, e.insert > e.strstart && (e.insert = e.strstart)), a > e.strm.avail_in && (a = e.strm.avail_in), a && (ct(e.strm, e.window, e.strstart, a), e.strstart += a, e.insert += a > e.w_size - e.insert ? e.w_size - e.insert : a), e.high_water < e.strstart && (e.high_water = e.strstart), a = e.bi_valid + 42 >> 3, a = e.pending_buf_size - a > 65535 ? 65535 : e.pending_buf_size - a, t = a > e.w_size ? e.w_size : a, r = e.strstart - e.block_start, (r >= t || (r || i === C) && i !== W2 && e.strm.avail_in === 0 && r <= a) && (n = r > a ? a : r, f2 = i === C && e.strm.avail_in === 0 && n === r ? 1 : 0, ot(e, e.block_start, n, f2), e.block_start += n, L(e.strm)), f2 ? te : O2);
}, Ve = (e, i) => {
  let t, n;
  for (;; ) {
    if (e.lookahead < B2) {
      if (_e(e), e.lookahead < B2 && i === W2)
        return O2;
      if (e.lookahead === 0)
        break;
    }
    if (t = 0, e.lookahead >= k2 && (e.ins_h = V(e, e.ins_h, e.window[e.strstart + k2 - 1]), t = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), t !== 0 && e.strstart - t <= e.w_size - B2 && (e.match_length = vi(e, t)), e.match_length >= k2)
      if (n = j(e, e.strstart - e.match_start, e.match_length - k2), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= k2) {
        e.match_length--;
        do
          e.strstart++, e.ins_h = V(e, e.ins_h, e.window[e.strstart + k2 - 1]), t = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart;
        while (--e.match_length !== 0);
        e.strstart++;
      } else
        e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = V(e, e.ins_h, e.window[e.strstart + 1]);
    else
      n = j(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;
    if (n && (U(e, false), e.strm.avail_out === 0))
      return O2;
  }
  return e.insert = e.strstart < k2 - 1 ? e.strstart : k2 - 1, i === C ? (U(e, true), e.strm.avail_out === 0 ? te : se) : e.sym_next && (U(e, false), e.strm.avail_out === 0) ? O2 : de;
}, ae = (e, i) => {
  let t, n, r;
  for (;; ) {
    if (e.lookahead < B2) {
      if (_e(e), e.lookahead < B2 && i === W2)
        return O2;
      if (e.lookahead === 0)
        break;
    }
    if (t = 0, e.lookahead >= k2 && (e.ins_h = V(e, e.ins_h, e.window[e.strstart + k2 - 1]), t = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = k2 - 1, t !== 0 && e.prev_length < e.max_lazy_match && e.strstart - t <= e.w_size - B2 && (e.match_length = vi(e, t), e.match_length <= 5 && (e.strategy === En || e.match_length === k2 && e.strstart - e.match_start > 4096) && (e.match_length = k2 - 1)), e.prev_length >= k2 && e.match_length <= e.prev_length) {
      r = e.strstart + e.lookahead - k2, n = j(e, e.strstart - 1 - e.prev_match, e.prev_length - k2), e.lookahead -= e.prev_length - 1, e.prev_length -= 2;
      do
        ++e.strstart <= r && (e.ins_h = V(e, e.ins_h, e.window[e.strstart + k2 - 1]), t = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart);
      while (--e.prev_length !== 0);
      if (e.match_available = 0, e.match_length = k2 - 1, e.strstart++, n && (U(e, false), e.strm.avail_out === 0))
        return O2;
    } else if (e.match_available) {
      if (n = j(e, 0, e.window[e.strstart - 1]), n && U(e, false), e.strstart++, e.lookahead--, e.strm.avail_out === 0)
        return O2;
    } else
      e.match_available = 1, e.strstart++, e.lookahead--;
  }
  return e.match_available && (n = j(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < k2 - 1 ? e.strstart : k2 - 1, i === C ? (U(e, true), e.strm.avail_out === 0 ? te : se) : e.sym_next && (U(e, false), e.strm.avail_out === 0) ? O2 : de;
}, Mn = (e, i) => {
  let t, n, r, a;
  const f2 = e.window;
  for (;; ) {
    if (e.lookahead <= G) {
      if (_e(e), e.lookahead <= G && i === W2)
        return O2;
      if (e.lookahead === 0)
        break;
    }
    if (e.match_length = 0, e.lookahead >= k2 && e.strstart > 0 && (r = e.strstart - 1, n = f2[r], n === f2[++r] && n === f2[++r] && n === f2[++r])) {
      a = e.strstart + G;
      do
        ;
      while (n === f2[++r] && n === f2[++r] && n === f2[++r] && n === f2[++r] && n === f2[++r] && n === f2[++r] && n === f2[++r] && n === f2[++r] && r < a);
      e.match_length = G - (a - r), e.match_length > e.lookahead && (e.match_length = e.lookahead);
    }
    if (e.match_length >= k2 ? (t = j(e, 1, e.match_length - k2), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (t = j(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), t && (U(e, false), e.strm.avail_out === 0))
      return O2;
  }
  return e.insert = 0, i === C ? (U(e, true), e.strm.avail_out === 0 ? te : se) : e.sym_next && (U(e, false), e.strm.avail_out === 0) ? O2 : de;
}, Hn = (e, i) => {
  let t;
  for (;; ) {
    if (e.lookahead === 0 && (_e(e), e.lookahead === 0)) {
      if (i === W2)
        return O2;
      break;
    }
    if (e.match_length = 0, t = j(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, t && (U(e, false), e.strm.avail_out === 0))
      return O2;
  }
  return e.insert = 0, i === C ? (U(e, true), e.strm.avail_out === 0 ? te : se) : e.sym_next && (U(e, false), e.strm.avail_out === 0) ? O2 : de;
}, we, Bn = (e) => {
  e.window_size = 2 * e.w_size, Y2(e.head), e.max_lazy_match = we[e.level].max_lazy, e.good_match = we[e.level].good_length, e.nice_match = we[e.level].nice_length, e.max_chain_length = we[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = k2 - 1, e.match_available = 0, e.ins_h = 0;
}, Re = (e) => {
  if (!e)
    return 1;
  const i = e.state;
  return !i || i.strm !== e || i.status !== fe2 && i.status !== pt && i.status !== _t && i.status !== ht && i.status !== dt && i.status !== st && i.status !== q && i.status !== ue ? 1 : 0;
}, yi = (e) => {
  if (Re(e))
    return ee(e, H);
  e.total_in = e.total_out = 0, e.data_type = An;
  const i = e.state;
  return i.pending = 0, i.pending_out = 0, i.wrap < 0 && (i.wrap = -i.wrap), i.status = i.wrap === 2 ? pt : i.wrap ? fe2 : q, e.adler = i.wrap === 2 ? 0 : 1, i.last_flush = -2, wn(i), I;
}, mi = (e) => {
  const i = yi(e);
  return i === I && Bn(e.state), i;
}, Pn = (e, i) => Re(e) || e.state.wrap !== 2 ? H : (e.state.gzhead = i, I), Si = (e, i, t, n, r, a) => {
  if (!e)
    return H;
  let f2 = 1;
  if (i === vn && (i = 6), n < 0 ? (f2 = 0, n = -n) : n > 15 && (f2 = 2, n -= 16), r < 1 || r > zn || t !== Be || n < 8 || n > 15 || i < 0 || i > 9 || a < 0 || a > mn || n === 8 && f2 !== 1)
    return ee(e, H);
  n === 8 && (n = 9);
  const o = new Kn;
  return e.state = o, o.strm = e, o.status = fe2, o.wrap = f2, o.gzhead = null, o.w_bits = n, o.w_size = 1 << o.w_bits, o.w_mask = o.w_size - 1, o.hash_bits = r + 7, o.hash_size = 1 << o.hash_bits, o.hash_mask = o.hash_size - 1, o.hash_shift = ~~((o.hash_bits + k2 - 1) / k2), o.window = new Uint8Array(o.w_size * 2), o.head = new Uint16Array(o.hash_size), o.prev = new Uint16Array(o.w_size), o.lit_bufsize = 1 << r + 6, o.pending_buf_size = o.lit_bufsize * 4, o.pending_buf = new Uint8Array(o.pending_buf_size), o.sym_buf = o.lit_bufsize, o.sym_end = (o.lit_bufsize - 1) * 3, o.level = i, o.strategy = a, o.method = t, mi(e);
}, Xn = (e, i) => Si(e, i, Be, Tn, Rn, Sn), Yn = (e, i) => {
  if (Re(e) || i > zt || i < 0)
    return e ? ee(e, H) : H;
  const t = e.state;
  if (!e.output || e.avail_in !== 0 && !e.input || t.status === ue && i !== C)
    return ee(e, e.avail_out === 0 ? We : H);
  const n = t.last_flush;
  if (t.last_flush = i, t.pending !== 0) {
    if (L(e), e.avail_out === 0)
      return t.last_flush = -1, I;
  } else if (e.avail_in === 0 && Rt(i) <= Rt(n) && i !== C)
    return ee(e, We);
  if (t.status === ue && e.avail_in !== 0)
    return ee(e, We);
  if (t.status === fe2 && t.wrap === 0 && (t.status = q), t.status === fe2) {
    let r = Be + (t.w_bits - 8 << 4) << 8, a = -1;
    if (t.strategy >= Oe || t.level < 2 ? a = 0 : t.level < 6 ? a = 1 : t.level === 6 ? a = 2 : a = 3, r |= a << 6, t.strstart !== 0 && (r |= Un), r += 31 - r % 31, ce2(t, r), t.strstart !== 0 && (ce2(t, e.adler >>> 16), ce2(t, e.adler & 65535)), e.adler = 1, t.status = q, L(e), t.pending !== 0)
      return t.last_flush = -1, I;
  }
  if (t.status === pt) {
    if (e.adler = 0, S(t, 31), S(t, 139), S(t, 8), t.gzhead)
      S(t, (t.gzhead.text ? 1 : 0) + (t.gzhead.hcrc ? 2 : 0) + (t.gzhead.extra ? 4 : 0) + (t.gzhead.name ? 8 : 0) + (t.gzhead.comment ? 16 : 0)), S(t, t.gzhead.time & 255), S(t, t.gzhead.time >> 8 & 255), S(t, t.gzhead.time >> 16 & 255), S(t, t.gzhead.time >> 24 & 255), S(t, t.level === 9 ? 2 : t.strategy >= Oe || t.level < 2 ? 4 : 0), S(t, t.gzhead.os & 255), t.gzhead.extra && t.gzhead.extra.length && (S(t, t.gzhead.extra.length & 255), S(t, t.gzhead.extra.length >> 8 & 255)), t.gzhead.hcrc && (e.adler = Z2(e.adler, t.pending_buf, t.pending, 0)), t.gzindex = 0, t.status = _t;
    else if (S(t, 0), S(t, 0), S(t, 0), S(t, 0), S(t, 0), S(t, t.level === 9 ? 2 : t.strategy >= Oe || t.level < 2 ? 4 : 0), S(t, Cn), t.status = q, L(e), t.pending !== 0)
      return t.last_flush = -1, I;
  }
  if (t.status === _t) {
    if (t.gzhead.extra) {
      let r = t.pending, a = (t.gzhead.extra.length & 65535) - t.gzindex;
      for (;t.pending + a > t.pending_buf_size; ) {
        let o = t.pending_buf_size - t.pending;
        if (t.pending_buf.set(t.gzhead.extra.subarray(t.gzindex, t.gzindex + o), t.pending), t.pending = t.pending_buf_size, t.gzhead.hcrc && t.pending > r && (e.adler = Z2(e.adler, t.pending_buf, t.pending - r, r)), t.gzindex += o, L(e), t.pending !== 0)
          return t.last_flush = -1, I;
        r = 0, a -= o;
      }
      let f2 = new Uint8Array(t.gzhead.extra);
      t.pending_buf.set(f2.subarray(t.gzindex, t.gzindex + a), t.pending), t.pending += a, t.gzhead.hcrc && t.pending > r && (e.adler = Z2(e.adler, t.pending_buf, t.pending - r, r)), t.gzindex = 0;
    }
    t.status = ht;
  }
  if (t.status === ht) {
    if (t.gzhead.name) {
      let r = t.pending, a;
      do {
        if (t.pending === t.pending_buf_size) {
          if (t.gzhead.hcrc && t.pending > r && (e.adler = Z2(e.adler, t.pending_buf, t.pending - r, r)), L(e), t.pending !== 0)
            return t.last_flush = -1, I;
          r = 0;
        }
        t.gzindex < t.gzhead.name.length ? a = t.gzhead.name.charCodeAt(t.gzindex++) & 255 : a = 0, S(t, a);
      } while (a !== 0);
      t.gzhead.hcrc && t.pending > r && (e.adler = Z2(e.adler, t.pending_buf, t.pending - r, r)), t.gzindex = 0;
    }
    t.status = dt;
  }
  if (t.status === dt) {
    if (t.gzhead.comment) {
      let r = t.pending, a;
      do {
        if (t.pending === t.pending_buf_size) {
          if (t.gzhead.hcrc && t.pending > r && (e.adler = Z2(e.adler, t.pending_buf, t.pending - r, r)), L(e), t.pending !== 0)
            return t.last_flush = -1, I;
          r = 0;
        }
        t.gzindex < t.gzhead.comment.length ? a = t.gzhead.comment.charCodeAt(t.gzindex++) & 255 : a = 0, S(t, a);
      } while (a !== 0);
      t.gzhead.hcrc && t.pending > r && (e.adler = Z2(e.adler, t.pending_buf, t.pending - r, r));
    }
    t.status = st;
  }
  if (t.status === st) {
    if (t.gzhead.hcrc) {
      if (t.pending + 2 > t.pending_buf_size && (L(e), t.pending !== 0))
        return t.last_flush = -1, I;
      S(t, e.adler & 255), S(t, e.adler >> 8 & 255), e.adler = 0;
    }
    if (t.status = q, L(e), t.pending !== 0)
      return t.last_flush = -1, I;
  }
  if (e.avail_in !== 0 || t.lookahead !== 0 || i !== W2 && t.status !== ue) {
    let r = t.level === 0 ? Ei(t, i) : t.strategy === Oe ? Hn(t, i) : t.strategy === yn ? Mn(t, i) : we[t.level].func(t, i);
    if ((r === te || r === se) && (t.status = ue), r === O2 || r === te)
      return e.avail_out === 0 && (t.last_flush = -1), I;
    if (r === de && (i === pn ? gn(t) : i !== zt && (ot(t, 0, 0, false), i === xn && (Y2(t.head), t.lookahead === 0 && (t.strstart = 0, t.block_start = 0, t.insert = 0))), L(e), e.avail_out === 0))
      return t.last_flush = -1, I;
  }
  return i !== C ? I : t.wrap <= 0 ? Tt : (t.wrap === 2 ? (S(t, e.adler & 255), S(t, e.adler >> 8 & 255), S(t, e.adler >> 16 & 255), S(t, e.adler >> 24 & 255), S(t, e.total_in & 255), S(t, e.total_in >> 8 & 255), S(t, e.total_in >> 16 & 255), S(t, e.total_in >> 24 & 255)) : (ce2(t, e.adler >>> 16), ce2(t, e.adler & 65535)), L(e), t.wrap > 0 && (t.wrap = -t.wrap), t.pending !== 0 ? I : Tt);
}, Gn = (e) => {
  if (Re(e))
    return H;
  const i = e.state.status;
  return e.state = null, i === q ? ee(e, kn) : I;
}, jn = (e, i) => {
  let t = i.length;
  if (Re(e))
    return H;
  const n = e.state, r = n.wrap;
  if (r === 2 || r === 1 && n.status !== fe2 || n.lookahead)
    return H;
  if (r === 1 && (e.adler = ye(e.adler, i, t, 0)), n.wrap = 0, t >= n.w_size) {
    r === 0 && (Y2(n.head), n.strstart = 0, n.block_start = 0, n.insert = 0);
    let c = new Uint8Array(n.w_size);
    c.set(i.subarray(t - n.w_size, t), 0), i = c, t = n.w_size;
  }
  const { avail_in: a, next_in: f2, input: o } = e;
  for (e.avail_in = t, e.next_in = 0, e.input = i, _e(n);n.lookahead >= k2; ) {
    let c = n.strstart, l2 = n.lookahead - (k2 - 1);
    do
      n.ins_h = V(n, n.ins_h, n.window[c + k2 - 1]), n.prev[c & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = c, c++;
    while (--l2);
    n.strstart = c, n.lookahead = k2 - 1, _e(n);
  }
  return n.strstart += n.lookahead, n.block_start = n.strstart, n.insert = n.lookahead, n.lookahead = 0, n.match_length = n.prev_length = k2 - 1, n.match_available = 0, e.next_in = f2, e.input = o, e.avail_in = a, n.wrap = r, I;
}, Wn, Vn, Jn, Qn, qn, ea, ta, ia, na = "pako deflate (from Nodeca project)", ge, aa = (e, i) => Object.prototype.hasOwnProperty.call(e, i), ra = function(e) {
  const i = Array.prototype.slice.call(arguments, 1);
  for (;i.length; ) {
    const t = i.shift();
    if (t) {
      if (typeof t != "object")
        throw new TypeError(t + "must be non-object");
      for (const n in t)
        aa(t, n) && (e[n] = t[n]);
    }
  }
  return e;
}, la = (e) => {
  let i = 0;
  for (let n = 0, r = e.length;n < r; n++)
    i += e[n].length;
  const t = new Uint8Array(i);
  for (let n = 0, r = 0, a = e.length;n < a; n++) {
    let f2 = e[n];
    t.set(f2, r), r += f2.length;
  }
  return t;
}, Ke, Ai = true, me, oa = (e) => {
  if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
    return new TextEncoder().encode(e);
  let i, t, n, r, a, f2 = e.length, o = 0;
  for (r = 0;r < f2; r++)
    t = e.charCodeAt(r), (t & 64512) === 55296 && r + 1 < f2 && (n = e.charCodeAt(r + 1), (n & 64512) === 56320 && (t = 65536 + (t - 55296 << 10) + (n - 56320), r++)), o += t < 128 ? 1 : t < 2048 ? 2 : t < 65536 ? 3 : 4;
  for (i = new Uint8Array(o), a = 0, r = 0;a < o; r++)
    t = e.charCodeAt(r), (t & 64512) === 55296 && r + 1 < f2 && (n = e.charCodeAt(r + 1), (n & 64512) === 56320 && (t = 65536 + (t - 55296 << 10) + (n - 56320), r++)), t < 128 ? i[a++] = t : t < 2048 ? (i[a++] = 192 | t >>> 6, i[a++] = 128 | t & 63) : t < 65536 ? (i[a++] = 224 | t >>> 12, i[a++] = 128 | t >>> 6 & 63, i[a++] = 128 | t & 63) : (i[a++] = 240 | t >>> 18, i[a++] = 128 | t >>> 12 & 63, i[a++] = 128 | t >>> 6 & 63, i[a++] = 128 | t & 63);
  return i;
}, fa = (e, i) => {
  if (i < 65534 && e.subarray && Ai)
    return String.fromCharCode.apply(null, e.length === i ? e : e.subarray(0, i));
  let t = "";
  for (let n = 0;n < i; n++)
    t += String.fromCharCode(e[n]);
  return t;
}, _a = (e, i) => {
  const t = i || e.length;
  if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
    return new TextDecoder().decode(e.subarray(0, i));
  let n, r;
  const a = new Array(t * 2);
  for (r = 0, n = 0;n < t; ) {
    let f2 = e[n++];
    if (f2 < 128) {
      a[r++] = f2;
      continue;
    }
    let o = me[f2];
    if (o > 4) {
      a[r++] = 65533, n += o - 1;
      continue;
    }
    for (f2 &= o === 2 ? 31 : o === 3 ? 15 : 7;o > 1 && n < t; )
      f2 = f2 << 6 | e[n++] & 63, o--;
    if (o > 1) {
      a[r++] = 65533;
      continue;
    }
    f2 < 65536 ? a[r++] = f2 : (f2 -= 65536, a[r++] = 55296 | f2 >> 10 & 1023, a[r++] = 56320 | f2 & 1023);
  }
  return fa(a, r);
}, ha = (e, i) => {
  i = i || e.length, i > e.length && (i = e.length);
  let t = i - 1;
  for (;t >= 0 && (e[t] & 192) === 128; )
    t--;
  return t < 0 || t === 0 ? i : t + me[e[t]] > i ? t : i;
}, Se, zi, Ti, sa, ca, ua, wa, Me, ba, ga, pa, xa, Ne = 16209, ka = 16191, va = function(i, t) {
  let n, r, a, f2, o, c, l2, _, y, s, h, u, R2, v, g2, A2, p2, d3, m2, D2, w, z, E2, b;
  const x2 = i.state;
  n = i.next_in, E2 = i.input, r = n + (i.avail_in - 5), a = i.next_out, b = i.output, f2 = a - (t - i.avail_out), o = a + (i.avail_out - 257), c = x2.dmax, l2 = x2.wsize, _ = x2.whave, y = x2.wnext, s = x2.window, h = x2.hold, u = x2.bits, R2 = x2.lencode, v = x2.distcode, g2 = (1 << x2.lenbits) - 1, A2 = (1 << x2.distbits) - 1;
  e:
    do {
      u < 15 && (h += E2[n++] << u, u += 8, h += E2[n++] << u, u += 8), p2 = R2[h & g2];
      t:
        for (;; ) {
          if (d3 = p2 >>> 24, h >>>= d3, u -= d3, d3 = p2 >>> 16 & 255, d3 === 0)
            b[a++] = p2 & 65535;
          else if (d3 & 16) {
            m2 = p2 & 65535, d3 &= 15, d3 && (u < d3 && (h += E2[n++] << u, u += 8), m2 += h & (1 << d3) - 1, h >>>= d3, u -= d3), u < 15 && (h += E2[n++] << u, u += 8, h += E2[n++] << u, u += 8), p2 = v[h & A2];
            i:
              for (;; ) {
                if (d3 = p2 >>> 24, h >>>= d3, u -= d3, d3 = p2 >>> 16 & 255, d3 & 16) {
                  if (D2 = p2 & 65535, d3 &= 15, u < d3 && (h += E2[n++] << u, u += 8, u < d3 && (h += E2[n++] << u, u += 8)), D2 += h & (1 << d3) - 1, D2 > c) {
                    i.msg = "invalid distance too far back", x2.mode = Ne;
                    break e;
                  }
                  if (h >>>= d3, u -= d3, d3 = a - f2, D2 > d3) {
                    if (d3 = D2 - d3, d3 > _ && x2.sane) {
                      i.msg = "invalid distance too far back", x2.mode = Ne;
                      break e;
                    }
                    if (w = 0, z = s, y === 0) {
                      if (w += l2 - d3, d3 < m2) {
                        m2 -= d3;
                        do
                          b[a++] = s[w++];
                        while (--d3);
                        w = a - D2, z = b;
                      }
                    } else if (y < d3) {
                      if (w += l2 + y - d3, d3 -= y, d3 < m2) {
                        m2 -= d3;
                        do
                          b[a++] = s[w++];
                        while (--d3);
                        if (w = 0, y < m2) {
                          d3 = y, m2 -= d3;
                          do
                            b[a++] = s[w++];
                          while (--d3);
                          w = a - D2, z = b;
                        }
                      }
                    } else if (w += y - d3, d3 < m2) {
                      m2 -= d3;
                      do
                        b[a++] = s[w++];
                      while (--d3);
                      w = a - D2, z = b;
                    }
                    for (;m2 > 2; )
                      b[a++] = z[w++], b[a++] = z[w++], b[a++] = z[w++], m2 -= 3;
                    m2 && (b[a++] = z[w++], m2 > 1 && (b[a++] = z[w++]));
                  } else {
                    w = a - D2;
                    do
                      b[a++] = b[w++], b[a++] = b[w++], b[a++] = b[w++], m2 -= 3;
                    while (m2 > 2);
                    m2 && (b[a++] = b[w++], m2 > 1 && (b[a++] = b[w++]));
                  }
                } else if (d3 & 64) {
                  i.msg = "invalid distance code", x2.mode = Ne;
                  break e;
                } else {
                  p2 = v[(p2 & 65535) + (h & (1 << d3) - 1)];
                  continue i;
                }
                break;
              }
          } else if (d3 & 64)
            if (d3 & 32) {
              x2.mode = ka;
              break e;
            } else {
              i.msg = "invalid literal/length code", x2.mode = Ne;
              break e;
            }
          else {
            p2 = R2[(p2 & 65535) + (h & (1 << d3) - 1)];
            continue t;
          }
          break;
        }
    } while (n < r && a < o);
  m2 = u >> 3, n -= m2, u -= m2 << 3, h &= (1 << u) - 1, i.next_in = n, i.next_out = a, i.avail_in = n < r ? 5 + (r - n) : 5 - (n - r), i.avail_out = a < o ? 257 + (o - a) : 257 - (a - o), x2.hold = h, x2.bits = u;
}, re = 15, Dt = 852, Zt = 592, It = 0, Je = 1, Ot = 2, Ea, ya, ma, Sa, Aa = (e, i, t, n, r, a, f2, o) => {
  const c = o.bits;
  let l2 = 0, _ = 0, y = 0, s = 0, h = 0, u = 0, R2 = 0, v = 0, g2 = 0, A2 = 0, p2, d3, m2, D2, w, z = null, E2;
  const b = new Uint16Array(re + 1), x2 = new Uint16Array(re + 1);
  let J = null, vt, Ze, Ie;
  for (l2 = 0;l2 <= re; l2++)
    b[l2] = 0;
  for (_ = 0;_ < n; _++)
    b[i[t + _]]++;
  for (h = c, s = re;s >= 1 && b[s] === 0; s--)
    ;
  if (h > s && (h = s), s === 0)
    return r[a++] = 1 << 24 | 64 << 16 | 0, r[a++] = 1 << 24 | 64 << 16 | 0, o.bits = 1, 0;
  for (y = 1;y < s && b[y] === 0; y++)
    ;
  for (h < y && (h = y), v = 1, l2 = 1;l2 <= re; l2++)
    if (v <<= 1, v -= b[l2], v < 0)
      return -1;
  if (v > 0 && (e === It || s !== 1))
    return -1;
  for (x2[1] = 0, l2 = 1;l2 < re; l2++)
    x2[l2 + 1] = x2[l2] + b[l2];
  for (_ = 0;_ < n; _++)
    i[t + _] !== 0 && (f2[x2[i[t + _]]++] = _);
  if (e === It ? (z = J = f2, E2 = 20) : e === Je ? (z = Ea, J = ya, E2 = 257) : (z = ma, J = Sa, E2 = 0), A2 = 0, _ = 0, l2 = y, w = a, u = h, R2 = 0, m2 = -1, g2 = 1 << h, D2 = g2 - 1, e === Je && g2 > Dt || e === Ot && g2 > Zt)
    return 1;
  for (;; ) {
    vt = l2 - R2, f2[_] + 1 < E2 ? (Ze = 0, Ie = f2[_]) : f2[_] >= E2 ? (Ze = J[f2[_] - E2], Ie = z[f2[_] - E2]) : (Ze = 96, Ie = 0), p2 = 1 << l2 - R2, d3 = 1 << u, y = d3;
    do
      d3 -= p2, r[w + (A2 >> R2) + d3] = vt << 24 | Ze << 16 | Ie | 0;
    while (d3 !== 0);
    for (p2 = 1 << l2 - 1;A2 & p2; )
      p2 >>= 1;
    if (p2 !== 0 ? (A2 &= p2 - 1, A2 += p2) : A2 = 0, _++, --b[l2] === 0) {
      if (l2 === s)
        break;
      l2 = i[t + f2[_]];
    }
    if (l2 > h && (A2 & D2) !== m2) {
      for (R2 === 0 && (R2 = h), w += y, u = l2 - R2, v = 1 << u;u + R2 < s && (v -= b[u + R2], !(v <= 0)); )
        u++, v <<= 1;
      if (g2 += 1 << u, e === Je && g2 > Dt || e === Ot && g2 > Zt)
        return 1;
      m2 = A2 & D2, r[m2] = h << 24 | u << 16 | w - a | 0;
    }
  }
  return A2 !== 0 && (r[w + A2] = l2 - R2 << 24 | 64 << 16 | 0), o.bits = h, 0;
}, pe, za = 0, Ri = 1, Di = 2, Nt, Ta, Le, ie2, Ra, Da, $2, Zi, Ii, Za, Lt, Pe = 16180, Ut = 16181, Ct = 16182, $t = 16183, Ft = 16184, Mt = 16185, Ht = 16186, Bt = 16187, Kt = 16188, Pt = 16189, He = 16190, K2 = 16191, Qe = 16192, Xt = 16193, qe = 16194, Yt = 16195, Gt = 16196, jt = 16197, Wt = 16198, Ue = 16199, Ce = 16200, Vt = 16201, Jt = 16202, Qt = 16203, qt = 16204, ei = 16205, et = 16206, ti = 16207, ii = 16208, T = 16209, Oi = 16210, Ni = 16211, Ia = 852, Oa = 592, Na = 15, La, ni = (e) => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((e & 65280) << 8) + ((e & 255) << 24), ne2 = (e) => {
  if (!e)
    return 1;
  const i = e.state;
  return !i || i.strm !== e || i.mode < Pe || i.mode > Ni ? 1 : 0;
}, Li = (e) => {
  if (ne2(e))
    return $2;
  const i = e.state;
  return e.total_in = e.total_out = i.total = 0, e.msg = "", i.wrap && (e.adler = i.wrap & 1), i.mode = Pe, i.last = 0, i.havedict = 0, i.flags = -1, i.dmax = 32768, i.head = null, i.hold = 0, i.bits = 0, i.lencode = i.lendyn = new Int32Array(Ia), i.distcode = i.distdyn = new Int32Array(Oa), i.sane = 1, i.back = -1, ie2;
}, Ui = (e) => {
  if (ne2(e))
    return $2;
  const i = e.state;
  return i.wsize = 0, i.whave = 0, i.wnext = 0, Li(e);
}, Ci = (e, i) => {
  let t;
  if (ne2(e))
    return $2;
  const n = e.state;
  return i < 0 ? (t = 0, i = -i) : (t = (i >> 4) + 5, i < 48 && (i &= 15)), i && (i < 8 || i > 15) ? $2 : (n.window !== null && n.wbits !== i && (n.window = null), n.wrap = t, n.wbits = i, Ui(e));
}, $i = (e, i) => {
  if (!e)
    return $2;
  const t = new Ua;
  e.state = t, t.strm = e, t.window = null, t.mode = Pe;
  const n = Ci(e, i);
  return n !== ie2 && (e.state = null), n;
}, Ca = (e) => $i(e, La), ai = true, tt, it, $a = (e) => {
  if (ai) {
    tt = new Int32Array(512), it = new Int32Array(32);
    let i = 0;
    for (;i < 144; )
      e.lens[i++] = 8;
    for (;i < 256; )
      e.lens[i++] = 9;
    for (;i < 280; )
      e.lens[i++] = 7;
    for (;i < 288; )
      e.lens[i++] = 8;
    for (pe(Ri, e.lens, 0, 288, tt, 0, e.work, { bits: 9 }), i = 0;i < 32; )
      e.lens[i++] = 5;
    pe(Di, e.lens, 0, 32, it, 0, e.work, { bits: 5 }), ai = false;
  }
  e.lencode = tt, e.lenbits = 9, e.distcode = it, e.distbits = 5;
}, Fi = (e, i, t, n) => {
  let r;
  const a = e.state;
  return a.window === null && (a.wsize = 1 << a.wbits, a.wnext = 0, a.whave = 0, a.window = new Uint8Array(a.wsize)), n >= a.wsize ? (a.window.set(i.subarray(t - a.wsize, t), 0), a.wnext = 0, a.whave = a.wsize) : (r = a.wsize - a.wnext, r > n && (r = n), a.window.set(i.subarray(t - n, t - n + r), a.wnext), n -= r, n ? (a.window.set(i.subarray(t - n, t), 0), a.wnext = n, a.whave = a.wsize) : (a.wnext += r, a.wnext === a.wsize && (a.wnext = 0), a.whave < a.wsize && (a.whave += r))), 0;
}, Fa = (e, i) => {
  let t, n, r, a, f2, o, c, l2, _, y, s, h, u, R2, v = 0, g2, A2, p2, d3, m2, D2, w, z;
  const E2 = new Uint8Array(4);
  let b, x2;
  const J = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  if (ne2(e) || !e.output || !e.input && e.avail_in !== 0)
    return $2;
  t = e.state, t.mode === K2 && (t.mode = Qe), f2 = e.next_out, r = e.output, c = e.avail_out, a = e.next_in, n = e.input, o = e.avail_in, l2 = t.hold, _ = t.bits, y = o, s = c, z = ie2;
  e:
    for (;; )
      switch (t.mode) {
        case Pe:
          if (t.wrap === 0) {
            t.mode = Qe;
            break;
          }
          for (;_ < 16; ) {
            if (o === 0)
              break e;
            o--, l2 += n[a++] << _, _ += 8;
          }
          if (t.wrap & 2 && l2 === 35615) {
            t.wbits === 0 && (t.wbits = 15), t.check = 0, E2[0] = l2 & 255, E2[1] = l2 >>> 8 & 255, t.check = Z2(t.check, E2, 2, 0), l2 = 0, _ = 0, t.mode = Ut;
            break;
          }
          if (t.head && (t.head.done = false), !(t.wrap & 1) || (((l2 & 255) << 8) + (l2 >> 8)) % 31) {
            e.msg = "incorrect header check", t.mode = T;
            break;
          }
          if ((l2 & 15) !== Lt) {
            e.msg = "unknown compression method", t.mode = T;
            break;
          }
          if (l2 >>>= 4, _ -= 4, w = (l2 & 15) + 8, t.wbits === 0 && (t.wbits = w), w > 15 || w > t.wbits) {
            e.msg = "invalid window size", t.mode = T;
            break;
          }
          t.dmax = 1 << t.wbits, t.flags = 0, e.adler = t.check = 1, t.mode = l2 & 512 ? Pt : K2, l2 = 0, _ = 0;
          break;
        case Ut:
          for (;_ < 16; ) {
            if (o === 0)
              break e;
            o--, l2 += n[a++] << _, _ += 8;
          }
          if (t.flags = l2, (t.flags & 255) !== Lt) {
            e.msg = "unknown compression method", t.mode = T;
            break;
          }
          if (t.flags & 57344) {
            e.msg = "unknown header flags set", t.mode = T;
            break;
          }
          t.head && (t.head.text = l2 >> 8 & 1), t.flags & 512 && t.wrap & 4 && (E2[0] = l2 & 255, E2[1] = l2 >>> 8 & 255, t.check = Z2(t.check, E2, 2, 0)), l2 = 0, _ = 0, t.mode = Ct;
        case Ct:
          for (;_ < 32; ) {
            if (o === 0)
              break e;
            o--, l2 += n[a++] << _, _ += 8;
          }
          t.head && (t.head.time = l2), t.flags & 512 && t.wrap & 4 && (E2[0] = l2 & 255, E2[1] = l2 >>> 8 & 255, E2[2] = l2 >>> 16 & 255, E2[3] = l2 >>> 24 & 255, t.check = Z2(t.check, E2, 4, 0)), l2 = 0, _ = 0, t.mode = $t;
        case $t:
          for (;_ < 16; ) {
            if (o === 0)
              break e;
            o--, l2 += n[a++] << _, _ += 8;
          }
          t.head && (t.head.xflags = l2 & 255, t.head.os = l2 >> 8), t.flags & 512 && t.wrap & 4 && (E2[0] = l2 & 255, E2[1] = l2 >>> 8 & 255, t.check = Z2(t.check, E2, 2, 0)), l2 = 0, _ = 0, t.mode = Ft;
        case Ft:
          if (t.flags & 1024) {
            for (;_ < 16; ) {
              if (o === 0)
                break e;
              o--, l2 += n[a++] << _, _ += 8;
            }
            t.length = l2, t.head && (t.head.extra_len = l2), t.flags & 512 && t.wrap & 4 && (E2[0] = l2 & 255, E2[1] = l2 >>> 8 & 255, t.check = Z2(t.check, E2, 2, 0)), l2 = 0, _ = 0;
          } else
            t.head && (t.head.extra = null);
          t.mode = Mt;
        case Mt:
          if (t.flags & 1024 && (h = t.length, h > o && (h = o), h && (t.head && (w = t.head.extra_len - t.length, t.head.extra || (t.head.extra = new Uint8Array(t.head.extra_len)), t.head.extra.set(n.subarray(a, a + h), w)), t.flags & 512 && t.wrap & 4 && (t.check = Z2(t.check, n, h, a)), o -= h, a += h, t.length -= h), t.length))
            break e;
          t.length = 0, t.mode = Ht;
        case Ht:
          if (t.flags & 2048) {
            if (o === 0)
              break e;
            h = 0;
            do
              w = n[a + h++], t.head && w && t.length < 65536 && (t.head.name += String.fromCharCode(w));
            while (w && h < o);
            if (t.flags & 512 && t.wrap & 4 && (t.check = Z2(t.check, n, h, a)), o -= h, a += h, w)
              break e;
          } else
            t.head && (t.head.name = null);
          t.length = 0, t.mode = Bt;
        case Bt:
          if (t.flags & 4096) {
            if (o === 0)
              break e;
            h = 0;
            do
              w = n[a + h++], t.head && w && t.length < 65536 && (t.head.comment += String.fromCharCode(w));
            while (w && h < o);
            if (t.flags & 512 && t.wrap & 4 && (t.check = Z2(t.check, n, h, a)), o -= h, a += h, w)
              break e;
          } else
            t.head && (t.head.comment = null);
          t.mode = Kt;
        case Kt:
          if (t.flags & 512) {
            for (;_ < 16; ) {
              if (o === 0)
                break e;
              o--, l2 += n[a++] << _, _ += 8;
            }
            if (t.wrap & 4 && l2 !== (t.check & 65535)) {
              e.msg = "header crc mismatch", t.mode = T;
              break;
            }
            l2 = 0, _ = 0;
          }
          t.head && (t.head.hcrc = t.flags >> 9 & 1, t.head.done = true), e.adler = t.check = 0, t.mode = K2;
          break;
        case Pt:
          for (;_ < 32; ) {
            if (o === 0)
              break e;
            o--, l2 += n[a++] << _, _ += 8;
          }
          e.adler = t.check = ni(l2), l2 = 0, _ = 0, t.mode = He;
        case He:
          if (t.havedict === 0)
            return e.next_out = f2, e.avail_out = c, e.next_in = a, e.avail_in = o, t.hold = l2, t.bits = _, Da;
          e.adler = t.check = 1, t.mode = K2;
        case K2:
          if (i === Ta || i === Le)
            break e;
        case Qe:
          if (t.last) {
            l2 >>>= _ & 7, _ -= _ & 7, t.mode = et;
            break;
          }
          for (;_ < 3; ) {
            if (o === 0)
              break e;
            o--, l2 += n[a++] << _, _ += 8;
          }
          switch (t.last = l2 & 1, l2 >>>= 1, _ -= 1, l2 & 3) {
            case 0:
              t.mode = Xt;
              break;
            case 1:
              if ($a(t), t.mode = Ue, i === Le) {
                l2 >>>= 2, _ -= 2;
                break e;
              }
              break;
            case 2:
              t.mode = Gt;
              break;
            case 3:
              e.msg = "invalid block type", t.mode = T;
          }
          l2 >>>= 2, _ -= 2;
          break;
        case Xt:
          for (l2 >>>= _ & 7, _ -= _ & 7;_ < 32; ) {
            if (o === 0)
              break e;
            o--, l2 += n[a++] << _, _ += 8;
          }
          if ((l2 & 65535) !== (l2 >>> 16 ^ 65535)) {
            e.msg = "invalid stored block lengths", t.mode = T;
            break;
          }
          if (t.length = l2 & 65535, l2 = 0, _ = 0, t.mode = qe, i === Le)
            break e;
        case qe:
          t.mode = Yt;
        case Yt:
          if (h = t.length, h) {
            if (h > o && (h = o), h > c && (h = c), h === 0)
              break e;
            r.set(n.subarray(a, a + h), f2), o -= h, a += h, c -= h, f2 += h, t.length -= h;
            break;
          }
          t.mode = K2;
          break;
        case Gt:
          for (;_ < 14; ) {
            if (o === 0)
              break e;
            o--, l2 += n[a++] << _, _ += 8;
          }
          if (t.nlen = (l2 & 31) + 257, l2 >>>= 5, _ -= 5, t.ndist = (l2 & 31) + 1, l2 >>>= 5, _ -= 5, t.ncode = (l2 & 15) + 4, l2 >>>= 4, _ -= 4, t.nlen > 286 || t.ndist > 30) {
            e.msg = "too many length or distance symbols", t.mode = T;
            break;
          }
          t.have = 0, t.mode = jt;
        case jt:
          for (;t.have < t.ncode; ) {
            for (;_ < 3; ) {
              if (o === 0)
                break e;
              o--, l2 += n[a++] << _, _ += 8;
            }
            t.lens[J[t.have++]] = l2 & 7, l2 >>>= 3, _ -= 3;
          }
          for (;t.have < 19; )
            t.lens[J[t.have++]] = 0;
          if (t.lencode = t.lendyn, t.lenbits = 7, b = { bits: t.lenbits }, z = pe(za, t.lens, 0, 19, t.lencode, 0, t.work, b), t.lenbits = b.bits, z) {
            e.msg = "invalid code lengths set", t.mode = T;
            break;
          }
          t.have = 0, t.mode = Wt;
        case Wt:
          for (;t.have < t.nlen + t.ndist; ) {
            for (;v = t.lencode[l2 & (1 << t.lenbits) - 1], g2 = v >>> 24, A2 = v >>> 16 & 255, p2 = v & 65535, !(g2 <= _); ) {
              if (o === 0)
                break e;
              o--, l2 += n[a++] << _, _ += 8;
            }
            if (p2 < 16)
              l2 >>>= g2, _ -= g2, t.lens[t.have++] = p2;
            else {
              if (p2 === 16) {
                for (x2 = g2 + 2;_ < x2; ) {
                  if (o === 0)
                    break e;
                  o--, l2 += n[a++] << _, _ += 8;
                }
                if (l2 >>>= g2, _ -= g2, t.have === 0) {
                  e.msg = "invalid bit length repeat", t.mode = T;
                  break;
                }
                w = t.lens[t.have - 1], h = 3 + (l2 & 3), l2 >>>= 2, _ -= 2;
              } else if (p2 === 17) {
                for (x2 = g2 + 3;_ < x2; ) {
                  if (o === 0)
                    break e;
                  o--, l2 += n[a++] << _, _ += 8;
                }
                l2 >>>= g2, _ -= g2, w = 0, h = 3 + (l2 & 7), l2 >>>= 3, _ -= 3;
              } else {
                for (x2 = g2 + 7;_ < x2; ) {
                  if (o === 0)
                    break e;
                  o--, l2 += n[a++] << _, _ += 8;
                }
                l2 >>>= g2, _ -= g2, w = 0, h = 11 + (l2 & 127), l2 >>>= 7, _ -= 7;
              }
              if (t.have + h > t.nlen + t.ndist) {
                e.msg = "invalid bit length repeat", t.mode = T;
                break;
              }
              for (;h--; )
                t.lens[t.have++] = w;
            }
          }
          if (t.mode === T)
            break;
          if (t.lens[256] === 0) {
            e.msg = "invalid code -- missing end-of-block", t.mode = T;
            break;
          }
          if (t.lenbits = 9, b = { bits: t.lenbits }, z = pe(Ri, t.lens, 0, t.nlen, t.lencode, 0, t.work, b), t.lenbits = b.bits, z) {
            e.msg = "invalid literal/lengths set", t.mode = T;
            break;
          }
          if (t.distbits = 6, t.distcode = t.distdyn, b = { bits: t.distbits }, z = pe(Di, t.lens, t.nlen, t.ndist, t.distcode, 0, t.work, b), t.distbits = b.bits, z) {
            e.msg = "invalid distances set", t.mode = T;
            break;
          }
          if (t.mode = Ue, i === Le)
            break e;
        case Ue:
          t.mode = Ce;
        case Ce:
          if (o >= 6 && c >= 258) {
            e.next_out = f2, e.avail_out = c, e.next_in = a, e.avail_in = o, t.hold = l2, t.bits = _, va(e, s), f2 = e.next_out, r = e.output, c = e.avail_out, a = e.next_in, n = e.input, o = e.avail_in, l2 = t.hold, _ = t.bits, t.mode === K2 && (t.back = -1);
            break;
          }
          for (t.back = 0;v = t.lencode[l2 & (1 << t.lenbits) - 1], g2 = v >>> 24, A2 = v >>> 16 & 255, p2 = v & 65535, !(g2 <= _); ) {
            if (o === 0)
              break e;
            o--, l2 += n[a++] << _, _ += 8;
          }
          if (A2 && !(A2 & 240)) {
            for (d3 = g2, m2 = A2, D2 = p2;v = t.lencode[D2 + ((l2 & (1 << d3 + m2) - 1) >> d3)], g2 = v >>> 24, A2 = v >>> 16 & 255, p2 = v & 65535, !(d3 + g2 <= _); ) {
              if (o === 0)
                break e;
              o--, l2 += n[a++] << _, _ += 8;
            }
            l2 >>>= d3, _ -= d3, t.back += d3;
          }
          if (l2 >>>= g2, _ -= g2, t.back += g2, t.length = p2, A2 === 0) {
            t.mode = ei;
            break;
          }
          if (A2 & 32) {
            t.back = -1, t.mode = K2;
            break;
          }
          if (A2 & 64) {
            e.msg = "invalid literal/length code", t.mode = T;
            break;
          }
          t.extra = A2 & 15, t.mode = Vt;
        case Vt:
          if (t.extra) {
            for (x2 = t.extra;_ < x2; ) {
              if (o === 0)
                break e;
              o--, l2 += n[a++] << _, _ += 8;
            }
            t.length += l2 & (1 << t.extra) - 1, l2 >>>= t.extra, _ -= t.extra, t.back += t.extra;
          }
          t.was = t.length, t.mode = Jt;
        case Jt:
          for (;v = t.distcode[l2 & (1 << t.distbits) - 1], g2 = v >>> 24, A2 = v >>> 16 & 255, p2 = v & 65535, !(g2 <= _); ) {
            if (o === 0)
              break e;
            o--, l2 += n[a++] << _, _ += 8;
          }
          if (!(A2 & 240)) {
            for (d3 = g2, m2 = A2, D2 = p2;v = t.distcode[D2 + ((l2 & (1 << d3 + m2) - 1) >> d3)], g2 = v >>> 24, A2 = v >>> 16 & 255, p2 = v & 65535, !(d3 + g2 <= _); ) {
              if (o === 0)
                break e;
              o--, l2 += n[a++] << _, _ += 8;
            }
            l2 >>>= d3, _ -= d3, t.back += d3;
          }
          if (l2 >>>= g2, _ -= g2, t.back += g2, A2 & 64) {
            e.msg = "invalid distance code", t.mode = T;
            break;
          }
          t.offset = p2, t.extra = A2 & 15, t.mode = Qt;
        case Qt:
          if (t.extra) {
            for (x2 = t.extra;_ < x2; ) {
              if (o === 0)
                break e;
              o--, l2 += n[a++] << _, _ += 8;
            }
            t.offset += l2 & (1 << t.extra) - 1, l2 >>>= t.extra, _ -= t.extra, t.back += t.extra;
          }
          if (t.offset > t.dmax) {
            e.msg = "invalid distance too far back", t.mode = T;
            break;
          }
          t.mode = qt;
        case qt:
          if (c === 0)
            break e;
          if (h = s - c, t.offset > h) {
            if (h = t.offset - h, h > t.whave && t.sane) {
              e.msg = "invalid distance too far back", t.mode = T;
              break;
            }
            h > t.wnext ? (h -= t.wnext, u = t.wsize - h) : u = t.wnext - h, h > t.length && (h = t.length), R2 = t.window;
          } else
            R2 = r, u = f2 - t.offset, h = t.length;
          h > c && (h = c), c -= h, t.length -= h;
          do
            r[f2++] = R2[u++];
          while (--h);
          t.length === 0 && (t.mode = Ce);
          break;
        case ei:
          if (c === 0)
            break e;
          r[f2++] = t.length, c--, t.mode = Ce;
          break;
        case et:
          if (t.wrap) {
            for (;_ < 32; ) {
              if (o === 0)
                break e;
              o--, l2 |= n[a++] << _, _ += 8;
            }
            if (s -= c, e.total_out += s, t.total += s, t.wrap & 4 && s && (e.adler = t.check = t.flags ? Z2(t.check, r, s, f2 - s) : ye(t.check, r, s, f2 - s)), s = c, t.wrap & 4 && (t.flags ? l2 : ni(l2)) !== t.check) {
              e.msg = "incorrect data check", t.mode = T;
              break;
            }
            l2 = 0, _ = 0;
          }
          t.mode = ti;
        case ti:
          if (t.wrap && t.flags) {
            for (;_ < 32; ) {
              if (o === 0)
                break e;
              o--, l2 += n[a++] << _, _ += 8;
            }
            if (t.wrap & 4 && l2 !== (t.total & 4294967295)) {
              e.msg = "incorrect length check", t.mode = T;
              break;
            }
            l2 = 0, _ = 0;
          }
          t.mode = ii;
        case ii:
          z = Ra;
          break e;
        case T:
          z = Zi;
          break e;
        case Oi:
          return Ii;
        case Ni:
        default:
          return $2;
      }
  return e.next_out = f2, e.avail_out = c, e.next_in = a, e.avail_in = o, t.hold = l2, t.bits = _, (t.wsize || s !== e.avail_out && t.mode < T && (t.mode < et || i !== Nt)) && Fi(e, e.output, e.next_out, s - e.avail_out), y -= e.avail_in, s -= e.avail_out, e.total_in += y, e.total_out += s, t.total += s, t.wrap & 4 && s && (e.adler = t.check = t.flags ? Z2(t.check, r, s, e.next_out - s) : ye(t.check, r, s, e.next_out - s)), e.data_type = t.bits + (t.last ? 64 : 0) + (t.mode === K2 ? 128 : 0) + (t.mode === Ue || t.mode === qe ? 256 : 0), (y === 0 && s === 0 || i === Nt) && z === ie2 && (z = Za), z;
}, Ma = (e) => {
  if (ne2(e))
    return $2;
  let i = e.state;
  return i.window && (i.window = null), e.state = null, ie2;
}, Ha = (e, i) => {
  if (ne2(e))
    return $2;
  const t = e.state;
  return t.wrap & 2 ? (t.head = i, i.done = false, ie2) : $2;
}, Ba = (e, i) => {
  const t = i.length;
  let n, r, a;
  return ne2(e) || (n = e.state, n.wrap !== 0 && n.mode !== He) ? $2 : n.mode === He && (r = 1, r = ye(r, i, t, 0), r !== n.check) ? Zi : (a = Fi(e, i, t, t), a ? (n.mode = Oi, Ii) : (n.havedict = 1, ie2));
}, Ka, Pa, Xa, Ya, Ga, ja, Wa, Va, Ja, Qa = "pako inflate (from Nodeca project)", X, er, Mi, tr, ir, Ae, nt, at, nr, ri, ar, lr, or, fr, _r, hr, dr, cr, sr, ur, wr, br;
var init_pako_esm_CB1uQYY0 = __esm(() => {
  /*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
  xe = ze + 1 + ut;
  oi = 2 * xe + 1;
  rt = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
  $e = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
  Yi = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
  di = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  P = new Array((xe + 2) * 2);
  he(P);
  be = new Array(le2 * 2);
  he(be);
  ke = new Array(Gi);
  he(ke);
  ve = new Array(Pi - Ki + 1);
  he(ve);
  gt = new Array(ut);
  he(gt);
  Fe = new Array(le2);
  he(Fe);
  rn = en;
  ln = ki;
  on = nn;
  fn = an;
  _n = tn;
  hn = {
    _tr_init: rn,
    _tr_stored_block: ln,
    _tr_flush_block: on,
    _tr_tally: fn,
    _tr_align: _n
  };
  ye = dn;
  cn = new Uint32Array(sn());
  Z2 = un;
  oe = {
    2: "need dictionary",
    1: "stream end",
    0: "",
    "-1": "file error",
    "-2": "stream error",
    "-3": "data error",
    "-4": "insufficient memory",
    "-5": "buffer error",
    "-6": "incompatible version"
  };
  Te = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    Z_BINARY: 0,
    Z_TEXT: 1,
    Z_UNKNOWN: 2,
    Z_DEFLATED: 8
  };
  ({ _tr_init: wn, _tr_stored_block: ot, _tr_flush_block: bn, _tr_tally: j, _tr_align: gn } = hn);
  ({
    Z_NO_FLUSH: W2,
    Z_PARTIAL_FLUSH: pn,
    Z_FULL_FLUSH: xn,
    Z_FINISH: C,
    Z_BLOCK: zt,
    Z_OK: I,
    Z_STREAM_END: Tt,
    Z_STREAM_ERROR: H,
    Z_DATA_ERROR: kn,
    Z_BUF_ERROR: We,
    Z_DEFAULT_COMPRESSION: vn,
    Z_FILTERED: En,
    Z_HUFFMAN_ONLY: Oe,
    Z_RLE: yn,
    Z_FIXED: mn,
    Z_DEFAULT_STRATEGY: Sn,
    Z_UNKNOWN: An,
    Z_DEFLATED: Be
  } = Te);
  ft = Zn + 1 + Dn;
  Nn = 2 * ft + 1;
  B2 = G + k2 + 1;
  V = Fn;
  we = [
    new F(0, 0, 0, 0, Ei),
    new F(4, 4, 8, 4, Ve),
    new F(4, 5, 16, 8, Ve),
    new F(4, 6, 32, 32, Ve),
    new F(4, 4, 16, 16, ae),
    new F(8, 16, 32, 32, ae),
    new F(8, 16, 128, 128, ae),
    new F(8, 32, 128, 256, ae),
    new F(32, 128, 258, 1024, ae),
    new F(32, 258, 258, 4096, ae)
  ];
  Wn = Xn;
  Vn = Si;
  Jn = mi;
  Qn = yi;
  qn = Pn;
  ea = Yn;
  ta = Gn;
  ia = jn;
  ge = {
    deflateInit: Wn,
    deflateInit2: Vn,
    deflateReset: Jn,
    deflateResetKeep: Qn,
    deflateSetHeader: qn,
    deflate: ea,
    deflateEnd: ta,
    deflateSetDictionary: ia,
    deflateInfo: na
  };
  Ke = {
    assign: ra,
    flattenChunks: la
  };
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch {
    Ai = false;
  }
  me = new Uint8Array(256);
  for (let e = 0;e < 256; e++)
    me[e] = e >= 252 ? 6 : e >= 248 ? 5 : e >= 240 ? 4 : e >= 224 ? 3 : e >= 192 ? 2 : 1;
  me[254] = me[254] = 1;
  Se = {
    string2buf: oa,
    buf2string: _a,
    utf8border: ha
  };
  zi = da;
  Ti = Object.prototype.toString;
  ({
    Z_NO_FLUSH: sa,
    Z_SYNC_FLUSH: ca,
    Z_FULL_FLUSH: ua,
    Z_FINISH: wa,
    Z_OK: Me,
    Z_STREAM_END: ba,
    Z_DEFAULT_COMPRESSION: ga,
    Z_DEFAULT_STRATEGY: pa,
    Z_DEFLATED: xa
  } = Te);
  xt.prototype.push = function(e, i) {
    const t = this.strm, n = this.options.chunkSize;
    let r, a;
    if (this.ended)
      return false;
    for (i === ~~i ? a = i : a = i === true ? wa : sa, typeof e == "string" ? t.input = Se.string2buf(e) : Ti.call(e) === "[object ArrayBuffer]" ? t.input = new Uint8Array(e) : t.input = e, t.next_in = 0, t.avail_in = t.input.length;; ) {
      if (t.avail_out === 0 && (t.output = new Uint8Array(n), t.next_out = 0, t.avail_out = n), (a === ca || a === ua) && t.avail_out <= 6) {
        this.onData(t.output.subarray(0, t.next_out)), t.avail_out = 0;
        continue;
      }
      if (r = ge.deflate(t, a), r === ba)
        return t.next_out > 0 && this.onData(t.output.subarray(0, t.next_out)), r = ge.deflateEnd(this.strm), this.onEnd(r), this.ended = true, r === Me;
      if (t.avail_out === 0) {
        this.onData(t.output);
        continue;
      }
      if (a > 0 && t.next_out > 0) {
        this.onData(t.output.subarray(0, t.next_out)), t.avail_out = 0;
        continue;
      }
      if (t.avail_in === 0)
        break;
    }
    return true;
  };
  xt.prototype.onData = function(e) {
    this.chunks.push(e);
  };
  xt.prototype.onEnd = function(e) {
    e === Me && (this.result = Ke.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
  };
  Ea = new Uint16Array([
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ]);
  ya = new Uint8Array([
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ]);
  ma = new Uint16Array([
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ]);
  Sa = new Uint8Array([
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ]);
  pe = Aa;
  ({
    Z_FINISH: Nt,
    Z_BLOCK: Ta,
    Z_TREES: Le,
    Z_OK: ie2,
    Z_STREAM_END: Ra,
    Z_NEED_DICT: Da,
    Z_STREAM_ERROR: $2,
    Z_DATA_ERROR: Zi,
    Z_MEM_ERROR: Ii,
    Z_BUF_ERROR: Za,
    Z_DEFLATED: Lt
  } = Te);
  La = Na;
  Ka = Ui;
  Pa = Ci;
  Xa = Li;
  Ya = Ca;
  Ga = $i;
  ja = Fa;
  Wa = Ma;
  Va = Ha;
  Ja = Ba;
  X = {
    inflateReset: Ka,
    inflateReset2: Pa,
    inflateResetKeep: Xa,
    inflateInit: Ya,
    inflateInit2: Ga,
    inflate: ja,
    inflateEnd: Wa,
    inflateGetHeader: Va,
    inflateSetDictionary: Ja,
    inflateInfo: Qa
  };
  er = qa;
  Mi = Object.prototype.toString;
  ({
    Z_NO_FLUSH: tr,
    Z_FINISH: ir,
    Z_OK: Ae,
    Z_STREAM_END: nt,
    Z_NEED_DICT: at,
    Z_STREAM_ERROR: nr,
    Z_DATA_ERROR: ri,
    Z_MEM_ERROR: ar
  } = Te);
  De.prototype.push = function(e, i) {
    const t = this.strm, n = this.options.chunkSize, r = this.options.dictionary;
    let a, f2, o;
    if (this.ended)
      return false;
    for (i === ~~i ? f2 = i : f2 = i === true ? ir : tr, Mi.call(e) === "[object ArrayBuffer]" ? t.input = new Uint8Array(e) : t.input = e, t.next_in = 0, t.avail_in = t.input.length;; ) {
      for (t.avail_out === 0 && (t.output = new Uint8Array(n), t.next_out = 0, t.avail_out = n), a = X.inflate(t, f2), a === at && r && (a = X.inflateSetDictionary(t, r), a === Ae ? a = X.inflate(t, f2) : a === ri && (a = at));t.avail_in > 0 && a === nt && t.state.wrap > 0 && e[t.next_in] !== 0; )
        X.inflateReset(t), a = X.inflate(t, f2);
      switch (a) {
        case nr:
        case ri:
        case at:
        case ar:
          return this.onEnd(a), this.ended = true, false;
      }
      if (o = t.avail_out, t.next_out && (t.avail_out === 0 || a === nt))
        if (this.options.to === "string") {
          let c = Se.utf8border(t.output, t.next_out), l2 = t.next_out - c, _ = Se.buf2string(t.output, c);
          t.next_out = l2, t.avail_out = n - l2, l2 && t.output.set(t.output.subarray(c, c + l2), 0), this.onData(_);
        } else
          this.onData(t.output.length === t.next_out ? t.output : t.output.subarray(0, t.next_out));
      if (!(a === Ae && o === 0)) {
        if (a === nt)
          return a = X.inflateEnd(this.strm), this.onEnd(a), this.ended = true, true;
        if (t.avail_in === 0)
          break;
      }
    }
    return true;
  };
  De.prototype.onData = function(e) {
    this.chunks.push(e);
  };
  De.prototype.onEnd = function(e) {
    e === Ae && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = Ke.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
  };
  lr = De;
  or = kt;
  fr = rr;
  _r = kt;
  hr = Te;
  dr = {
    Inflate: lr,
    inflate: or,
    inflateRaw: fr,
    ungzip: _r,
    constants: hr
  };
  ({ Inflate: cr, inflate: sr, inflateRaw: ur, ungzip: wr } = dr);
  br = sr;
});

// node_modules/geotiff-tilesource/dist/deflate-BXt-9JA_.js
var exports_deflate_BXt_9JA_ = {};
__export(exports_deflate_BXt_9JA_, {
  default: () => s
});
var s;
var init_deflate_BXt_9JA_ = __esm(() => {
  init_pako_esm_CB1uQYY0();
  init_basedecoder_DHcBySSe();
  s = class s extends g {
    decodeBlock(e) {
      return br(new Uint8Array(e)).buffer;
    }
  };
});

// node_modules/geotiff-tilesource/dist/packbits-BlDR4Kj5.js
var exports_packbits_BlDR4Kj5 = {};
__export(exports_packbits_BlDR4Kj5, {
  default: () => l2
});
var l2;
var init_packbits_BlDR4Kj5 = __esm(() => {
  init_basedecoder_DHcBySSe();
  l2 = class l2 extends g {
    decodeBlock(s2) {
      const n = new DataView(s2), r = [];
      for (let e = 0;e < s2.byteLength; ++e) {
        let t = n.getInt8(e);
        if (t < 0) {
          const o = n.getUint8(e + 1);
          t = -t;
          for (let a = 0;a <= t; ++a)
            r.push(o);
          e += 1;
        } else {
          for (let o = 0;o <= t; ++o)
            r.push(n.getUint8(e + o + 1));
          e += t + 1;
        }
      }
      return new Uint8Array(r).buffer;
    }
  };
});

// node_modules/geotiff-tilesource/dist/lerc-CoQvYJmm.js
var exports_lerc_CoQvYJmm = {};
__export(exports_lerc_CoQvYJmm, {
  zstd: () => hA,
  default: () => lA
});

class wA {
  init() {
    return _ || (typeof fetch < "u" ? _ = fetch("data:application/wasm;base64," + EA).then((J) => J.arrayBuffer()).then((J) => WebAssembly.instantiate(J, BA)).then(this._init) : _ = WebAssembly.instantiate(Buffer.from(EA, "base64"), BA).then(this._init), _);
  }
  _init(J) {
    x2 = J.instance, BA.env.emscripten_notify_memory_growth(0);
  }
  decode(J, T2 = 0) {
    if (!x2)
      throw new Error("ZSTDDecoder: Await .init() before decoding.");
    const Z3 = J.byteLength, X2 = x2.exports.malloc(Z3);
    QA.set(J, X2), T2 = T2 || Number(x2.exports.ZSTD_findDecompressedSize(X2, Z3));
    const u = x2.exports.malloc(T2), L2 = x2.exports.ZSTD_decompress(u, T2, X2, Z3), d3 = QA.slice(u, u + L2);
    return x2.exports.free(X2), x2.exports.free(u), d3;
  }
}
var iA, fA, tA, _, x2, QA, BA, EA = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ", hA, lA;
var init_lerc_CoQvYJmm = __esm(() => {
  init_pako_esm_CB1uQYY0();
  init_main_8v7k2MJ1();
  init_basedecoder_DHcBySSe();
  iA = { exports: {} };
  (function(j2) {
    (function() {
      var J = function() {
        var u = {};
        u.defaultNoDataValue = -340279993879014840000000000000000000000, u.decode = function(I2, a) {
          a = a || {};
          var Q3 = a.encodedMaskData || a.encodedMaskData === null, g2 = E2(I2, a.inputOffset || 0, Q3), D2 = a.noDataValue !== null ? a.noDataValue : u.defaultNoDataValue, B3 = L2(g2, a.pixelType || Float32Array, a.encodedMaskData, D2, a.returnMask), C2 = {
            width: g2.width,
            height: g2.height,
            pixelData: B3.resultPixels,
            minValue: B3.minValue,
            maxValue: g2.pixels.maxValue,
            noDataValue: D2
          };
          return B3.resultMask && (C2.maskData = B3.resultMask), a.returnEncodedMask && g2.mask && (C2.encodedMaskData = g2.mask.bitset ? g2.mask.bitset : null), a.returnFileInfo && (C2.fileInfo = d3(g2), a.computeUsedBitDepths && (C2.fileInfo.bitDepths = z(g2))), C2;
        };
        var L2 = function(I2, a, Q3, g2, D2) {
          var B3 = 0, C2 = I2.pixels.numBlocksX, o = I2.pixels.numBlocksY, r = Math.floor(I2.width / C2), s2 = Math.floor(I2.height / o), f2 = 2 * I2.maxZError, e = Number.MAX_VALUE, i;
          Q3 = Q3 || (I2.mask ? I2.mask.bitset : null);
          var t, F2;
          t = new a(I2.width * I2.height), D2 && Q3 && (F2 = new Uint8Array(I2.width * I2.height));
          for (var S2 = new Float32Array(r * s2), h, U2, G2 = 0;G2 <= o; G2++) {
            var R2 = G2 !== o ? s2 : I2.height % o;
            if (R2 !== 0)
              for (var w = 0;w <= C2; w++) {
                var n = w !== C2 ? r : I2.width % C2;
                if (n !== 0) {
                  var l3 = G2 * I2.width * s2 + w * r, y = I2.width - n, k3 = I2.pixels.blocks[B3], M2, c, N3;
                  k3.encoding < 2 ? (k3.encoding === 0 ? M2 = k3.rawData : (A2(k3.stuffedData, k3.bitsPerPixel, k3.numValidPixels, k3.offset, f2, S2, I2.pixels.maxValue), M2 = S2), c = 0) : k3.encoding === 2 ? N3 = 0 : N3 = k3.offset;
                  var q2;
                  if (Q3)
                    for (U2 = 0;U2 < R2; U2++) {
                      for (l3 & 7 && (q2 = Q3[l3 >> 3], q2 <<= l3 & 7), h = 0;h < n; h++)
                        l3 & 7 || (q2 = Q3[l3 >> 3]), q2 & 128 ? (F2 && (F2[l3] = 1), i = k3.encoding < 2 ? M2[c++] : N3, e = e > i ? i : e, t[l3++] = i) : (F2 && (F2[l3] = 0), t[l3++] = g2), q2 <<= 1;
                      l3 += y;
                    }
                  else if (k3.encoding < 2)
                    for (U2 = 0;U2 < R2; U2++) {
                      for (h = 0;h < n; h++)
                        i = M2[c++], e = e > i ? i : e, t[l3++] = i;
                      l3 += y;
                    }
                  else
                    for (e = e > N3 ? N3 : e, U2 = 0;U2 < R2; U2++) {
                      for (h = 0;h < n; h++)
                        t[l3++] = N3;
                      l3 += y;
                    }
                  if (k3.encoding === 1 && c !== k3.numValidPixels)
                    throw "Block and Mask do not match";
                  B3++;
                }
              }
          }
          return {
            resultPixels: t,
            resultMask: F2,
            minValue: e
          };
        }, d3 = function(I2) {
          return {
            fileIdentifierString: I2.fileIdentifierString,
            fileVersion: I2.fileVersion,
            imageType: I2.imageType,
            height: I2.height,
            width: I2.width,
            maxZError: I2.maxZError,
            eofOffset: I2.eofOffset,
            mask: I2.mask ? {
              numBlocksX: I2.mask.numBlocksX,
              numBlocksY: I2.mask.numBlocksY,
              numBytes: I2.mask.numBytes,
              maxValue: I2.mask.maxValue
            } : null,
            pixels: {
              numBlocksX: I2.pixels.numBlocksX,
              numBlocksY: I2.pixels.numBlocksY,
              numBytes: I2.pixels.numBytes,
              maxValue: I2.pixels.maxValue,
              noDataValue: I2.noDataValue
            }
          };
        }, z = function(I2) {
          for (var a = I2.pixels.numBlocksX * I2.pixels.numBlocksY, Q3 = {}, g2 = 0;g2 < a; g2++) {
            var D2 = I2.pixels.blocks[g2];
            D2.encoding === 0 ? Q3.float32 = true : D2.encoding === 1 ? Q3[D2.bitsPerPixel] = true : Q3[0] = true;
          }
          return Object.keys(Q3);
        }, E2 = function(I2, a, Q3) {
          var g2 = {}, D2 = new Uint8Array(I2, a, 10);
          if (g2.fileIdentifierString = String.fromCharCode.apply(null, D2), g2.fileIdentifierString.trim() !== "CntZImage")
            throw "Unexpected file identifier string: " + g2.fileIdentifierString;
          a += 10;
          var B3 = new DataView(I2, a, 24);
          if (g2.fileVersion = B3.getInt32(0, true), g2.imageType = B3.getInt32(4, true), g2.height = B3.getUint32(8, true), g2.width = B3.getUint32(12, true), g2.maxZError = B3.getFloat64(16, true), a += 24, !Q3)
            if (B3 = new DataView(I2, a, 16), g2.mask = {}, g2.mask.numBlocksY = B3.getUint32(0, true), g2.mask.numBlocksX = B3.getUint32(4, true), g2.mask.numBytes = B3.getUint32(8, true), g2.mask.maxValue = B3.getFloat32(12, true), a += 16, g2.mask.numBytes > 0) {
              var C2 = new Uint8Array(Math.ceil(g2.width * g2.height / 8));
              B3 = new DataView(I2, a, g2.mask.numBytes);
              var o = B3.getInt16(0, true), r = 2, s2 = 0;
              do {
                if (o > 0)
                  for (;o--; )
                    C2[s2++] = B3.getUint8(r++);
                else {
                  var f2 = B3.getUint8(r++);
                  for (o = -o;o--; )
                    C2[s2++] = f2;
                }
                o = B3.getInt16(r, true), r += 2;
              } while (r < g2.mask.numBytes);
              if (o !== -32768 || s2 < C2.length)
                throw "Unexpected end of mask RLE encoding";
              g2.mask.bitset = C2, a += g2.mask.numBytes;
            } else
              g2.mask.numBytes | g2.mask.numBlocksY | g2.mask.maxValue || (g2.mask.bitset = new Uint8Array(Math.ceil(g2.width * g2.height / 8)));
          B3 = new DataView(I2, a, 16), g2.pixels = {}, g2.pixels.numBlocksY = B3.getUint32(0, true), g2.pixels.numBlocksX = B3.getUint32(4, true), g2.pixels.numBytes = B3.getUint32(8, true), g2.pixels.maxValue = B3.getFloat32(12, true), a += 16;
          var e = g2.pixels.numBlocksX, i = g2.pixels.numBlocksY, t = e + (g2.width % e > 0 ? 1 : 0), F2 = i + (g2.height % i > 0 ? 1 : 0);
          g2.pixels.blocks = new Array(t * F2);
          for (var S2 = 0, h = 0;h < F2; h++)
            for (var U2 = 0;U2 < t; U2++) {
              var G2 = 0, R2 = I2.byteLength - a;
              B3 = new DataView(I2, a, Math.min(10, R2));
              var w = {};
              g2.pixels.blocks[S2++] = w;
              var n = B3.getUint8(0);
              if (G2++, w.encoding = n & 63, w.encoding > 3)
                throw "Invalid block encoding (" + w.encoding + ")";
              if (w.encoding === 2) {
                a++;
                continue;
              }
              if (n !== 0 && n !== 2) {
                if (n >>= 6, w.offsetType = n, n === 2)
                  w.offset = B3.getInt8(1), G2++;
                else if (n === 1)
                  w.offset = B3.getInt16(1, true), G2 += 2;
                else if (n === 0)
                  w.offset = B3.getFloat32(1, true), G2 += 4;
                else
                  throw "Invalid block offset type";
                if (w.encoding === 1)
                  if (n = B3.getUint8(G2), G2++, w.bitsPerPixel = n & 63, n >>= 6, w.numValidPixelsType = n, n === 2)
                    w.numValidPixels = B3.getUint8(G2), G2++;
                  else if (n === 1)
                    w.numValidPixels = B3.getUint16(G2, true), G2 += 2;
                  else if (n === 0)
                    w.numValidPixels = B3.getUint32(G2, true), G2 += 4;
                  else
                    throw "Invalid valid pixel count type";
              }
              if (a += G2, w.encoding !== 3) {
                var l3, y;
                if (w.encoding === 0) {
                  var k3 = (g2.pixels.numBytes - 1) / 4;
                  if (k3 !== Math.floor(k3))
                    throw "uncompressed block has invalid length";
                  l3 = new ArrayBuffer(k3 * 4), y = new Uint8Array(l3), y.set(new Uint8Array(I2, a, k3 * 4));
                  var M2 = new Float32Array(l3);
                  w.rawData = M2, a += k3 * 4;
                } else if (w.encoding === 1) {
                  var c = Math.ceil(w.numValidPixels * w.bitsPerPixel / 8), N3 = Math.ceil(c / 4);
                  l3 = new ArrayBuffer(N3 * 4), y = new Uint8Array(l3), y.set(new Uint8Array(I2, a, c)), w.stuffedData = new Uint32Array(l3), a += c;
                }
              }
            }
          return g2.eofOffset = a, g2;
        }, A2 = function(I2, a, Q3, g2, D2, B3, C2) {
          var o = (1 << a) - 1, r = 0, s2, f2 = 0, e, i, t = Math.ceil((C2 - g2) / D2), F2 = I2.length * 4 - Math.ceil(a * Q3 / 8);
          for (I2[I2.length - 1] <<= 8 * F2, s2 = 0;s2 < Q3; s2++) {
            if (f2 === 0 && (i = I2[r++], f2 = 32), f2 >= a)
              e = i >>> f2 - a & o, f2 -= a;
            else {
              var S2 = a - f2;
              e = (i & o) << S2 & o, i = I2[r++], f2 = 32 - S2, e += i >>> f2;
            }
            B3[s2] = e < t ? g2 + e * D2 : C2;
          }
          return B3;
        };
        return u;
      }(), T2 = /* @__PURE__ */ function() {
        var u = {
          unstuff: function(E2, A2, I2, a, Q3, g2, D2, B3) {
            var C2 = (1 << I2) - 1, o = 0, r, s2 = 0, f2, e, i, t, F2 = E2.length * 4 - Math.ceil(I2 * a / 8);
            if (E2[E2.length - 1] <<= 8 * F2, Q3)
              for (r = 0;r < a; r++)
                s2 === 0 && (e = E2[o++], s2 = 32), s2 >= I2 ? (f2 = e >>> s2 - I2 & C2, s2 -= I2) : (i = I2 - s2, f2 = (e & C2) << i & C2, e = E2[o++], s2 = 32 - i, f2 += e >>> s2), A2[r] = Q3[f2];
            else
              for (t = Math.ceil((B3 - g2) / D2), r = 0;r < a; r++)
                s2 === 0 && (e = E2[o++], s2 = 32), s2 >= I2 ? (f2 = e >>> s2 - I2 & C2, s2 -= I2) : (i = I2 - s2, f2 = (e & C2) << i & C2, e = E2[o++], s2 = 32 - i, f2 += e >>> s2), A2[r] = f2 < t ? g2 + f2 * D2 : B3;
          },
          unstuffLUT: function(E2, A2, I2, a, Q3, g2) {
            var D2 = (1 << A2) - 1, B3 = 0, C2 = 0, o = 0, r = 0, s2 = 0, f2, e = [], i = E2.length * 4 - Math.ceil(A2 * I2 / 8);
            E2[E2.length - 1] <<= 8 * i;
            var t = Math.ceil((g2 - a) / Q3);
            for (C2 = 0;C2 < I2; C2++)
              r === 0 && (f2 = E2[B3++], r = 32), r >= A2 ? (s2 = f2 >>> r - A2 & D2, r -= A2) : (o = A2 - r, s2 = (f2 & D2) << o & D2, f2 = E2[B3++], r = 32 - o, s2 += f2 >>> r), e[C2] = s2 < t ? a + s2 * Q3 : g2;
            return e.unshift(a), e;
          },
          unstuff2: function(E2, A2, I2, a, Q3, g2, D2, B3) {
            var C2 = (1 << I2) - 1, o = 0, r, s2 = 0, f2 = 0, e, i, t;
            if (Q3)
              for (r = 0;r < a; r++)
                s2 === 0 && (i = E2[o++], s2 = 32, f2 = 0), s2 >= I2 ? (e = i >>> f2 & C2, s2 -= I2, f2 += I2) : (t = I2 - s2, e = i >>> f2 & C2, i = E2[o++], s2 = 32 - t, e |= (i & (1 << t) - 1) << I2 - t, f2 = t), A2[r] = Q3[e];
            else {
              var F2 = Math.ceil((B3 - g2) / D2);
              for (r = 0;r < a; r++)
                s2 === 0 && (i = E2[o++], s2 = 32, f2 = 0), s2 >= I2 ? (e = i >>> f2 & C2, s2 -= I2, f2 += I2) : (t = I2 - s2, e = i >>> f2 & C2, i = E2[o++], s2 = 32 - t, e |= (i & (1 << t) - 1) << I2 - t, f2 = t), A2[r] = e < F2 ? g2 + e * D2 : B3;
            }
            return A2;
          },
          unstuffLUT2: function(E2, A2, I2, a, Q3, g2) {
            var D2 = (1 << A2) - 1, B3 = 0, C2 = 0, o = 0, r = 0, s2 = 0, f2 = 0, e, i = [], t = Math.ceil((g2 - a) / Q3);
            for (C2 = 0;C2 < I2; C2++)
              r === 0 && (e = E2[B3++], r = 32, f2 = 0), r >= A2 ? (s2 = e >>> f2 & D2, r -= A2, f2 += A2) : (o = A2 - r, s2 = e >>> f2 & D2, e = E2[B3++], r = 32 - o, s2 |= (e & (1 << o) - 1) << A2 - o, f2 = o), i[C2] = s2 < t ? a + s2 * Q3 : g2;
            return i.unshift(a), i;
          },
          originalUnstuff: function(E2, A2, I2, a) {
            var Q3 = (1 << I2) - 1, g2 = 0, D2, B3 = 0, C2, o, r, s2 = E2.length * 4 - Math.ceil(I2 * a / 8);
            for (E2[E2.length - 1] <<= 8 * s2, D2 = 0;D2 < a; D2++)
              B3 === 0 && (o = E2[g2++], B3 = 32), B3 >= I2 ? (C2 = o >>> B3 - I2 & Q3, B3 -= I2) : (r = I2 - B3, C2 = (o & Q3) << r & Q3, o = E2[g2++], B3 = 32 - r, C2 += o >>> B3), A2[D2] = C2;
            return A2;
          },
          originalUnstuff2: function(E2, A2, I2, a) {
            var Q3 = (1 << I2) - 1, g2 = 0, D2, B3 = 0, C2 = 0, o, r, s2;
            for (D2 = 0;D2 < a; D2++)
              B3 === 0 && (r = E2[g2++], B3 = 32, C2 = 0), B3 >= I2 ? (o = r >>> C2 & Q3, B3 -= I2, C2 += I2) : (s2 = I2 - B3, o = r >>> C2 & Q3, r = E2[g2++], B3 = 32 - s2, o |= (r & (1 << s2) - 1) << I2 - s2, C2 = s2), A2[D2] = o;
            return A2;
          }
        }, L2 = {
          HUFFMAN_LUT_BITS_MAX: 12,
          computeChecksumFletcher32: function(E2) {
            for (var A2 = 65535, I2 = 65535, a = E2.length, Q3 = Math.floor(a / 2), g2 = 0;Q3; ) {
              var D2 = Q3 >= 359 ? 359 : Q3;
              Q3 -= D2;
              do
                A2 += E2[g2++] << 8, I2 += A2 += E2[g2++];
              while (--D2);
              A2 = (A2 & 65535) + (A2 >>> 16), I2 = (I2 & 65535) + (I2 >>> 16);
            }
            return a & 1 && (I2 += A2 += E2[g2] << 8), A2 = (A2 & 65535) + (A2 >>> 16), I2 = (I2 & 65535) + (I2 >>> 16), (I2 << 16 | A2) >>> 0;
          },
          readHeaderInfo: function(E2, A2) {
            var I2 = A2.ptr, a = new Uint8Array(E2, I2, 6), Q3 = {};
            if (Q3.fileIdentifierString = String.fromCharCode.apply(null, a), Q3.fileIdentifierString.lastIndexOf("Lerc2", 0) !== 0)
              throw "Unexpected file identifier string (expect Lerc2 ): " + Q3.fileIdentifierString;
            I2 += 6;
            var g2 = new DataView(E2, I2, 8), D2 = g2.getInt32(0, true);
            Q3.fileVersion = D2, I2 += 4, D2 >= 3 && (Q3.checksum = g2.getUint32(4, true), I2 += 4), g2 = new DataView(E2, I2, 12), Q3.height = g2.getUint32(0, true), Q3.width = g2.getUint32(4, true), I2 += 8, D2 >= 4 ? (Q3.numDims = g2.getUint32(8, true), I2 += 4) : Q3.numDims = 1, g2 = new DataView(E2, I2, 40), Q3.numValidPixel = g2.getUint32(0, true), Q3.microBlockSize = g2.getInt32(4, true), Q3.blobSize = g2.getInt32(8, true), Q3.imageType = g2.getInt32(12, true), Q3.maxZError = g2.getFloat64(16, true), Q3.zMin = g2.getFloat64(24, true), Q3.zMax = g2.getFloat64(32, true), I2 += 40, A2.headerInfo = Q3, A2.ptr = I2;
            var B3, C2;
            if (D2 >= 3 && (C2 = D2 >= 4 ? 52 : 48, B3 = this.computeChecksumFletcher32(new Uint8Array(E2, I2 - C2, Q3.blobSize - 14)), B3 !== Q3.checksum))
              throw "Checksum failed.";
            return true;
          },
          checkMinMaxRanges: function(E2, A2) {
            var I2 = A2.headerInfo, a = this.getDataTypeArray(I2.imageType), Q3 = I2.numDims * this.getDataTypeSize(I2.imageType), g2 = this.readSubArray(E2, A2.ptr, a, Q3), D2 = this.readSubArray(E2, A2.ptr + Q3, a, Q3);
            A2.ptr += 2 * Q3;
            var B3, C2 = true;
            for (B3 = 0;B3 < I2.numDims; B3++)
              if (g2[B3] !== D2[B3]) {
                C2 = false;
                break;
              }
            return I2.minValues = g2, I2.maxValues = D2, C2;
          },
          readSubArray: function(E2, A2, I2, a) {
            var Q3;
            if (I2 === Uint8Array)
              Q3 = new Uint8Array(E2, A2, a);
            else {
              var g2 = new ArrayBuffer(a), D2 = new Uint8Array(g2);
              D2.set(new Uint8Array(E2, A2, a)), Q3 = new I2(g2);
            }
            return Q3;
          },
          readMask: function(E2, A2) {
            var { ptr: I2, headerInfo: a } = A2, Q3 = a.width * a.height, g2 = a.numValidPixel, D2 = new DataView(E2, I2, 4), B3 = {};
            if (B3.numBytes = D2.getUint32(0, true), I2 += 4, (g2 === 0 || Q3 === g2) && B3.numBytes !== 0)
              throw "invalid mask";
            var C2, o;
            if (g2 === 0)
              C2 = new Uint8Array(Math.ceil(Q3 / 8)), B3.bitset = C2, o = new Uint8Array(Q3), A2.pixels.resultMask = o, I2 += B3.numBytes;
            else if (B3.numBytes > 0) {
              C2 = new Uint8Array(Math.ceil(Q3 / 8)), D2 = new DataView(E2, I2, B3.numBytes);
              var r = D2.getInt16(0, true), s2 = 2, f2 = 0, e = 0;
              do {
                if (r > 0)
                  for (;r--; )
                    C2[f2++] = D2.getUint8(s2++);
                else
                  for (e = D2.getUint8(s2++), r = -r;r--; )
                    C2[f2++] = e;
                r = D2.getInt16(s2, true), s2 += 2;
              } while (s2 < B3.numBytes);
              if (r !== -32768 || f2 < C2.length)
                throw "Unexpected end of mask RLE encoding";
              o = new Uint8Array(Q3);
              var i = 0, t = 0;
              for (t = 0;t < Q3; t++)
                t & 7 ? (i = C2[t >> 3], i <<= t & 7) : i = C2[t >> 3], i & 128 && (o[t] = 1);
              A2.pixels.resultMask = o, B3.bitset = C2, I2 += B3.numBytes;
            }
            return A2.ptr = I2, A2.mask = B3, true;
          },
          readDataOneSweep: function(E2, A2, I2, a) {
            var { ptr: Q3, headerInfo: g2 } = A2, D2 = g2.numDims, B3 = g2.width * g2.height, C2 = g2.imageType, o = g2.numValidPixel * L2.getDataTypeSize(C2) * D2, r, s2 = A2.pixels.resultMask;
            if (I2 === Uint8Array)
              r = new Uint8Array(E2, Q3, o);
            else {
              var f2 = new ArrayBuffer(o), e = new Uint8Array(f2);
              e.set(new Uint8Array(E2, Q3, o)), r = new I2(f2);
            }
            if (r.length === B3 * D2)
              a ? A2.pixels.resultPixels = L2.swapDimensionOrder(r, B3, D2, I2, true) : A2.pixels.resultPixels = r;
            else {
              A2.pixels.resultPixels = new I2(B3 * D2);
              var i = 0, t = 0, F2 = 0, S2 = 0;
              if (D2 > 1) {
                if (a) {
                  for (t = 0;t < B3; t++)
                    if (s2[t])
                      for (S2 = t, F2 = 0;F2 < D2; F2++, S2 += B3)
                        A2.pixels.resultPixels[S2] = r[i++];
                } else
                  for (t = 0;t < B3; t++)
                    if (s2[t])
                      for (S2 = t * D2, F2 = 0;F2 < D2; F2++)
                        A2.pixels.resultPixels[S2 + F2] = r[i++];
              } else
                for (t = 0;t < B3; t++)
                  s2[t] && (A2.pixels.resultPixels[t] = r[i++]);
            }
            return Q3 += o, A2.ptr = Q3, true;
          },
          readHuffmanTree: function(E2, A2) {
            var I2 = this.HUFFMAN_LUT_BITS_MAX, a = new DataView(E2, A2.ptr, 16);
            A2.ptr += 16;
            var Q3 = a.getInt32(0, true);
            if (Q3 < 2)
              throw "unsupported Huffman version";
            var g2 = a.getInt32(4, true), D2 = a.getInt32(8, true), B3 = a.getInt32(12, true);
            if (D2 >= B3)
              return false;
            var C2 = new Uint32Array(B3 - D2);
            L2.decodeBits(E2, A2, C2);
            var o = [], r, s2, f2, e;
            for (r = D2;r < B3; r++)
              s2 = r - (r < g2 ? 0 : g2), o[s2] = { first: C2[r - D2], second: null };
            var i = E2.byteLength - A2.ptr, t = Math.ceil(i / 4), F2 = new ArrayBuffer(t * 4), S2 = new Uint8Array(F2);
            S2.set(new Uint8Array(E2, A2.ptr, i));
            var h = new Uint32Array(F2), U2 = 0, G2, R2 = 0;
            for (G2 = h[0], r = D2;r < B3; r++)
              s2 = r - (r < g2 ? 0 : g2), e = o[s2].first, e > 0 && (o[s2].second = G2 << U2 >>> 32 - e, 32 - U2 >= e ? (U2 += e, U2 === 32 && (U2 = 0, R2++, G2 = h[R2])) : (U2 += e - 32, R2++, G2 = h[R2], o[s2].second |= G2 >>> 32 - U2));
            var w = 0, n = 0, l3 = new d3;
            for (r = 0;r < o.length; r++)
              o[r] !== undefined && (w = Math.max(w, o[r].first));
            w >= I2 ? n = I2 : n = w;
            var y = [], k3, M2, c, N3, q2, m2;
            for (r = D2;r < B3; r++)
              if (s2 = r - (r < g2 ? 0 : g2), e = o[s2].first, e > 0)
                if (k3 = [e, s2], e <= n)
                  for (M2 = o[s2].second << n - e, c = 1 << n - e, f2 = 0;f2 < c; f2++)
                    y[M2 | f2] = k3;
                else
                  for (M2 = o[s2].second, m2 = l3, N3 = e - 1;N3 >= 0; N3--)
                    q2 = M2 >>> N3 & 1, q2 ? (m2.right || (m2.right = new d3), m2 = m2.right) : (m2.left || (m2.left = new d3), m2 = m2.left), N3 === 0 && !m2.val && (m2.val = k3[1]);
            return {
              decodeLut: y,
              numBitsLUTQick: n,
              numBitsLUT: w,
              tree: l3,
              stuffedData: h,
              srcPtr: R2,
              bitPos: U2
            };
          },
          readHuffman: function(E2, A2, I2, a) {
            var Q3 = A2.headerInfo, g2 = Q3.numDims, D2 = A2.headerInfo.height, B3 = A2.headerInfo.width, C2 = B3 * D2, o = this.readHuffmanTree(E2, A2), r = o.decodeLut, s2 = o.tree, f2 = o.stuffedData, e = o.srcPtr, i = o.bitPos, t = o.numBitsLUTQick, F2 = o.numBitsLUT, S2 = A2.headerInfo.imageType === 0 ? 128 : 0, h, U2, G2, R2 = A2.pixels.resultMask, w, n, l3, y, k3, M2, c, N3 = 0;
            i > 0 && (e++, i = 0);
            var q2 = f2[e], m2 = A2.encodeMode === 1, O3 = new I2(C2 * g2), v = O3, Y3;
            if (g2 < 2 || m2) {
              for (Y3 = 0;Y3 < g2; Y3++)
                if (g2 > 1 && (v = new I2(O3.buffer, C2 * Y3, C2), N3 = 0), A2.headerInfo.numValidPixel === B3 * D2)
                  for (M2 = 0, y = 0;y < D2; y++)
                    for (k3 = 0;k3 < B3; k3++, M2++) {
                      if (U2 = 0, w = q2 << i >>> 32 - t, n = w, 32 - i < t && (w |= f2[e + 1] >>> 64 - i - t, n = w), r[n])
                        U2 = r[n][1], i += r[n][0];
                      else
                        for (w = q2 << i >>> 32 - F2, n = w, 32 - i < F2 && (w |= f2[e + 1] >>> 64 - i - F2, n = w), h = s2, c = 0;c < F2; c++)
                          if (l3 = w >>> F2 - c - 1 & 1, h = l3 ? h.right : h.left, !(h.left || h.right)) {
                            U2 = h.val, i = i + c + 1;
                            break;
                          }
                      i >= 32 && (i -= 32, e++, q2 = f2[e]), G2 = U2 - S2, m2 ? (k3 > 0 ? G2 += N3 : y > 0 ? G2 += v[M2 - B3] : G2 += N3, G2 &= 255, v[M2] = G2, N3 = G2) : v[M2] = G2;
                    }
                else
                  for (M2 = 0, y = 0;y < D2; y++)
                    for (k3 = 0;k3 < B3; k3++, M2++)
                      if (R2[M2]) {
                        if (U2 = 0, w = q2 << i >>> 32 - t, n = w, 32 - i < t && (w |= f2[e + 1] >>> 64 - i - t, n = w), r[n])
                          U2 = r[n][1], i += r[n][0];
                        else
                          for (w = q2 << i >>> 32 - F2, n = w, 32 - i < F2 && (w |= f2[e + 1] >>> 64 - i - F2, n = w), h = s2, c = 0;c < F2; c++)
                            if (l3 = w >>> F2 - c - 1 & 1, h = l3 ? h.right : h.left, !(h.left || h.right)) {
                              U2 = h.val, i = i + c + 1;
                              break;
                            }
                        i >= 32 && (i -= 32, e++, q2 = f2[e]), G2 = U2 - S2, m2 ? (k3 > 0 && R2[M2 - 1] ? G2 += N3 : y > 0 && R2[M2 - B3] ? G2 += v[M2 - B3] : G2 += N3, G2 &= 255, v[M2] = G2, N3 = G2) : v[M2] = G2;
                      }
            } else
              for (M2 = 0, y = 0;y < D2; y++)
                for (k3 = 0;k3 < B3; k3++)
                  if (M2 = y * B3 + k3, !R2 || R2[M2])
                    for (Y3 = 0;Y3 < g2; Y3++, M2 += C2) {
                      if (U2 = 0, w = q2 << i >>> 32 - t, n = w, 32 - i < t && (w |= f2[e + 1] >>> 64 - i - t, n = w), r[n])
                        U2 = r[n][1], i += r[n][0];
                      else
                        for (w = q2 << i >>> 32 - F2, n = w, 32 - i < F2 && (w |= f2[e + 1] >>> 64 - i - F2, n = w), h = s2, c = 0;c < F2; c++)
                          if (l3 = w >>> F2 - c - 1 & 1, h = l3 ? h.right : h.left, !(h.left || h.right)) {
                            U2 = h.val, i = i + c + 1;
                            break;
                          }
                      i >= 32 && (i -= 32, e++, q2 = f2[e]), G2 = U2 - S2, v[M2] = G2;
                    }
            A2.ptr = A2.ptr + (e + 1) * 4 + (i > 0 ? 4 : 0), A2.pixels.resultPixels = O3, g2 > 1 && !a && (A2.pixels.resultPixels = L2.swapDimensionOrder(O3, C2, g2, I2));
          },
          decodeBits: function(E2, A2, I2, a, Q3) {
            {
              var g2 = A2.headerInfo, D2 = g2.fileVersion, B3 = 0, C2 = E2.byteLength - A2.ptr >= 5 ? 5 : E2.byteLength - A2.ptr, o = new DataView(E2, A2.ptr, C2), r = o.getUint8(0);
              B3++;
              var s2 = r >> 6, f2 = s2 === 0 ? 4 : 3 - s2, e = (r & 32) > 0, i = r & 31, t = 0;
              if (f2 === 1)
                t = o.getUint8(B3), B3++;
              else if (f2 === 2)
                t = o.getUint16(B3, true), B3 += 2;
              else if (f2 === 4)
                t = o.getUint32(B3, true), B3 += 4;
              else
                throw "Invalid valid pixel count type";
              var F2 = 2 * g2.maxZError, S2, h, U2, G2, R2, w, n, l3, y, k3 = g2.numDims > 1 ? g2.maxValues[Q3] : g2.zMax;
              if (e) {
                for (A2.counter.lut++, l3 = o.getUint8(B3), B3++, G2 = Math.ceil((l3 - 1) * i / 8), R2 = Math.ceil(G2 / 4), h = new ArrayBuffer(R2 * 4), U2 = new Uint8Array(h), A2.ptr += B3, U2.set(new Uint8Array(E2, A2.ptr, G2)), n = new Uint32Array(h), A2.ptr += G2, y = 0;l3 - 1 >>> y; )
                  y++;
                G2 = Math.ceil(t * y / 8), R2 = Math.ceil(G2 / 4), h = new ArrayBuffer(R2 * 4), U2 = new Uint8Array(h), U2.set(new Uint8Array(E2, A2.ptr, G2)), S2 = new Uint32Array(h), A2.ptr += G2, D2 >= 3 ? w = u.unstuffLUT2(n, i, l3 - 1, a, F2, k3) : w = u.unstuffLUT(n, i, l3 - 1, a, F2, k3), D2 >= 3 ? u.unstuff2(S2, I2, y, t, w) : u.unstuff(S2, I2, y, t, w);
              } else
                A2.counter.bitstuffer++, y = i, A2.ptr += B3, y > 0 && (G2 = Math.ceil(t * y / 8), R2 = Math.ceil(G2 / 4), h = new ArrayBuffer(R2 * 4), U2 = new Uint8Array(h), U2.set(new Uint8Array(E2, A2.ptr, G2)), S2 = new Uint32Array(h), A2.ptr += G2, D2 >= 3 ? a == null ? u.originalUnstuff2(S2, I2, y, t) : u.unstuff2(S2, I2, y, t, false, a, F2, k3) : a == null ? u.originalUnstuff(S2, I2, y, t) : u.unstuff(S2, I2, y, t, false, a, F2, k3));
            }
          },
          readTiles: function(E2, A2, I2, a) {
            var Q3 = A2.headerInfo, g2 = Q3.width, D2 = Q3.height, B3 = g2 * D2, C2 = Q3.microBlockSize, o = Q3.imageType, r = L2.getDataTypeSize(o), s2 = Math.ceil(g2 / C2), f2 = Math.ceil(D2 / C2);
            A2.pixels.numBlocksY = f2, A2.pixels.numBlocksX = s2, A2.pixels.ptr = 0;
            var e = 0, i = 0, t = 0, F2 = 0, S2 = 0, h = 0, U2 = 0, G2 = 0, R2 = 0, w = 0, n = 0, l3 = 0, y = 0, k3 = 0, M2 = 0, c = 0, N3, q2, m2, O3, v, Y3, P2 = new I2(C2 * C2), eA = D2 % C2 || C2, aA = g2 % C2 || C2, AA, b, $3 = Q3.numDims, W3, K3 = A2.pixels.resultMask, H2 = A2.pixels.resultPixels, rA = Q3.fileVersion, CA = rA >= 5 ? 14 : 15, p2, IA = Q3.zMax, V2;
            for (t = 0;t < f2; t++)
              for (S2 = t !== f2 - 1 ? C2 : eA, F2 = 0;F2 < s2; F2++)
                for (h = F2 !== s2 - 1 ? C2 : aA, n = t * g2 * C2 + F2 * C2, l3 = g2 - h, W3 = 0;W3 < $3; W3++) {
                  if ($3 > 1 ? (V2 = H2, n = t * g2 * C2 + F2 * C2, H2 = new I2(A2.pixels.resultPixels.buffer, B3 * W3 * r, B3), IA = Q3.maxValues[W3]) : V2 = null, U2 = E2.byteLength - A2.ptr, N3 = new DataView(E2, A2.ptr, Math.min(10, U2)), q2 = {}, c = 0, G2 = N3.getUint8(0), c++, p2 = Q3.fileVersion >= 5 ? G2 & 4 : 0, R2 = G2 >> 6 & 255, w = G2 >> 2 & CA, w !== (F2 * C2 >> 3 & CA) || p2 && W3 === 0)
                    throw "integrity issue";
                  if (Y3 = G2 & 3, Y3 > 3)
                    throw A2.ptr += c, "Invalid block encoding (" + Y3 + ")";
                  if (Y3 === 2) {
                    if (p2)
                      if (K3)
                        for (e = 0;e < S2; e++)
                          for (i = 0;i < h; i++)
                            K3[n] && (H2[n] = V2[n]), n++;
                      else
                        for (e = 0;e < S2; e++)
                          for (i = 0;i < h; i++)
                            H2[n] = V2[n], n++;
                    A2.counter.constant++, A2.ptr += c;
                    continue;
                  } else if (Y3 === 0) {
                    if (p2)
                      throw "integrity issue";
                    if (A2.counter.uncompressed++, A2.ptr += c, y = S2 * h * r, k3 = E2.byteLength - A2.ptr, y = y < k3 ? y : k3, m2 = new ArrayBuffer(y % r === 0 ? y : y + r - y % r), O3 = new Uint8Array(m2), O3.set(new Uint8Array(E2, A2.ptr, y)), v = new I2(m2), M2 = 0, K3)
                      for (e = 0;e < S2; e++) {
                        for (i = 0;i < h; i++)
                          K3[n] && (H2[n] = v[M2++]), n++;
                        n += l3;
                      }
                    else
                      for (e = 0;e < S2; e++) {
                        for (i = 0;i < h; i++)
                          H2[n++] = v[M2++];
                        n += l3;
                      }
                    A2.ptr += M2 * r;
                  } else if (AA = L2.getDataTypeUsed(p2 && o < 6 ? 4 : o, R2), b = L2.getOnePixel(q2, c, AA, N3), c += L2.getDataTypeSize(AA), Y3 === 3)
                    if (A2.ptr += c, A2.counter.constantoffset++, K3)
                      for (e = 0;e < S2; e++) {
                        for (i = 0;i < h; i++)
                          K3[n] && (H2[n] = p2 ? Math.min(IA, V2[n] + b) : b), n++;
                        n += l3;
                      }
                    else
                      for (e = 0;e < S2; e++) {
                        for (i = 0;i < h; i++)
                          H2[n] = p2 ? Math.min(IA, V2[n] + b) : b, n++;
                        n += l3;
                      }
                  else if (A2.ptr += c, L2.decodeBits(E2, A2, P2, b, W3), c = 0, p2)
                    if (K3)
                      for (e = 0;e < S2; e++) {
                        for (i = 0;i < h; i++)
                          K3[n] && (H2[n] = P2[c++] + V2[n]), n++;
                        n += l3;
                      }
                    else
                      for (e = 0;e < S2; e++) {
                        for (i = 0;i < h; i++)
                          H2[n] = P2[c++] + V2[n], n++;
                        n += l3;
                      }
                  else if (K3)
                    for (e = 0;e < S2; e++) {
                      for (i = 0;i < h; i++)
                        K3[n] && (H2[n] = P2[c++]), n++;
                      n += l3;
                    }
                  else
                    for (e = 0;e < S2; e++) {
                      for (i = 0;i < h; i++)
                        H2[n++] = P2[c++];
                      n += l3;
                    }
                }
            $3 > 1 && !a && (A2.pixels.resultPixels = L2.swapDimensionOrder(A2.pixels.resultPixels, B3, $3, I2));
          },
          formatFileInfo: function(E2) {
            return {
              fileIdentifierString: E2.headerInfo.fileIdentifierString,
              fileVersion: E2.headerInfo.fileVersion,
              imageType: E2.headerInfo.imageType,
              height: E2.headerInfo.height,
              width: E2.headerInfo.width,
              numValidPixel: E2.headerInfo.numValidPixel,
              microBlockSize: E2.headerInfo.microBlockSize,
              blobSize: E2.headerInfo.blobSize,
              maxZError: E2.headerInfo.maxZError,
              pixelType: L2.getPixelType(E2.headerInfo.imageType),
              eofOffset: E2.eofOffset,
              mask: E2.mask ? {
                numBytes: E2.mask.numBytes
              } : null,
              pixels: {
                numBlocksX: E2.pixels.numBlocksX,
                numBlocksY: E2.pixels.numBlocksY,
                maxValue: E2.headerInfo.zMax,
                minValue: E2.headerInfo.zMin,
                noDataValue: E2.noDataValue
              }
            };
          },
          constructConstantSurface: function(E2, A2) {
            var I2 = E2.headerInfo.zMax, a = E2.headerInfo.zMin, Q3 = E2.headerInfo.maxValues, g2 = E2.headerInfo.numDims, D2 = E2.headerInfo.height * E2.headerInfo.width, B3 = 0, C2 = 0, o = 0, r = E2.pixels.resultMask, s2 = E2.pixels.resultPixels;
            if (r)
              if (g2 > 1) {
                if (A2)
                  for (B3 = 0;B3 < g2; B3++)
                    for (o = B3 * D2, I2 = Q3[B3], C2 = 0;C2 < D2; C2++)
                      r[C2] && (s2[o + C2] = I2);
                else
                  for (C2 = 0;C2 < D2; C2++)
                    if (r[C2])
                      for (o = C2 * g2, B3 = 0;B3 < g2; B3++)
                        s2[o + g2] = Q3[B3];
              } else
                for (C2 = 0;C2 < D2; C2++)
                  r[C2] && (s2[C2] = I2);
            else if (g2 > 1 && a !== I2)
              if (A2)
                for (B3 = 0;B3 < g2; B3++)
                  for (o = B3 * D2, I2 = Q3[B3], C2 = 0;C2 < D2; C2++)
                    s2[o + C2] = I2;
              else
                for (C2 = 0;C2 < D2; C2++)
                  for (o = C2 * g2, B3 = 0;B3 < g2; B3++)
                    s2[o + B3] = Q3[B3];
            else
              for (C2 = 0;C2 < D2 * g2; C2++)
                s2[C2] = I2;
          },
          getDataTypeArray: function(E2) {
            var A2;
            switch (E2) {
              case 0:
                A2 = Int8Array;
                break;
              case 1:
                A2 = Uint8Array;
                break;
              case 2:
                A2 = Int16Array;
                break;
              case 3:
                A2 = Uint16Array;
                break;
              case 4:
                A2 = Int32Array;
                break;
              case 5:
                A2 = Uint32Array;
                break;
              case 6:
                A2 = Float32Array;
                break;
              case 7:
                A2 = Float64Array;
                break;
              default:
                A2 = Float32Array;
            }
            return A2;
          },
          getPixelType: function(E2) {
            var A2;
            switch (E2) {
              case 0:
                A2 = "S8";
                break;
              case 1:
                A2 = "U8";
                break;
              case 2:
                A2 = "S16";
                break;
              case 3:
                A2 = "U16";
                break;
              case 4:
                A2 = "S32";
                break;
              case 5:
                A2 = "U32";
                break;
              case 6:
                A2 = "F32";
                break;
              case 7:
                A2 = "F64";
                break;
              default:
                A2 = "F32";
            }
            return A2;
          },
          isValidPixelValue: function(E2, A2) {
            if (A2 == null)
              return false;
            var I2;
            switch (E2) {
              case 0:
                I2 = A2 >= -128 && A2 <= 127;
                break;
              case 1:
                I2 = A2 >= 0 && A2 <= 255;
                break;
              case 2:
                I2 = A2 >= -32768 && A2 <= 32767;
                break;
              case 3:
                I2 = A2 >= 0 && A2 <= 65536;
                break;
              case 4:
                I2 = A2 >= -2147483648 && A2 <= 2147483647;
                break;
              case 5:
                I2 = A2 >= 0 && A2 <= 4294967296;
                break;
              case 6:
                I2 = A2 >= -340279993879014840000000000000000000000 && A2 <= 340279993879014840000000000000000000000;
                break;
              case 7:
                I2 = A2 >= -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 && A2 <= 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
                break;
              default:
                I2 = false;
            }
            return I2;
          },
          getDataTypeSize: function(E2) {
            var A2 = 0;
            switch (E2) {
              case 0:
              case 1:
                A2 = 1;
                break;
              case 2:
              case 3:
                A2 = 2;
                break;
              case 4:
              case 5:
              case 6:
                A2 = 4;
                break;
              case 7:
                A2 = 8;
                break;
              default:
                A2 = E2;
            }
            return A2;
          },
          getDataTypeUsed: function(E2, A2) {
            var I2 = E2;
            switch (E2) {
              case 2:
              case 4:
                I2 = E2 - A2;
                break;
              case 3:
              case 5:
                I2 = E2 - 2 * A2;
                break;
              case 6:
                A2 === 0 ? I2 = E2 : A2 === 1 ? I2 = 2 : I2 = 1;
                break;
              case 7:
                A2 === 0 ? I2 = E2 : I2 = E2 - 2 * A2 + 1;
                break;
              default:
                I2 = E2;
                break;
            }
            return I2;
          },
          getOnePixel: function(E2, A2, I2, a) {
            var Q3 = 0;
            switch (I2) {
              case 0:
                Q3 = a.getInt8(A2);
                break;
              case 1:
                Q3 = a.getUint8(A2);
                break;
              case 2:
                Q3 = a.getInt16(A2, true);
                break;
              case 3:
                Q3 = a.getUint16(A2, true);
                break;
              case 4:
                Q3 = a.getInt32(A2, true);
                break;
              case 5:
                Q3 = a.getUInt32(A2, true);
                break;
              case 6:
                Q3 = a.getFloat32(A2, true);
                break;
              case 7:
                Q3 = a.getFloat64(A2, true);
                break;
              default:
                throw "the decoder does not understand this pixel type";
            }
            return Q3;
          },
          swapDimensionOrder: function(E2, A2, I2, a, Q3) {
            var g2 = 0, D2 = 0, B3 = 0, C2 = 0, o = E2;
            if (I2 > 1)
              if (o = new a(A2 * I2), Q3)
                for (g2 = 0;g2 < A2; g2++)
                  for (C2 = g2, B3 = 0;B3 < I2; B3++, C2 += A2)
                    o[C2] = E2[D2++];
              else
                for (g2 = 0;g2 < A2; g2++)
                  for (C2 = g2, B3 = 0;B3 < I2; B3++, C2 += A2)
                    o[D2++] = E2[C2];
            return o;
          }
        }, d3 = function(E2, A2, I2) {
          this.val = E2, this.left = A2, this.right = I2;
        }, z = {
          decode: function(E2, A2) {
            A2 = A2 || {};
            var I2 = A2.noDataValue, a = 0, Q3 = {};
            if (Q3.ptr = A2.inputOffset || 0, Q3.pixels = {}, !!L2.readHeaderInfo(E2, Q3)) {
              var g2 = Q3.headerInfo, D2 = g2.fileVersion, B3 = L2.getDataTypeArray(g2.imageType);
              if (D2 > 5)
                throw "unsupported lerc version 2." + D2;
              L2.readMask(E2, Q3), g2.numValidPixel !== g2.width * g2.height && !Q3.pixels.resultMask && (Q3.pixels.resultMask = A2.maskData);
              var C2 = g2.width * g2.height;
              Q3.pixels.resultPixels = new B3(C2 * g2.numDims), Q3.counter = {
                onesweep: 0,
                uncompressed: 0,
                lut: 0,
                bitstuffer: 0,
                constant: 0,
                constantoffset: 0
              };
              var o = !A2.returnPixelInterleavedDims;
              if (g2.numValidPixel !== 0)
                if (g2.zMax === g2.zMin)
                  L2.constructConstantSurface(Q3, o);
                else if (D2 >= 4 && L2.checkMinMaxRanges(E2, Q3))
                  L2.constructConstantSurface(Q3, o);
                else {
                  var r = new DataView(E2, Q3.ptr, 2), s2 = r.getUint8(0);
                  if (Q3.ptr++, s2)
                    L2.readDataOneSweep(E2, Q3, B3, o);
                  else if (D2 > 1 && g2.imageType <= 1 && Math.abs(g2.maxZError - 0.5) < 0.00001) {
                    var f2 = r.getUint8(1);
                    if (Q3.ptr++, Q3.encodeMode = f2, f2 > 2 || D2 < 4 && f2 > 1)
                      throw "Invalid Huffman flag " + f2;
                    f2 ? L2.readHuffman(E2, Q3, B3, o) : L2.readTiles(E2, Q3, B3, o);
                  } else
                    L2.readTiles(E2, Q3, B3, o);
                }
              Q3.eofOffset = Q3.ptr;
              var e;
              A2.inputOffset ? (e = Q3.headerInfo.blobSize + A2.inputOffset - Q3.ptr, Math.abs(e) >= 1 && (Q3.eofOffset = A2.inputOffset + Q3.headerInfo.blobSize)) : (e = Q3.headerInfo.blobSize - Q3.ptr, Math.abs(e) >= 1 && (Q3.eofOffset = Q3.headerInfo.blobSize));
              var i = {
                width: g2.width,
                height: g2.height,
                pixelData: Q3.pixels.resultPixels,
                minValue: g2.zMin,
                maxValue: g2.zMax,
                validPixelCount: g2.numValidPixel,
                dimCount: g2.numDims,
                dimStats: {
                  minValues: g2.minValues,
                  maxValues: g2.maxValues
                },
                maskData: Q3.pixels.resultMask
              };
              if (Q3.pixels.resultMask && L2.isValidPixelValue(g2.imageType, I2)) {
                var t = Q3.pixels.resultMask;
                for (a = 0;a < C2; a++)
                  t[a] || (i.pixelData[a] = I2);
                i.noDataValue = I2;
              }
              return Q3.noDataValue = I2, A2.returnFileInfo && (i.fileInfo = L2.formatFileInfo(Q3)), i;
            }
          },
          getBandCount: function(E2) {
            var A2 = 0, I2 = 0, a = {};
            for (a.ptr = 0, a.pixels = {};I2 < E2.byteLength - 58; )
              L2.readHeaderInfo(E2, a), I2 += a.headerInfo.blobSize, A2++, a.ptr = I2;
            return A2;
          }
        };
        return z;
      }(), Z3 = function() {
        var u = new ArrayBuffer(4), L2 = new Uint8Array(u), d3 = new Uint32Array(u);
        return d3[0] = 1, L2[0] === 1;
      }(), X2 = {
        decode: function(u, L2) {
          if (!Z3)
            throw "Big endian system is not supported.";
          L2 = L2 || {};
          var d3 = L2.inputOffset || 0, z = new Uint8Array(u, d3, 10), E2 = String.fromCharCode.apply(null, z), A2, I2;
          if (E2.trim() === "CntZImage")
            A2 = J, I2 = 1;
          else if (E2.substring(0, 5) === "Lerc2")
            A2 = T2, I2 = 2;
          else
            throw "Unexpected file identifier string: " + E2;
          for (var a = 0, Q3 = u.byteLength - 10, g2, D2 = [], B3, C2, o = {
            width: 0,
            height: 0,
            pixels: [],
            pixelType: L2.pixelType,
            mask: null,
            statistics: []
          }, r = 0;d3 < Q3; ) {
            var s2 = A2.decode(u, {
              inputOffset: d3,
              encodedMaskData: g2,
              maskData: C2,
              returnMask: a === 0,
              returnEncodedMask: a === 0,
              returnFileInfo: true,
              returnPixelInterleavedDims: L2.returnPixelInterleavedDims,
              pixelType: L2.pixelType || null,
              noDataValue: L2.noDataValue || null
            });
            d3 = s2.fileInfo.eofOffset, C2 = s2.maskData, a === 0 && (g2 = s2.encodedMaskData, o.width = s2.width, o.height = s2.height, o.dimCount = s2.dimCount || 1, o.pixelType = s2.pixelType || s2.fileInfo.pixelType, o.mask = C2), I2 > 1 && (C2 && D2.push(C2), s2.fileInfo.mask && s2.fileInfo.mask.numBytes > 0 && r++), a++, o.pixels.push(s2.pixelData), o.statistics.push({
              minValue: s2.minValue,
              maxValue: s2.maxValue,
              noDataValue: s2.noDataValue,
              dimStats: s2.dimStats
            });
          }
          var f2, e, i;
          if (I2 > 1 && r > 1) {
            for (i = o.width * o.height, o.bandMasks = D2, C2 = new Uint8Array(i), C2.set(D2[0]), f2 = 1;f2 < D2.length; f2++)
              for (B3 = D2[f2], e = 0;e < i; e++)
                C2[e] = C2[e] & B3[e];
            o.maskData = C2;
          }
          return o;
        }
      };
      j2.exports ? j2.exports = X2 : this.Lerc = X2;
    })();
  })(iA);
  fA = iA.exports;
  tA = /* @__PURE__ */ We2(fA);
  BA = {
    env: {
      emscripten_notify_memory_growth: function(j2) {
        QA = new Uint8Array(x2.exports.memory.buffer);
      }
    }
  };
  hA = new wA;
  lA = class lA extends g {
    constructor(J) {
      super(), this.planarConfiguration = typeof J.PlanarConfiguration < "u" ? J.PlanarConfiguration : 1, this.samplesPerPixel = typeof J.SamplesPerPixel < "u" ? J.SamplesPerPixel : 1, this.addCompression = J.LercParameters[ss.AddCompression];
    }
    decodeBlock(J) {
      switch (this.addCompression) {
        case is.None:
          break;
        case is.Deflate:
          J = br(new Uint8Array(J)).buffer;
          break;
        case is.Zstandard:
          J = hA.decode(new Uint8Array(J)).buffer;
          break;
        default:
          throw new Error(`Unsupported LERC additional compression method identifier: ${this.addCompression}`);
      }
      return tA.decode(J, { returnPixelInterleavedDims: this.planarConfiguration === 1 }).pixels[0].buffer;
    }
  };
});

// node_modules/geotiff-tilesource/dist/webimage-BM_pbLN3.js
var exports_webimage_BM_pbLN3 = {};
__export(exports_webimage_BM_pbLN3, {
  default: () => s2
});
var s2;
var init_webimage_BM_pbLN3 = __esm(() => {
  init_basedecoder_DHcBySSe();
  s2 = class s2 extends g {
    constructor() {
      if (super(), typeof createImageBitmap > "u")
        throw new Error("Cannot decode WebImage as `createImageBitmap` is not available");
      if (typeof document > "u" && typeof OffscreenCanvas > "u")
        throw new Error("Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available");
    }
    async decode(i, n) {
      const o = new Blob([n]), e = await createImageBitmap(o);
      let t;
      typeof document < "u" ? (t = document.createElement("canvas"), t.width = e.width, t.height = e.height) : t = new OffscreenCanvas(e.width, e.height);
      const a = t.getContext("2d");
      return a.drawImage(e, 0, 0), a.getImageData(0, 0, e.width, e.height).data.buffer;
    }
  };
});

// node_modules/geotiff-tilesource/dist/decoder-DJlmx386.js
var exports_decoder_DJlmx386 = {};
__export(exports_decoder_DJlmx386, {
  create: () => t
});
function t() {
  const A2 = 'function A(A,e,t,i,r,I,g){try{var n=A[I](g),a=n.value}catch(A){return void t(A)}n.done?e(a):Promise.resolve(a).then(i,r)}function e(e){return function(){var t=this,i=arguments;return new Promise((function(r,I){var g=e.apply(t,i);function n(e){A(g,r,I,n,a,"next",e)}function a(e){A(g,r,I,n,a,"throw",e)}n(void 0)}))}}function t(A){return t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(A){return typeof A}:function(A){return A&&"function"==typeof Symbol&&A.constructor===Symbol&&A!==Symbol.prototype?"symbol":typeof A},t(A)}var i={exports:{}};!function(A){var e=function(A){var e,i=Object.prototype,r=i.hasOwnProperty,I="function"==typeof Symbol?Symbol:{},g=I.iterator||"@@iterator",n=I.asyncIterator||"@@asyncIterator",a=I.toStringTag||"@@toStringTag";function o(A,e,t){return Object.defineProperty(A,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),A[e]}try{o({},"")}catch(A){o=function(A,e,t){return A[e]=t}}function B(A,e,t,i){var r=e&&e.prototype instanceof h?e:h,I=Object.create(r.prototype),g=new S(i||[]);return I._invoke=function(A,e,t){var i=Q;return function(r,I){if(i===s)throw new Error("Generator is already running");if(i===f){if("throw"===r)throw I;return R()}for(t.method=r,t.arg=I;;){var g=t.delegate;if(g){var n=m(g,t);if(n){if(n===c)continue;return n}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if(i===Q)throw i=f,t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);i=s;var a=C(A,e,t);if("normal"===a.type){if(i=t.done?f:E,a.arg===c)continue;return{value:a.arg,done:t.done}}"throw"===a.type&&(i=f,t.method="throw",t.arg=a.arg)}}}(A,t,g),I}function C(A,e,t){try{return{type:"normal",arg:A.call(e,t)}}catch(A){return{type:"throw",arg:A}}}A.wrap=B;var Q="suspendedStart",E="suspendedYield",s="executing",f="completed",c={};function h(){}function l(){}function u(){}var w={};o(w,g,(function(){return this}));var d=Object.getPrototypeOf,D=d&&d(d(v([])));D&&D!==i&&r.call(D,g)&&(w=D);var y=u.prototype=h.prototype=Object.create(w);function k(A){["next","throw","return"].forEach((function(e){o(A,e,(function(A){return this._invoke(e,A)}))}))}function p(A,e){function i(I,g,n,a){var o=C(A[I],A,g);if("throw"!==o.type){var B=o.arg,Q=B.value;return Q&&"object"===t(Q)&&r.call(Q,"__await")?e.resolve(Q.__await).then((function(A){i("next",A,n,a)}),(function(A){i("throw",A,n,a)})):e.resolve(Q).then((function(A){B.value=A,n(B)}),(function(A){return i("throw",A,n,a)}))}a(o.arg)}var I;this._invoke=function(A,t){function r(){return new e((function(e,r){i(A,t,e,r)}))}return I=I?I.then(r,r):r()}}function m(A,t){var i=A.iterator[t.method];if(i===e){if(t.delegate=null,"throw"===t.method){if(A.iterator.return&&(t.method="return",t.arg=e,m(A,t),"throw"===t.method))return c;t.method="throw",t.arg=new TypeError("The iterator does not provide a \'throw\' method")}return c}var r=C(i,A.iterator,t.arg);if("throw"===r.type)return t.method="throw",t.arg=r.arg,t.delegate=null,c;var I=r.arg;return I?I.done?(t[A.resultName]=I.value,t.next=A.nextLoc,"return"!==t.method&&(t.method="next",t.arg=e),t.delegate=null,c):I:(t.method="throw",t.arg=new TypeError("iterator result is not an object"),t.delegate=null,c)}function G(A){var e={tryLoc:A[0]};1 in A&&(e.catchLoc=A[1]),2 in A&&(e.finallyLoc=A[2],e.afterLoc=A[3]),this.tryEntries.push(e)}function F(A){var e=A.completion||{};e.type="normal",delete e.arg,A.completion=e}function S(A){this.tryEntries=[{tryLoc:"root"}],A.forEach(G,this),this.reset(!0)}function v(A){if(A){var t=A[g];if(t)return t.call(A);if("function"==typeof A.next)return A;if(!isNaN(A.length)){var i=-1,I=function t(){for(;++i<A.length;)if(r.call(A,i))return t.value=A[i],t.done=!1,t;return t.value=e,t.done=!0,t};return I.next=I}}return{next:R}}function R(){return{value:e,done:!0}}return l.prototype=u,o(y,"constructor",u),o(u,"constructor",l),l.displayName=o(u,a,"GeneratorFunction"),A.isGeneratorFunction=function(A){var e="function"==typeof A&&A.constructor;return!!e&&(e===l||"GeneratorFunction"===(e.displayName||e.name))},A.mark=function(A){return Object.setPrototypeOf?Object.setPrototypeOf(A,u):(A.__proto__=u,o(A,a,"GeneratorFunction")),A.prototype=Object.create(y),A},A.awrap=function(A){return{__await:A}},k(p.prototype),o(p.prototype,n,(function(){return this})),A.AsyncIterator=p,A.async=function(e,t,i,r,I){void 0===I&&(I=Promise);var g=new p(B(e,t,i,r),I);return A.isGeneratorFunction(t)?g:g.next().then((function(A){return A.done?A.value:g.next()}))},k(y),o(y,a,"Generator"),o(y,g,(function(){return this})),o(y,"toString",(function(){return"[object Generator]"})),A.keys=function(A){var e=[];for(var t in A)e.push(t);return e.reverse(),function t(){for(;e.length;){var i=e.pop();if(i in A)return t.value=i,t.done=!1,t}return t.done=!0,t}},A.values=v,S.prototype={constructor:S,reset:function(A){if(this.prev=0,this.next=0,this.sent=this._sent=e,this.done=!1,this.delegate=null,this.method="next",this.arg=e,this.tryEntries.forEach(F),!A)for(var t in this)"t"===t.charAt(0)&&r.call(this,t)&&!isNaN(+t.slice(1))&&(this[t]=e)},stop:function(){this.done=!0;var A=this.tryEntries[0].completion;if("throw"===A.type)throw A.arg;return this.rval},dispatchException:function(A){if(this.done)throw A;var t=this;function i(i,r){return n.type="throw",n.arg=A,t.next=i,r&&(t.method="next",t.arg=e),!!r}for(var I=this.tryEntries.length-1;I>=0;--I){var g=this.tryEntries[I],n=g.completion;if("root"===g.tryLoc)return i("end");if(g.tryLoc<=this.prev){var a=r.call(g,"catchLoc"),o=r.call(g,"finallyLoc");if(a&&o){if(this.prev<g.catchLoc)return i(g.catchLoc,!0);if(this.prev<g.finallyLoc)return i(g.finallyLoc)}else if(a){if(this.prev<g.catchLoc)return i(g.catchLoc,!0)}else{if(!o)throw new Error("try statement without catch or finally");if(this.prev<g.finallyLoc)return i(g.finallyLoc)}}}},abrupt:function(A,e){for(var t=this.tryEntries.length-1;t>=0;--t){var i=this.tryEntries[t];if(i.tryLoc<=this.prev&&r.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var I=i;break}}I&&("break"===A||"continue"===A)&&I.tryLoc<=e&&e<=I.finallyLoc&&(I=null);var g=I?I.completion:{};return g.type=A,g.arg=e,I?(this.method="next",this.next=I.finallyLoc,c):this.complete(g)},complete:function(A,e){if("throw"===A.type)throw A.arg;return"break"===A.type||"continue"===A.type?this.next=A.arg:"return"===A.type?(this.rval=this.arg=A.arg,this.method="return",this.next="end"):"normal"===A.type&&e&&(this.next=e),c},finish:function(A){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===A)return this.complete(t.completion,t.afterLoc),F(t),c}},catch:function(A){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===A){var i=t.completion;if("throw"===i.type){var r=i.arg;F(t)}return r}}throw new Error("illegal catch attempt")},delegateYield:function(A,t,i){return this.delegate={iterator:v(A),resultName:t,nextLoc:i},"next"===this.method&&(this.arg=e),c}},A}(A.exports);try{regeneratorRuntime=e}catch(A){"object"===("undefined"==typeof globalThis?"undefined":t(globalThis))?globalThis.regeneratorRuntime=e:Function("r","regeneratorRuntime = r")(e)}}(i);var r=i.exports,I=new Map;function g(A,e){Array.isArray(A)||(A=[A]),A.forEach((function(A){return I.set(A,e)}))}function n(A){return a.apply(this,arguments)}function a(){return(a=e(r.mark((function A(e){var t,i;return r.wrap((function(A){for(;;)switch(A.prev=A.next){case 0:if(t=I.get(e.Compression)){A.next=3;break}throw new Error("Unknown compression method identifier: ".concat(e.Compression));case 3:return A.next=5,t();case 5:return i=A.sent,A.abrupt("return",new i(e));case 7:case"end":return A.stop()}}),A)})))).apply(this,arguments)}g([void 0,1],(function(){return Promise.resolve().then((function(){return y})).then((function(A){return A.default}))})),g(5,(function(){return Promise.resolve().then((function(){return F})).then((function(A){return A.default}))})),g(6,(function(){throw new Error("old style JPEG compression is not supported.")})),g(7,(function(){return Promise.resolve().then((function(){return N})).then((function(A){return A.default}))})),g([8,32946],(function(){return Promise.resolve().then((function(){return OA})).then((function(A){return A.default}))})),g(32773,(function(){return Promise.resolve().then((function(){return _A})).then((function(A){return A.default}))})),g(34887,(function(){return Promise.resolve().then((function(){return le})).then(function(){var A=e(r.mark((function A(e){return r.wrap((function(A){for(;;)switch(A.prev=A.next){case 0:return A.next=2,e.zstd.init();case 2:return A.abrupt("return",e);case 3:case"end":return A.stop()}}),A)})));return function(e){return A.apply(this,arguments)}}()).then((function(A){return A.default}))})),g(50001,(function(){return Promise.resolve().then((function(){return de})).then((function(A){return A.default}))}));var o=globalThis;function B(A,e){if(!(A instanceof e))throw new TypeError("Cannot call a class as a function")}function C(A,e){for(var t=0;t<e.length;t++){var i=e[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(A,i.key,i)}}function Q(A,e,t){return e&&C(A.prototype,e),t&&C(A,t),A}function E(A,e){return E=Object.setPrototypeOf||function(A,e){return A.__proto__=e,A},E(A,e)}function s(A,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");A.prototype=Object.create(e&&e.prototype,{constructor:{value:A,writable:!0,configurable:!0}}),e&&E(A,e)}function f(A,e){if(e&&("object"===t(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(A){if(void 0===A)throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");return A}(A)}function c(A){return c=Object.setPrototypeOf?Object.getPrototypeOf:function(A){return A.__proto__||Object.getPrototypeOf(A)},c(A)}function h(A,e){var t=A.length-e,i=0;do{for(var r=e;r>0;r--)A[i+e]+=A[i],i++;t-=e}while(t>0)}function l(A,e,t){for(var i=0,r=A.length,I=r/t;r>e;){for(var g=e;g>0;--g)A[i+e]+=A[i],++i;r-=e}for(var n=A.slice(),a=0;a<I;++a)for(var o=0;o<t;++o)A[t*a+o]=n[(t-o-1)*I+a]}function u(A,e,t,i,r,I){if(!e||1===e)return A;for(var g=0;g<r.length;++g){if(r[g]%8!=0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(r[g]!==r[0])throw new Error("When decoding with predictor, all samples must have the same size.")}for(var n=r[0]/8,a=2===I?1:r.length,o=0;o<i&&!(o*a*t*n>=A.byteLength);++o){var B=void 0;if(2===e){switch(r[0]){case 8:B=new Uint8Array(A,o*a*t*n,a*t*n);break;case 16:B=new Uint16Array(A,o*a*t*n,a*t*n/2);break;case 32:B=new Uint32Array(A,o*a*t*n,a*t*n/4);break;default:throw new Error("Predictor 2 not allowed with ".concat(r[0]," bits per sample."))}h(B,a)}else 3===e&&l(B=new Uint8Array(A,o*a*t*n,a*t*n),a,n)}return A}o.addEventListener("message",function(){var A=e(r.mark((function A(e){var t,i,I,g,a,B;return r.wrap((function(A){for(;;)switch(A.prev=A.next){case 0:return t=e.data,i=t.id,I=t.fileDirectory,g=t.buffer,A.next=3,n(I);case 3:return a=A.sent,A.next=6,a.decode(I,g);case 6:B=A.sent,o.postMessage({decoded:B,id:i},[B]);case 8:case"end":return A.stop()}}),A)})));return function(e){return A.apply(this,arguments)}}());var w=function(){function A(){B(this,A)}var t;return Q(A,[{key:"decode",value:(t=e(r.mark((function A(e,t){var i,I,g,n,a;return r.wrap((function(A){for(;;)switch(A.prev=A.next){case 0:return A.next=2,this.decodeBlock(t);case 2:if(i=A.sent,1===(I=e.Predictor||1)){A.next=9;break}return g=!e.StripOffsets,n=g?e.TileWidth:e.ImageWidth,a=g?e.TileLength:e.RowsPerStrip||e.ImageLength,A.abrupt("return",u(i,I,n,a,e.BitsPerSample,e.PlanarConfiguration));case 9:return A.abrupt("return",i);case 10:case"end":return A.stop()}}),A,this)}))),function(A,e){return t.apply(this,arguments)})}]),A}();function d(A){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var D=function(A){s(t,w);var e=d(t);function t(){return B(this,t),e.apply(this,arguments)}return Q(t,[{key:"decodeBlock",value:function(A){return A}}]),t}(),y=Object.freeze({__proto__:null,default:D});function k(A){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}function p(A,e){for(var t=e.length-1;t>=0;t--)A.push(e[t]);return A}function m(A){for(var e=new Uint16Array(4093),t=new Uint8Array(4093),i=0;i<=257;i++)e[i]=4096,t[i]=i;var r=258,I=9,g=0;function n(){r=258,I=9}function a(A){var e=function(A,e,t){var i=e%8,r=Math.floor(e/8),I=8-i,g=e+t-8*(r+1),n=8*(r+2)-(e+t),a=8*(r+2)-e;if(n=Math.max(0,n),r>=A.length)return console.warn("ran off the end of the buffer before finding EOI_CODE (end on input code)"),257;var o=A[r]&Math.pow(2,8-i)-1,B=o<<=t-I;if(r+1<A.length){var C=A[r+1]>>>n;B+=C<<=Math.max(0,t-a)}if(g>8&&r+2<A.length){var Q=8*(r+3)-(e+t);B+=A[r+2]>>>Q}return B}(A,g,I);return g+=I,e}function o(A,i){return t[r]=i,e[r]=A,++r-1}function B(A){for(var i=[],r=A;4096!==r;r=e[r])i.push(t[r]);return i}var C=[];n();for(var Q,E=new Uint8Array(A),s=a(E);257!==s;){if(256===s){for(n(),s=a(E);256===s;)s=a(E);if(257===s)break;if(s>256)throw new Error("corrupted code at scanline ".concat(s));p(C,B(s)),Q=s}else if(s<r){var f=B(s);p(C,f),o(Q,f[f.length-1]),Q=s}else{var c=B(Q);if(!c)throw new Error("Bogus entry. Not in dictionary, ".concat(Q," / ").concat(r,", position: ").concat(g));p(C,c),C.push(c[c.length-1]),o(Q,c[c.length-1]),Q=s}r+1>=Math.pow(2,I)&&(12===I?Q=void 0:I++),s=a(E)}return new Uint8Array(C)}var G=function(A){s(t,w);var e=k(t);function t(){return B(this,t),e.apply(this,arguments)}return Q(t,[{key:"decodeBlock",value:function(A){return m(A).buffer}}]),t}(),F=Object.freeze({__proto__:null,default:G});function S(A){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var v=new Int32Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]);function R(A,e){for(var t=0,i=[],r=16;r>0&&!A[r-1];)--r;i.push({children:[],index:0});for(var I,g=i[0],n=0;n<r;n++){for(var a=0;a<A[n];a++){for((g=i.pop()).children[g.index]=e[t];g.index>0;)g=i.pop();for(g.index++,i.push(g);i.length<=n;)i.push(I={children:[],index:0}),g.children[g.index]=I.children,g=I;t++}n+1<r&&(i.push(I={children:[],index:0}),g.children[g.index]=I.children,g=I)}return i[0].children}function U(A,e,i,r,I,g,n,a,o){var B=i.mcusPerLine,C=i.progressive,Q=e,E=e,s=0,f=0;function c(){if(f>0)return f--,s>>f&1;if(255===(s=A[E++])){var e=A[E++];if(e)throw new Error("unexpected marker: ".concat((s<<8|e).toString(16)))}return f=7,s>>>7}function h(A){for(var e,i=A;null!==(e=c());){if("number"==typeof(i=i[e]))return i;if("object"!==t(i))throw new Error("invalid huffman sequence")}return null}function l(A){for(var e=A,t=0;e>0;){var i=c();if(null===i)return;t=t<<1|i,--e}return t}function u(A){var e=l(A);return e>=1<<A-1?e:e+(-1<<A)+1}var w=0;var d,D=0;function y(A,e,t,i,r){var I=t%B,g=(t/B|0)*A.v+i,n=I*A.h+r;e(A,A.blocks[g][n])}function k(A,e,t){var i=t/A.blocksPerLine|0,r=t%A.blocksPerLine;e(A,A.blocks[i][r])}var p,m,G,F,S,R,U=r.length;R=C?0===g?0===a?function(A,e){var t=h(A.huffmanTableDC),i=0===t?0:u(t)<<o;A.pred+=i,e[0]=A.pred}:function(A,e){e[0]|=c()<<o}:0===a?function(A,e){if(w>0)w--;else for(var t=g,i=n;t<=i;){var r=h(A.huffmanTableAC),I=15&r,a=r>>4;if(0===I){if(a<15){w=l(a)+(1<<a)-1;break}t+=16}else e[v[t+=a]]=u(I)*(1<<o),t++}}:function(A,e){for(var t=g,i=n,r=0;t<=i;){var I=v[t],a=e[I]<0?-1:1;switch(D){case 0:var B=h(A.huffmanTableAC),C=15&B;if(r=B>>4,0===C)r<15?(w=l(r)+(1<<r),D=4):(r=16,D=1);else{if(1!==C)throw new Error("invalid ACn encoding");d=u(C),D=r?2:3}continue;case 1:case 2:e[I]?e[I]+=(c()<<o)*a:0==--r&&(D=2===D?3:0);break;case 3:e[I]?e[I]+=(c()<<o)*a:(e[I]=d<<o,D=0);break;case 4:e[I]&&(e[I]+=(c()<<o)*a)}t++}4===D&&0==--w&&(D=0)}:function(A,e){var t=h(A.huffmanTableDC),i=0===t?0:u(t);A.pred+=i,e[0]=A.pred;for(var r=1;r<64;){var I=h(A.huffmanTableAC),g=15&I,n=I>>4;if(0===g){if(n<15)break;r+=16}else e[v[r+=n]]=u(g),r++}};var L,b,M=0;b=1===U?r[0].blocksPerLine*r[0].blocksPerColumn:B*i.mcusPerColumn;for(var N=I||b;M<b;){for(m=0;m<U;m++)r[m].pred=0;if(w=0,1===U)for(p=r[0],S=0;S<N;S++)k(p,R,M),M++;else for(S=0;S<N;S++){for(m=0;m<U;m++){var x=p=r[m],J=x.h,q=x.v;for(G=0;G<q;G++)for(F=0;F<J;F++)y(p,R,M,G,F)}if(++M===b)break}if(f=0,(L=A[E]<<8|A[E+1])<65280)throw new Error("marker was not found");if(!(L>=65488&&L<=65495))break;E+=2}return E-Q}function L(A,e){var t=[],i=e.blocksPerLine,r=e.blocksPerColumn,I=i<<3,g=new Int32Array(64),n=new Uint8Array(64);function a(A,t,i){var r,I,g,n,a,o,B,C,Q,E,s=e.quantizationTable,f=i;for(E=0;E<64;E++)f[E]=A[E]*s[E];for(E=0;E<8;++E){var c=8*E;0!==f[1+c]||0!==f[2+c]||0!==f[3+c]||0!==f[4+c]||0!==f[5+c]||0!==f[6+c]||0!==f[7+c]?(r=5793*f[0+c]+128>>8,I=5793*f[4+c]+128>>8,g=f[2+c],n=f[6+c],a=2896*(f[1+c]-f[7+c])+128>>8,C=2896*(f[1+c]+f[7+c])+128>>8,o=f[3+c]<<4,Q=r-I+1>>1,r=r+I+1>>1,I=Q,Q=3784*g+1567*n+128>>8,g=1567*g-3784*n+128>>8,n=Q,Q=a-(B=f[5+c]<<4)+1>>1,a=a+B+1>>1,B=Q,Q=C+o+1>>1,o=C-o+1>>1,C=Q,Q=r-n+1>>1,r=r+n+1>>1,n=Q,Q=I-g+1>>1,I=I+g+1>>1,g=Q,Q=2276*a+3406*C+2048>>12,a=3406*a-2276*C+2048>>12,C=Q,Q=799*o+4017*B+2048>>12,o=4017*o-799*B+2048>>12,B=Q,f[0+c]=r+C,f[7+c]=r-C,f[1+c]=I+B,f[6+c]=I-B,f[2+c]=g+o,f[5+c]=g-o,f[3+c]=n+a,f[4+c]=n-a):(Q=5793*f[0+c]+512>>10,f[0+c]=Q,f[1+c]=Q,f[2+c]=Q,f[3+c]=Q,f[4+c]=Q,f[5+c]=Q,f[6+c]=Q,f[7+c]=Q)}for(E=0;E<8;++E){var h=E;0!==f[8+h]||0!==f[16+h]||0!==f[24+h]||0!==f[32+h]||0!==f[40+h]||0!==f[48+h]||0!==f[56+h]?(r=5793*f[0+h]+2048>>12,I=5793*f[32+h]+2048>>12,g=f[16+h],n=f[48+h],a=2896*(f[8+h]-f[56+h])+2048>>12,C=2896*(f[8+h]+f[56+h])+2048>>12,o=f[24+h],Q=r-I+1>>1,r=r+I+1>>1,I=Q,Q=3784*g+1567*n+2048>>12,g=1567*g-3784*n+2048>>12,n=Q,Q=a-(B=f[40+h])+1>>1,a=a+B+1>>1,B=Q,Q=C+o+1>>1,o=C-o+1>>1,C=Q,Q=r-n+1>>1,r=r+n+1>>1,n=Q,Q=I-g+1>>1,I=I+g+1>>1,g=Q,Q=2276*a+3406*C+2048>>12,a=3406*a-2276*C+2048>>12,C=Q,Q=799*o+4017*B+2048>>12,o=4017*o-799*B+2048>>12,B=Q,f[0+h]=r+C,f[56+h]=r-C,f[8+h]=I+B,f[48+h]=I-B,f[16+h]=g+o,f[40+h]=g-o,f[24+h]=n+a,f[32+h]=n-a):(Q=5793*i[E+0]+8192>>14,f[0+h]=Q,f[8+h]=Q,f[16+h]=Q,f[24+h]=Q,f[32+h]=Q,f[40+h]=Q,f[48+h]=Q,f[56+h]=Q)}for(E=0;E<64;++E){var l=128+(f[E]+8>>4);t[E]=l<0?0:l>255?255:l}}for(var o=0;o<r;o++){for(var B=o<<3,C=0;C<8;C++)t.push(new Uint8Array(I));for(var Q=0;Q<i;Q++){a(e.blocks[o][Q],n,g);for(var E=0,s=Q<<3,f=0;f<8;f++)for(var c=t[B+f],h=0;h<8;h++)c[s+h]=n[E++]}}return t}var b=function(){function A(){B(this,A),this.jfif=null,this.adobe=null,this.quantizationTables=[],this.huffmanTablesAC=[],this.huffmanTablesDC=[],this.resetFrames()}return Q(A,[{key:"resetFrames",value:function(){this.frames=[]}},{key:"parse",value:function(A){var e=0;function t(){var t=A[e]<<8|A[e+1];return e+=2,t}function i(A){var e,t,i=0,r=0;for(t in A.components)A.components.hasOwnProperty(t)&&(i<(e=A.components[t]).h&&(i=e.h),r<e.v&&(r=e.v));var I=Math.ceil(A.samplesPerLine/8/i),g=Math.ceil(A.scanLines/8/r);for(t in A.components)if(A.components.hasOwnProperty(t)){e=A.components[t];for(var n=Math.ceil(Math.ceil(A.samplesPerLine/8)*e.h/i),a=Math.ceil(Math.ceil(A.scanLines/8)*e.v/r),o=I*e.h,B=g*e.v,C=[],Q=0;Q<B;Q++){for(var E=[],s=0;s<o;s++)E.push(new Int32Array(64));C.push(E)}e.blocksPerLine=n,e.blocksPerColumn=a,e.blocks=C}A.maxH=i,A.maxV=r,A.mcusPerLine=I,A.mcusPerColumn=g}var r,I,g=t();if(65496!==g)throw new Error("SOI not found");for(g=t();65497!==g;){switch(g){case 65280:break;case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:var n=(r=void 0,I=void 0,r=t(),I=A.subarray(e,e+r-2),e+=I.length,I);65504===g&&74===n[0]&&70===n[1]&&73===n[2]&&70===n[3]&&0===n[4]&&(this.jfif={version:{major:n[5],minor:n[6]},densityUnits:n[7],xDensity:n[8]<<8|n[9],yDensity:n[10]<<8|n[11],thumbWidth:n[12],thumbHeight:n[13],thumbData:n.subarray(14,14+3*n[12]*n[13])}),65518===g&&65===n[0]&&100===n[1]&&111===n[2]&&98===n[3]&&101===n[4]&&0===n[5]&&(this.adobe={version:n[6],flags0:n[7]<<8|n[8],flags1:n[9]<<8|n[10],transformCode:n[11]});break;case 65499:for(var a=t()+e-2;e<a;){var o=A[e++],B=new Int32Array(64);if(o>>4==0)for(var C=0;C<64;C++){B[v[C]]=A[e++]}else{if(o>>4!=1)throw new Error("DQT: invalid table spec");for(var Q=0;Q<64;Q++){B[v[Q]]=t()}}this.quantizationTables[15&o]=B}break;case 65472:case 65473:case 65474:t();for(var E={extended:65473===g,progressive:65474===g,precision:A[e++],scanLines:t(),samplesPerLine:t(),components:{},componentsOrder:[]},s=A[e++],f=void 0,c=0;c<s;c++){f=A[e];var h=A[e+1]>>4,l=15&A[e+1],u=A[e+2];E.componentsOrder.push(f),E.components[f]={h:h,v:l,quantizationIdx:u},e+=3}i(E),this.frames.push(E);break;case 65476:for(var w=t(),d=2;d<w;){for(var D=A[e++],y=new Uint8Array(16),k=0,p=0;p<16;p++,e++)y[p]=A[e],k+=y[p];for(var m=new Uint8Array(k),G=0;G<k;G++,e++)m[G]=A[e];d+=17+k,D>>4==0?this.huffmanTablesDC[15&D]=R(y,m):this.huffmanTablesAC[15&D]=R(y,m)}break;case 65501:t(),this.resetInterval=t();break;case 65498:t();for(var F=A[e++],S=[],L=this.frames[0],b=0;b<F;b++){var M=L.components[A[e++]],N=A[e++];M.huffmanTableDC=this.huffmanTablesDC[N>>4],M.huffmanTableAC=this.huffmanTablesAC[15&N],S.push(M)}var x=A[e++],J=A[e++],q=A[e++],Y=U(A,e,L,S,this.resetInterval,x,J,q>>4,15&q);e+=Y;break;case 65535:255!==A[e]&&e--;break;default:if(255===A[e-3]&&A[e-2]>=192&&A[e-2]<=254){e-=3;break}throw new Error("unknown JPEG marker ".concat(g.toString(16)))}g=t()}}},{key:"getResult",value:function(){var A=this.frames;if(0===this.frames.length)throw new Error("no frames were decoded");this.frames.length>1&&console.warn("more than one frame is not supported");for(var e=0;e<this.frames.length;e++)for(var t=this.frames[e].components,i=0,r=Object.keys(t);i<r.length;i++){var I=r[i];t[I].quantizationTable=this.quantizationTables[t[I].quantizationIdx],delete t[I].quantizationIdx}for(var g=A[0],n=g.components,a=g.componentsOrder,o=[],B=g.samplesPerLine,C=g.scanLines,Q=0;Q<a.length;Q++){var E=n[a[Q]];o.push({lines:L(0,E),scaleX:E.h/g.maxH,scaleY:E.v/g.maxV})}for(var s=new Uint8Array(B*C*o.length),f=0,c=0;c<C;++c)for(var h=0;h<B;++h)for(var l=0;l<o.length;++l){var u=o[l];s[f]=u.lines[0|c*u.scaleY][0|h*u.scaleX],++f}return s}}]),A}(),M=function(A){s(t,w);var e=S(t);function t(A){var i;return B(this,t),(i=e.call(this)).reader=new b,A.JPEGTables&&i.reader.parse(A.JPEGTables),i}return Q(t,[{key:"decodeBlock",value:function(A){return this.reader.resetFrames(),this.reader.parse(new Uint8Array(A)),this.reader.getResult().buffer}}]),t}(),N=Object.freeze({__proto__:null,default:M});function x(A){for(var e=A.length;--e>=0;)A[e]=0}x(new Array(576)),x(new Array(60)),x(new Array(512)),x(new Array(256)),x(new Array(29)),x(new Array(30));var J=function(A,e,t,i){for(var r=65535&A|0,I=A>>>16&65535|0,g=0;0!==t;){t-=g=t>2e3?2e3:t;do{I=I+(r=r+e[i++]|0)|0}while(--g);r%=65521,I%=65521}return r|I<<16|0},q=new Uint32Array(function(){for(var A,e=[],t=0;t<256;t++){A=t;for(var i=0;i<8;i++)A=1&A?3988292384^A>>>1:A>>>1;e[t]=A}return e}()),Y=function(A,e,t,i){var r=q,I=i+t;A^=-1;for(var g=i;g<I;g++)A=A>>>8^r[255&(A^e[g])];return-1^A},K={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},H={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},O=function(A,e){return Object.prototype.hasOwnProperty.call(A,e)},P=function(A){for(var e=Array.prototype.slice.call(arguments,1);e.length;){var i=e.shift();if(i){if("object"!==t(i))throw new TypeError(i+"must be non-object");for(var r in i)O(i,r)&&(A[r]=i[r])}}return A},T=function(A){for(var e=0,t=0,i=A.length;t<i;t++)e+=A[t].length;for(var r=new Uint8Array(e),I=0,g=0,n=A.length;I<n;I++){var a=A[I];r.set(a,g),g+=a.length}return r},V=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(A){V=!1}for(var _=new Uint8Array(256),X=0;X<256;X++)_[X]=X>=252?6:X>=248?5:X>=240?4:X>=224?3:X>=192?2:1;_[254]=_[254]=1;var Z=function(A){if("function"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(A);var e,t,i,r,I,g=A.length,n=0;for(r=0;r<g;r++)55296==(64512&(t=A.charCodeAt(r)))&&r+1<g&&56320==(64512&(i=A.charCodeAt(r+1)))&&(t=65536+(t-55296<<10)+(i-56320),r++),n+=t<128?1:t<2048?2:t<65536?3:4;for(e=new Uint8Array(n),I=0,r=0;I<n;r++)55296==(64512&(t=A.charCodeAt(r)))&&r+1<g&&56320==(64512&(i=A.charCodeAt(r+1)))&&(t=65536+(t-55296<<10)+(i-56320),r++),t<128?e[I++]=t:t<2048?(e[I++]=192|t>>>6,e[I++]=128|63&t):t<65536?(e[I++]=224|t>>>12,e[I++]=128|t>>>6&63,e[I++]=128|63&t):(e[I++]=240|t>>>18,e[I++]=128|t>>>12&63,e[I++]=128|t>>>6&63,e[I++]=128|63&t);return e},j=function(A,e){var t,i,r=e||A.length;if("function"==typeof TextDecoder&&TextDecoder.prototype.decode)return(new TextDecoder).decode(A.subarray(0,e));var I=new Array(2*r);for(i=0,t=0;t<r;){var g=A[t++];if(g<128)I[i++]=g;else{var n=_[g];if(n>4)I[i++]=65533,t+=n-1;else{for(g&=2===n?31:3===n?15:7;n>1&&t<r;)g=g<<6|63&A[t++],n--;n>1?I[i++]=65533:g<65536?I[i++]=g:(g-=65536,I[i++]=55296|g>>10&1023,I[i++]=56320|1023&g)}}}return function(A,e){if(e<65534&&A.subarray&&V)return String.fromCharCode.apply(null,A.length===e?A:A.subarray(0,e));for(var t="",i=0;i<e;i++)t+=String.fromCharCode(A[i]);return t}(I,i)},W=function(A,e){(e=e||A.length)>A.length&&(e=A.length);for(var t=e-1;t>=0&&128==(192&A[t]);)t--;return t<0||0===t?e:t+_[A[t]]>e?t:e};var z=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},$=function(A,e){var t,i,r,I,g,n,a,o,B,C,Q,E,s,f,c,h,l,u,w,d,D,y,k,p,m=A.state;t=A.next_in,k=A.input,i=t+(A.avail_in-5),r=A.next_out,p=A.output,I=r-(e-A.avail_out),g=r+(A.avail_out-257),n=m.dmax,a=m.wsize,o=m.whave,B=m.wnext,C=m.window,Q=m.hold,E=m.bits,s=m.lencode,f=m.distcode,c=(1<<m.lenbits)-1,h=(1<<m.distbits)-1;A:do{E<15&&(Q+=k[t++]<<E,E+=8,Q+=k[t++]<<E,E+=8),l=s[Q&c];e:for(;;){if(Q>>>=u=l>>>24,E-=u,0===(u=l>>>16&255))p[r++]=65535&l;else{if(!(16&u)){if(0==(64&u)){l=s[(65535&l)+(Q&(1<<u)-1)];continue e}if(32&u){m.mode=12;break A}A.msg="invalid literal/length code",m.mode=30;break A}w=65535&l,(u&=15)&&(E<u&&(Q+=k[t++]<<E,E+=8),w+=Q&(1<<u)-1,Q>>>=u,E-=u),E<15&&(Q+=k[t++]<<E,E+=8,Q+=k[t++]<<E,E+=8),l=f[Q&h];t:for(;;){if(Q>>>=u=l>>>24,E-=u,!(16&(u=l>>>16&255))){if(0==(64&u)){l=f[(65535&l)+(Q&(1<<u)-1)];continue t}A.msg="invalid distance code",m.mode=30;break A}if(d=65535&l,E<(u&=15)&&(Q+=k[t++]<<E,(E+=8)<u&&(Q+=k[t++]<<E,E+=8)),(d+=Q&(1<<u)-1)>n){A.msg="invalid distance too far back",m.mode=30;break A}if(Q>>>=u,E-=u,d>(u=r-I)){if((u=d-u)>o&&m.sane){A.msg="invalid distance too far back",m.mode=30;break A}if(D=0,y=C,0===B){if(D+=a-u,u<w){w-=u;do{p[r++]=C[D++]}while(--u);D=r-d,y=p}}else if(B<u){if(D+=a+B-u,(u-=B)<w){w-=u;do{p[r++]=C[D++]}while(--u);if(D=0,B<w){w-=u=B;do{p[r++]=C[D++]}while(--u);D=r-d,y=p}}}else if(D+=B-u,u<w){w-=u;do{p[r++]=C[D++]}while(--u);D=r-d,y=p}for(;w>2;)p[r++]=y[D++],p[r++]=y[D++],p[r++]=y[D++],w-=3;w&&(p[r++]=y[D++],w>1&&(p[r++]=y[D++]))}else{D=r-d;do{p[r++]=p[D++],p[r++]=p[D++],p[r++]=p[D++],w-=3}while(w>2);w&&(p[r++]=p[D++],w>1&&(p[r++]=p[D++]))}break}}break}}while(t<i&&r<g);t-=w=E>>3,Q&=(1<<(E-=w<<3))-1,A.next_in=t,A.next_out=r,A.avail_in=t<i?i-t+5:5-(t-i),A.avail_out=r<g?g-r+257:257-(r-g),m.hold=Q,m.bits=E},AA=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),eA=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),tA=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),iA=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),rA=function(A,e,t,i,r,I,g,n){var a,o,B,C,Q,E,s,f,c,h=n.bits,l=0,u=0,w=0,d=0,D=0,y=0,k=0,p=0,m=0,G=0,F=null,S=0,v=new Uint16Array(16),R=new Uint16Array(16),U=null,L=0;for(l=0;l<=15;l++)v[l]=0;for(u=0;u<i;u++)v[e[t+u]]++;for(D=h,d=15;d>=1&&0===v[d];d--);if(D>d&&(D=d),0===d)return r[I++]=20971520,r[I++]=20971520,n.bits=1,0;for(w=1;w<d&&0===v[w];w++);for(D<w&&(D=w),p=1,l=1;l<=15;l++)if(p<<=1,(p-=v[l])<0)return-1;if(p>0&&(0===A||1!==d))return-1;for(R[1]=0,l=1;l<15;l++)R[l+1]=R[l]+v[l];for(u=0;u<i;u++)0!==e[t+u]&&(g[R[e[t+u]]++]=u);if(0===A?(F=U=g,E=19):1===A?(F=AA,S-=257,U=eA,L-=257,E=256):(F=tA,U=iA,E=-1),G=0,u=0,l=w,Q=I,y=D,k=0,B=-1,C=(m=1<<D)-1,1===A&&m>852||2===A&&m>592)return 1;for(;;){s=l-k,g[u]<E?(f=0,c=g[u]):g[u]>E?(f=U[L+g[u]],c=F[S+g[u]]):(f=96,c=0),a=1<<l-k,w=o=1<<y;do{r[Q+(G>>k)+(o-=a)]=s<<24|f<<16|c|0}while(0!==o);for(a=1<<l-1;G&a;)a>>=1;if(0!==a?(G&=a-1,G+=a):G=0,u++,0==--v[l]){if(l===d)break;l=e[t+g[u]]}if(l>D&&(G&C)!==B){for(0===k&&(k=D),Q+=w,p=1<<(y=l-k);y+k<d&&!((p-=v[y+k])<=0);)y++,p<<=1;if(m+=1<<y,1===A&&m>852||2===A&&m>592)return 1;r[B=G&C]=D<<24|y<<16|Q-I|0}}return 0!==G&&(r[Q+G]=l-k<<24|64<<16|0),n.bits=D,0},IA=H.Z_FINISH,gA=H.Z_BLOCK,nA=H.Z_TREES,aA=H.Z_OK,oA=H.Z_STREAM_END,BA=H.Z_NEED_DICT,CA=H.Z_STREAM_ERROR,QA=H.Z_DATA_ERROR,EA=H.Z_MEM_ERROR,sA=H.Z_BUF_ERROR,fA=H.Z_DEFLATED,cA=function(A){return(A>>>24&255)+(A>>>8&65280)+((65280&A)<<8)+((255&A)<<24)};function hA(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}var lA,uA,wA=function(A){if(!A||!A.state)return CA;var e=A.state;return A.total_in=A.total_out=e.total=0,A.msg="",e.wrap&&(A.adler=1&e.wrap),e.mode=1,e.last=0,e.havedict=0,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new Int32Array(852),e.distcode=e.distdyn=new Int32Array(592),e.sane=1,e.back=-1,aA},dA=function(A){if(!A||!A.state)return CA;var e=A.state;return e.wsize=0,e.whave=0,e.wnext=0,wA(A)},DA=function(A,e){var t;if(!A||!A.state)return CA;var i=A.state;return e<0?(t=0,e=-e):(t=1+(e>>4),e<48&&(e&=15)),e&&(e<8||e>15)?CA:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=t,i.wbits=e,dA(A))},yA=function(A,e){if(!A)return CA;var t=new hA;A.state=t,t.window=null;var i=DA(A,e);return i!==aA&&(A.state=null),i},kA=!0,pA=function(A){if(kA){lA=new Int32Array(512),uA=new Int32Array(32);for(var e=0;e<144;)A.lens[e++]=8;for(;e<256;)A.lens[e++]=9;for(;e<280;)A.lens[e++]=7;for(;e<288;)A.lens[e++]=8;for(rA(1,A.lens,0,288,lA,0,A.work,{bits:9}),e=0;e<32;)A.lens[e++]=5;rA(2,A.lens,0,32,uA,0,A.work,{bits:5}),kA=!1}A.lencode=lA,A.lenbits=9,A.distcode=uA,A.distbits=5},mA=function(A,e,t,i){var r,I=A.state;return null===I.window&&(I.wsize=1<<I.wbits,I.wnext=0,I.whave=0,I.window=new Uint8Array(I.wsize)),i>=I.wsize?(I.window.set(e.subarray(t-I.wsize,t),0),I.wnext=0,I.whave=I.wsize):((r=I.wsize-I.wnext)>i&&(r=i),I.window.set(e.subarray(t-i,t-i+r),I.wnext),(i-=r)?(I.window.set(e.subarray(t-i,t),0),I.wnext=i,I.whave=I.wsize):(I.wnext+=r,I.wnext===I.wsize&&(I.wnext=0),I.whave<I.wsize&&(I.whave+=r))),0},GA={inflateReset:dA,inflateReset2:DA,inflateResetKeep:wA,inflateInit:function(A){return yA(A,15)},inflateInit2:yA,inflate:function(A,e){var t,i,r,I,g,n,a,o,B,C,Q,E,s,f,c,h,l,u,w,d,D,y,k,p,m=0,G=new Uint8Array(4),F=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(!A||!A.state||!A.output||!A.input&&0!==A.avail_in)return CA;12===(t=A.state).mode&&(t.mode=13),g=A.next_out,r=A.output,a=A.avail_out,I=A.next_in,i=A.input,n=A.avail_in,o=t.hold,B=t.bits,C=n,Q=a,y=aA;A:for(;;)switch(t.mode){case 1:if(0===t.wrap){t.mode=13;break}for(;B<16;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(2&t.wrap&&35615===o){t.check=0,G[0]=255&o,G[1]=o>>>8&255,t.check=Y(t.check,G,2,0),o=0,B=0,t.mode=2;break}if(t.flags=0,t.head&&(t.head.done=!1),!(1&t.wrap)||(((255&o)<<8)+(o>>8))%31){A.msg="incorrect header check",t.mode=30;break}if((15&o)!==fA){A.msg="unknown compression method",t.mode=30;break}if(B-=4,D=8+(15&(o>>>=4)),0===t.wbits)t.wbits=D;else if(D>t.wbits){A.msg="invalid window size",t.mode=30;break}t.dmax=1<<t.wbits,A.adler=t.check=1,t.mode=512&o?10:12,o=0,B=0;break;case 2:for(;B<16;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(t.flags=o,(255&t.flags)!==fA){A.msg="unknown compression method",t.mode=30;break}if(57344&t.flags){A.msg="unknown header flags set",t.mode=30;break}t.head&&(t.head.text=o>>8&1),512&t.flags&&(G[0]=255&o,G[1]=o>>>8&255,t.check=Y(t.check,G,2,0)),o=0,B=0,t.mode=3;case 3:for(;B<32;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.head&&(t.head.time=o),512&t.flags&&(G[0]=255&o,G[1]=o>>>8&255,G[2]=o>>>16&255,G[3]=o>>>24&255,t.check=Y(t.check,G,4,0)),o=0,B=0,t.mode=4;case 4:for(;B<16;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.head&&(t.head.xflags=255&o,t.head.os=o>>8),512&t.flags&&(G[0]=255&o,G[1]=o>>>8&255,t.check=Y(t.check,G,2,0)),o=0,B=0,t.mode=5;case 5:if(1024&t.flags){for(;B<16;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.length=o,t.head&&(t.head.extra_len=o),512&t.flags&&(G[0]=255&o,G[1]=o>>>8&255,t.check=Y(t.check,G,2,0)),o=0,B=0}else t.head&&(t.head.extra=null);t.mode=6;case 6:if(1024&t.flags&&((E=t.length)>n&&(E=n),E&&(t.head&&(D=t.head.extra_len-t.length,t.head.extra||(t.head.extra=new Uint8Array(t.head.extra_len)),t.head.extra.set(i.subarray(I,I+E),D)),512&t.flags&&(t.check=Y(t.check,i,E,I)),n-=E,I+=E,t.length-=E),t.length))break A;t.length=0,t.mode=7;case 7:if(2048&t.flags){if(0===n)break A;E=0;do{D=i[I+E++],t.head&&D&&t.length<65536&&(t.head.name+=String.fromCharCode(D))}while(D&&E<n);if(512&t.flags&&(t.check=Y(t.check,i,E,I)),n-=E,I+=E,D)break A}else t.head&&(t.head.name=null);t.length=0,t.mode=8;case 8:if(4096&t.flags){if(0===n)break A;E=0;do{D=i[I+E++],t.head&&D&&t.length<65536&&(t.head.comment+=String.fromCharCode(D))}while(D&&E<n);if(512&t.flags&&(t.check=Y(t.check,i,E,I)),n-=E,I+=E,D)break A}else t.head&&(t.head.comment=null);t.mode=9;case 9:if(512&t.flags){for(;B<16;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(o!==(65535&t.check)){A.msg="header crc mismatch",t.mode=30;break}o=0,B=0}t.head&&(t.head.hcrc=t.flags>>9&1,t.head.done=!0),A.adler=t.check=0,t.mode=12;break;case 10:for(;B<32;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}A.adler=t.check=cA(o),o=0,B=0,t.mode=11;case 11:if(0===t.havedict)return A.next_out=g,A.avail_out=a,A.next_in=I,A.avail_in=n,t.hold=o,t.bits=B,BA;A.adler=t.check=1,t.mode=12;case 12:if(e===gA||e===nA)break A;case 13:if(t.last){o>>>=7&B,B-=7&B,t.mode=27;break}for(;B<3;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}switch(t.last=1&o,B-=1,3&(o>>>=1)){case 0:t.mode=14;break;case 1:if(pA(t),t.mode=20,e===nA){o>>>=2,B-=2;break A}break;case 2:t.mode=17;break;case 3:A.msg="invalid block type",t.mode=30}o>>>=2,B-=2;break;case 14:for(o>>>=7&B,B-=7&B;B<32;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if((65535&o)!=(o>>>16^65535)){A.msg="invalid stored block lengths",t.mode=30;break}if(t.length=65535&o,o=0,B=0,t.mode=15,e===nA)break A;case 15:t.mode=16;case 16:if(E=t.length){if(E>n&&(E=n),E>a&&(E=a),0===E)break A;r.set(i.subarray(I,I+E),g),n-=E,I+=E,a-=E,g+=E,t.length-=E;break}t.mode=12;break;case 17:for(;B<14;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(t.nlen=257+(31&o),o>>>=5,B-=5,t.ndist=1+(31&o),o>>>=5,B-=5,t.ncode=4+(15&o),o>>>=4,B-=4,t.nlen>286||t.ndist>30){A.msg="too many length or distance symbols",t.mode=30;break}t.have=0,t.mode=18;case 18:for(;t.have<t.ncode;){for(;B<3;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.lens[F[t.have++]]=7&o,o>>>=3,B-=3}for(;t.have<19;)t.lens[F[t.have++]]=0;if(t.lencode=t.lendyn,t.lenbits=7,k={bits:t.lenbits},y=rA(0,t.lens,0,19,t.lencode,0,t.work,k),t.lenbits=k.bits,y){A.msg="invalid code lengths set",t.mode=30;break}t.have=0,t.mode=19;case 19:for(;t.have<t.nlen+t.ndist;){for(;h=(m=t.lencode[o&(1<<t.lenbits)-1])>>>16&255,l=65535&m,!((c=m>>>24)<=B);){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(l<16)o>>>=c,B-=c,t.lens[t.have++]=l;else{if(16===l){for(p=c+2;B<p;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(o>>>=c,B-=c,0===t.have){A.msg="invalid bit length repeat",t.mode=30;break}D=t.lens[t.have-1],E=3+(3&o),o>>>=2,B-=2}else if(17===l){for(p=c+3;B<p;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}B-=c,D=0,E=3+(7&(o>>>=c)),o>>>=3,B-=3}else{for(p=c+7;B<p;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}B-=c,D=0,E=11+(127&(o>>>=c)),o>>>=7,B-=7}if(t.have+E>t.nlen+t.ndist){A.msg="invalid bit length repeat",t.mode=30;break}for(;E--;)t.lens[t.have++]=D}}if(30===t.mode)break;if(0===t.lens[256]){A.msg="invalid code -- missing end-of-block",t.mode=30;break}if(t.lenbits=9,k={bits:t.lenbits},y=rA(1,t.lens,0,t.nlen,t.lencode,0,t.work,k),t.lenbits=k.bits,y){A.msg="invalid literal/lengths set",t.mode=30;break}if(t.distbits=6,t.distcode=t.distdyn,k={bits:t.distbits},y=rA(2,t.lens,t.nlen,t.ndist,t.distcode,0,t.work,k),t.distbits=k.bits,y){A.msg="invalid distances set",t.mode=30;break}if(t.mode=20,e===nA)break A;case 20:t.mode=21;case 21:if(n>=6&&a>=258){A.next_out=g,A.avail_out=a,A.next_in=I,A.avail_in=n,t.hold=o,t.bits=B,$(A,Q),g=A.next_out,r=A.output,a=A.avail_out,I=A.next_in,i=A.input,n=A.avail_in,o=t.hold,B=t.bits,12===t.mode&&(t.back=-1);break}for(t.back=0;h=(m=t.lencode[o&(1<<t.lenbits)-1])>>>16&255,l=65535&m,!((c=m>>>24)<=B);){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(h&&0==(240&h)){for(u=c,w=h,d=l;h=(m=t.lencode[d+((o&(1<<u+w)-1)>>u)])>>>16&255,l=65535&m,!(u+(c=m>>>24)<=B);){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}o>>>=u,B-=u,t.back+=u}if(o>>>=c,B-=c,t.back+=c,t.length=l,0===h){t.mode=26;break}if(32&h){t.back=-1,t.mode=12;break}if(64&h){A.msg="invalid literal/length code",t.mode=30;break}t.extra=15&h,t.mode=22;case 22:if(t.extra){for(p=t.extra;B<p;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.length+=o&(1<<t.extra)-1,o>>>=t.extra,B-=t.extra,t.back+=t.extra}t.was=t.length,t.mode=23;case 23:for(;h=(m=t.distcode[o&(1<<t.distbits)-1])>>>16&255,l=65535&m,!((c=m>>>24)<=B);){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(0==(240&h)){for(u=c,w=h,d=l;h=(m=t.distcode[d+((o&(1<<u+w)-1)>>u)])>>>16&255,l=65535&m,!(u+(c=m>>>24)<=B);){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}o>>>=u,B-=u,t.back+=u}if(o>>>=c,B-=c,t.back+=c,64&h){A.msg="invalid distance code",t.mode=30;break}t.offset=l,t.extra=15&h,t.mode=24;case 24:if(t.extra){for(p=t.extra;B<p;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.offset+=o&(1<<t.extra)-1,o>>>=t.extra,B-=t.extra,t.back+=t.extra}if(t.offset>t.dmax){A.msg="invalid distance too far back",t.mode=30;break}t.mode=25;case 25:if(0===a)break A;if(E=Q-a,t.offset>E){if((E=t.offset-E)>t.whave&&t.sane){A.msg="invalid distance too far back",t.mode=30;break}E>t.wnext?(E-=t.wnext,s=t.wsize-E):s=t.wnext-E,E>t.length&&(E=t.length),f=t.window}else f=r,s=g-t.offset,E=t.length;E>a&&(E=a),a-=E,t.length-=E;do{r[g++]=f[s++]}while(--E);0===t.length&&(t.mode=21);break;case 26:if(0===a)break A;r[g++]=t.length,a--,t.mode=21;break;case 27:if(t.wrap){for(;B<32;){if(0===n)break A;n--,o|=i[I++]<<B,B+=8}if(Q-=a,A.total_out+=Q,t.total+=Q,Q&&(A.adler=t.check=t.flags?Y(t.check,r,Q,g-Q):J(t.check,r,Q,g-Q)),Q=a,(t.flags?o:cA(o))!==t.check){A.msg="incorrect data check",t.mode=30;break}o=0,B=0}t.mode=28;case 28:if(t.wrap&&t.flags){for(;B<32;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(o!==(4294967295&t.total)){A.msg="incorrect length check",t.mode=30;break}o=0,B=0}t.mode=29;case 29:y=oA;break A;case 30:y=QA;break A;case 31:return EA;default:return CA}return A.next_out=g,A.avail_out=a,A.next_in=I,A.avail_in=n,t.hold=o,t.bits=B,(t.wsize||Q!==A.avail_out&&t.mode<30&&(t.mode<27||e!==IA))&&mA(A,A.output,A.next_out,Q-A.avail_out),C-=A.avail_in,Q-=A.avail_out,A.total_in+=C,A.total_out+=Q,t.total+=Q,t.wrap&&Q&&(A.adler=t.check=t.flags?Y(t.check,r,Q,A.next_out-Q):J(t.check,r,Q,A.next_out-Q)),A.data_type=t.bits+(t.last?64:0)+(12===t.mode?128:0)+(20===t.mode||15===t.mode?256:0),(0===C&&0===Q||e===IA)&&y===aA&&(y=sA),y},inflateEnd:function(A){if(!A||!A.state)return CA;var e=A.state;return e.window&&(e.window=null),A.state=null,aA},inflateGetHeader:function(A,e){if(!A||!A.state)return CA;var t=A.state;return 0==(2&t.wrap)?CA:(t.head=e,e.done=!1,aA)},inflateSetDictionary:function(A,e){var t,i=e.length;return A&&A.state?0!==(t=A.state).wrap&&11!==t.mode?CA:11===t.mode&&J(1,e,i,0)!==t.check?QA:mA(A,e,i,i)?(t.mode=31,EA):(t.havedict=1,aA):CA},inflateInfo:"pako inflate (from Nodeca project)"};var FA=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},SA=Object.prototype.toString,vA=H.Z_NO_FLUSH,RA=H.Z_FINISH,UA=H.Z_OK,LA=H.Z_STREAM_END,bA=H.Z_NEED_DICT,MA=H.Z_STREAM_ERROR,NA=H.Z_DATA_ERROR,xA=H.Z_MEM_ERROR;function JA(A){this.options=P({chunkSize:65536,windowBits:15,to:""},A||{});var e=this.options;e.raw&&e.windowBits>=0&&e.windowBits<16&&(e.windowBits=-e.windowBits,0===e.windowBits&&(e.windowBits=-15)),!(e.windowBits>=0&&e.windowBits<16)||A&&A.windowBits||(e.windowBits+=32),e.windowBits>15&&e.windowBits<48&&0==(15&e.windowBits)&&(e.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new z,this.strm.avail_out=0;var t=GA.inflateInit2(this.strm,e.windowBits);if(t!==UA)throw new Error(K[t]);if(this.header=new FA,GA.inflateGetHeader(this.strm,this.header),e.dictionary&&("string"==typeof e.dictionary?e.dictionary=Z(e.dictionary):"[object ArrayBuffer]"===SA.call(e.dictionary)&&(e.dictionary=new Uint8Array(e.dictionary)),e.raw&&(t=GA.inflateSetDictionary(this.strm,e.dictionary))!==UA))throw new Error(K[t])}function qA(A,e){var t=new JA(e);if(t.push(A),t.err)throw t.msg||K[t.err];return t.result}JA.prototype.push=function(A,e){var t,i,r,I=this.strm,g=this.options.chunkSize,n=this.options.dictionary;if(this.ended)return!1;for(i=e===~~e?e:!0===e?RA:vA,"[object ArrayBuffer]"===SA.call(A)?I.input=new Uint8Array(A):I.input=A,I.next_in=0,I.avail_in=I.input.length;;){for(0===I.avail_out&&(I.output=new Uint8Array(g),I.next_out=0,I.avail_out=g),(t=GA.inflate(I,i))===bA&&n&&((t=GA.inflateSetDictionary(I,n))===UA?t=GA.inflate(I,i):t===NA&&(t=bA));I.avail_in>0&&t===LA&&I.state.wrap>0&&0!==A[I.next_in];)GA.inflateReset(I),t=GA.inflate(I,i);switch(t){case MA:case NA:case bA:case xA:return this.onEnd(t),this.ended=!0,!1}if(r=I.avail_out,I.next_out&&(0===I.avail_out||t===LA))if("string"===this.options.to){var a=W(I.output,I.next_out),o=I.next_out-a,B=j(I.output,a);I.next_out=o,I.avail_out=g-o,o&&I.output.set(I.output.subarray(a,a+o),0),this.onData(B)}else this.onData(I.output.length===I.next_out?I.output:I.output.subarray(0,I.next_out));if(t!==UA||0!==r){if(t===LA)return t=GA.inflateEnd(this.strm),this.onEnd(t),this.ended=!0,!0;if(0===I.avail_in)break}}return!0},JA.prototype.onData=function(A){this.chunks.push(A)},JA.prototype.onEnd=function(A){A===UA&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=T(this.chunks)),this.chunks=[],this.err=A,this.msg=this.strm.msg};var YA={Inflate:JA,inflate:qA,inflateRaw:function(A,e){return(e=e||{}).raw=!0,qA(A,e)},ungzip:qA,constants:H}.inflate;function KA(A){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var HA=function(A){s(t,w);var e=KA(t);function t(){return B(this,t),e.apply(this,arguments)}return Q(t,[{key:"decodeBlock",value:function(A){return YA(new Uint8Array(A)).buffer}}]),t}(),OA=Object.freeze({__proto__:null,default:HA});function PA(A){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var TA,VA=function(A){s(t,w);var e=PA(t);function t(){return B(this,t),e.apply(this,arguments)}return Q(t,[{key:"decodeBlock",value:function(A){for(var e=new DataView(A),t=[],i=0;i<A.byteLength;++i){var r=e.getInt8(i);if(r<0){var I=e.getUint8(i+1);r=-r;for(var g=0;g<=r;++g)t.push(I);i+=1}else{for(var n=0;n<=r;++n)t.push(e.getUint8(i+n+1));i+=r+1}}return new Uint8Array(t).buffer}}]),t}(),_A=Object.freeze({__proto__:null,default:VA}),XA={exports:{}};TA=XA,\n/* Copyright 2015-2021 Esri. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve */\nfunction(){var A,e,t,i,r,I,g,n,a,o,B,C,Q,E,s,f,c=(A={defaultNoDataValue:-34027999387901484e22,decode:function(I,g){var n=(g=g||{}).encodedMaskData||null===g.encodedMaskData,a=r(I,g.inputOffset||0,n),o=null!==g.noDataValue?g.noDataValue:A.defaultNoDataValue,B=e(a,g.pixelType||Float32Array,g.encodedMaskData,o,g.returnMask),C={width:a.width,height:a.height,pixelData:B.resultPixels,minValue:B.minValue,maxValue:a.pixels.maxValue,noDataValue:o};return B.resultMask&&(C.maskData=B.resultMask),g.returnEncodedMask&&a.mask&&(C.encodedMaskData=a.mask.bitset?a.mask.bitset:null),g.returnFileInfo&&(C.fileInfo=t(a),g.computeUsedBitDepths&&(C.fileInfo.bitDepths=i(a))),C}},e=function(A,e,t,i,r){var g,n,a,o=0,B=A.pixels.numBlocksX,C=A.pixels.numBlocksY,Q=Math.floor(A.width/B),E=Math.floor(A.height/C),s=2*A.maxZError,f=Number.MAX_VALUE;t=t||(A.mask?A.mask.bitset:null),n=new e(A.width*A.height),r&&t&&(a=new Uint8Array(A.width*A.height));for(var c,h,l=new Float32Array(Q*E),u=0;u<=C;u++){var w=u!==C?E:A.height%C;if(0!==w)for(var d=0;d<=B;d++){var D=d!==B?Q:A.width%B;if(0!==D){var y,k,p,m,G=u*A.width*E+d*Q,F=A.width-D,S=A.pixels.blocks[o];if(S.encoding<2?(0===S.encoding?y=S.rawData:(I(S.stuffedData,S.bitsPerPixel,S.numValidPixels,S.offset,s,l,A.pixels.maxValue),y=l),k=0):p=2===S.encoding?0:S.offset,t)for(h=0;h<w;h++){for(7&G&&(m=t[G>>3],m<<=7&G),c=0;c<D;c++)7&G||(m=t[G>>3]),128&m?(a&&(a[G]=1),f=f>(g=S.encoding<2?y[k++]:p)?g:f,n[G++]=g):(a&&(a[G]=0),n[G++]=i),m<<=1;G+=F}else if(S.encoding<2)for(h=0;h<w;h++){for(c=0;c<D;c++)f=f>(g=y[k++])?g:f,n[G++]=g;G+=F}else for(f=f>p?p:f,h=0;h<w;h++){for(c=0;c<D;c++)n[G++]=p;G+=F}if(1===S.encoding&&k!==S.numValidPixels)throw"Block and Mask do not match";o++}}}return{resultPixels:n,resultMask:a,minValue:f}},t=function(A){return{fileIdentifierString:A.fileIdentifierString,fileVersion:A.fileVersion,imageType:A.imageType,height:A.height,width:A.width,maxZError:A.maxZError,eofOffset:A.eofOffset,mask:A.mask?{numBlocksX:A.mask.numBlocksX,numBlocksY:A.mask.numBlocksY,numBytes:A.mask.numBytes,maxValue:A.mask.maxValue}:null,pixels:{numBlocksX:A.pixels.numBlocksX,numBlocksY:A.pixels.numBlocksY,numBytes:A.pixels.numBytes,maxValue:A.pixels.maxValue,noDataValue:A.noDataValue}}},i=function(A){for(var e=A.pixels.numBlocksX*A.pixels.numBlocksY,t={},i=0;i<e;i++){var r=A.pixels.blocks[i];0===r.encoding?t.float32=!0:1===r.encoding?t[r.bitsPerPixel]=!0:t[0]=!0}return Object.keys(t)},r=function(A,e,t){var i={},r=new Uint8Array(A,e,10);if(i.fileIdentifierString=String.fromCharCode.apply(null,r),"CntZImage"!==i.fileIdentifierString.trim())throw"Unexpected file identifier string: "+i.fileIdentifierString;e+=10;var I=new DataView(A,e,24);if(i.fileVersion=I.getInt32(0,!0),i.imageType=I.getInt32(4,!0),i.height=I.getUint32(8,!0),i.width=I.getUint32(12,!0),i.maxZError=I.getFloat64(16,!0),e+=24,!t)if(I=new DataView(A,e,16),i.mask={},i.mask.numBlocksY=I.getUint32(0,!0),i.mask.numBlocksX=I.getUint32(4,!0),i.mask.numBytes=I.getUint32(8,!0),i.mask.maxValue=I.getFloat32(12,!0),e+=16,i.mask.numBytes>0){var g=new Uint8Array(Math.ceil(i.width*i.height/8)),n=(I=new DataView(A,e,i.mask.numBytes)).getInt16(0,!0),a=2,o=0;do{if(n>0)for(;n--;)g[o++]=I.getUint8(a++);else{var B=I.getUint8(a++);for(n=-n;n--;)g[o++]=B}n=I.getInt16(a,!0),a+=2}while(a<i.mask.numBytes);if(-32768!==n||o<g.length)throw"Unexpected end of mask RLE encoding";i.mask.bitset=g,e+=i.mask.numBytes}else 0==(i.mask.numBytes|i.mask.numBlocksY|i.mask.maxValue)&&(i.mask.bitset=new Uint8Array(Math.ceil(i.width*i.height/8)));I=new DataView(A,e,16),i.pixels={},i.pixels.numBlocksY=I.getUint32(0,!0),i.pixels.numBlocksX=I.getUint32(4,!0),i.pixels.numBytes=I.getUint32(8,!0),i.pixels.maxValue=I.getFloat32(12,!0),e+=16;var C=i.pixels.numBlocksX,Q=i.pixels.numBlocksY,E=C+(i.width%C>0?1:0),s=Q+(i.height%Q>0?1:0);i.pixels.blocks=new Array(E*s);for(var f=0,c=0;c<s;c++)for(var h=0;h<E;h++){var l=0,u=A.byteLength-e;I=new DataView(A,e,Math.min(10,u));var w={};i.pixels.blocks[f++]=w;var d=I.getUint8(0);if(l++,w.encoding=63&d,w.encoding>3)throw"Invalid block encoding ("+w.encoding+")";if(2!==w.encoding){if(0!==d&&2!==d){if(d>>=6,w.offsetType=d,2===d)w.offset=I.getInt8(1),l++;else if(1===d)w.offset=I.getInt16(1,!0),l+=2;else{if(0!==d)throw"Invalid block offset type";w.offset=I.getFloat32(1,!0),l+=4}if(1===w.encoding)if(d=I.getUint8(l),l++,w.bitsPerPixel=63&d,d>>=6,w.numValidPixelsType=d,2===d)w.numValidPixels=I.getUint8(l),l++;else if(1===d)w.numValidPixels=I.getUint16(l,!0),l+=2;else{if(0!==d)throw"Invalid valid pixel count type";w.numValidPixels=I.getUint32(l,!0),l+=4}}var D;if(e+=l,3!==w.encoding)if(0===w.encoding){var y=(i.pixels.numBytes-1)/4;if(y!==Math.floor(y))throw"uncompressed block has invalid length";D=new ArrayBuffer(4*y),new Uint8Array(D).set(new Uint8Array(A,e,4*y));var k=new Float32Array(D);w.rawData=k,e+=4*y}else if(1===w.encoding){var p=Math.ceil(w.numValidPixels*w.bitsPerPixel/8),m=Math.ceil(p/4);D=new ArrayBuffer(4*m),new Uint8Array(D).set(new Uint8Array(A,e,p)),w.stuffedData=new Uint32Array(D),e+=p}}else e++}return i.eofOffset=e,i},I=function(A,e,t,i,r,I,g){var n,a,o,B=(1<<e)-1,C=0,Q=0,E=Math.ceil((g-i)/r),s=4*A.length-Math.ceil(e*t/8);for(A[A.length-1]<<=8*s,n=0;n<t;n++){if(0===Q&&(o=A[C++],Q=32),Q>=e)a=o>>>Q-e&B,Q-=e;else{var f=e-Q;a=(o&B)<<f&B,a+=(o=A[C++])>>>(Q=32-f)}I[n]=a<E?i+a*r:g}return I},A),h=(g=function(A,e,t,i,r,I,g,n){var a,o,B,C,Q,E=(1<<t)-1,s=0,f=0,c=4*A.length-Math.ceil(t*i/8);if(A[A.length-1]<<=8*c,r)for(a=0;a<i;a++)0===f&&(B=A[s++],f=32),f>=t?(o=B>>>f-t&E,f-=t):(o=(B&E)<<(C=t-f)&E,o+=(B=A[s++])>>>(f=32-C)),e[a]=r[o];else for(Q=Math.ceil((n-I)/g),a=0;a<i;a++)0===f&&(B=A[s++],f=32),f>=t?(o=B>>>f-t&E,f-=t):(o=(B&E)<<(C=t-f)&E,o+=(B=A[s++])>>>(f=32-C)),e[a]=o<Q?I+o*g:n},n=function(A,e,t,i,r,I){var g,n=(1<<e)-1,a=0,o=0,B=0,C=0,Q=0,E=[],s=4*A.length-Math.ceil(e*t/8);A[A.length-1]<<=8*s;var f=Math.ceil((I-i)/r);for(o=0;o<t;o++)0===C&&(g=A[a++],C=32),C>=e?(Q=g>>>C-e&n,C-=e):(Q=(g&n)<<(B=e-C)&n,Q+=(g=A[a++])>>>(C=32-B)),E[o]=Q<f?i+Q*r:I;return E.unshift(i),E},a=function(A,e,t,i,r,I,g,n){var a,o,B,C,Q=(1<<t)-1,E=0,s=0,f=0;if(r)for(a=0;a<i;a++)0===s&&(B=A[E++],s=32,f=0),s>=t?(o=B>>>f&Q,s-=t,f+=t):(o=B>>>f&Q,s=32-(C=t-s),o|=((B=A[E++])&(1<<C)-1)<<t-C,f=C),e[a]=r[o];else{var c=Math.ceil((n-I)/g);for(a=0;a<i;a++)0===s&&(B=A[E++],s=32,f=0),s>=t?(o=B>>>f&Q,s-=t,f+=t):(o=B>>>f&Q,s=32-(C=t-s),o|=((B=A[E++])&(1<<C)-1)<<t-C,f=C),e[a]=o<c?I+o*g:n}return e},o=function(A,e,t,i,r,I){var g,n=(1<<e)-1,a=0,o=0,B=0,C=0,Q=0,E=0,s=[],f=Math.ceil((I-i)/r);for(o=0;o<t;o++)0===C&&(g=A[a++],C=32,E=0),C>=e?(Q=g>>>E&n,C-=e,E+=e):(Q=g>>>E&n,C=32-(B=e-C),Q|=((g=A[a++])&(1<<B)-1)<<e-B,E=B),s[o]=Q<f?i+Q*r:I;return s.unshift(i),s},B=function(A,e,t,i){var r,I,g,n,a=(1<<t)-1,o=0,B=0,C=4*A.length-Math.ceil(t*i/8);for(A[A.length-1]<<=8*C,r=0;r<i;r++)0===B&&(g=A[o++],B=32),B>=t?(I=g>>>B-t&a,B-=t):(I=(g&a)<<(n=t-B)&a,I+=(g=A[o++])>>>(B=32-n)),e[r]=I;return e},C=function(A,e,t,i){var r,I,g,n,a=(1<<t)-1,o=0,B=0,C=0;for(r=0;r<i;r++)0===B&&(g=A[o++],B=32,C=0),B>=t?(I=g>>>C&a,B-=t,C+=t):(I=g>>>C&a,B=32-(n=t-B),I|=((g=A[o++])&(1<<n)-1)<<t-n,C=n),e[r]=I;return e},Q={HUFFMAN_LUT_BITS_MAX:12,computeChecksumFletcher32:function(A){for(var e=65535,t=65535,i=A.length,r=Math.floor(i/2),I=0;r;){var g=r>=359?359:r;r-=g;do{e+=A[I++]<<8,t+=e+=A[I++]}while(--g);e=(65535&e)+(e>>>16),t=(65535&t)+(t>>>16)}return 1&i&&(t+=e+=A[I]<<8),((t=(65535&t)+(t>>>16))<<16|(e=(65535&e)+(e>>>16)))>>>0},readHeaderInfo:function(A,e){var t=e.ptr,i=new Uint8Array(A,t,6),r={};if(r.fileIdentifierString=String.fromCharCode.apply(null,i),0!==r.fileIdentifierString.lastIndexOf("Lerc2",0))throw"Unexpected file identifier string (expect Lerc2 ): "+r.fileIdentifierString;t+=6;var I,g=new DataView(A,t,8),n=g.getInt32(0,!0);if(r.fileVersion=n,t+=4,n>=3&&(r.checksum=g.getUint32(4,!0),t+=4),g=new DataView(A,t,12),r.height=g.getUint32(0,!0),r.width=g.getUint32(4,!0),t+=8,n>=4?(r.numDims=g.getUint32(8,!0),t+=4):r.numDims=1,g=new DataView(A,t,40),r.numValidPixel=g.getUint32(0,!0),r.microBlockSize=g.getInt32(4,!0),r.blobSize=g.getInt32(8,!0),r.imageType=g.getInt32(12,!0),r.maxZError=g.getFloat64(16,!0),r.zMin=g.getFloat64(24,!0),r.zMax=g.getFloat64(32,!0),t+=40,e.headerInfo=r,e.ptr=t,n>=3&&(I=n>=4?52:48,this.computeChecksumFletcher32(new Uint8Array(A,t-I,r.blobSize-14))!==r.checksum))throw"Checksum failed.";return!0},checkMinMaxRanges:function(A,e){var t=e.headerInfo,i=this.getDataTypeArray(t.imageType),r=t.numDims*this.getDataTypeSize(t.imageType),I=this.readSubArray(A,e.ptr,i,r),g=this.readSubArray(A,e.ptr+r,i,r);e.ptr+=2*r;var n,a=!0;for(n=0;n<t.numDims;n++)if(I[n]!==g[n]){a=!1;break}return t.minValues=I,t.maxValues=g,a},readSubArray:function(A,e,t,i){var r;if(t===Uint8Array)r=new Uint8Array(A,e,i);else{var I=new ArrayBuffer(i);new Uint8Array(I).set(new Uint8Array(A,e,i)),r=new t(I)}return r},readMask:function(A,e){var t,i,r=e.ptr,I=e.headerInfo,g=I.width*I.height,n=I.numValidPixel,a=new DataView(A,r,4),o={};if(o.numBytes=a.getUint32(0,!0),r+=4,(0===n||g===n)&&0!==o.numBytes)throw"invalid mask";if(0===n)t=new Uint8Array(Math.ceil(g/8)),o.bitset=t,i=new Uint8Array(g),e.pixels.resultMask=i,r+=o.numBytes;else if(o.numBytes>0){t=new Uint8Array(Math.ceil(g/8));var B=(a=new DataView(A,r,o.numBytes)).getInt16(0,!0),C=2,Q=0,E=0;do{if(B>0)for(;B--;)t[Q++]=a.getUint8(C++);else for(E=a.getUint8(C++),B=-B;B--;)t[Q++]=E;B=a.getInt16(C,!0),C+=2}while(C<o.numBytes);if(-32768!==B||Q<t.length)throw"Unexpected end of mask RLE encoding";i=new Uint8Array(g);var s=0,f=0;for(f=0;f<g;f++)7&f?(s=t[f>>3],s<<=7&f):s=t[f>>3],128&s&&(i[f]=1);e.pixels.resultMask=i,o.bitset=t,r+=o.numBytes}return e.ptr=r,e.mask=o,!0},readDataOneSweep:function(A,e,t,i){var r,I=e.ptr,g=e.headerInfo,n=g.numDims,a=g.width*g.height,o=g.imageType,B=g.numValidPixel*Q.getDataTypeSize(o)*n,C=e.pixels.resultMask;if(t===Uint8Array)r=new Uint8Array(A,I,B);else{var E=new ArrayBuffer(B);new Uint8Array(E).set(new Uint8Array(A,I,B)),r=new t(E)}if(r.length===a*n)e.pixels.resultPixels=i?Q.swapDimensionOrder(r,a,n,t,!0):r;else{e.pixels.resultPixels=new t(a*n);var s=0,f=0,c=0,h=0;if(n>1){if(i){for(f=0;f<a;f++)if(C[f])for(h=f,c=0;c<n;c++,h+=a)e.pixels.resultPixels[h]=r[s++]}else for(f=0;f<a;f++)if(C[f])for(h=f*n,c=0;c<n;c++)e.pixels.resultPixels[h+c]=r[s++]}else for(f=0;f<a;f++)C[f]&&(e.pixels.resultPixels[f]=r[s++])}return I+=B,e.ptr=I,!0},readHuffmanTree:function(A,e){var t=this.HUFFMAN_LUT_BITS_MAX,i=new DataView(A,e.ptr,16);if(e.ptr+=16,i.getInt32(0,!0)<2)throw"unsupported Huffman version";var r=i.getInt32(4,!0),I=i.getInt32(8,!0),g=i.getInt32(12,!0);if(I>=g)return!1;var n=new Uint32Array(g-I);Q.decodeBits(A,e,n);var a,o,B,C,s=[];for(a=I;a<g;a++)s[o=a-(a<r?0:r)]={first:n[a-I],second:null};var f=A.byteLength-e.ptr,c=Math.ceil(f/4),h=new ArrayBuffer(4*c);new Uint8Array(h).set(new Uint8Array(A,e.ptr,f));var l,u=new Uint32Array(h),w=0,d=0;for(l=u[0],a=I;a<g;a++)(C=s[o=a-(a<r?0:r)].first)>0&&(s[o].second=l<<w>>>32-C,32-w>=C?32===(w+=C)&&(w=0,l=u[++d]):(w+=C-32,l=u[++d],s[o].second|=l>>>32-w));var D=0,y=0,k=new E;for(a=0;a<s.length;a++)void 0!==s[a]&&(D=Math.max(D,s[a].first));y=D>=t?t:D;var p,m,G,F,S,v=[];for(a=I;a<g;a++)if((C=s[o=a-(a<r?0:r)].first)>0)if(p=[C,o],C<=y)for(m=s[o].second<<y-C,G=1<<y-C,B=0;B<G;B++)v[m|B]=p;else for(m=s[o].second,S=k,F=C-1;F>=0;F--)m>>>F&1?(S.right||(S.right=new E),S=S.right):(S.left||(S.left=new E),S=S.left),0!==F||S.val||(S.val=p[1]);return{decodeLut:v,numBitsLUTQick:y,numBitsLUT:D,tree:k,stuffedData:u,srcPtr:d,bitPos:w}},readHuffman:function(A,e,t,i){var r,I,g,n,a,o,B,C,E,s=e.headerInfo.numDims,f=e.headerInfo.height,c=e.headerInfo.width,h=c*f,l=this.readHuffmanTree(A,e),u=l.decodeLut,w=l.tree,d=l.stuffedData,D=l.srcPtr,y=l.bitPos,k=l.numBitsLUTQick,p=l.numBitsLUT,m=0===e.headerInfo.imageType?128:0,G=e.pixels.resultMask,F=0;y>0&&(D++,y=0);var S,v=d[D],R=1===e.encodeMode,U=new t(h*s),L=U;if(s<2||R){for(S=0;S<s;S++)if(s>1&&(L=new t(U.buffer,h*S,h),F=0),e.headerInfo.numValidPixel===c*f)for(C=0,o=0;o<f;o++)for(B=0;B<c;B++,C++){if(I=0,a=n=v<<y>>>32-k,32-y<k&&(a=n|=d[D+1]>>>64-y-k),u[a])I=u[a][1],y+=u[a][0];else for(a=n=v<<y>>>32-p,32-y<p&&(a=n|=d[D+1]>>>64-y-p),r=w,E=0;E<p;E++)if(!(r=n>>>p-E-1&1?r.right:r.left).left&&!r.right){I=r.val,y=y+E+1;break}y>=32&&(y-=32,v=d[++D]),g=I-m,R?(g+=B>0?F:o>0?L[C-c]:F,g&=255,L[C]=g,F=g):L[C]=g}else for(C=0,o=0;o<f;o++)for(B=0;B<c;B++,C++)if(G[C]){if(I=0,a=n=v<<y>>>32-k,32-y<k&&(a=n|=d[D+1]>>>64-y-k),u[a])I=u[a][1],y+=u[a][0];else for(a=n=v<<y>>>32-p,32-y<p&&(a=n|=d[D+1]>>>64-y-p),r=w,E=0;E<p;E++)if(!(r=n>>>p-E-1&1?r.right:r.left).left&&!r.right){I=r.val,y=y+E+1;break}y>=32&&(y-=32,v=d[++D]),g=I-m,R?(B>0&&G[C-1]?g+=F:o>0&&G[C-c]?g+=L[C-c]:g+=F,g&=255,L[C]=g,F=g):L[C]=g}}else for(C=0,o=0;o<f;o++)for(B=0;B<c;B++)if(C=o*c+B,!G||G[C])for(S=0;S<s;S++,C+=h){if(I=0,a=n=v<<y>>>32-k,32-y<k&&(a=n|=d[D+1]>>>64-y-k),u[a])I=u[a][1],y+=u[a][0];else for(a=n=v<<y>>>32-p,32-y<p&&(a=n|=d[D+1]>>>64-y-p),r=w,E=0;E<p;E++)if(!(r=n>>>p-E-1&1?r.right:r.left).left&&!r.right){I=r.val,y=y+E+1;break}y>=32&&(y-=32,v=d[++D]),g=I-m,L[C]=g}e.ptr=e.ptr+4*(D+1)+(y>0?4:0),e.pixels.resultPixels=U,s>1&&!i&&(e.pixels.resultPixels=Q.swapDimensionOrder(U,h,s,t))},decodeBits:function(A,e,t,i,r){var I=e.headerInfo,Q=I.fileVersion,E=0,s=A.byteLength-e.ptr>=5?5:A.byteLength-e.ptr,f=new DataView(A,e.ptr,s),c=f.getUint8(0);E++;var h=c>>6,l=0===h?4:3-h,u=(32&c)>0,w=31&c,d=0;if(1===l)d=f.getUint8(E),E++;else if(2===l)d=f.getUint16(E,!0),E+=2;else{if(4!==l)throw"Invalid valid pixel count type";d=f.getUint32(E,!0),E+=4}var D,y,k,p,m,G,F,S,v,R=2*I.maxZError,U=I.numDims>1?I.maxValues[r]:I.zMax;if(u){for(e.counter.lut++,S=f.getUint8(E),E++,p=Math.ceil((S-1)*w/8),m=Math.ceil(p/4),y=new ArrayBuffer(4*m),k=new Uint8Array(y),e.ptr+=E,k.set(new Uint8Array(A,e.ptr,p)),F=new Uint32Array(y),e.ptr+=p,v=0;S-1>>>v;)v++;p=Math.ceil(d*v/8),m=Math.ceil(p/4),y=new ArrayBuffer(4*m),(k=new Uint8Array(y)).set(new Uint8Array(A,e.ptr,p)),D=new Uint32Array(y),e.ptr+=p,G=Q>=3?o(F,w,S-1,i,R,U):n(F,w,S-1,i,R,U),Q>=3?a(D,t,v,d,G):g(D,t,v,d,G)}else e.counter.bitstuffer++,v=w,e.ptr+=E,v>0&&(p=Math.ceil(d*v/8),m=Math.ceil(p/4),y=new ArrayBuffer(4*m),(k=new Uint8Array(y)).set(new Uint8Array(A,e.ptr,p)),D=new Uint32Array(y),e.ptr+=p,Q>=3?null==i?C(D,t,v,d):a(D,t,v,d,!1,i,R,U):null==i?B(D,t,v,d):g(D,t,v,d,!1,i,R,U))},readTiles:function(A,e,t,i){var r=e.headerInfo,I=r.width,g=r.height,n=I*g,a=r.microBlockSize,o=r.imageType,B=Q.getDataTypeSize(o),C=Math.ceil(I/a),E=Math.ceil(g/a);e.pixels.numBlocksY=E,e.pixels.numBlocksX=C,e.pixels.ptr=0;var s,f,c,h,l,u,w,d,D,y,k=0,p=0,m=0,G=0,F=0,S=0,v=0,R=0,U=0,L=0,b=0,M=0,N=0,x=0,J=0,q=new t(a*a),Y=g%a||a,K=I%a||a,H=r.numDims,O=e.pixels.resultMask,P=e.pixels.resultPixels,T=r.fileVersion>=5?14:15,V=r.zMax;for(m=0;m<E;m++)for(F=m!==E-1?a:Y,G=0;G<C;G++)for(L=m*I*a+G*a,b=I-(S=G!==C-1?a:K),d=0;d<H;d++){if(H>1?(y=P,L=m*I*a+G*a,P=new t(e.pixels.resultPixels.buffer,n*d*B,n),V=r.maxValues[d]):y=null,v=A.byteLength-e.ptr,f={},J=0,R=(s=new DataView(A,e.ptr,Math.min(10,v))).getUint8(0),J++,D=r.fileVersion>=5?4&R:0,U=R>>6&255,(R>>2&T)!=(G*a>>3&T))throw"integrity issue";if(D&&0===d)throw"integrity issue";if((l=3&R)>3)throw e.ptr+=J,"Invalid block encoding ("+l+")";if(2!==l)if(0===l){if(D)throw"integrity issue";if(e.counter.uncompressed++,e.ptr+=J,M=(M=F*S*B)<(N=A.byteLength-e.ptr)?M:N,c=new ArrayBuffer(M%B==0?M:M+B-M%B),new Uint8Array(c).set(new Uint8Array(A,e.ptr,M)),h=new t(c),x=0,O)for(k=0;k<F;k++){for(p=0;p<S;p++)O[L]&&(P[L]=h[x++]),L++;L+=b}else for(k=0;k<F;k++){for(p=0;p<S;p++)P[L++]=h[x++];L+=b}e.ptr+=x*B}else if(u=Q.getDataTypeUsed(D&&o<6?4:o,U),w=Q.getOnePixel(f,J,u,s),J+=Q.getDataTypeSize(u),3===l)if(e.ptr+=J,e.counter.constantoffset++,O)for(k=0;k<F;k++){for(p=0;p<S;p++)O[L]&&(P[L]=D?Math.min(V,y[L]+w):w),L++;L+=b}else for(k=0;k<F;k++){for(p=0;p<S;p++)P[L]=D?Math.min(V,y[L]+w):w,L++;L+=b}else if(e.ptr+=J,Q.decodeBits(A,e,q,w,d),J=0,D)if(O)for(k=0;k<F;k++){for(p=0;p<S;p++)O[L]&&(P[L]=q[J++]+y[L]),L++;L+=b}else for(k=0;k<F;k++){for(p=0;p<S;p++)P[L]=q[J++]+y[L],L++;L+=b}else if(O)for(k=0;k<F;k++){for(p=0;p<S;p++)O[L]&&(P[L]=q[J++]),L++;L+=b}else for(k=0;k<F;k++){for(p=0;p<S;p++)P[L++]=q[J++];L+=b}else{if(D)if(O)for(k=0;k<F;k++)for(p=0;p<S;p++)O[L]&&(P[L]=y[L]),L++;else for(k=0;k<F;k++)for(p=0;p<S;p++)P[L]=y[L],L++;e.counter.constant++,e.ptr+=J}}H>1&&!i&&(e.pixels.resultPixels=Q.swapDimensionOrder(e.pixels.resultPixels,n,H,t))},formatFileInfo:function(A){return{fileIdentifierString:A.headerInfo.fileIdentifierString,fileVersion:A.headerInfo.fileVersion,imageType:A.headerInfo.imageType,height:A.headerInfo.height,width:A.headerInfo.width,numValidPixel:A.headerInfo.numValidPixel,microBlockSize:A.headerInfo.microBlockSize,blobSize:A.headerInfo.blobSize,maxZError:A.headerInfo.maxZError,pixelType:Q.getPixelType(A.headerInfo.imageType),eofOffset:A.eofOffset,mask:A.mask?{numBytes:A.mask.numBytes}:null,pixels:{numBlocksX:A.pixels.numBlocksX,numBlocksY:A.pixels.numBlocksY,maxValue:A.headerInfo.zMax,minValue:A.headerInfo.zMin,noDataValue:A.noDataValue}}},constructConstantSurface:function(A,e){var t=A.headerInfo.zMax,i=A.headerInfo.zMin,r=A.headerInfo.maxValues,I=A.headerInfo.numDims,g=A.headerInfo.height*A.headerInfo.width,n=0,a=0,o=0,B=A.pixels.resultMask,C=A.pixels.resultPixels;if(B)if(I>1){if(e)for(n=0;n<I;n++)for(o=n*g,t=r[n],a=0;a<g;a++)B[a]&&(C[o+a]=t);else for(a=0;a<g;a++)if(B[a])for(o=a*I,n=0;n<I;n++)C[o+I]=r[n]}else for(a=0;a<g;a++)B[a]&&(C[a]=t);else if(I>1&&i!==t)if(e)for(n=0;n<I;n++)for(o=n*g,t=r[n],a=0;a<g;a++)C[o+a]=t;else for(a=0;a<g;a++)for(o=a*I,n=0;n<I;n++)C[o+n]=r[n];else for(a=0;a<g*I;a++)C[a]=t},getDataTypeArray:function(A){var e;switch(A){case 0:e=Int8Array;break;case 1:e=Uint8Array;break;case 2:e=Int16Array;break;case 3:e=Uint16Array;break;case 4:e=Int32Array;break;case 5:e=Uint32Array;break;case 6:default:e=Float32Array;break;case 7:e=Float64Array}return e},getPixelType:function(A){var e;switch(A){case 0:e="S8";break;case 1:e="U8";break;case 2:e="S16";break;case 3:e="U16";break;case 4:e="S32";break;case 5:e="U32";break;case 6:default:e="F32";break;case 7:e="F64"}return e},isValidPixelValue:function(A,e){if(null==e)return!1;var t;switch(A){case 0:t=e>=-128&&e<=127;break;case 1:t=e>=0&&e<=255;break;case 2:t=e>=-32768&&e<=32767;break;case 3:t=e>=0&&e<=65536;break;case 4:t=e>=-2147483648&&e<=2147483647;break;case 5:t=e>=0&&e<=4294967296;break;case 6:t=e>=-34027999387901484e22&&e<=34027999387901484e22;break;case 7:t=e>=-17976931348623157e292&&e<=17976931348623157e292;break;default:t=!1}return t},getDataTypeSize:function(A){var e=0;switch(A){case 0:case 1:e=1;break;case 2:case 3:e=2;break;case 4:case 5:case 6:e=4;break;case 7:e=8;break;default:e=A}return e},getDataTypeUsed:function(A,e){var t=A;switch(A){case 2:case 4:t=A-e;break;case 3:case 5:t=A-2*e;break;case 6:t=0===e?A:1===e?2:1;break;case 7:t=0===e?A:A-2*e+1;break;default:t=A}return t},getOnePixel:function(A,e,t,i){var r=0;switch(t){case 0:r=i.getInt8(e);break;case 1:r=i.getUint8(e);break;case 2:r=i.getInt16(e,!0);break;case 3:r=i.getUint16(e,!0);break;case 4:r=i.getInt32(e,!0);break;case 5:r=i.getUInt32(e,!0);break;case 6:r=i.getFloat32(e,!0);break;case 7:r=i.getFloat64(e,!0);break;default:throw"the decoder does not understand this pixel type"}return r},swapDimensionOrder:function(A,e,t,i,r){var I=0,g=0,n=0,a=0,o=A;if(t>1)if(o=new i(e*t),r)for(I=0;I<e;I++)for(a=I,n=0;n<t;n++,a+=e)o[a]=A[g++];else for(I=0;I<e;I++)for(a=I,n=0;n<t;n++,a+=e)o[g++]=A[a];return o}},E=function(A,e,t){this.val=A,this.left=e,this.right=t},{decode:function(A,e){var t=(e=e||{}).noDataValue,i=0,r={};r.ptr=e.inputOffset||0,r.pixels={},Q.readHeaderInfo(A,r);var I=r.headerInfo,g=I.fileVersion,n=Q.getDataTypeArray(I.imageType);if(g>5)throw"unsupported lerc version 2."+g;Q.readMask(A,r),I.numValidPixel===I.width*I.height||r.pixels.resultMask||(r.pixels.resultMask=e.maskData);var a=I.width*I.height;r.pixels.resultPixels=new n(a*I.numDims),r.counter={onesweep:0,uncompressed:0,lut:0,bitstuffer:0,constant:0,constantoffset:0};var o,B=!e.returnPixelInterleavedDims;if(0!==I.numValidPixel)if(I.zMax===I.zMin)Q.constructConstantSurface(r,B);else if(g>=4&&Q.checkMinMaxRanges(A,r))Q.constructConstantSurface(r,B);else{var C=new DataView(A,r.ptr,2),E=C.getUint8(0);if(r.ptr++,E)Q.readDataOneSweep(A,r,n,B);else if(g>1&&I.imageType<=1&&Math.abs(I.maxZError-.5)<1e-5){var s=C.getUint8(1);if(r.ptr++,r.encodeMode=s,s>2||g<4&&s>1)throw"Invalid Huffman flag "+s;s?Q.readHuffman(A,r,n,B):Q.readTiles(A,r,n,B)}else Q.readTiles(A,r,n,B)}r.eofOffset=r.ptr,e.inputOffset?(o=r.headerInfo.blobSize+e.inputOffset-r.ptr,Math.abs(o)>=1&&(r.eofOffset=e.inputOffset+r.headerInfo.blobSize)):(o=r.headerInfo.blobSize-r.ptr,Math.abs(o)>=1&&(r.eofOffset=r.headerInfo.blobSize));var f={width:I.width,height:I.height,pixelData:r.pixels.resultPixels,minValue:I.zMin,maxValue:I.zMax,validPixelCount:I.numValidPixel,dimCount:I.numDims,dimStats:{minValues:I.minValues,maxValues:I.maxValues},maskData:r.pixels.resultMask};if(r.pixels.resultMask&&Q.isValidPixelValue(I.imageType,t)){var c=r.pixels.resultMask;for(i=0;i<a;i++)c[i]||(f.pixelData[i]=t);f.noDataValue=t}return r.noDataValue=t,e.returnFileInfo&&(f.fileInfo=Q.formatFileInfo(r)),f},getBandCount:function(A){for(var e=0,t=0,i={ptr:0,pixels:{}};t<A.byteLength-58;)Q.readHeaderInfo(A,i),t+=i.headerInfo.blobSize,e++,i.ptr=t;return e}}),l=(s=new ArrayBuffer(4),f=new Uint8Array(s),new Uint32Array(s)[0]=1,1===f[0]),u={decode:function(A,e){if(!l)throw"Big endian system is not supported.";var t,i,r=(e=e||{}).inputOffset||0,I=new Uint8Array(A,r,10),g=String.fromCharCode.apply(null,I);if("CntZImage"===g.trim())t=c,i=1;else{if("Lerc2"!==g.substring(0,5))throw"Unexpected file identifier string: "+g;t=h,i=2}for(var n,a,o,B,C,Q,E=0,s=A.byteLength-10,f=[],u={width:0,height:0,pixels:[],pixelType:e.pixelType,mask:null,statistics:[]},w=0;r<s;){var d=t.decode(A,{inputOffset:r,encodedMaskData:n,maskData:o,returnMask:0===E,returnEncodedMask:0===E,returnFileInfo:!0,returnPixelInterleavedDims:e.returnPixelInterleavedDims,pixelType:e.pixelType||null,noDataValue:e.noDataValue||null});r=d.fileInfo.eofOffset,o=d.maskData,0===E&&(n=d.encodedMaskData,u.width=d.width,u.height=d.height,u.dimCount=d.dimCount||1,u.pixelType=d.pixelType||d.fileInfo.pixelType,u.mask=o),i>1&&(o&&f.push(o),d.fileInfo.mask&&d.fileInfo.mask.numBytes>0&&w++),E++,u.pixels.push(d.pixelData),u.statistics.push({minValue:d.minValue,maxValue:d.maxValue,noDataValue:d.noDataValue,dimStats:d.dimStats})}if(i>1&&w>1){for(Q=u.width*u.height,u.bandMasks=f,(o=new Uint8Array(Q)).set(f[0]),B=1;B<f.length;B++)for(a=f[B],C=0;C<Q;C++)o[C]=o[C]&a[C];u.maskData=o}return u}};TA.exports?TA.exports=u:this.Lerc=u}();var ZA,jA,WA,zA=XA.exports,$A={env:{emscripten_notify_memory_growth:function(A){WA=new Uint8Array(jA.exports.memory.buffer)}}},Ae=function(){function A(){B(this,A)}return Q(A,[{key:"init",value:function(){return ZA||(ZA="undefined"!=typeof fetch?fetch("data:application/wasm;base64,"+ee).then((function(A){return A.arrayBuffer()})).then((function(A){return WebAssembly.instantiate(A,$A)})).then(this._init):WebAssembly.instantiate(Buffer.from(ee,"base64"),$A).then(this._init))}},{key:"_init",value:function(A){jA=A.instance,$A.env.emscripten_notify_memory_growth(0)}},{key:"decode",value:function(A){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!jA)throw new Error("ZSTDDecoder: Await .init() before decoding.");var t=A.byteLength,i=jA.exports.malloc(t);WA.set(A,i),e=e||Number(jA.exports.ZSTD_findDecompressedSize(i,t));var r=jA.exports.malloc(e),I=jA.exports.ZSTD_decompress(r,e,i,t),g=WA.slice(r,r+I);return jA.exports.free(i),jA.exports.free(r),g}}]),A}(),ee="AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ",te={315:"Artist",258:"BitsPerSample",265:"CellLength",264:"CellWidth",320:"ColorMap",259:"Compression",33432:"Copyright",306:"DateTime",338:"ExtraSamples",266:"FillOrder",289:"FreeByteCounts",288:"FreeOffsets",291:"GrayResponseCurve",290:"GrayResponseUnit",316:"HostComputer",270:"ImageDescription",257:"ImageLength",256:"ImageWidth",271:"Make",281:"MaxSampleValue",280:"MinSampleValue",272:"Model",254:"NewSubfileType",274:"Orientation",262:"PhotometricInterpretation",284:"PlanarConfiguration",296:"ResolutionUnit",278:"RowsPerStrip",277:"SamplesPerPixel",305:"Software",279:"StripByteCounts",273:"StripOffsets",255:"SubfileType",263:"Threshholding",282:"XResolution",283:"YResolution",326:"BadFaxLines",327:"CleanFaxData",343:"ClipPath",328:"ConsecutiveBadFaxLines",433:"Decode",434:"DefaultImageColor",269:"DocumentName",336:"DotRange",321:"HalftoneHints",346:"Indexed",347:"JPEGTables",285:"PageName",297:"PageNumber",317:"Predictor",319:"PrimaryChromaticities",532:"ReferenceBlackWhite",339:"SampleFormat",340:"SMinSampleValue",341:"SMaxSampleValue",559:"StripRowCounts",330:"SubIFDs",292:"T4Options",293:"T6Options",325:"TileByteCounts",323:"TileLength",324:"TileOffsets",322:"TileWidth",301:"TransferFunction",318:"WhitePoint",344:"XClipPathUnits",286:"XPosition",529:"YCbCrCoefficients",531:"YCbCrPositioning",530:"YCbCrSubSampling",345:"YClipPathUnits",287:"YPosition",37378:"ApertureValue",40961:"ColorSpace",36868:"DateTimeDigitized",36867:"DateTimeOriginal",34665:"Exif IFD",36864:"ExifVersion",33434:"ExposureTime",41728:"FileSource",37385:"Flash",40960:"FlashpixVersion",33437:"FNumber",42016:"ImageUniqueID",37384:"LightSource",37500:"MakerNote",37377:"ShutterSpeedValue",37510:"UserComment",33723:"IPTC",34675:"ICC Profile",700:"XMP",42112:"GDAL_METADATA",42113:"GDAL_NODATA",34377:"Photoshop",33550:"ModelPixelScale",33922:"ModelTiepoint",34264:"ModelTransformation",34735:"GeoKeyDirectory",34736:"GeoDoubleParams",34737:"GeoAsciiParams",50674:"LercParameters"},ie={};for(var re in te)te.hasOwnProperty(re)&&(ie[te[re]]=parseInt(re,10));ie.BitsPerSample,ie.ExtraSamples,ie.SampleFormat,ie.StripByteCounts,ie.StripOffsets,ie.StripRowCounts,ie.TileByteCounts,ie.TileOffsets,ie.SubIFDs;var Ie={1:"BYTE",2:"ASCII",3:"SHORT",4:"LONG",5:"RATIONAL",6:"SBYTE",7:"UNDEFINED",8:"SSHORT",9:"SLONG",10:"SRATIONAL",11:"FLOAT",12:"DOUBLE",13:"IFD",16:"LONG8",17:"SLONG8",18:"IFD8"},ge={};for(var ne in Ie)Ie.hasOwnProperty(ne)&&(ge[Ie[ne]]=parseInt(ne,10));var ae=1,oe=0,Be=1,Ce=2,Qe={1024:"GTModelTypeGeoKey",1025:"GTRasterTypeGeoKey",1026:"GTCitationGeoKey",2048:"GeographicTypeGeoKey",2049:"GeogCitationGeoKey",2050:"GeogGeodeticDatumGeoKey",2051:"GeogPrimeMeridianGeoKey",2052:"GeogLinearUnitsGeoKey",2053:"GeogLinearUnitSizeGeoKey",2054:"GeogAngularUnitsGeoKey",2055:"GeogAngularUnitSizeGeoKey",2056:"GeogEllipsoidGeoKey",2057:"GeogSemiMajorAxisGeoKey",2058:"GeogSemiMinorAxisGeoKey",2059:"GeogInvFlatteningGeoKey",2060:"GeogAzimuthUnitsGeoKey",2061:"GeogPrimeMeridianLongGeoKey",2062:"GeogTOWGS84GeoKey",3072:"ProjectedCSTypeGeoKey",3073:"PCSCitationGeoKey",3074:"ProjectionGeoKey",3075:"ProjCoordTransGeoKey",3076:"ProjLinearUnitsGeoKey",3077:"ProjLinearUnitSizeGeoKey",3078:"ProjStdParallel1GeoKey",3079:"ProjStdParallel2GeoKey",3080:"ProjNatOriginLongGeoKey",3081:"ProjNatOriginLatGeoKey",3082:"ProjFalseEastingGeoKey",3083:"ProjFalseNorthingGeoKey",3084:"ProjFalseOriginLongGeoKey",3085:"ProjFalseOriginLatGeoKey",3086:"ProjFalseOriginEastingGeoKey",3087:"ProjFalseOriginNorthingGeoKey",3088:"ProjCenterLongGeoKey",3089:"ProjCenterLatGeoKey",3090:"ProjCenterEastingGeoKey",3091:"ProjCenterNorthingGeoKey",3092:"ProjScaleAtNatOriginGeoKey",3093:"ProjScaleAtCenterGeoKey",3094:"ProjAzimuthAngleGeoKey",3095:"ProjStraightVertPoleLongGeoKey",3096:"ProjRectifiedGridAngleGeoKey",4096:"VerticalCSTypeGeoKey",4097:"VerticalCitationGeoKey",4098:"VerticalDatumGeoKey",4099:"VerticalUnitsGeoKey"},Ee={};for(var se in Qe)Qe.hasOwnProperty(se)&&(Ee[Qe[se]]=parseInt(se,10));function fe(A){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var ce=new Ae,he=function(A){s(t,w);var e=fe(t);function t(A){var i;return B(this,t),(i=e.call(this)).planarConfiguration=void 0!==A.PlanarConfiguration?A.PlanarConfiguration:1,i.samplesPerPixel=void 0!==A.SamplesPerPixel?A.SamplesPerPixel:1,i.addCompression=A.LercParameters[ae],i}return Q(t,[{key:"decodeBlock",value:function(A){switch(this.addCompression){case oe:break;case Be:A=YA(new Uint8Array(A)).buffer;break;case Ce:A=ce.decode(new Uint8Array(A)).buffer;break;default:throw new Error("Unsupported LERC additional compression method identifier: ".concat(this.addCompression))}return zA.decode(A,{returnPixelInterleavedDims:1===this.planarConfiguration}).pixels[0].buffer}}]),t}(),le=Object.freeze({__proto__:null,zstd:ce,default:he});function ue(A){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var we=function(A){s(I,w);var t,i=ue(I);function I(){var A;if(B(this,I),A=i.call(this),"undefined"==typeof createImageBitmap)throw new Error("Cannot decode WebImage as `createImageBitmap` is not available");if("undefined"==typeof document&&"undefined"==typeof OffscreenCanvas)throw new Error("Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available");return A}return Q(I,[{key:"decode",value:(t=e(r.mark((function A(e,t){var i,I,g,n;return r.wrap((function(A){for(;;)switch(A.prev=A.next){case 0:return i=new Blob([t]),A.next=3,createImageBitmap(i);case 3:return I=A.sent,"undefined"!=typeof document?((g=document.createElement("canvas")).width=I.width,g.height=I.height):g=new OffscreenCanvas(I.width,I.height),(n=g.getContext("2d")).drawImage(I,0,0),A.abrupt("return",n.getImageData(0,0,I.width,I.height).data.buffer);case 8:case"end":return A.stop()}}),A)}))),function(A,e){return t.apply(this,arguments)})}]),I}(),de=Object.freeze({__proto__:null,default:we});';
  return new e(typeof Buffer < "u" ? "data:application/javascript;base64," + Buffer.from(A2, "binary").toString("base64") : URL.createObjectURL(new Blob([A2], { type: "application/javascript" })));
}
var e;
var init_decoder_DJlmx386 = __esm(() => {
  e = Worker;
});

// node_modules/geotiff-tilesource/dist/main-8v7k2MJ1.js
var exports_main_8v7k2MJ1 = {};
__export(exports_main_8v7k2MJ1, {
  g: () => We2,
  e: () => qr,
  a: () => is,
  L: () => ss
});
function E2(i) {
  return (e2, ...t2) => gt2(i, e2, t2);
}
function H2(i, e2) {
  return E2(Ue2(i, e2).get);
}
function Rt2(i) {
  if (i[ee2] === Le2 && Q3.next === Ke2)
    return i;
  const e2 = pe2(kt2);
  return Pt2(He2, e2, It2(i)), e2;
}
function vt(i) {
  const e2 = i >> 10;
  return Ot2[0] = xe2[Xe2[e2] + (i & 1023)] + Y3[e2], Gt2[0];
}
function $e2(i, e2, ...t2) {
  return vt(Et2(i, e2, ...Rt2(t2)));
}
function We2(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
function Ze(i, e2, t2) {
  const r = t2 && t2.debug || false;
  r && console.log("[xml-utils] getting " + e2 + " in " + i);
  const s3 = typeof i == "object" ? i.outer : i, o = s3.slice(0, s3.indexOf(">") + 1), n = ['"', "'"];
  for (let a = 0;a < n.length; a++) {
    const l3 = n[a], c = e2 + "\\=" + l3 + "([^" + l3 + "]*)" + l3;
    r && console.log("[xml-utils] pattern:", c);
    const d3 = new RegExp(c).exec(o);
    if (r && console.log("[xml-utils] match:", d3), d3)
      return d3[1];
  }
}
function Je2(i, e2, t2) {
  const s3 = new RegExp(e2).exec(i.slice(t2));
  return s3 ? t2 + s3.index : -1;
}
function Qe2(i, e2, t2) {
  const s3 = new RegExp(e2).exec(i.slice(t2));
  return s3 ? t2 + s3.index + s3[0].length - 1 : -1;
}
function et2(i, e2) {
  const t2 = new RegExp(e2, "g"), r = i.match(t2);
  return r ? r.length : 0;
}
function tt2(i, e2, t2) {
  const r = t2 && t2.debug || false, s3 = !(t2 && typeof t2.nested === false), o = t2 && t2.startIndex || 0;
  r && console.log("[xml-utils] starting findTagByName with", e2, " and ", t2);
  const n = jt2(i, `<${e2}[ 
>/]`, o);
  if (r && console.log("[xml-utils] start:", n), n === -1)
    return;
  const a = i.slice(n + e2.length);
  let l3 = le3(a, "^[^<]*[ /]>", 0);
  const c = l3 !== -1 && a[l3 - 1] === "/";
  if (r && console.log("[xml-utils] selfClosing:", c), c === false)
    if (s3) {
      let g2 = 0, f2 = 1, y = 0;
      for (;(l3 = le3(a, "[ /]" + e2 + ">", g2)) !== -1; ) {
        const p2 = a.substring(g2, l3 + 1);
        if (f2 += Be2(p2, "<" + e2 + `[ 
	>]`), y += Be2(p2, "</" + e2 + ">"), y >= f2)
          break;
        g2 = l3;
      }
    } else
      l3 = le3(a, "[ /]" + e2 + ">", 0);
  const h = n + e2.length + l3 + 1;
  if (r && console.log("[xml-utils] end:", h), h === -1)
    return;
  const d3 = i.slice(n, h);
  let u;
  return c ? u = null : u = d3.slice(d3.indexOf(">") + 1, d3.lastIndexOf("<")), { inner: u, outer: d3, start: n, end: h };
}
function rt2(i, e2, t2) {
  const r = [], s3 = t2 && t2.debug || false, o = t2 && typeof t2.nested == "boolean" ? t2.nested : true;
  let n = t2 && t2.startIndex || 0, a;
  for (;a = Kt2(i, e2, { debug: s3, startIndex: n }); )
    o ? n = a.start + 1 + e2.length : n = a.end, r.push(a);
  return s3 && console.log("findTagsByName found", r.length, "tags"), r;
}
function $t2(i, e2) {
  const { width: t2, height: r } = i, s3 = new Uint8Array(t2 * r * 3);
  let o;
  for (let n = 0, a = 0;n < i.length; ++n, a += 3)
    o = 256 - i[n] / e2 * 256, s3[a] = o, s3[a + 1] = o, s3[a + 2] = o;
  return s3;
}
function Wt2(i, e2) {
  const { width: t2, height: r } = i, s3 = new Uint8Array(t2 * r * 3);
  let o;
  for (let n = 0, a = 0;n < i.length; ++n, a += 3)
    o = i[n] / e2 * 256, s3[a] = o, s3[a + 1] = o, s3[a + 2] = o;
  return s3;
}
function Zt2(i, e2) {
  const { width: t2, height: r } = i, s3 = new Uint8Array(t2 * r * 3), o = e2.length / 3, n = e2.length / 3 * 2;
  for (let a = 0, l3 = 0;a < i.length; ++a, l3 += 3) {
    const c = i[a];
    s3[l3] = e2[c] / 65536 * 256, s3[l3 + 1] = e2[c + o] / 65536 * 256, s3[l3 + 2] = e2[c + n] / 65536 * 256;
  }
  return s3;
}
function Jt2(i) {
  const { width: e2, height: t2 } = i, r = new Uint8Array(e2 * t2 * 3);
  for (let s3 = 0, o = 0;s3 < i.length; s3 += 4, o += 3) {
    const n = i[s3], a = i[s3 + 1], l3 = i[s3 + 2], c = i[s3 + 3];
    r[o] = 255 * ((255 - n) / 256) * ((255 - c) / 256), r[o + 1] = 255 * ((255 - a) / 256) * ((255 - c) / 256), r[o + 2] = 255 * ((255 - l3) / 256) * ((255 - c) / 256);
  }
  return r;
}
function Qt2(i) {
  const { width: e2, height: t2 } = i, r = new Uint8ClampedArray(e2 * t2 * 3);
  for (let s3 = 0, o = 0;s3 < i.length; s3 += 3, o += 3) {
    const n = i[s3], a = i[s3 + 1], l3 = i[s3 + 2];
    r[o] = n + 1.402 * (l3 - 128), r[o + 1] = n - 0.34414 * (a - 128) - 0.71414 * (l3 - 128), r[o + 2] = n + 1.772 * (a - 128);
  }
  return r;
}
function sr2(i) {
  const { width: e2, height: t2 } = i, r = new Uint8Array(e2 * t2 * 3);
  for (let s3 = 0, o = 0;s3 < i.length; s3 += 3, o += 3) {
    const n = i[s3 + 0], a = i[s3 + 1] << 24 >> 24, l3 = i[s3 + 2] << 24 >> 24;
    let c = (n + 16) / 116, h = a / 500 + c, d3 = c - l3 / 200, u, g2, f2;
    h = er2 * (h * h * h > 0.008856 ? h * h * h : (h - 16 / 116) / 7.787), c = tr2 * (c * c * c > 0.008856 ? c * c * c : (c - 16 / 116) / 7.787), d3 = rr2 * (d3 * d3 * d3 > 0.008856 ? d3 * d3 * d3 : (d3 - 16 / 116) / 7.787), u = h * 3.2406 + c * -1.5372 + d3 * -0.4986, g2 = h * -0.9689 + c * 1.8758 + d3 * 0.0415, f2 = h * 0.0557 + c * -0.204 + d3 * 1.057, u = u > 0.0031308 ? 1.055 * u ** (1 / 2.4) - 0.055 : 12.92 * u, g2 = g2 > 0.0031308 ? 1.055 * g2 ** (1 / 2.4) - 0.055 : 12.92 * g2, f2 = f2 > 0.0031308 ? 1.055 * f2 ** (1 / 2.4) - 0.055 : 12.92 * f2, r[o] = Math.max(0, Math.min(1, u)) * 255, r[o + 1] = Math.max(0, Math.min(1, g2)) * 255, r[o + 2] = Math.max(0, Math.min(1, f2)) * 255;
  }
  return r;
}
function j2(i, e2) {
  Array.isArray(i) || (i = [i]), i.forEach((t2) => st2.set(t2, e2));
}
async function it2(i) {
  const e2 = st2.get(i.Compression);
  if (!e2)
    throw new Error(`Unknown compression method identifier: ${i.Compression}`);
  const t2 = await e2();
  return new t2(i);
}
function ne3(i, e2, t2, r = 1) {
  return new (Object.getPrototypeOf(i)).constructor(e2 * t2 * r);
}
function ir2(i, e2, t2, r, s3) {
  const o = e2 / r, n = t2 / s3;
  return i.map((a) => {
    const l3 = ne3(a, r, s3);
    for (let c = 0;c < s3; ++c) {
      const h = Math.min(Math.round(n * c), t2 - 1);
      for (let d3 = 0;d3 < r; ++d3) {
        const u = Math.min(Math.round(o * d3), e2 - 1), g2 = a[h * e2 + u];
        l3[c * r + d3] = g2;
      }
    }
    return l3;
  });
}
function V2(i, e2, t2) {
  return (1 - t2) * i + t2 * e2;
}
function nr2(i, e2, t2, r, s3) {
  const o = e2 / r, n = t2 / s3;
  return i.map((a) => {
    const l3 = ne3(a, r, s3);
    for (let c = 0;c < s3; ++c) {
      const h = n * c, d3 = Math.floor(h), u = Math.min(Math.ceil(h), t2 - 1);
      for (let g2 = 0;g2 < r; ++g2) {
        const f2 = o * g2, y = f2 % 1, p2 = Math.floor(f2), w = Math.min(Math.ceil(f2), e2 - 1), m2 = a[d3 * e2 + p2], b = a[d3 * e2 + w], T2 = a[u * e2 + p2], S2 = a[u * e2 + w], D2 = V2(V2(m2, b, y), V2(T2, S2, y), h % 1);
        l3[c * r + g2] = D2;
      }
    }
    return l3;
  });
}
function or2(i, e2, t2, r, s3, o = "nearest") {
  switch (o.toLowerCase()) {
    case "nearest":
      return ir2(i, e2, t2, r, s3);
    case "bilinear":
    case "linear":
      return nr2(i, e2, t2, r, s3);
    default:
      throw new Error(`Unsupported resampling method: '${o}'`);
  }
}
function ar2(i, e2, t2, r, s3, o) {
  const n = e2 / r, a = t2 / s3, l3 = ne3(i, r, s3, o);
  for (let c = 0;c < s3; ++c) {
    const h = Math.min(Math.round(a * c), t2 - 1);
    for (let d3 = 0;d3 < r; ++d3) {
      const u = Math.min(Math.round(n * d3), e2 - 1);
      for (let g2 = 0;g2 < o; ++g2) {
        const f2 = i[h * e2 * o + u * o + g2];
        l3[c * r * o + d3 * o + g2] = f2;
      }
    }
  }
  return l3;
}
function lr2(i, e2, t2, r, s3, o) {
  const n = e2 / r, a = t2 / s3, l3 = ne3(i, r, s3, o);
  for (let c = 0;c < s3; ++c) {
    const h = a * c, d3 = Math.floor(h), u = Math.min(Math.ceil(h), t2 - 1);
    for (let g2 = 0;g2 < r; ++g2) {
      const f2 = n * g2, y = f2 % 1, p2 = Math.floor(f2), w = Math.min(Math.ceil(f2), e2 - 1);
      for (let m2 = 0;m2 < o; ++m2) {
        const b = i[d3 * e2 * o + p2 * o + m2], T2 = i[d3 * e2 * o + w * o + m2], S2 = i[u * e2 * o + p2 * o + m2], D2 = i[u * e2 * o + w * o + m2], M2 = V2(V2(b, T2, y), V2(S2, D2, y), h % 1);
        l3[c * r * o + g2 * o + m2] = M2;
      }
    }
  }
  return l3;
}
function cr2(i, e2, t2, r, s3, o, n = "nearest") {
  switch (n.toLowerCase()) {
    case "nearest":
      return ar2(i, e2, t2, r, s3, o);
    case "bilinear":
    case "linear":
      return lr2(i, e2, t2, r, s3, o);
    default:
      throw new Error(`Unsupported resampling method: '${n}'`);
  }
}
function hr2(i, e2, t2) {
  let r = 0;
  for (let s3 = e2;s3 < t2; ++s3)
    r += i[s3];
  return r;
}
function ue2(i, e2, t2) {
  switch (i) {
    case 1:
      if (e2 <= 8)
        return new Uint8Array(t2);
      if (e2 <= 16)
        return new Uint16Array(t2);
      if (e2 <= 32)
        return new Uint32Array(t2);
      break;
    case 2:
      if (e2 === 8)
        return new Int8Array(t2);
      if (e2 === 16)
        return new Int16Array(t2);
      if (e2 === 32)
        return new Int32Array(t2);
      break;
    case 3:
      switch (e2) {
        case 16:
        case 32:
          return new Float32Array(t2);
        case 64:
          return new Float64Array(t2);
      }
      break;
  }
  throw Error("Unsupported data format/bitsPerSample");
}
function fr2(i, e2) {
  return (i === 1 || i === 2) && e2 <= 32 && e2 % 8 === 0 ? false : !(i === 3 && (e2 === 16 || e2 === 32 || e2 === 64));
}
function ur2(i, e2, t2, r, s3, o, n) {
  const a = new DataView(i), l3 = t2 === 2 ? n * o : n * o * r, c = t2 === 2 ? 1 : r, h = ue2(e2, s3, l3), d3 = parseInt("1".repeat(s3), 2);
  if (e2 === 1) {
    let u;
    t2 === 1 ? u = r * s3 : u = s3;
    let g2 = o * u;
    g2 & 7 && (g2 = g2 + 7 & -8);
    for (let f2 = 0;f2 < n; ++f2) {
      const y = f2 * g2;
      for (let p2 = 0;p2 < o; ++p2) {
        const w = y + p2 * c * s3;
        for (let m2 = 0;m2 < c; ++m2) {
          const b = w + m2 * s3, T2 = (f2 * o + p2) * c + m2, S2 = Math.floor(b / 8), D2 = b % 8;
          if (D2 + s3 <= 8)
            h[T2] = a.getUint8(S2) >> 8 - s3 - D2 & d3;
          else if (D2 + s3 <= 16)
            h[T2] = a.getUint16(S2) >> 16 - s3 - D2 & d3;
          else if (D2 + s3 <= 24) {
            const M2 = a.getUint16(S2) << 8 | a.getUint8(S2 + 2);
            h[T2] = M2 >> 24 - s3 - D2 & d3;
          } else
            h[T2] = a.getUint32(S2) >> 32 - s3 - D2 & d3;
        }
      }
    }
  }
  return h.buffer;
}

class dr2 {
  constructor(e2, t2, r, s3, o, n) {
    this.fileDirectory = e2, this.geoKeys = t2, this.dataView = r, this.littleEndian = s3, this.tiles = o ? {} : null, this.isTiled = !e2.StripOffsets;
    const a = e2.PlanarConfiguration;
    if (this.planarConfiguration = typeof a > "u" ? 1 : a, this.planarConfiguration !== 1 && this.planarConfiguration !== 2)
      throw new Error("Invalid planar configuration.");
    this.source = n;
  }
  getFileDirectory() {
    return this.fileDirectory;
  }
  getGeoKeys() {
    return this.geoKeys;
  }
  getWidth() {
    return this.fileDirectory.ImageWidth;
  }
  getHeight() {
    return this.fileDirectory.ImageLength;
  }
  getSamplesPerPixel() {
    return typeof this.fileDirectory.SamplesPerPixel < "u" ? this.fileDirectory.SamplesPerPixel : 1;
  }
  getTileWidth() {
    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();
  }
  getTileHeight() {
    return this.isTiled ? this.fileDirectory.TileLength : typeof this.fileDirectory.RowsPerStrip < "u" ? Math.min(this.fileDirectory.RowsPerStrip, this.getHeight()) : this.getHeight();
  }
  getBlockWidth() {
    return this.getTileWidth();
  }
  getBlockHeight(e2) {
    return this.isTiled || (e2 + 1) * this.getTileHeight() <= this.getHeight() ? this.getTileHeight() : this.getHeight() - e2 * this.getTileHeight();
  }
  getBytesPerPixel() {
    let e2 = 0;
    for (let t2 = 0;t2 < this.fileDirectory.BitsPerSample.length; ++t2)
      e2 += this.getSampleByteSize(t2);
    return e2;
  }
  getSampleByteSize(e2) {
    if (e2 >= this.fileDirectory.BitsPerSample.length)
      throw new RangeError(`Sample index ${e2} is out of range.`);
    return Math.ceil(this.fileDirectory.BitsPerSample[e2] / 8);
  }
  getReaderForSample(e2) {
    const t2 = this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[e2] : 1, r = this.fileDirectory.BitsPerSample[e2];
    switch (t2) {
      case 1:
        if (r <= 8)
          return DataView.prototype.getUint8;
        if (r <= 16)
          return DataView.prototype.getUint16;
        if (r <= 32)
          return DataView.prototype.getUint32;
        break;
      case 2:
        if (r <= 8)
          return DataView.prototype.getInt8;
        if (r <= 16)
          return DataView.prototype.getInt16;
        if (r <= 32)
          return DataView.prototype.getInt32;
        break;
      case 3:
        switch (r) {
          case 16:
            return function(s3, o) {
              return $e2(this, s3, o);
            };
          case 32:
            return DataView.prototype.getFloat32;
          case 64:
            return DataView.prototype.getFloat64;
        }
        break;
    }
    throw Error("Unsupported data format/bitsPerSample");
  }
  getSampleFormat(e2 = 0) {
    return this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[e2] : 1;
  }
  getBitsPerSample(e2 = 0) {
    return this.fileDirectory.BitsPerSample[e2];
  }
  getArrayForSample(e2, t2) {
    const r = this.getSampleFormat(e2), s3 = this.getBitsPerSample(e2);
    return ue2(r, s3, t2);
  }
  async getTileOrStrip(e2, t2, r, s3, o) {
    const n = Math.ceil(this.getWidth() / this.getTileWidth()), a = Math.ceil(this.getHeight() / this.getTileHeight());
    let l3;
    const { tiles: c } = this;
    this.planarConfiguration === 1 ? l3 = t2 * n + e2 : this.planarConfiguration === 2 && (l3 = r * n * a + t2 * n + e2);
    let h, d3;
    this.isTiled ? (h = this.fileDirectory.TileOffsets[l3], d3 = this.fileDirectory.TileByteCounts[l3]) : (h = this.fileDirectory.StripOffsets[l3], d3 = this.fileDirectory.StripByteCounts[l3]);
    const u = (await this.source.fetch([{ offset: h, length: d3 }], o))[0];
    let g2;
    return c === null || !c[l3] ? (g2 = (async () => {
      let f2 = await s3.decode(this.fileDirectory, u);
      const y = this.getSampleFormat(), p2 = this.getBitsPerSample();
      return fr2(y, p2) && (f2 = ur2(f2, y, this.planarConfiguration, this.getSamplesPerPixel(), p2, this.getTileWidth(), this.getBlockHeight(t2))), f2;
    })(), c !== null && (c[l3] = g2)) : g2 = c[l3], { x: e2, y: t2, sample: r, data: await g2 };
  }
  async _readRaster(e2, t2, r, s3, o, n, a, l3, c) {
    const h = this.getTileWidth(), d3 = this.getTileHeight(), u = this.getWidth(), g2 = this.getHeight(), f2 = Math.max(Math.floor(e2[0] / h), 0), y = Math.min(Math.ceil(e2[2] / h), Math.ceil(u / h)), p2 = Math.max(Math.floor(e2[1] / d3), 0), w = Math.min(Math.ceil(e2[3] / d3), Math.ceil(g2 / d3)), m2 = e2[2] - e2[0];
    let b = this.getBytesPerPixel();
    const T2 = [], S2 = [];
    for (let I2 = 0;I2 < t2.length; ++I2)
      this.planarConfiguration === 1 ? T2.push(hr2(this.fileDirectory.BitsPerSample, 0, t2[I2]) / 8) : T2.push(0), S2.push(this.getReaderForSample(t2[I2]));
    const D2 = [], { littleEndian: M2 } = this;
    for (let I2 = p2;I2 < w; ++I2)
      for (let C2 = f2;C2 < y; ++C2) {
        let O3;
        this.planarConfiguration === 1 && (O3 = this.getTileOrStrip(C2, I2, 0, o, c));
        for (let P2 = 0;P2 < t2.length; ++P2) {
          const F2 = P2, G2 = t2[P2];
          this.planarConfiguration === 2 && (b = this.getSampleByteSize(G2), O3 = this.getTileOrStrip(C2, I2, G2, o, c));
          const L2 = O3.then((B3) => {
            const N3 = B3.data, te2 = new DataView(N3), X2 = this.getBlockHeight(B3.y), $3 = B3.y * d3, re2 = B3.x * h, ot2 = $3 + X2, at2 = (B3.x + 1) * h, lt2 = S2[F2], ct2 = Math.min(X2, X2 - (ot2 - e2[3]), g2 - $3), ht2 = Math.min(h, h - (at2 - e2[2]), u - re2);
            for (let W3 = Math.max(0, e2[1] - $3);W3 < ct2; ++W3)
              for (let Z3 = Math.max(0, e2[0] - re2);Z3 < ht2; ++Z3) {
                const ft2 = (W3 * h + Z3) * b, Re2 = lt2.call(te2, ft2 + T2[F2], M2);
                let se2;
                s3 ? (se2 = (W3 + $3 - e2[1]) * m2 * t2.length + (Z3 + re2 - e2[0]) * t2.length + F2, r[se2] = Re2) : (se2 = (W3 + $3 - e2[1]) * m2 + Z3 + re2 - e2[0], r[F2][se2] = Re2);
              }
          });
          D2.push(L2);
        }
      }
    if (await Promise.all(D2), n && e2[2] - e2[0] !== n || a && e2[3] - e2[1] !== a) {
      let I2;
      return s3 ? I2 = cr2(r, e2[2] - e2[0], e2[3] - e2[1], n, a, t2.length, l3) : I2 = or2(r, e2[2] - e2[0], e2[3] - e2[1], n, a, l3), I2.width = n, I2.height = a, I2;
    }
    return r.width = n || e2[2] - e2[0], r.height = a || e2[3] - e2[1], r;
  }
  async readRasters({
    window: e2,
    samples: t2 = [],
    interleave: r,
    pool: s3 = null,
    width: o,
    height: n,
    resampleMethod: a,
    fillValue: l3,
    signal: c
  } = {}) {
    const h = e2 || [0, 0, this.getWidth(), this.getHeight()];
    if (h[0] > h[2] || h[1] > h[3])
      throw new Error("Invalid subsets");
    const d3 = h[2] - h[0], u = h[3] - h[1], g2 = d3 * u, f2 = this.getSamplesPerPixel();
    if (!t2 || !t2.length)
      for (let m2 = 0;m2 < f2; ++m2)
        t2.push(m2);
    else
      for (let m2 = 0;m2 < t2.length; ++m2)
        if (t2[m2] >= f2)
          return Promise.reject(new RangeError(`Invalid sample index '${t2[m2]}'.`));
    let y;
    if (r) {
      const m2 = this.fileDirectory.SampleFormat ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1, b = Math.max.apply(null, this.fileDirectory.BitsPerSample);
      y = ue2(m2, b, g2 * t2.length), l3 && y.fill(l3);
    } else {
      y = [];
      for (let m2 = 0;m2 < t2.length; ++m2) {
        const b = this.getArrayForSample(t2[m2], g2);
        Array.isArray(l3) && m2 < l3.length ? b.fill(l3[m2]) : l3 && !Array.isArray(l3) && b.fill(l3), y.push(b);
      }
    }
    const p2 = s3 || await it2(this.fileDirectory);
    return await this._readRaster(h, t2, y, r, p2, o, n, a, c);
  }
  async readRGB({
    window: e2,
    interleave: t2 = true,
    pool: r = null,
    width: s3,
    height: o,
    resampleMethod: n,
    enableAlpha: a = false,
    signal: l3
  } = {}) {
    const c = e2 || [0, 0, this.getWidth(), this.getHeight()];
    if (c[0] > c[2] || c[1] > c[3])
      throw new Error("Invalid subsets");
    const h = this.fileDirectory.PhotometricInterpretation;
    if (h === A2.RGB) {
      let w = [0, 1, 2];
      if (this.fileDirectory.ExtraSamples !== Yt2.Unspecified && a) {
        w = [];
        for (let m2 = 0;m2 < this.fileDirectory.BitsPerSample.length; m2 += 1)
          w.push(m2);
      }
      return this.readRasters({
        window: e2,
        interleave: t2,
        samples: w,
        pool: r,
        width: s3,
        height: o,
        resampleMethod: n,
        signal: l3
      });
    }
    let d3;
    switch (h) {
      case A2.WhiteIsZero:
      case A2.BlackIsZero:
      case A2.Palette:
        d3 = [0];
        break;
      case A2.CMYK:
        d3 = [0, 1, 2, 3];
        break;
      case A2.YCbCr:
      case A2.CIELab:
        d3 = [0, 1, 2];
        break;
      default:
        throw new Error("Invalid or unsupported photometric interpretation.");
    }
    const u = {
      window: c,
      interleave: true,
      samples: d3,
      pool: r,
      width: s3,
      height: o,
      resampleMethod: n,
      signal: l3
    }, { fileDirectory: g2 } = this, f2 = await this.readRasters(u), y = 2 ** this.fileDirectory.BitsPerSample[0];
    let p2;
    switch (h) {
      case A2.WhiteIsZero:
        p2 = $t2(f2, y);
        break;
      case A2.BlackIsZero:
        p2 = Wt2(f2, y);
        break;
      case A2.Palette:
        p2 = Zt2(f2, g2.ColorMap);
        break;
      case A2.CMYK:
        p2 = Jt2(f2);
        break;
      case A2.YCbCr:
        p2 = Qt2(f2);
        break;
      case A2.CIELab:
        p2 = sr2(f2);
        break;
      default:
        throw new Error("Unsupported photometric interpretation.");
    }
    if (!t2) {
      const w = new Uint8Array(p2.length / 3), m2 = new Uint8Array(p2.length / 3), b = new Uint8Array(p2.length / 3);
      for (let T2 = 0, S2 = 0;T2 < p2.length; T2 += 3, ++S2)
        w[S2] = p2[T2], m2[S2] = p2[T2 + 1], b[S2] = p2[T2 + 2];
      p2 = [w, m2, b];
    }
    return p2.width = f2.width, p2.height = f2.height, p2;
  }
  getTiePoints() {
    if (!this.fileDirectory.ModelTiepoint)
      return [];
    const e2 = [];
    for (let t2 = 0;t2 < this.fileDirectory.ModelTiepoint.length; t2 += 6)
      e2.push({
        i: this.fileDirectory.ModelTiepoint[t2],
        j: this.fileDirectory.ModelTiepoint[t2 + 1],
        k: this.fileDirectory.ModelTiepoint[t2 + 2],
        x: this.fileDirectory.ModelTiepoint[t2 + 3],
        y: this.fileDirectory.ModelTiepoint[t2 + 4],
        z: this.fileDirectory.ModelTiepoint[t2 + 5]
      });
    return e2;
  }
  getGDALMetadata(e2 = null) {
    const t2 = {};
    if (!this.fileDirectory.GDAL_METADATA)
      return null;
    const r = this.fileDirectory.GDAL_METADATA;
    let s3 = qt2(r, "Item");
    e2 === null ? s3 = s3.filter((o) => ae2(o, "sample") === undefined) : s3 = s3.filter((o) => Number(ae2(o, "sample")) === e2);
    for (let o = 0;o < s3.length; ++o) {
      const n = s3[o];
      t2[ae2(n, "name")] = n.inner;
    }
    return t2;
  }
  getGDALNoData() {
    if (!this.fileDirectory.GDAL_NODATA)
      return null;
    const e2 = this.fileDirectory.GDAL_NODATA;
    return Number(e2.substring(0, e2.length - 1));
  }
  getOrigin() {
    const e2 = this.fileDirectory.ModelTiepoint, t2 = this.fileDirectory.ModelTransformation;
    if (e2 && e2.length === 6)
      return [
        e2[3],
        e2[4],
        e2[5]
      ];
    if (t2)
      return [
        t2[3],
        t2[7],
        t2[11]
      ];
    throw new Error("The image does not have an affine transformation.");
  }
  getResolution(e2 = null) {
    const t2 = this.fileDirectory.ModelPixelScale, r = this.fileDirectory.ModelTransformation;
    if (t2)
      return [
        t2[0],
        -t2[1],
        t2[2]
      ];
    if (r)
      return r[1] === 0 && r[4] === 0 ? [
        r[0],
        -r[5],
        r[10]
      ] : [
        Math.sqrt(r[0] * r[0] + r[4] * r[4]),
        -Math.sqrt(r[1] * r[1] + r[5] * r[5]),
        r[10]
      ];
    if (e2) {
      const [s3, o, n] = e2.getResolution();
      return [
        s3 * e2.getWidth() / this.getWidth(),
        o * e2.getHeight() / this.getHeight(),
        n * e2.getWidth() / this.getWidth()
      ];
    }
    throw new Error("The image does not have an affine transformation.");
  }
  pixelIsArea() {
    return this.geoKeys.GTRasterTypeGeoKey === 1;
  }
  getBoundingBox(e2 = false) {
    const t2 = this.getHeight(), r = this.getWidth();
    if (this.fileDirectory.ModelTransformation && !e2) {
      const [s3, o, n, a, l3, c, h, d3] = this.fileDirectory.ModelTransformation, g2 = [
        [0, 0],
        [0, t2],
        [r, 0],
        [r, t2]
      ].map(([p2, w]) => [
        a + s3 * p2 + o * w,
        d3 + l3 * p2 + c * w
      ]), f2 = g2.map((p2) => p2[0]), y = g2.map((p2) => p2[1]);
      return [
        Math.min(...f2),
        Math.min(...y),
        Math.max(...f2),
        Math.max(...y)
      ];
    } else {
      const s3 = this.getOrigin(), o = this.getResolution(), n = s3[0], a = s3[1], l3 = n + o[0] * r, c = a + o[1] * t2;
      return [
        Math.min(n, l3),
        Math.min(a, c),
        Math.max(n, l3),
        Math.max(a, c)
      ];
    }
  }
}

class gr {
  constructor(e2) {
    this._dataView = new DataView(e2);
  }
  get buffer() {
    return this._dataView.buffer;
  }
  getUint64(e2, t2) {
    const r = this.getUint32(e2, t2), s3 = this.getUint32(e2 + 4, t2);
    let o;
    if (t2) {
      if (o = r + 2 ** 32 * s3, !Number.isSafeInteger(o))
        throw new Error(`${o} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
      return o;
    }
    if (o = 2 ** 32 * r + s3, !Number.isSafeInteger(o))
      throw new Error(`${o} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
    return o;
  }
  getInt64(e2, t2) {
    let r = 0;
    const s3 = (this._dataView.getUint8(e2 + (t2 ? 7 : 0)) & 128) > 0;
    let o = true;
    for (let n = 0;n < 8; n++) {
      let a = this._dataView.getUint8(e2 + (t2 ? n : 7 - n));
      s3 && (o ? a !== 0 && (a = ~(a - 1) & 255, o = false) : a = ~a & 255), r += a * 256 ** n;
    }
    return s3 && (r = -r), r;
  }
  getUint8(e2, t2) {
    return this._dataView.getUint8(e2, t2);
  }
  getInt8(e2, t2) {
    return this._dataView.getInt8(e2, t2);
  }
  getUint16(e2, t2) {
    return this._dataView.getUint16(e2, t2);
  }
  getInt16(e2, t2) {
    return this._dataView.getInt16(e2, t2);
  }
  getUint32(e2, t2) {
    return this._dataView.getUint32(e2, t2);
  }
  getInt32(e2, t2) {
    return this._dataView.getInt32(e2, t2);
  }
  getFloat16(e2, t2) {
    return $e2(this._dataView, e2, t2);
  }
  getFloat32(e2, t2) {
    return this._dataView.getFloat32(e2, t2);
  }
  getFloat64(e2, t2) {
    return this._dataView.getFloat64(e2, t2);
  }
}

class yr {
  constructor(e2, t2, r, s3) {
    this._dataView = new DataView(e2), this._sliceOffset = t2, this._littleEndian = r, this._bigTiff = s3;
  }
  get sliceOffset() {
    return this._sliceOffset;
  }
  get sliceTop() {
    return this._sliceOffset + this.buffer.byteLength;
  }
  get littleEndian() {
    return this._littleEndian;
  }
  get bigTiff() {
    return this._bigTiff;
  }
  get buffer() {
    return this._dataView.buffer;
  }
  covers(e2, t2) {
    return this.sliceOffset <= e2 && this.sliceTop >= e2 + t2;
  }
  readUint8(e2) {
    return this._dataView.getUint8(e2 - this._sliceOffset, this._littleEndian);
  }
  readInt8(e2) {
    return this._dataView.getInt8(e2 - this._sliceOffset, this._littleEndian);
  }
  readUint16(e2) {
    return this._dataView.getUint16(e2 - this._sliceOffset, this._littleEndian);
  }
  readInt16(e2) {
    return this._dataView.getInt16(e2 - this._sliceOffset, this._littleEndian);
  }
  readUint32(e2) {
    return this._dataView.getUint32(e2 - this._sliceOffset, this._littleEndian);
  }
  readInt32(e2) {
    return this._dataView.getInt32(e2 - this._sliceOffset, this._littleEndian);
  }
  readFloat32(e2) {
    return this._dataView.getFloat32(e2 - this._sliceOffset, this._littleEndian);
  }
  readFloat64(e2) {
    return this._dataView.getFloat64(e2 - this._sliceOffset, this._littleEndian);
  }
  readUint64(e2) {
    const t2 = this.readUint32(e2), r = this.readUint32(e2 + 4);
    let s3;
    if (this._littleEndian) {
      if (s3 = t2 + 2 ** 32 * r, !Number.isSafeInteger(s3))
        throw new Error(`${s3} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
      return s3;
    }
    if (s3 = 2 ** 32 * t2 + r, !Number.isSafeInteger(s3))
      throw new Error(`${s3} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
    return s3;
  }
  readInt64(e2) {
    let t2 = 0;
    const r = (this._dataView.getUint8(e2 + (this._littleEndian ? 7 : 0)) & 128) > 0;
    let s3 = true;
    for (let o = 0;o < 8; o++) {
      let n = this._dataView.getUint8(e2 + (this._littleEndian ? o : 7 - o));
      r && (s3 ? n !== 0 && (n = ~(n - 1) & 255, s3 = false) : n = ~n & 255), t2 += n * 256 ** o;
    }
    return r && (t2 = -t2), t2;
  }
  readOffset(e2) {
    return this._bigTiff ? this.readUint64(e2) : this.readUint32(e2);
  }
}

class mr {
  constructor(e2 = pr, t2) {
    this.workers = null, this._awaitingDecoder = null, this.size = e2, this.messageId = 0, e2 && (this._awaitingDecoder = t2 ? Promise.resolve(t2) : new Promise((r) => {
      Promise.resolve().then(() => (init_decoder_DJlmx386(), exports_decoder_DJlmx386)).then((s3) => {
        r(s3.create);
      });
    }), this._awaitingDecoder.then((r) => {
      this._awaitingDecoder = null, this.workers = [];
      for (let s3 = 0;s3 < e2; s3++)
        this.workers.push({ worker: r(), idle: true });
    }));
  }
  async decode(e2, t2) {
    return this._awaitingDecoder && await this._awaitingDecoder, this.size === 0 ? it2(e2).then((r) => r.decode(e2, t2)) : new Promise((r) => {
      const s3 = this.workers.find((a) => a.idle) || this.workers[Math.floor(Math.random() * this.size)];
      s3.idle = false;
      const o = this.messageId++, n = (a) => {
        a.data.id === o && (s3.idle = true, r(a.data.decoded), s3.worker.removeEventListener("message", n));
      };
      s3.worker.addEventListener("message", n), s3.worker.postMessage({ fileDirectory: e2, buffer: t2, id: o }, [t2]);
    });
  }
  destroy() {
    this.workers && (this.workers.forEach((e2) => {
      e2.worker.terminate();
    }), this.workers = null);
  }
}
function nt2(i) {
  if (typeof Object.fromEntries < "u")
    return Object.fromEntries(i);
  const e2 = {};
  for (const [t2, r] of i)
    e2[t2.toLowerCase()] = r;
  return e2;
}
function wr2(i) {
  const e2 = i.split(`\r
`).map((t2) => {
    const r = t2.split(":").map((s3) => s3.trim());
    return r[0] = r[0].toLowerCase(), r;
  });
  return nt2(e2);
}
function xr(i) {
  const [e2, ...t2] = i.split(";").map((s3) => s3.trim()), r = t2.map((s3) => s3.split("="));
  return { type: e2, params: nt2(r) };
}
function de2(i) {
  let e2, t2, r;
  return i && ([, e2, t2, r] = i.match(/bytes (\d+)-(\d+)\/(\d+)/), e2 = parseInt(e2, 10), t2 = parseInt(t2, 10), r = parseInt(r, 10)), { start: e2, end: t2, total: r };
}
function br2(i, e2) {
  let t2 = null;
  const r = new TextDecoder("ascii"), s3 = [], o = `--${e2}`, n = `${o}--`;
  for (let a = 0;a < 10; ++a)
    r.decode(new Uint8Array(i, a, o.length)) === o && (t2 = a);
  if (t2 === null)
    throw new Error("Could not find initial boundary");
  for (;t2 < i.byteLength; ) {
    const a = r.decode(new Uint8Array(i, t2, Math.min(o.length + 1024, i.byteLength - t2)));
    if (a.length === 0 || a.startsWith(n))
      break;
    if (!a.startsWith(o))
      throw new Error("Part does not start with boundary");
    const l3 = a.substr(o.length + 2);
    if (l3.length === 0)
      break;
    const c = l3.indexOf(Ge2), h = wr2(l3.substr(0, c)), { start: d3, end: u, total: g2 } = de2(h["content-range"]), f2 = t2 + o.length + c + Ge2.length, y = parseInt(u, 10) + 1 - parseInt(d3, 10);
    s3.push({
      headers: h,
      data: i.slice(f2, f2 + y),
      offset: d3,
      length: y,
      fileSize: g2
    }), t2 = f2 + y + 4;
  }
  return s3;
}

class Ce2 {
  async fetch(e2, t2 = undefined) {
    return Promise.all(e2.map((r) => this.fetchSlice(r, t2)));
  }
  async fetchSlice(e2) {
    throw new Error(`fetching of slice ${e2} not possible, not implemented`);
  }
  get fileSize() {
    return null;
  }
  async close() {}
}
async function Tr(i) {
  return new Promise((e2) => setTimeout(e2, i));
}
function Sr(i, e2) {
  const t2 = Array.isArray(i) ? i : Array.from(i), r = Array.isArray(e2) ? e2 : Array.from(e2);
  return t2.map((s3, o) => [s3, r[o]]);
}

class Cr {
  constructor(e2, t2, r = null) {
    this.offset = e2, this.length = t2, this.data = r;
  }
  get top() {
    return this.offset + this.length;
  }
}

class Oe2 {
  constructor(e2, t2, r) {
    this.offset = e2, this.length = t2, this.blockIds = r;
  }
}

class Fe2 {
  get ok() {
    return this.status >= 200 && this.status <= 299;
  }
  get status() {
    throw new Error("not implemented");
  }
  getHeader(e2) {
    throw new Error("not implemented");
  }
  async getData() {
    throw new Error("not implemented");
  }
}

class Ee2 {
  constructor(e2) {
    this.url = e2;
  }
  async request({ headers: e2, signal: t2 } = {}) {
    throw new Error("request is not implemented");
  }
}
function ke2(i, { blockSize: e2, cacheSize: t2 }) {
  return e2 === null ? i : new Fr(i, { blockSize: e2, cacheSize: t2 });
}
function Gr(i, { headers: e2 = {}, credentials: t2, maxRanges: r = 0, allowFullFile: s3 = false, ...o } = {}) {
  const n = new Pr(i, t2), a = new Pe2(n, e2, r, s3);
  return ke2(a, o);
}
function Or(i, { headers: e2 = {}, maxRanges: t2 = 0, allowFullFile: r = false, ...s3 } = {}) {
  const o = new Rr(i), n = new Pe2(o, e2, t2, r);
  return ke2(n, s3);
}
function vr(i, { headers: e2 = {}, maxRanges: t2 = 0, allowFullFile: r = false, ...s3 } = {}) {
  const o = new Br(i), n = new Pe2(o, e2, t2, r);
  return ke2(n, s3);
}
function _r2(i, { forceXHR: e2 = false, ...t2 } = {}) {
  return typeof fetch == "function" && !e2 ? Gr(i, t2) : typeof XMLHttpRequest < "u" ? Or(i, t2) : vr(i, t2);
}
function Lr(i) {
  return new Ur(i);
}
function ge2(i) {
  switch (i) {
    case x3.BYTE:
    case x3.ASCII:
    case x3.SBYTE:
    case x3.UNDEFINED:
      return 1;
    case x3.SHORT:
    case x3.SSHORT:
      return 2;
    case x3.LONG:
    case x3.SLONG:
    case x3.FLOAT:
    case x3.IFD:
      return 4;
    case x3.RATIONAL:
    case x3.SRATIONAL:
    case x3.DOUBLE:
    case x3.LONG8:
    case x3.SLONG8:
    case x3.IFD8:
      return 8;
    default:
      throw new RangeError(`Invalid field type: ${i}`);
  }
}
function Nr(i) {
  const e2 = i.GeoKeyDirectory;
  if (!e2)
    return null;
  const t2 = {};
  for (let r = 4;r <= e2[3] * 4; r += 4) {
    const s3 = Xt2[e2[r]], o = e2[r + 1] ? J[e2[r + 1]] : null, n = e2[r + 2], a = e2[r + 3];
    let l3 = null;
    if (!o)
      l3 = a;
    else {
      if (l3 = i[o], typeof l3 > "u" || l3 === null)
        throw new Error(`Could not get value of geoKey '${s3}'.`);
      typeof l3 == "string" ? l3 = l3.substring(a, a + n - 1) : l3.subarray && (l3 = l3.subarray(a, a + n), n === 1 && (l3 = l3[0]));
    }
    t2[s3] = l3;
  }
  return t2;
}
function K3(i, e2, t2, r) {
  let s3 = null, o = null;
  const n = ge2(e2);
  switch (e2) {
    case x3.BYTE:
    case x3.ASCII:
    case x3.UNDEFINED:
      s3 = new Uint8Array(t2), o = i.readUint8;
      break;
    case x3.SBYTE:
      s3 = new Int8Array(t2), o = i.readInt8;
      break;
    case x3.SHORT:
      s3 = new Uint16Array(t2), o = i.readUint16;
      break;
    case x3.SSHORT:
      s3 = new Int16Array(t2), o = i.readInt16;
      break;
    case x3.LONG:
    case x3.IFD:
      s3 = new Uint32Array(t2), o = i.readUint32;
      break;
    case x3.SLONG:
      s3 = new Int32Array(t2), o = i.readInt32;
      break;
    case x3.LONG8:
    case x3.IFD8:
      s3 = new Array(t2), o = i.readUint64;
      break;
    case x3.SLONG8:
      s3 = new Array(t2), o = i.readInt64;
      break;
    case x3.RATIONAL:
      s3 = new Uint32Array(t2 * 2), o = i.readUint32;
      break;
    case x3.SRATIONAL:
      s3 = new Int32Array(t2 * 2), o = i.readInt32;
      break;
    case x3.FLOAT:
      s3 = new Float32Array(t2), o = i.readFloat32;
      break;
    case x3.DOUBLE:
      s3 = new Float64Array(t2), o = i.readFloat64;
      break;
    default:
      throw new RangeError(`Invalid field type: ${e2}`);
  }
  if (e2 === x3.RATIONAL || e2 === x3.SRATIONAL)
    for (let a = 0;a < t2; a += 2)
      s3[a] = o.call(i, r + a * n), s3[a + 1] = o.call(i, r + (a * n + 4));
  else
    for (let a = 0;a < t2; ++a)
      s3[a] = o.call(i, r + a * n);
  return e2 === x3.ASCII ? new TextDecoder("utf-8").decode(s3) : s3;
}

class jr {
  constructor(e2, t2, r) {
    this.fileDirectory = e2, this.geoKeyDirectory = t2, this.nextIFDByteOffset = r;
  }
}

class zr {
  async readRasters(e2 = {}) {
    const { window: t2, width: r, height: s3 } = e2;
    let { resX: o, resY: n, bbox: a } = e2;
    const l3 = await this.getImage();
    let c = l3;
    const h = await this.getImageCount(), d3 = l3.getBoundingBox();
    if (t2 && a)
      throw new Error('Both "bbox" and "window" passed.');
    if (r || s3) {
      if (t2) {
        const [f2, y] = l3.getOrigin(), [p2, w] = l3.getResolution();
        a = [
          f2 + t2[0] * p2,
          y + t2[1] * w,
          f2 + t2[2] * p2,
          y + t2[3] * w
        ];
      }
      const g2 = a || d3;
      if (r) {
        if (o)
          throw new Error("Both width and resX passed");
        o = (g2[2] - g2[0]) / r;
      }
      if (s3) {
        if (n)
          throw new Error("Both width and resY passed");
        n = (g2[3] - g2[1]) / s3;
      }
    }
    if (o || n) {
      const g2 = [];
      for (let f2 = 0;f2 < h; ++f2) {
        const y = await this.getImage(f2), { SubfileType: p2, NewSubfileType: w } = y.fileDirectory;
        (f2 === 0 || p2 === 2 || w & 1) && g2.push(y);
      }
      g2.sort((f2, y) => f2.getWidth() - y.getWidth());
      for (let f2 = 0;f2 < g2.length; ++f2) {
        const y = g2[f2], p2 = (d3[2] - d3[0]) / y.getWidth(), w = (d3[3] - d3[1]) / y.getHeight();
        if (c = y, o && o > p2 || n && n > w)
          break;
      }
    }
    let u = t2;
    if (a) {
      const [g2, f2] = l3.getOrigin(), [y, p2] = c.getResolution(l3);
      u = [
        Math.round((a[0] - g2) / y),
        Math.round((a[1] - f2) / p2),
        Math.round((a[2] - g2) / y),
        Math.round((a[3] - f2) / p2)
      ], u = [
        Math.min(u[0], u[2]),
        Math.min(u[1], u[3]),
        Math.max(u[0], u[2]),
        Math.max(u[1], u[3])
      ];
    }
    return c.readRasters({ ...e2, window: u });
  }
}
async function ve2(i, e2 = {}, t2) {
  return oe2.fromSource(_r2(i, e2), t2);
}
async function _e2(i, e2) {
  return oe2.fromSource(Lr(i), e2);
}

class fe3 {
  constructor() {
    this.promise = new Promise((e2, t2) => {
      this.reject = t2, this.resolve = e2;
    });
  }
}

class z {
  static RGBAfromYCbCr(e2) {
    const t2 = new Uint8ClampedArray(e2.length * 4 / 3);
    let r, s3;
    for (r = 0, s3 = 0;r < e2.length; r += 3, s3 += 4) {
      const o = e2[r], n = e2[r + 1], a = e2[r + 2];
      t2[s3] = o + 1.402 * (a - 128), t2[s3 + 1] = o - 0.34414 * (n - 128) - 0.71414 * (a - 128), t2[s3 + 2] = o + 1.772 * (n - 128), t2[s3 + 3] = 255;
    }
    return t2;
  }
  static RGBAfromRGB(e2) {
    const t2 = new Uint8ClampedArray(e2.length * 4 / 3);
    let r, s3;
    for (r = 0, s3 = 0;r < e2.length; r += 3, s3 += 4)
      t2[s3] = e2[r], t2[s3 + 1] = e2[r + 1], t2[s3 + 2] = e2[r + 2], t2[s3 + 3] = 255;
    return t2;
  }
  static RGBAfromWhiteIsZero(e2, t2) {
    const r = new Uint8ClampedArray(e2.length * 4);
    let s3;
    for (let o = 0, n = 0;o < e2.length; ++o, n += 4)
      s3 = 256 - e2[o] / t2 * 256, r[n] = s3, r[n + 1] = s3, r[n + 2] = s3, r[n + 3] = 255;
    return r;
  }
  static RGBAfromBlackIsZero(e2, t2) {
    const r = new Uint8ClampedArray(e2.length * 4);
    let s3;
    for (let o = 0, n = 0;o < e2.length; ++o, n += 4)
      s3 = e2[o] / t2 * 256, r[n] = s3, r[n + 1] = s3, r[n + 2] = s3, r[n + 3] = 255;
    return r;
  }
  static RGBAfromPalette(e2, t2) {
    const r = new Uint8ClampedArray(e2.length * 4), s3 = t2.length / 3, o = t2.length / 3 * 2;
    for (let n = 0, a = 0;n < e2.length; ++n, a += 4) {
      const l3 = e2[n];
      r[a] = t2[l3] / 65536 * 256, r[a + 1] = t2[l3 + s3] / 65536 * 256, r[a + 2] = t2[l3 + o] / 65536 * 256, r[a + 3] = 255;
    }
    return r;
  }
  static RGBAfromCMYK(e2) {
    const t2 = new Uint8ClampedArray(e2.length);
    for (let r = 0, s3 = 0;r < e2.length; r += 4, s3 += 4) {
      const o = e2[r], n = e2[r + 1], a = e2[r + 2], l3 = e2[r + 3];
      t2[s3] = 255 * ((255 - o) / 256) * ((255 - l3) / 256), t2[s3 + 1] = 255 * ((255 - n) / 256) * ((255 - l3) / 256), t2[s3 + 2] = 255 * ((255 - a) / 256) * ((255 - l3) / 256), t2[s3 + 3] = 255;
    }
    return t2;
  }
  static RGBAfromCIELab(e2) {
    const o = new Uint8ClampedArray(e2.length * 4 / 3);
    for (let n = 0, a = 0;n < e2.length; n += 3, a += 4) {
      const l3 = e2[n + 0], c = e2[n + 1] << 24 >> 24, h = e2[n + 2] << 24 >> 24;
      let d3 = (l3 + 16) / 116, u = c / 500 + d3, g2 = d3 - h / 200, f2, y, p2;
      u = 0.95047 * (u * u * u > 0.008856 ? u * u * u : (u - 0.13793103448275862) / 7.787), d3 = 1 * (d3 * d3 * d3 > 0.008856 ? d3 * d3 * d3 : (d3 - 0.13793103448275862) / 7.787), g2 = 1.08883 * (g2 * g2 * g2 > 0.008856 ? g2 * g2 * g2 : (g2 - 0.13793103448275862) / 7.787), f2 = u * 3.2406 + d3 * -1.5372 + g2 * -0.4986, y = u * -0.9689 + d3 * 1.8758 + g2 * 0.0415, p2 = u * 0.0557 + d3 * -0.204 + g2 * 1.057, f2 = f2 > 0.0031308 ? 1.055 * f2 ** 0.4166666666666667 - 0.055 : 12.92 * f2, y = y > 0.0031308 ? 1.055 * y ** 0.4166666666666667 - 0.055 : 12.92 * y, p2 = p2 > 0.0031308 ? 1.055 * p2 ** 0.4166666666666667 - 0.055 : 12.92 * p2, o[a] = Math.max(0, Math.min(1, f2)) * 255, o[a + 1] = Math.max(0, Math.min(1, y)) * 255, o[a + 2] = Math.max(0, Math.min(1, p2)) * 255, o[a + 3] = 255;
    }
    return o;
  }
}
function Vr(i) {
  if (!i.version || i.version.major < 2 || i.version.major == 2 && i.version.minor < 3) {
    console.error("This version of OpenSeadragon is too old to support this monkey patch");
    return;
  }
  if (i.ImageJob)
    return;
  function e2(r) {
    i.extend(true, this, {
      timeout: i.DEFAULT_SETTINGS.timeout,
      jobId: null
    }, r), this.image = null;
  }
  e2.prototype = {
    errorMsg: null,
    start: function() {
      var r = this, s3 = this.abort;
      this.image = new Image, this.image.onload = function() {
        r.finish(true);
      }, this.image.onabort = this.image.onerror = function() {
        r.errorMsg = "Image load aborted", r.finish(false);
      }, this.jobId = window.setTimeout(function() {
        r.errorMsg = "Image load exceeded timeout (" + r.timeout + " ms)", r.finish(false);
      }, this.timeout), this.loadWithAjax ? (this.request = i.makeAjaxRequest({
        url: this.src,
        withCredentials: this.ajaxWithCredentials,
        headers: this.ajaxHeaders,
        responseType: "arraybuffer",
        postData: this.postData,
        success: function(o) {
          var n;
          try {
            n = new window.Blob([o.response]);
          } catch (h) {
            var a = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
            if (h.name === "TypeError" && a) {
              var l3 = new a;
              l3.append(o.response), n = l3.getBlob();
            }
          }
          n.size === 0 && (r.errorMsg = "Empty image response.", r.finish(false));
          var c = (window.URL || window.webkitURL).createObjectURL(n);
          r.image.src = c;
        },
        error: function(o) {
          r.errorMsg = "Image load aborted - XHR error: Ajax returned " + o.status, r.finish(false);
        }
      }), this.abort = function() {
        r.request.abort(), typeof s3 == "function" && s3();
      }) : (this.crossOriginPolicy !== false && (this.image.crossOrigin = this.crossOriginPolicy), this.src.fetch ? this.src.fetch().then((o) => this.image.src = o) : this.image.src = this.src);
    },
    finish: function(r) {
      this.image.onload = this.image.onerror = this.image.onabort = null, r || (this.image = null), this.jobId && window.clearTimeout(this.jobId), this.callback(this);
    }
  };
  function t2(r, s3, o) {
    var n;
    r.jobsInProgress--, (!r.jobLimit || r.jobsInProgress < r.jobLimit) && r.jobQueue.length > 0 && (n = r.jobQueue.shift(), n.start(), r.jobsInProgress++), o(s3.image, s3.errorMsg, s3.request);
  }
  i.ImageLoader.prototype.addJob = function(r) {
    var s3 = this, o = function(l3) {
      t2(s3, l3, r.callback);
    }, n = {
      src: r.src,
      loadWithAjax: r.loadWithAjax,
      ajaxHeaders: r.loadWithAjax ? r.ajaxHeaders : null,
      crossOriginPolicy: r.crossOriginPolicy,
      ajaxWithCredentials: r.ajaxWithCredentials,
      postData: r.postData,
      callback: o,
      abort: r.abort,
      timeout: this.timeout
    }, a = new e2(n);
    !this.jobLimit || this.jobsInProgress < this.jobLimit ? (a.start(), this.jobsInProgress++) : this.jobQueue.push(a);
  }, i.Tile.prototype._hasTransparencyChannel = function() {
    return false;
  };
}
var ut2, dt2 = (i, e2, t2) => (e2 in i) ? ut2(i, e2, { enumerable: true, configurable: true, writable: true, value: t2 }) : i[e2] = t2, k3 = (i, e2, t2) => dt2(i, typeof e2 != "symbol" ? e2 + "" : e2, t2), gt2, Yr, Xr, $r, Ue2, ye2, Wr, yt2, Zr, Jr, ee2, Qr, pt2, es, mt2, pe2, wt2, ts, rs, xt2, bt2, Le2, It2, Ne2, Tt2, Me2, je2, R2, St2, ze2, me2, At2, Q3, Ke2, Dt2, Ct2, Ft2, Et2, we2, Ve2, qe2, Pt2, He2, kt2, Mt2, Bt2, Ye2, Gt2, Ot2, v, _2, xe2, Y3, Xe2, be2, _t2, ae2, Ie, Te2, Se2, Ut2, Ae2, Lt2, De2, Nt2, jt2, le3, Be2, zt2, Kt2, Vt2, qt2, J, U2, Ht2, ce3, x3, A2, Yt2, ss, is, Xt2, er2 = 0.95047, tr2 = 1, rr2 = 1.08883, st2, pr, Ge2 = `\r
\r
`, Ir, q2, Ar, Dr, Fr, Er, Pr, kr, Rr, he2, Mr, Br, Pe2, Ur, ie3, oe2, Kr = (i) => {
  var t2, r, s3;
  const e2 = /* @__PURE__ */ new Map;
  for (const o of i) {
    const n = new DOMParser().parseFromString((t2 = o.fileDirectory) == null ? undefined : t2.ImageDescription, "text/xml"), a = (r = n == null ? undefined : n.querySelector("Name")) == null ? undefined : r.textContent, l3 = (s3 = n == null ? undefined : n.querySelector("Color")) == null ? undefined : s3.textContent;
    if (!a)
      continue;
    const c = l3 ? l3.split(",").map((h) => parseInt(h)) : [255, 255, 255];
    e2.has(a) || e2.set(a, {
      name: a,
      color: c,
      images: []
    }), e2.get(a).images.push(o);
  }
  return e2;
}, qr = (i) => {
  let e2 = 0;
  const r = class r2 extends i.TileSource {
    constructor(n, a = { logLatency: false }) {
      super();
      k3(this, "getTileWidth", (n2) => {
        if (this.levels.length > n2)
          return this.levels[n2].tileWidth;
      });
      k3(this, "getTileHeight", (n2) => {
        if (this.levels.length > n2)
          return this.levels[n2].tileHeight;
      });
      k3(this, "getLevelScale", (n2) => {
        let a2 = NaN;
        return this.levels.length > 0 && n2 >= this.minLevel && n2 <= this.maxLevel && (a2 = this.levels[n2].width / this.levels[this.maxLevel].width), a2;
      });
      k3(this, "getTileHashKey", (n2, a2, l4) => {
        var c;
        return `geotiffTileSource${this._tsCounter}_${((c = this == null ? undefined : this.channel) == null ? undefined : c.name) ?? ""}_${n2}_${a2}_${l4}`;
      });
      k3(this, "getTileUrl", (n2, a2, l4) => {
        let c = this.levels[n2], h = new String(`${n2}/${a2}_${l4}`);
        return h.fetch = /* @__PURE__ */ ((d3, u, g2, f2, y) => () => this.regionToDataUrl.call(d3, u, g2, f2, y))(this, c, a2, l4, h), h;
      });
      k3(this, "downloadTileStart", (n2) => {
        n2.src.fetch().then((a2) => {
          let l4 = new Image, c = "" + n2.src;
          l4.onload = function() {
            n2.finish(l4);
          }, l4.onerror = l4.onabort = function() {
            n2.finish(null, c, "Request aborted");
          }, l4.src = a2;
        });
      });
      k3(this, "downloadTileAbort", (n2) => {
        n2.src.abortController && n2.src.abortController.abort();
      });
      k3(this, "setupComplete", () => {
        this._ready = true, this.promises.ready.resolve(), this.raiseEvent("ready", { tileSource: this });
      });
      k3(this, "setupLevels", () => {
        if (this._ready)
          return;
        let n2 = this.GeoTIFFImages.sort((u, g2) => g2.getWidth() - u.getWidth()), a2 = this._tileSize, l4 = this._tileSize, c = n2[0].getWidth();
        this.width = c;
        let h = n2[0].getHeight();
        if (this.height = h, this.tileOverlap = 0, this.minLevel = 0, this.aspectRatio = this.width / this.height, this.dimensions = new i.Point(this.width, this.height), n2.reduce((u, g2) => (u.width !== -1 && (u.valid = u.valid && g2.getWidth() < u.width), u.width = g2.getWidth(), u), { valid: true, width: -1 }).valid)
          this.levels = n2.map((u) => {
            let g2 = u.getWidth(), f2 = u.getHeight();
            return {
              width: g2,
              height: f2,
              tileWidth: this.options.tileWidth || u.getTileWidth() || a2,
              tileHeight: this.options.tileHeight || u.getTileHeight() || l4,
              image: u,
              scaleFactor: 1
            };
          }), this.maxLevel = this.levels.length - 1;
        else {
          let u = Math.ceil(Math.log2(Math.max(c / a2, h / l4))), g2 = [...Array(u).keys()].filter((f2) => f2 % 2 == 0);
          this.levels = g2.map((f2) => {
            let y = Math.pow(2, f2);
            const p2 = n2.filter((m2) => {
              const b = Math.pow(2, f2 - 1);
              return b >= 0 ? m2.getWidth() * b < c && m2.getWidth() * y >= c : m2.getWidth() * y >= c;
            });
            if (p2.length === 0)
              return null;
            const w = p2[0];
            return {
              width: c / y,
              height: h / y,
              tileWidth: this.options.tileWidth || w.getTileWidth() || a2,
              tileHeight: this.options.tileHeight || w.getTileHeight() || l4,
              image: w,
              scaleFactor: y * w.getWidth() / c
            };
          }).filter((f2) => f2 !== null), this.maxLevel = this.levels.length - 1;
        }
        this.levels = this.levels.sort((u, g2) => u.width - g2.width), this._tileWidth = this.levels[0].tileWidth, this._tileHeight = this.levels[0].tileHeight, this.setupComplete();
      });
      k3(this, "regionToDataUrl", (n2, a2, l4, c) => {
        var m2, b, T2, S2, D2;
        let h = this.options.logLatency && Date.now(), u = (c.abortController = new AbortController).signal;
        const { tileWidth: g2, tileHeight: f2 } = n2, y = [a2 * g2, l4 * f2, (a2 + 1) * g2, (l4 + 1) * f2].map((M2) => M2 * n2.scaleFactor), p2 = n2.image;
        if ((b = (m2 = p2.fileDirectory) == null ? undefined : m2.Software) == null ? undefined : b.startsWith("PerkinElmer-QPI")) {
          const M2 = new DOMParser().parseFromString((T2 = p2.fileDirectory) == null ? undefined : T2.ImageDescription, "text/xml");
          (S2 = M2.querySelector("Name")) == null || S2.textContent;
          const I2 = (D2 = M2.querySelector("Color")) == null ? undefined : D2.textContent, C2 = I2 ? I2.split(",").map((O3) => parseInt(O3)) : [255, 255, 255];
          return n2.image.readRGB({
            interleave: true,
            window: y,
            pool: this._pool,
            width: n2.tileWidth,
            height: n2.tileHeight,
            signal: u
          }).then((O3) => {
            let P2 = document.createElement("canvas");
            P2.width = n2.tileWidth, P2.height = n2.tileHeight;
            let F2 = P2.getContext("2d"), G2 = new Uint8ClampedArray(4 * P2.width * P2.height), L2 = new Uint8ClampedArray(O3), B3, N3;
            for (B3 = 0, N3 = 0;B3 < L2.length; B3 += 3, N3 += 4)
              G2[N3] = L2[B3] * C2[0] / 255, G2[N3 + 1] = L2[B3 + 1] * C2[1] / 255, G2[N3 + 2] = L2[B3 + 2] * C2[2] / 255, G2[N3 + 3] = 255;
            const te2 = F2.createImageData(P2.width, P2.height);
            te2.data.set(G2), F2.putImageData(te2, 0, 0);
            let X2 = P2.toDataURL("image/jpeg", 0.8);
            return this.options.logLatency && (typeof this.options.logLatency == "function" ? this.options.logLatency : console.log)("Tile latency (ms):", Date.now() - h), X2;
          });
        } else
          return n2.image.getTileOrStrip(a2, l4, null, this._pool, u).then((M2) => {
            let I2 = new Uint8ClampedArray(M2.data), C2 = document.createElement("canvas");
            C2.width = n2.tileWidth, C2.height = n2.tileHeight;
            let O3 = C2.getContext("2d"), P2 = n2.image.fileDirectory.PhotometricInterpretation, F2;
            if (I2.length / (C2.width * C2.height) % 4 === 0)
              F2 = I2;
            else
              switch (P2) {
                case A2.WhiteIsZero:
                  F2 = z.RGBAfromWhiteIsZero(I2, 2 ** n2.image.fileDirectory.BitsPerSample[0]);
                  break;
                case A2.BlackIsZero:
                  F2 = z.RGBAfromBlackIsZero(I2, 2 ** n2.image.fileDirectory.BitsPerSample[0]);
                  break;
                case A2.RGB:
                  F2 = z.RGBAfromRGB(I2);
                  break;
                case A2.Palette:
                  F2 = z.RGBAfromPalette(I2, 2 ** n2.image.fileDirectory.colorMap);
                  break;
                case A2.CMYK:
                  F2 = z.RGBAfromCMYK(I2);
                  break;
                case A2.YCbCr:
                  F2 = z.RGBAfromYCbCr(I2);
                  break;
                case A2.CIELab:
                  F2 = z.RGBAfromCIELab(I2);
                  break;
              }
            const G2 = O3.createImageData(C2.width, C2.height);
            G2.data.set(F2), O3.putImageData(G2, 0, 0);
            let L2 = C2.toDataURL("image/jpeg", 0.8);
            return this.options.logLatency && (typeof this.options.logLatency == "function" ? this.options.logLatency : console.log)("Tile latency (ms):", Date.now() - h), L2;
          });
      });
      r2._osdReady || r2.applyOSDPatch(i);
      let l3 = this;
      this.input = n, this.options = a, this.channel = (n == null ? undefined : n.channel) ?? null, this._ready = false, this._pool = r2.sharedPool, this._tileSize = 256, this._tsCounter = e2, e2 += 1, n.GeoTIFF && n.GeoTIFFImages ? (this.promises = {
        GeoTIFF: Promise.resolve(n.GeoTIFF),
        GeoTIFFImages: Promise.resolve(n.GeoTIFFImages),
        ready: new fe3
      }, this.GeoTIFF = n.GeoTIFF, this.imageCount = n.GeoTIFFImages.length, this.GeoTIFFImages = n.GeoTIFFImages, this.setupLevels()) : (this.promises = {
        GeoTIFF: n instanceof File ? _e2(n) : ve2(n),
        GeoTIFFImages: new fe3,
        ready: new fe3
      }, this.promises.GeoTIFF.then((c) => (l3.GeoTIFF = c, c.getImageCount())).then((c) => {
        l3.imageCount = c;
        let h = [...Array(c).keys()].map((d3) => l3.GeoTIFF.getImage(d3));
        return Promise.all(h);
      }).then((c) => {
        l3.GeoTIFFImages = c, l3.promises.GeoTIFFImages.resolve(c), this.setupLevels();
      }).catch((c) => {
        throw console.error("Re-throwing error with GeoTIFF:", c), c;
      }));
    }
  };
  k3(r, "sharedPool", new mr), k3(r, "_osdReady", false), k3(r, "applyOSDPatch", (n) => {
    Vr(n), r._osdReady = true;
  }), k3(r, "getAllTileSources", async (n, a) => {
    const l3 = n instanceof File ? n.name.split(".").pop() : n.split(".").pop();
    let c = n instanceof File ? _e2(n) : ve2(n);
    return c.then((h) => (c = h, h.getImageCount())).then((h) => Promise.all([...Array(h).keys()].map(async (d3) => (await c).getImage(d3)))).then((h) => {
      h = h.filter((f2) => f2.fileDirectory.photometricInterpretation !== A2.TransparencyMask), h.sort((f2, y) => y.getWidth() - f2.getWidth());
      const d3 = 0.015;
      return h.reduce((f2, y) => {
        const p2 = y.getWidth() / y.getHeight();
        let w = "";
        y.fileDirectory.ImageDescription && (w = y.fileDirectory.ImageDescription.split(`
`)[1] ?? "");
        const m2 = f2.filter((b) => Math.abs(1 - b.aspectRatio / p2) < d3 && !(w != null && w.includes("macro") || w != null && w.includes("label")));
        if (m2.length === 0) {
          let b = {
            aspectRatio: p2,
            images: [y]
          };
          f2.push(b);
        } else
          m2[0].images.push(y);
        return f2;
      }, []).map((f2) => f2.images).map((f2, y) => {
        if (y !== 0)
          return new i.GeoTIFFTileSource({
            GeoTIFF: c,
            GeoTIFFImages: f2
          }, a);
        switch (l3) {
          case "qptiff":
            const p2 = Kr(f2);
            return Array.from(p2.values()).map((w, m2) => new i.GeoTIFFTileSource({
              GeoTIFF: c,
              GeoTIFFImages: w.images,
              channel: {
                name: w.name,
                color: w.color
              }
            }, a));
          default:
            return new i.GeoTIFFTileSource({
              GeoTIFF: c,
              GeoTIFFImages: f2
            }, a);
        }
      });
    });
  });
  let t2 = r;
  i.GeoTIFFTileSource = t2;
};
var init_main_8v7k2MJ1 = __esm(() => {
  ut2 = Object.defineProperty;
  ({
    apply: gt2,
    construct: Yr,
    defineProperty: Xr,
    get: $r,
    getOwnPropertyDescriptor: Ue2,
    getPrototypeOf: ye2,
    has: Wr,
    ownKeys: yt2,
    set: Zr,
    setPrototypeOf: Jr
  } = Reflect);
  ({
    iterator: ee2,
    species: Qr,
    toStringTag: pt2,
    for: es
  } = Symbol);
  mt2 = Object;
  ({
    create: pe2,
    defineProperty: wt2,
    freeze: ts,
    is: rs
  } = mt2);
  xt2 = Array;
  bt2 = xt2.prototype;
  Le2 = bt2[ee2];
  It2 = E2(Le2);
  Ne2 = ArrayBuffer;
  Tt2 = Ne2.prototype;
  H2(Tt2, "byteLength");
  Me2 = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : null;
  Me2 && H2(Me2.prototype, "byteLength");
  je2 = ye2(Uint8Array);
  je2.from;
  R2 = je2.prototype;
  R2[ee2];
  E2(R2.keys);
  E2(R2.values);
  E2(R2.entries);
  E2(R2.set);
  E2(R2.reverse);
  E2(R2.fill);
  E2(R2.copyWithin);
  E2(R2.sort);
  E2(R2.slice);
  E2(R2.subarray);
  H2(R2, "buffer");
  H2(R2, "byteOffset");
  H2(R2, "length");
  H2(R2, pt2);
  St2 = Uint8Array;
  ze2 = Uint16Array;
  me2 = Uint32Array;
  At2 = Float32Array;
  Q3 = ye2([][ee2]());
  Ke2 = E2(Q3.next);
  Dt2 = E2(function* () {}().next);
  Ct2 = ye2(Q3);
  Ft2 = DataView.prototype;
  Et2 = E2(Ft2.getUint16);
  we2 = WeakMap;
  Ve2 = we2.prototype;
  qe2 = E2(Ve2.get);
  Pt2 = E2(Ve2.set);
  He2 = new we2;
  kt2 = pe2(null, {
    next: {
      value: function() {
        const e2 = qe2(He2, this);
        return Ke2(e2);
      }
    },
    [ee2]: {
      value: function() {
        return this;
      }
    }
  });
  Mt2 = new we2;
  Bt2 = pe2(Ct2, {
    next: {
      value: function() {
        const e2 = qe2(Mt2, this);
        return Dt2(e2);
      },
      writable: true,
      configurable: true
    }
  });
  for (const i of yt2(Q3))
    i !== "next" && wt2(Bt2, i, Ue2(Q3, i));
  Ye2 = new Ne2(4);
  Gt2 = new At2(Ye2);
  Ot2 = new me2(Ye2);
  v = new ze2(512);
  _2 = new St2(512);
  for (let i = 0;i < 256; ++i) {
    const e2 = i - 127;
    e2 < -24 ? (v[i] = 0, v[i | 256] = 32768, _2[i] = 24, _2[i | 256] = 24) : e2 < -14 ? (v[i] = 1024 >> -e2 - 14, v[i | 256] = 1024 >> -e2 - 14 | 32768, _2[i] = -e2 - 1, _2[i | 256] = -e2 - 1) : e2 <= 15 ? (v[i] = e2 + 15 << 10, v[i | 256] = e2 + 15 << 10 | 32768, _2[i] = 13, _2[i | 256] = 13) : e2 < 128 ? (v[i] = 31744, v[i | 256] = 64512, _2[i] = 24, _2[i | 256] = 24) : (v[i] = 31744, v[i | 256] = 64512, _2[i] = 13, _2[i | 256] = 13);
  }
  xe2 = new me2(2048);
  for (let i = 1;i < 1024; ++i) {
    let e2 = i << 13, t2 = 0;
    for (;!(e2 & 8388608); )
      e2 <<= 1, t2 -= 8388608;
    e2 &= -8388609, t2 += 947912704, xe2[i] = e2 | t2;
  }
  for (let i = 1024;i < 2048; ++i)
    xe2[i] = 939524096 + (i - 1024 << 13);
  Y3 = new me2(64);
  for (let i = 1;i < 31; ++i)
    Y3[i] = i << 23;
  Y3[31] = 1199570944;
  Y3[32] = 2147483648;
  for (let i = 33;i < 63; ++i)
    Y3[i] = 2147483648 + (i - 32 << 23);
  Y3[63] = 3347054592;
  Xe2 = new ze2(64);
  for (let i = 1;i < 64; ++i)
    i !== 32 && (Xe2[i] = 1024);
  be2 = { exports: {} };
  be2.exports = Ze;
  be2.exports.default = Ze;
  _t2 = be2.exports;
  ae2 = /* @__PURE__ */ We2(_t2);
  Ie = { exports: {} };
  Te2 = { exports: {} };
  Se2 = { exports: {} };
  Se2.exports = Je2;
  Se2.exports.default = Je2;
  Ut2 = Se2.exports;
  Ae2 = { exports: {} };
  Ae2.exports = Qe2;
  Ae2.exports.default = Qe2;
  Lt2 = Ae2.exports;
  De2 = { exports: {} };
  De2.exports = et2;
  De2.exports.default = et2;
  Nt2 = De2.exports;
  jt2 = Ut2;
  le3 = Lt2;
  Be2 = Nt2;
  Te2.exports = tt2;
  Te2.exports.default = tt2;
  zt2 = Te2.exports;
  Kt2 = zt2;
  Ie.exports = rt2;
  Ie.exports.default = rt2;
  Vt2 = Ie.exports;
  qt2 = /* @__PURE__ */ We2(Vt2);
  J = {
    315: "Artist",
    258: "BitsPerSample",
    265: "CellLength",
    264: "CellWidth",
    320: "ColorMap",
    259: "Compression",
    33432: "Copyright",
    306: "DateTime",
    338: "ExtraSamples",
    266: "FillOrder",
    289: "FreeByteCounts",
    288: "FreeOffsets",
    291: "GrayResponseCurve",
    290: "GrayResponseUnit",
    316: "HostComputer",
    270: "ImageDescription",
    257: "ImageLength",
    256: "ImageWidth",
    271: "Make",
    281: "MaxSampleValue",
    280: "MinSampleValue",
    272: "Model",
    254: "NewSubfileType",
    274: "Orientation",
    262: "PhotometricInterpretation",
    284: "PlanarConfiguration",
    296: "ResolutionUnit",
    278: "RowsPerStrip",
    277: "SamplesPerPixel",
    305: "Software",
    279: "StripByteCounts",
    273: "StripOffsets",
    255: "SubfileType",
    263: "Threshholding",
    282: "XResolution",
    283: "YResolution",
    326: "BadFaxLines",
    327: "CleanFaxData",
    343: "ClipPath",
    328: "ConsecutiveBadFaxLines",
    433: "Decode",
    434: "DefaultImageColor",
    269: "DocumentName",
    336: "DotRange",
    321: "HalftoneHints",
    346: "Indexed",
    347: "JPEGTables",
    285: "PageName",
    297: "PageNumber",
    317: "Predictor",
    319: "PrimaryChromaticities",
    532: "ReferenceBlackWhite",
    339: "SampleFormat",
    340: "SMinSampleValue",
    341: "SMaxSampleValue",
    559: "StripRowCounts",
    330: "SubIFDs",
    292: "T4Options",
    293: "T6Options",
    325: "TileByteCounts",
    323: "TileLength",
    324: "TileOffsets",
    322: "TileWidth",
    301: "TransferFunction",
    318: "WhitePoint",
    344: "XClipPathUnits",
    286: "XPosition",
    529: "YCbCrCoefficients",
    531: "YCbCrPositioning",
    530: "YCbCrSubSampling",
    345: "YClipPathUnits",
    287: "YPosition",
    37378: "ApertureValue",
    40961: "ColorSpace",
    36868: "DateTimeDigitized",
    36867: "DateTimeOriginal",
    34665: "Exif IFD",
    36864: "ExifVersion",
    33434: "ExposureTime",
    41728: "FileSource",
    37385: "Flash",
    40960: "FlashpixVersion",
    33437: "FNumber",
    42016: "ImageUniqueID",
    37384: "LightSource",
    37500: "MakerNote",
    37377: "ShutterSpeedValue",
    37510: "UserComment",
    33723: "IPTC",
    34675: "ICC Profile",
    700: "XMP",
    42112: "GDAL_METADATA",
    42113: "GDAL_NODATA",
    34377: "Photoshop",
    33550: "ModelPixelScale",
    33922: "ModelTiepoint",
    34264: "ModelTransformation",
    34735: "GeoKeyDirectory",
    34736: "GeoDoubleParams",
    34737: "GeoAsciiParams",
    50674: "LercParameters"
  };
  U2 = {};
  for (const i in J)
    J.hasOwnProperty(i) && (U2[J[i]] = parseInt(i, 10));
  Ht2 = [
    U2.BitsPerSample,
    U2.ExtraSamples,
    U2.SampleFormat,
    U2.StripByteCounts,
    U2.StripOffsets,
    U2.StripRowCounts,
    U2.TileByteCounts,
    U2.TileOffsets,
    U2.SubIFDs
  ];
  ce3 = {
    1: "BYTE",
    2: "ASCII",
    3: "SHORT",
    4: "LONG",
    5: "RATIONAL",
    6: "SBYTE",
    7: "UNDEFINED",
    8: "SSHORT",
    9: "SLONG",
    10: "SRATIONAL",
    11: "FLOAT",
    12: "DOUBLE",
    13: "IFD",
    16: "LONG8",
    17: "SLONG8",
    18: "IFD8"
  };
  x3 = {};
  for (const i in ce3)
    ce3.hasOwnProperty(i) && (x3[ce3[i]] = parseInt(i, 10));
  A2 = {
    WhiteIsZero: 0,
    BlackIsZero: 1,
    RGB: 2,
    Palette: 3,
    TransparencyMask: 4,
    CMYK: 5,
    YCbCr: 6,
    CIELab: 8,
    ICCLab: 9
  };
  Yt2 = {
    Unspecified: 0,
    Assocalpha: 1,
    Unassalpha: 2
  };
  ss = {
    Version: 0,
    AddCompression: 1
  };
  is = {
    None: 0,
    Deflate: 1,
    Zstandard: 2
  };
  Xt2 = {
    1024: "GTModelTypeGeoKey",
    1025: "GTRasterTypeGeoKey",
    1026: "GTCitationGeoKey",
    2048: "GeographicTypeGeoKey",
    2049: "GeogCitationGeoKey",
    2050: "GeogGeodeticDatumGeoKey",
    2051: "GeogPrimeMeridianGeoKey",
    2052: "GeogLinearUnitsGeoKey",
    2053: "GeogLinearUnitSizeGeoKey",
    2054: "GeogAngularUnitsGeoKey",
    2055: "GeogAngularUnitSizeGeoKey",
    2056: "GeogEllipsoidGeoKey",
    2057: "GeogSemiMajorAxisGeoKey",
    2058: "GeogSemiMinorAxisGeoKey",
    2059: "GeogInvFlatteningGeoKey",
    2060: "GeogAzimuthUnitsGeoKey",
    2061: "GeogPrimeMeridianLongGeoKey",
    2062: "GeogTOWGS84GeoKey",
    3072: "ProjectedCSTypeGeoKey",
    3073: "PCSCitationGeoKey",
    3074: "ProjectionGeoKey",
    3075: "ProjCoordTransGeoKey",
    3076: "ProjLinearUnitsGeoKey",
    3077: "ProjLinearUnitSizeGeoKey",
    3078: "ProjStdParallel1GeoKey",
    3079: "ProjStdParallel2GeoKey",
    3080: "ProjNatOriginLongGeoKey",
    3081: "ProjNatOriginLatGeoKey",
    3082: "ProjFalseEastingGeoKey",
    3083: "ProjFalseNorthingGeoKey",
    3084: "ProjFalseOriginLongGeoKey",
    3085: "ProjFalseOriginLatGeoKey",
    3086: "ProjFalseOriginEastingGeoKey",
    3087: "ProjFalseOriginNorthingGeoKey",
    3088: "ProjCenterLongGeoKey",
    3089: "ProjCenterLatGeoKey",
    3090: "ProjCenterEastingGeoKey",
    3091: "ProjCenterNorthingGeoKey",
    3092: "ProjScaleAtNatOriginGeoKey",
    3093: "ProjScaleAtCenterGeoKey",
    3094: "ProjAzimuthAngleGeoKey",
    3095: "ProjStraightVertPoleLongGeoKey",
    3096: "ProjRectifiedGridAngleGeoKey",
    4096: "VerticalCSTypeGeoKey",
    4097: "VerticalCitationGeoKey",
    4098: "VerticalDatumGeoKey",
    4099: "VerticalUnitsGeoKey"
  };
  st2 = /* @__PURE__ */ new Map;
  j2([undefined, 1], () => Promise.resolve().then(() => (init_raw_CMGvRjfu(), exports_raw_CMGvRjfu)).then((i) => i.default));
  j2(5, () => Promise.resolve().then(() => (init_lzw_LAGDNbSC(), exports_lzw_LAGDNbSC)).then((i) => i.default));
  j2(6, () => {
    throw new Error("old style JPEG compression is not supported.");
  });
  j2(7, () => Promise.resolve().then(() => (init_jpeg_BAgeD1d3(), exports_jpeg_BAgeD1d3)).then((i) => i.default));
  j2([8, 32946], () => Promise.resolve().then(() => (init_deflate_BXt_9JA_(), exports_deflate_BXt_9JA_)).then((i) => i.default));
  j2(32773, () => Promise.resolve().then(() => (init_packbits_BlDR4Kj5(), exports_packbits_BlDR4Kj5)).then((i) => i.default));
  j2(34887, () => Promise.resolve().then(() => (init_lerc_CoQvYJmm(), exports_lerc_CoQvYJmm)).then(async (i) => (await i.zstd.init(), i)).then((i) => i.default));
  j2(50001, () => Promise.resolve().then(() => (init_webimage_BM_pbLN3(), exports_webimage_BM_pbLN3)).then((i) => i.default));
  pr = typeof navigator < "u" && navigator.hardwareConcurrency || 2;
  Ir = class Ir extends Map {
    constructor(e2 = {}) {
      if (super(), !(e2.maxSize && e2.maxSize > 0))
        throw new TypeError("`maxSize` must be a number greater than 0");
      if (typeof e2.maxAge == "number" && e2.maxAge === 0)
        throw new TypeError("`maxAge` must be a number greater than 0");
      this.maxSize = e2.maxSize, this.maxAge = e2.maxAge || Number.POSITIVE_INFINITY, this.onEviction = e2.onEviction, this.cache = /* @__PURE__ */ new Map, this.oldCache = /* @__PURE__ */ new Map, this._size = 0;
    }
    _emitEvictions(e2) {
      if (typeof this.onEviction == "function")
        for (const [t2, r] of e2)
          this.onEviction(t2, r.value);
    }
    _deleteIfExpired(e2, t2) {
      return typeof t2.expiry == "number" && t2.expiry <= Date.now() ? (typeof this.onEviction == "function" && this.onEviction(e2, t2.value), this.delete(e2)) : false;
    }
    _getOrDeleteIfExpired(e2, t2) {
      if (this._deleteIfExpired(e2, t2) === false)
        return t2.value;
    }
    _getItemValue(e2, t2) {
      return t2.expiry ? this._getOrDeleteIfExpired(e2, t2) : t2.value;
    }
    _peek(e2, t2) {
      const r = t2.get(e2);
      return this._getItemValue(e2, r);
    }
    _set(e2, t2) {
      this.cache.set(e2, t2), this._size++, this._size >= this.maxSize && (this._size = 0, this._emitEvictions(this.oldCache), this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map);
    }
    _moveToRecent(e2, t2) {
      this.oldCache.delete(e2), this._set(e2, t2);
    }
    *_entriesAscending() {
      for (const e2 of this.oldCache) {
        const [t2, r] = e2;
        this.cache.has(t2) || this._deleteIfExpired(t2, r) === false && (yield e2);
      }
      for (const e2 of this.cache) {
        const [t2, r] = e2;
        this._deleteIfExpired(t2, r) === false && (yield e2);
      }
    }
    get(e2) {
      if (this.cache.has(e2)) {
        const t2 = this.cache.get(e2);
        return this._getItemValue(e2, t2);
      }
      if (this.oldCache.has(e2)) {
        const t2 = this.oldCache.get(e2);
        if (this._deleteIfExpired(e2, t2) === false)
          return this._moveToRecent(e2, t2), t2.value;
      }
    }
    set(e2, t2, { maxAge: r = this.maxAge } = {}) {
      const s3 = typeof r == "number" && r !== Number.POSITIVE_INFINITY ? Date.now() + r : undefined;
      return this.cache.has(e2) ? this.cache.set(e2, {
        value: t2,
        expiry: s3
      }) : this._set(e2, { value: t2, expiry: s3 }), this;
    }
    has(e2) {
      return this.cache.has(e2) ? !this._deleteIfExpired(e2, this.cache.get(e2)) : this.oldCache.has(e2) ? !this._deleteIfExpired(e2, this.oldCache.get(e2)) : false;
    }
    peek(e2) {
      if (this.cache.has(e2))
        return this._peek(e2, this.cache);
      if (this.oldCache.has(e2))
        return this._peek(e2, this.oldCache);
    }
    delete(e2) {
      const t2 = this.cache.delete(e2);
      return t2 && this._size--, this.oldCache.delete(e2) || t2;
    }
    clear() {
      this.cache.clear(), this.oldCache.clear(), this._size = 0;
    }
    resize(e2) {
      if (!(e2 && e2 > 0))
        throw new TypeError("`maxSize` must be a number greater than 0");
      const t2 = [...this._entriesAscending()], r = t2.length - e2;
      r < 0 ? (this.cache = new Map(t2), this.oldCache = /* @__PURE__ */ new Map, this._size = t2.length) : (r > 0 && this._emitEvictions(t2.slice(0, r)), this.oldCache = new Map(t2.slice(r)), this.cache = /* @__PURE__ */ new Map, this._size = 0), this.maxSize = e2;
    }
    *keys() {
      for (const [e2] of this)
        yield e2;
    }
    *values() {
      for (const [, e2] of this)
        yield e2;
    }
    *[Symbol.iterator]() {
      for (const e2 of this.cache) {
        const [t2, r] = e2;
        this._deleteIfExpired(t2, r) === false && (yield [t2, r.value]);
      }
      for (const e2 of this.oldCache) {
        const [t2, r] = e2;
        this.cache.has(t2) || this._deleteIfExpired(t2, r) === false && (yield [t2, r.value]);
      }
    }
    *entriesDescending() {
      let e2 = [...this.cache];
      for (let t2 = e2.length - 1;t2 >= 0; --t2) {
        const r = e2[t2], [s3, o] = r;
        this._deleteIfExpired(s3, o) === false && (yield [s3, o.value]);
      }
      e2 = [...this.oldCache];
      for (let t2 = e2.length - 1;t2 >= 0; --t2) {
        const r = e2[t2], [s3, o] = r;
        this.cache.has(s3) || this._deleteIfExpired(s3, o) === false && (yield [s3, o.value]);
      }
    }
    *entriesAscending() {
      for (const [e2, t2] of this._entriesAscending())
        yield [e2, t2.value];
    }
    get size() {
      if (!this._size)
        return this.oldCache.size;
      let e2 = 0;
      for (const t2 of this.oldCache.keys())
        this.cache.has(t2) || e2++;
      return Math.min(this._size + e2, this.maxSize);
    }
    entries() {
      return this.entriesAscending();
    }
    forEach(e2, t2 = this) {
      for (const [r, s3] of this.entriesAscending())
        e2.call(t2, s3, r, this);
    }
    get [Symbol.toStringTag]() {
      return JSON.stringify([...this.entriesAscending()]);
    }
  };
  q2 = class q2 extends Error {
    constructor(e2) {
      super(e2), Error.captureStackTrace && Error.captureStackTrace(this, q2), this.name = "AbortError";
    }
  };
  Ar = class Ar extends Error {
    constructor(e2, t2) {
      super(t2), this.errors = e2, this.message = t2, this.name = "AggregateError";
    }
  };
  Dr = Ar;
  Fr = class Fr extends Ce2 {
    constructor(e2, { blockSize: t2 = 65536, cacheSize: r = 100 } = {}) {
      super(), this.source = e2, this.blockSize = t2, this.blockCache = new Ir({
        maxSize: r,
        onEviction: (s3, o) => {
          this.evictedBlocks.set(s3, o);
        }
      }), this.evictedBlocks = /* @__PURE__ */ new Map, this.blockRequests = /* @__PURE__ */ new Map, this.blockIdsToFetch = /* @__PURE__ */ new Set, this.abortedBlockIds = /* @__PURE__ */ new Set;
    }
    get fileSize() {
      return this.source.fileSize;
    }
    async fetch(e2, t2) {
      const r = [], s3 = [], o = [];
      this.evictedBlocks.clear();
      for (const { offset: u, length: g2 } of e2) {
        let f2 = u + g2;
        const { fileSize: y } = this;
        y !== null && (f2 = Math.min(f2, y));
        const p2 = Math.floor(u / this.blockSize) * this.blockSize;
        for (let w = p2;w < f2; w += this.blockSize) {
          const m2 = Math.floor(w / this.blockSize);
          !this.blockCache.has(m2) && !this.blockRequests.has(m2) && (this.blockIdsToFetch.add(m2), s3.push(m2)), this.blockRequests.has(m2) && r.push(this.blockRequests.get(m2)), o.push(m2);
        }
      }
      await Tr(), this.fetchBlocks(t2);
      const n = [];
      for (const u of s3)
        this.blockRequests.has(u) && n.push(this.blockRequests.get(u));
      await Promise.allSettled(r), await Promise.allSettled(n);
      const a = [], l3 = o.filter((u) => this.abortedBlockIds.has(u) || !this.blockCache.has(u));
      if (l3.forEach((u) => this.blockIdsToFetch.add(u)), l3.length > 0 && t2 && !t2.aborted) {
        this.fetchBlocks(null);
        for (const u of l3) {
          const g2 = this.blockRequests.get(u);
          if (!g2)
            throw new Error(`Block ${u} is not in the block requests`);
          a.push(g2);
        }
        await Promise.allSettled(a);
      }
      if (t2 && t2.aborted)
        throw new q2("Request was aborted");
      const c = o.map((u) => this.blockCache.get(u) || this.evictedBlocks.get(u)), h = c.filter((u) => !u);
      if (h.length)
        throw new Dr(h, "Request failed");
      const d3 = new Map(Sr(o, c));
      return this.readSliceData(e2, d3);
    }
    fetchBlocks(e2) {
      if (this.blockIdsToFetch.size > 0) {
        const t2 = this.groupBlocks(this.blockIdsToFetch), r = this.source.fetch(t2, e2);
        for (let s3 = 0;s3 < t2.length; ++s3) {
          const o = t2[s3];
          for (const n of o.blockIds)
            this.blockRequests.set(n, (async () => {
              try {
                const a = (await r)[s3], l3 = n * this.blockSize, c = l3 - a.offset, h = Math.min(c + this.blockSize, a.data.byteLength), d3 = a.data.slice(c, h), u = new Cr(l3, d3.byteLength, d3, n);
                this.blockCache.set(n, u), this.abortedBlockIds.delete(n);
              } catch (a) {
                if (a.name === "AbortError")
                  a.signal = e2, this.blockCache.delete(n), this.abortedBlockIds.add(n);
                else
                  throw a;
              } finally {
                this.blockRequests.delete(n);
              }
            })());
        }
        this.blockIdsToFetch.clear();
      }
    }
    groupBlocks(e2) {
      const t2 = Array.from(e2).sort((n, a) => n - a);
      if (t2.length === 0)
        return [];
      let r = [], s3 = null;
      const o = [];
      for (const n of t2)
        s3 === null || s3 + 1 === n ? (r.push(n), s3 = n) : (o.push(new Oe2(r[0] * this.blockSize, r.length * this.blockSize, r)), r = [n], s3 = n);
      return o.push(new Oe2(r[0] * this.blockSize, r.length * this.blockSize, r)), o;
    }
    readSliceData(e2, t2) {
      return e2.map((r) => {
        let s3 = r.offset + r.length;
        this.fileSize !== null && (s3 = Math.min(this.fileSize, s3));
        const o = Math.floor(r.offset / this.blockSize), n = Math.floor(s3 / this.blockSize), a = new ArrayBuffer(r.length), l3 = new Uint8Array(a);
        for (let c = o;c <= n; ++c) {
          const h = t2.get(c), d3 = h.offset - r.offset, u = h.top - s3;
          let g2 = 0, f2 = 0, y;
          d3 < 0 ? g2 = -d3 : d3 > 0 && (f2 = d3), u < 0 ? y = h.length - g2 : y = s3 - h.offset - g2;
          const p2 = new Uint8Array(h.data, g2, y);
          l3.set(p2, f2);
        }
        return a;
      });
    }
  };
  Er = class Er extends Fe2 {
    constructor(e2) {
      super(), this.response = e2;
    }
    get status() {
      return this.response.status;
    }
    getHeader(e2) {
      return this.response.headers.get(e2);
    }
    async getData() {
      return this.response.arrayBuffer ? await this.response.arrayBuffer() : (await this.response.buffer()).buffer;
    }
  };
  Pr = class Pr extends Ee2 {
    constructor(e2, t2) {
      super(e2), this.credentials = t2;
    }
    async request({ headers: e2, signal: t2 } = {}) {
      const r = await fetch(this.url, {
        headers: e2,
        credentials: this.credentials,
        signal: t2
      });
      return new Er(r);
    }
  };
  kr = class kr extends Fe2 {
    constructor(e2, t2) {
      super(), this.xhr = e2, this.data = t2;
    }
    get status() {
      return this.xhr.status;
    }
    getHeader(e2) {
      return this.xhr.getResponseHeader(e2);
    }
    async getData() {
      return this.data;
    }
  };
  Rr = class Rr extends Ee2 {
    constructRequest(e2, t2) {
      return new Promise((r, s3) => {
        const o = new XMLHttpRequest;
        o.open("GET", this.url), o.responseType = "arraybuffer";
        for (const [n, a] of Object.entries(e2))
          o.setRequestHeader(n, a);
        o.onload = () => {
          const n = o.response;
          r(new kr(o, n));
        }, o.onerror = s3, o.onabort = () => s3(new q2("Request aborted")), o.send(), t2 && (t2.aborted && o.abort(), t2.addEventListener("abort", () => o.abort()));
      });
    }
    async request({ headers: e2, signal: t2 } = {}) {
      return await this.constructRequest(e2, t2);
    }
  };
  he2 = {};
  Mr = class Mr extends Fe2 {
    constructor(e2, t2) {
      super(), this.response = e2, this.dataPromise = t2;
    }
    get status() {
      return this.response.statusCode;
    }
    getHeader(e2) {
      return this.response.headers[e2];
    }
    async getData() {
      return await this.dataPromise;
    }
  };
  Br = class Br extends Ee2 {
    constructor(e2) {
      super(e2), this.parsedUrl = he2.parse(this.url), this.httpApi = (this.parsedUrl.protocol === "http:", he2);
    }
    constructRequest(e2, t2) {
      return new Promise((r, s3) => {
        const o = this.httpApi.get({
          ...this.parsedUrl,
          headers: e2
        }, (n) => {
          const a = new Promise((l3) => {
            const c = [];
            n.on("data", (h) => {
              c.push(h);
            }), n.on("end", () => {
              const h = Buffer.concat(c).buffer;
              l3(h);
            }), n.on("error", s3);
          });
          r(new Mr(n, a));
        });
        o.on("error", s3), t2 && (t2.aborted && o.destroy(new q2("Request aborted")), t2.addEventListener("abort", () => o.destroy(new q2("Request aborted"))));
      });
    }
    async request({ headers: e2, signal: t2 } = {}) {
      return await this.constructRequest(e2, t2);
    }
  };
  Pe2 = class Pe2 extends Ce2 {
    constructor(e2, t2, r, s3) {
      super(), this.client = e2, this.headers = t2, this.maxRanges = r, this.allowFullFile = s3, this._fileSize = null;
    }
    async fetch(e2, t2) {
      return this.maxRanges >= e2.length ? this.fetchSlices(e2, t2) : (this.maxRanges > 0 && e2.length > 1, Promise.all(e2.map((r) => this.fetchSlice(r, t2))));
    }
    async fetchSlices(e2, t2) {
      const r = await this.client.request({
        headers: {
          ...this.headers,
          Range: `bytes=${e2.map(({ offset: s3, length: o }) => `${s3}-${s3 + o}`).join(",")}`
        },
        signal: t2
      });
      if (r.ok)
        if (r.status === 206) {
          const { type: s3, params: o } = xr(r.getHeader("content-type"));
          if (s3 === "multipart/byteranges") {
            const d3 = br2(await r.getData(), o.boundary);
            return this._fileSize = d3[0].fileSize || null, d3;
          }
          const n = await r.getData(), { start: a, end: l3, total: c } = de2(r.getHeader("content-range"));
          this._fileSize = c || null;
          const h = [{
            data: n,
            offset: a,
            length: l3 - a
          }];
          if (e2.length > 1) {
            const d3 = await Promise.all(e2.slice(1).map((u) => this.fetchSlice(u, t2)));
            return h.concat(d3);
          }
          return h;
        } else {
          if (!this.allowFullFile)
            throw new Error("Server responded with full file");
          const s3 = await r.getData();
          return this._fileSize = s3.byteLength, [{
            data: s3,
            offset: 0,
            length: s3.byteLength
          }];
        }
      else
        throw new Error("Error fetching data.");
    }
    async fetchSlice(e2, t2) {
      const { offset: r, length: s3 } = e2, o = await this.client.request({
        headers: {
          ...this.headers,
          Range: `bytes=${r}-${r + s3}`
        },
        signal: t2
      });
      if (o.ok)
        if (o.status === 206) {
          const n = await o.getData(), { total: a } = de2(o.getHeader("content-range"));
          return this._fileSize = a || null, {
            data: n,
            offset: r,
            length: s3
          };
        } else {
          if (!this.allowFullFile)
            throw new Error("Server responded with full file");
          const n = await o.getData();
          return this._fileSize = n.byteLength, {
            data: n,
            offset: 0,
            length: n.byteLength
          };
        }
      else
        throw new Error("Error fetching data.");
    }
    get fileSize() {
      return this._fileSize;
    }
  };
  Ur = class Ur extends Ce2 {
    constructor(e2) {
      super(), this.file = e2;
    }
    async fetchSlice(e2, t2) {
      return new Promise((r, s3) => {
        const o = this.file.slice(e2.offset, e2.offset + e2.length), n = new FileReader;
        n.onload = (a) => r(a.target.result), n.onerror = s3, n.onabort = s3, n.readAsArrayBuffer(o), t2 && t2.addEventListener("abort", () => n.abort());
      });
    }
  };
  ie3 = class ie3 extends Error {
    constructor(e2) {
      super(`No image at index ${e2}`), this.index = e2;
    }
  };
  oe2 = class oe2 extends zr {
    constructor(e2, t2, r, s3, o = {}) {
      super(), this.source = e2, this.littleEndian = t2, this.bigTiff = r, this.firstIFDOffset = s3, this.cache = o.cache || false, this.ifdRequests = [], this.ghostValues = null;
    }
    async getSlice(e2, t2) {
      const r = this.bigTiff ? 4048 : 1024;
      return new yr((await this.source.fetch([{
        offset: e2,
        length: typeof t2 < "u" ? t2 : r
      }]))[0], e2, this.littleEndian, this.bigTiff);
    }
    async parseFileDirectoryAt(e2) {
      const t2 = this.bigTiff ? 20 : 12, r = this.bigTiff ? 8 : 2;
      let s3 = await this.getSlice(e2);
      const o = this.bigTiff ? s3.readUint64(e2) : s3.readUint16(e2), n = o * t2 + (this.bigTiff ? 16 : 6);
      s3.covers(e2, n) || (s3 = await this.getSlice(e2, n));
      const a = {};
      let l3 = e2 + (this.bigTiff ? 8 : 2);
      for (let d3 = 0;d3 < o; l3 += t2, ++d3) {
        const u = s3.readUint16(l3), g2 = s3.readUint16(l3 + 2), f2 = this.bigTiff ? s3.readUint64(l3 + 4) : s3.readUint32(l3 + 4);
        let y, p2;
        const w = ge2(g2), m2 = l3 + (this.bigTiff ? 12 : 8);
        if (w * f2 <= (this.bigTiff ? 8 : 4))
          y = K3(s3, g2, f2, m2);
        else {
          const b = s3.readOffset(m2), T2 = ge2(g2) * f2;
          if (s3.covers(b, T2))
            y = K3(s3, g2, f2, b);
          else {
            const S2 = await this.getSlice(b, T2);
            y = K3(S2, g2, f2, b);
          }
        }
        f2 === 1 && Ht2.indexOf(u) === -1 && !(g2 === x3.RATIONAL || g2 === x3.SRATIONAL) ? p2 = y[0] : p2 = y, a[J[u]] = p2;
      }
      const c = Nr(a), h = s3.readOffset(e2 + r + t2 * o);
      return new jr(a, c, h);
    }
    async requestIFD(e2) {
      if (this.ifdRequests[e2])
        return this.ifdRequests[e2];
      if (e2 === 0)
        return this.ifdRequests[e2] = this.parseFileDirectoryAt(this.firstIFDOffset), this.ifdRequests[e2];
      if (!this.ifdRequests[e2 - 1])
        try {
          this.ifdRequests[e2 - 1] = this.requestIFD(e2 - 1);
        } catch (t2) {
          throw t2 instanceof ie3 ? new ie3(e2) : t2;
        }
      return this.ifdRequests[e2] = (async () => {
        const t2 = await this.ifdRequests[e2 - 1];
        if (t2.nextIFDByteOffset === 0)
          throw new ie3(e2);
        return this.parseFileDirectoryAt(t2.nextIFDByteOffset);
      })(), this.ifdRequests[e2];
    }
    async getImage(e2 = 0) {
      const t2 = await this.requestIFD(e2);
      return new dr2(t2.fileDirectory, t2.geoKeyDirectory, this.dataView, this.littleEndian, this.cache, this.source);
    }
    async getImageCount() {
      let e2 = 0, t2 = true;
      for (;t2; )
        try {
          await this.requestIFD(e2), ++e2;
        } catch (r) {
          if (r instanceof ie3)
            t2 = false;
          else
            throw r;
        }
      return e2;
    }
    async getGhostValues() {
      const e2 = this.bigTiff ? 16 : 8;
      if (this.ghostValues)
        return this.ghostValues;
      const t2 = "GDAL_STRUCTURAL_METADATA_SIZE=", r = t2.length + 100;
      let s3 = await this.getSlice(e2, r);
      if (t2 === K3(s3, x3.ASCII, t2.length, e2)) {
        const n = K3(s3, x3.ASCII, r, e2).split(`
`)[0], a = Number(n.split("=")[1].split(" ")[0]) + n.length;
        a > r && (s3 = await this.getSlice(e2, a));
        const l3 = K3(s3, x3.ASCII, a, e2);
        this.ghostValues = {}, l3.split(`
`).filter((c) => c.length > 0).map((c) => c.split("=")).forEach(([c, h]) => {
          this.ghostValues[c] = h;
        });
      }
      return this.ghostValues;
    }
    static async fromSource(e2, t2, r) {
      const s3 = (await e2.fetch([{ offset: 0, length: 1024 }], r))[0], o = new gr(s3), n = o.getUint16(0, 0);
      let a;
      if (n === 18761)
        a = true;
      else if (n === 19789)
        a = false;
      else
        throw new TypeError("Invalid byte order value.");
      const l3 = o.getUint16(2, a);
      let c;
      if (l3 === 42)
        c = false;
      else if (l3 === 43) {
        if (c = true, o.getUint16(4, a) !== 8)
          throw new Error("Unsupported offset byte-size.");
      } else
        throw new TypeError("Invalid magic number.");
      const h = c ? o.getUint64(8, a) : o.getUint32(4, a);
      return new oe2(e2, a, c, h, t2);
    }
    close() {
      return typeof this.source.close == "function" ? this.source.close() : false;
    }
  };
  (function(i, e2) {
    typeof exports_main_8v7k2MJ1 > "u" || typeof i.OpenSeadragon < "u" && e2(i.OpenSeadragon);
  })(typeof window < "u" ? window : undefined, qr);
});

// node:path
var exports_path = {};
__export(exports_path, {
  sep: () => sep,
  resolve: () => resolve,
  relative: () => relative,
  posix: () => posix,
  parse: () => parse,
  normalize: () => normalize,
  join: () => join,
  isAbsolute: () => isAbsolute,
  format: () => format,
  extname: () => extname,
  dirname: () => dirname,
  delimiter: () => delimiter,
  default: () => path_default,
  basename: () => basename,
  _makeLong: () => _makeLong
});
function assertPath(path) {
  if (typeof path !== "string")
    throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
}
function normalizeStringPosix(path, allowAboveRoot) {
  var res = "", lastSegmentLength = 0, lastSlash = -1, dots = 0, code;
  for (var i = 0;i <= path.length; ++i) {
    if (i < path.length)
      code = path.charCodeAt(i);
    else if (code === 47)
      break;
    else
      code = 47;
    if (code === 47) {
      if (lastSlash === i - 1 || dots === 1)
        ;
      else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1)
                res = "", lastSegmentLength = 0;
              else
                res = res.slice(0, lastSlashIndex), lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              lastSlash = i, dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "", lastSegmentLength = 0, lastSlash = i, dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += "/..";
          else
            res = "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += "/" + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i, dots = 0;
    } else if (code === 46 && dots !== -1)
      ++dots;
    else
      dots = -1;
  }
  return res;
}
function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root, base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
  if (!dir)
    return base;
  if (dir === pathObject.root)
    return dir + base;
  return dir + sep + base;
}
function resolve() {
  var resolvedPath = "", resolvedAbsolute = false, cwd;
  for (var i = arguments.length - 1;i >= -1 && !resolvedAbsolute; i--) {
    var path;
    if (i >= 0)
      path = arguments[i];
    else {
      if (cwd === undefined)
        cwd = process.cwd();
      path = cwd;
    }
    if (assertPath(path), path.length === 0)
      continue;
    resolvedPath = path + "/" + resolvedPath, resolvedAbsolute = path.charCodeAt(0) === 47;
  }
  if (resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute), resolvedAbsolute)
    if (resolvedPath.length > 0)
      return "/" + resolvedPath;
    else
      return "/";
  else if (resolvedPath.length > 0)
    return resolvedPath;
  else
    return ".";
}
function normalize(path) {
  if (assertPath(path), path.length === 0)
    return ".";
  var isAbsolute = path.charCodeAt(0) === 47, trailingSeparator = path.charCodeAt(path.length - 1) === 47;
  if (path = normalizeStringPosix(path, !isAbsolute), path.length === 0 && !isAbsolute)
    path = ".";
  if (path.length > 0 && trailingSeparator)
    path += "/";
  if (isAbsolute)
    return "/" + path;
  return path;
}
function isAbsolute(path) {
  return assertPath(path), path.length > 0 && path.charCodeAt(0) === 47;
}
function join() {
  if (arguments.length === 0)
    return ".";
  var joined;
  for (var i = 0;i < arguments.length; ++i) {
    var arg = arguments[i];
    if (assertPath(arg), arg.length > 0)
      if (joined === undefined)
        joined = arg;
      else
        joined += "/" + arg;
  }
  if (joined === undefined)
    return ".";
  return normalize(joined);
}
function relative(from, to) {
  if (assertPath(from), assertPath(to), from === to)
    return "";
  if (from = resolve(from), to = resolve(to), from === to)
    return "";
  var fromStart = 1;
  for (;fromStart < from.length; ++fromStart)
    if (from.charCodeAt(fromStart) !== 47)
      break;
  var fromEnd = from.length, fromLen = fromEnd - fromStart, toStart = 1;
  for (;toStart < to.length; ++toStart)
    if (to.charCodeAt(toStart) !== 47)
      break;
  var toEnd = to.length, toLen = toEnd - toStart, length = fromLen < toLen ? fromLen : toLen, lastCommonSep = -1, i = 0;
  for (;i <= length; ++i) {
    if (i === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === 47)
          return to.slice(toStart + i + 1);
        else if (i === 0)
          return to.slice(toStart + i);
      } else if (fromLen > length) {
        if (from.charCodeAt(fromStart + i) === 47)
          lastCommonSep = i;
        else if (i === 0)
          lastCommonSep = 0;
      }
      break;
    }
    var fromCode = from.charCodeAt(fromStart + i), toCode = to.charCodeAt(toStart + i);
    if (fromCode !== toCode)
      break;
    else if (fromCode === 47)
      lastCommonSep = i;
  }
  var out = "";
  for (i = fromStart + lastCommonSep + 1;i <= fromEnd; ++i)
    if (i === fromEnd || from.charCodeAt(i) === 47)
      if (out.length === 0)
        out += "..";
      else
        out += "/..";
  if (out.length > 0)
    return out + to.slice(toStart + lastCommonSep);
  else {
    if (toStart += lastCommonSep, to.charCodeAt(toStart) === 47)
      ++toStart;
    return to.slice(toStart);
  }
}
function _makeLong(path) {
  return path;
}
function dirname(path) {
  if (assertPath(path), path.length === 0)
    return ".";
  var code = path.charCodeAt(0), hasRoot = code === 47, end = -1, matchedSlash = true;
  for (var i = path.length - 1;i >= 1; --i)
    if (code = path.charCodeAt(i), code === 47) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else
      matchedSlash = false;
  if (end === -1)
    return hasRoot ? "/" : ".";
  if (hasRoot && end === 1)
    return "//";
  return path.slice(0, end);
}
function basename(path, ext) {
  if (ext !== undefined && typeof ext !== "string")
    throw new TypeError('"ext" argument must be a string');
  assertPath(path);
  var start = 0, end = -1, matchedSlash = true, i;
  if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
    if (ext.length === path.length && ext === path)
      return "";
    var extIdx = ext.length - 1, firstNonSlashEnd = -1;
    for (i = path.length - 1;i >= 0; --i) {
      var code = path.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd === -1)
          matchedSlash = false, firstNonSlashEnd = i + 1;
        if (extIdx >= 0)
          if (code === ext.charCodeAt(extIdx)) {
            if (--extIdx === -1)
              end = i;
          } else
            extIdx = -1, end = firstNonSlashEnd;
      }
    }
    if (start === end)
      end = firstNonSlashEnd;
    else if (end === -1)
      end = path.length;
    return path.slice(start, end);
  } else {
    for (i = path.length - 1;i >= 0; --i)
      if (path.charCodeAt(i) === 47) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1)
        matchedSlash = false, end = i + 1;
    if (end === -1)
      return "";
    return path.slice(start, end);
  }
}
function extname(path) {
  assertPath(path);
  var startDot = -1, startPart = 0, end = -1, matchedSlash = true, preDotState = 0;
  for (var i = path.length - 1;i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1)
      matchedSlash = false, end = i + 1;
    if (code === 46) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1)
      preDotState = -1;
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)
    return "";
  return path.slice(startDot, end);
}
function format(pathObject) {
  if (pathObject === null || typeof pathObject !== "object")
    throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
  return _format("/", pathObject);
}
function parse(path) {
  assertPath(path);
  var ret = { root: "", dir: "", base: "", ext: "", name: "" };
  if (path.length === 0)
    return ret;
  var code = path.charCodeAt(0), isAbsolute2 = code === 47, start;
  if (isAbsolute2)
    ret.root = "/", start = 1;
  else
    start = 0;
  var startDot = -1, startPart = 0, end = -1, matchedSlash = true, i = path.length - 1, preDotState = 0;
  for (;i >= start; --i) {
    if (code = path.charCodeAt(i), code === 47) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1)
      matchedSlash = false, end = i + 1;
    if (code === 46) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1)
      preDotState = -1;
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1)
      if (startPart === 0 && isAbsolute2)
        ret.base = ret.name = path.slice(1, end);
      else
        ret.base = ret.name = path.slice(startPart, end);
  } else {
    if (startPart === 0 && isAbsolute2)
      ret.name = path.slice(1, startDot), ret.base = path.slice(1, end);
    else
      ret.name = path.slice(startPart, startDot), ret.base = path.slice(startPart, end);
    ret.ext = path.slice(startDot, end);
  }
  if (startPart > 0)
    ret.dir = path.slice(0, startPart - 1);
  else if (isAbsolute2)
    ret.dir = "/";
  return ret;
}
var sep = "/", delimiter = ":", posix, path_default;
var init_path = __esm(() => {
  posix = ((p2) => (p2.posix = p2, p2))({ resolve, normalize, isAbsolute, join, relative, _makeLong, dirname, basename, extname, format, parse, sep, delimiter, win32: null, posix: null });
  path_default = posix;
});

// node:buffer
var exports_buffer = {};
__export(exports_buffer, {
  transcode: () => transcode,
  resolveObjectURL: () => resolveObjectURL,
  kStringMaxLength: () => kStringMaxLength,
  kMaxLength: () => kMaxLength,
  isUtf8: () => isUtf8,
  isAscii: () => isAscii,
  default: () => buffer_default,
  constants: () => constants,
  btoa: () => btoa,
  atob: () => atob,
  INSPECT_MAX_BYTES: () => INSPECT_MAX_BYTES,
  File: () => File2,
  Buffer: () => Buffer2,
  Blob: () => Blob2
});
function getLens(b64) {
  var len2 = b64.length;
  if (len2 % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len2;
  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function _byteLength(validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp, lens = getLens(b64), validLen = lens[0], placeHoldersLen = lens[1], arr = new Uint8Array(_byteLength(validLen, placeHoldersLen)), curByte = 0, len2 = placeHoldersLen > 0 ? validLen - 4 : validLen, i2;
  for (i2 = 0;i2 < len2; i2 += 4)
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)], arr[curByte++] = tmp >> 16 & 255, arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = tmp & 255;
  if (placeHoldersLen === 2)
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4, arr[curByte++] = tmp & 255;
  if (placeHoldersLen === 1)
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2, arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = tmp & 255;
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp, output = [];
  for (var i2 = start;i2 < end; i2 += 3)
    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255), output.push(tripletToBase64(tmp));
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp, len2 = uint8.length, extraBytes = len2 % 3, parts = [], maxChunkLength = 16383;
  for (var i2 = 0, len22 = len2 - extraBytes;i2 < len22; i2 += maxChunkLength)
    parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
  if (extraBytes === 1)
    tmp = uint8[len2 - 1], parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
  else if (extraBytes === 2)
    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1], parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
  return parts.join("");
}
function read(buffer, offset, isLE, mLen, nBytes) {
  var e2, m2, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i2 = isLE ? nBytes - 1 : 0, d3 = isLE ? -1 : 1, s3 = buffer[offset + i2];
  i2 += d3, e2 = s3 & (1 << -nBits) - 1, s3 >>= -nBits, nBits += eLen;
  for (;nBits > 0; e2 = e2 * 256 + buffer[offset + i2], i2 += d3, nBits -= 8)
    ;
  m2 = e2 & (1 << -nBits) - 1, e2 >>= -nBits, nBits += mLen;
  for (;nBits > 0; m2 = m2 * 256 + buffer[offset + i2], i2 += d3, nBits -= 8)
    ;
  if (e2 === 0)
    e2 = 1 - eBias;
  else if (e2 === eMax)
    return m2 ? NaN : (s3 ? -1 : 1) * (1 / 0);
  else
    m2 = m2 + Math.pow(2, mLen), e2 = e2 - eBias;
  return (s3 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
}
function write(buffer, value, offset, isLE, mLen, nBytes) {
  var e2, m2, c, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt3 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i2 = isLE ? 0 : nBytes - 1, d3 = isLE ? 1 : -1, s3 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  if (value = Math.abs(value), isNaN(value) || value === 1 / 0)
    m2 = isNaN(value) ? 1 : 0, e2 = eMax;
  else {
    if (e2 = Math.floor(Math.log(value) / Math.LN2), value * (c = Math.pow(2, -e2)) < 1)
      e2--, c *= 2;
    if (e2 + eBias >= 1)
      value += rt3 / c;
    else
      value += rt3 * Math.pow(2, 1 - eBias);
    if (value * c >= 2)
      e2++, c /= 2;
    if (e2 + eBias >= eMax)
      m2 = 0, e2 = eMax;
    else if (e2 + eBias >= 1)
      m2 = (value * c - 1) * Math.pow(2, mLen), e2 = e2 + eBias;
    else
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen), e2 = 0;
  }
  for (;mLen >= 8; buffer[offset + i2] = m2 & 255, i2 += d3, m2 /= 256, mLen -= 8)
    ;
  e2 = e2 << mLen | m2, eLen += mLen;
  for (;eLen > 0; buffer[offset + i2] = e2 & 255, i2 += d3, e2 /= 256, eLen -= 8)
    ;
  buffer[offset + i2 - d3] |= s3 * 128;
}
function createBuffer(length) {
  if (length > kMaxLength)
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  let buf = new Uint8Array(length);
  return Object.setPrototypeOf(buf, Buffer2.prototype), buf;
}
function E3(sym, getMessage, Base) {
  return class NodeError extends Base {
    constructor() {
      super();
      Object.defineProperty(this, "message", { value: getMessage.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${sym}]`, this.stack, delete this.name;
    }
    get code() {
      return sym;
    }
    set code(value) {
      Object.defineProperty(this, "code", { configurable: true, enumerable: true, value, writable: true });
    }
    toString() {
      return `${this.name} [${sym}]: ${this.message}`;
    }
  };
}
function Buffer2(arg, encodingOrOffset, length) {
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string")
      throw new TypeError('The "string" argument must be of type string. Received type number');
    return allocUnsafe(arg);
  }
  return from(arg, encodingOrOffset, length);
}
function from(value, encodingOrOffset, length) {
  if (typeof value === "string")
    return fromString(value, encodingOrOffset);
  if (ArrayBuffer.isView(value))
    return fromArrayView(value);
  if (value == null)
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer))
    return fromArrayBuffer(value, encodingOrOffset, length);
  if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer)))
    return fromArrayBuffer(value, encodingOrOffset, length);
  if (typeof value === "number")
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  let valueOf = value.valueOf && value.valueOf();
  if (valueOf != null && valueOf !== value)
    return Buffer2.from(valueOf, encodingOrOffset, length);
  let b = fromObject(value);
  if (b)
    return b;
  if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function")
    return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
  throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
function assertSize(size) {
  if (typeof size !== "number")
    throw new TypeError('"size" argument must be of type number');
  else if (size < 0)
    throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
  if (assertSize(size), size <= 0)
    return createBuffer(size);
  if (fill !== undefined)
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
  return createBuffer(size);
}
function allocUnsafe(size) {
  return assertSize(size), createBuffer(size < 0 ? 0 : checked(size) | 0);
}
function fromString(string, encoding) {
  if (typeof encoding !== "string" || encoding === "")
    encoding = "utf8";
  if (!Buffer2.isEncoding(encoding))
    throw new TypeError("Unknown encoding: " + encoding);
  let length = byteLength(string, encoding) | 0, buf = createBuffer(length), actual = buf.write(string, encoding);
  if (actual !== length)
    buf = buf.slice(0, actual);
  return buf;
}
function fromArrayLike(array) {
  let length = array.length < 0 ? 0 : checked(array.length) | 0, buf = createBuffer(length);
  for (let i2 = 0;i2 < length; i2 += 1)
    buf[i2] = array[i2] & 255;
  return buf;
}
function fromArrayView(arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    let copy = new Uint8Array(arrayView);
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
  }
  return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset)
    throw new RangeError('"offset" is outside of buffer bounds');
  if (array.byteLength < byteOffset + (length || 0))
    throw new RangeError('"length" is outside of buffer bounds');
  let buf;
  if (byteOffset === undefined && length === undefined)
    buf = new Uint8Array(array);
  else if (length === undefined)
    buf = new Uint8Array(array, byteOffset);
  else
    buf = new Uint8Array(array, byteOffset, length);
  return Object.setPrototypeOf(buf, Buffer2.prototype), buf;
}
function fromObject(obj) {
  if (Buffer2.isBuffer(obj)) {
    let len2 = checked(obj.length) | 0, buf = createBuffer(len2);
    if (buf.length === 0)
      return buf;
    return obj.copy(buf, 0, 0, len2), buf;
  }
  if (obj.length !== undefined) {
    if (typeof obj.length !== "number" || Number.isNaN(obj.length))
      return createBuffer(0);
    return fromArrayLike(obj);
  }
  if (obj.type === "Buffer" && Array.isArray(obj.data))
    return fromArrayLike(obj.data);
}
function checked(length) {
  if (length >= kMaxLength)
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength.toString(16) + " bytes");
  return length | 0;
}
function byteLength(string, encoding) {
  if (Buffer2.isBuffer(string))
    return string.length;
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer))
    return string.byteLength;
  if (typeof string !== "string")
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
  let len2 = string.length, mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len2 === 0)
    return 0;
  let loweredCase = false;
  for (;; )
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len2;
      case "utf8":
      case "utf-8":
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len2 * 2;
      case "hex":
        return len2 >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return mustMatch ? -1 : utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase(), loweredCase = true;
    }
}
function slowToString(encoding, start, end) {
  let loweredCase = false;
  if (start === undefined || start < 0)
    start = 0;
  if (start > this.length)
    return "";
  if (end === undefined || end > this.length)
    end = this.length;
  if (end <= 0)
    return "";
  if (end >>>= 0, start >>>= 0, end <= start)
    return "";
  if (!encoding)
    encoding = "utf8";
  while (true)
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase(), loweredCase = true;
    }
}
function swap(b, n, m2) {
  let i2 = b[n];
  b[n] = b[m2], b[m2] = i2;
}
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string")
    encoding = byteOffset, byteOffset = 0;
  else if (byteOffset > 2147483647)
    byteOffset = 2147483647;
  else if (byteOffset < -2147483648)
    byteOffset = -2147483648;
  if (byteOffset = +byteOffset, Number.isNaN(byteOffset))
    byteOffset = dir ? 0 : buffer.length - 1;
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length)
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  else if (byteOffset < 0)
    if (dir)
      byteOffset = 0;
    else
      return -1;
  if (typeof val === "string")
    val = Buffer2.from(val, encoding);
  if (Buffer2.isBuffer(val)) {
    if (val.length === 0)
      return -1;
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    if (val = val & 255, typeof Uint8Array.prototype.indexOf === "function")
      if (dir)
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      else
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  let indexSize = 1, arrLength = arr.length, valLength = val.length;
  if (encoding !== undefined) {
    if (encoding = String(encoding).toLowerCase(), encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2)
        return -1;
      indexSize = 2, arrLength /= 2, valLength /= 2, byteOffset /= 2;
    }
  }
  function read2(buf, i3) {
    if (indexSize === 1)
      return buf[i3];
    else
      return buf.readUInt16BE(i3 * indexSize);
  }
  let i2;
  if (dir) {
    let foundIndex = -1;
    for (i2 = byteOffset;i2 < arrLength; i2++)
      if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i2;
        if (i2 - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i2 -= i2 - foundIndex;
        foundIndex = -1;
      }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i2 = byteOffset;i2 >= 0; i2--) {
      let found = true;
      for (let j3 = 0;j3 < valLength; j3++)
        if (read2(arr, i2 + j3) !== read2(val, j3)) {
          found = false;
          break;
        }
      if (found)
        return i2;
    }
  }
  return -1;
}
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  let remaining = buf.length - offset;
  if (!length)
    length = remaining;
  else if (length = Number(length), length > remaining)
    length = remaining;
  let strLen = string.length;
  if (length > strLen / 2)
    length = strLen / 2;
  let i2;
  for (i2 = 0;i2 < length; ++i2) {
    let parsed = parseInt(string.substr(i2 * 2, 2), 16);
    if (Number.isNaN(parsed))
      return i2;
    buf[offset + i2] = parsed;
  }
  return i2;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length)
    return fromByteArray(buf);
  else
    return fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  let res = [], i2 = start;
  while (i2 < end) {
    let firstByte = buf[i2], codePoint = null, bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i2 + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128)
            codePoint = firstByte;
          break;
        case 2:
          if (secondByte = buf[i2 + 1], (secondByte & 192) === 128) {
            if (tempCodePoint = (firstByte & 31) << 6 | secondByte & 63, tempCodePoint > 127)
              codePoint = tempCodePoint;
          }
          break;
        case 3:
          if (secondByte = buf[i2 + 1], thirdByte = buf[i2 + 2], (secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            if (tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63, tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343))
              codePoint = tempCodePoint;
          }
          break;
        case 4:
          if (secondByte = buf[i2 + 1], thirdByte = buf[i2 + 2], fourthByte = buf[i2 + 3], (secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            if (tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63, tempCodePoint > 65535 && tempCodePoint < 1114112)
              codePoint = tempCodePoint;
          }
      }
    }
    if (codePoint === null)
      codePoint = 65533, bytesPerSequence = 1;
    else if (codePoint > 65535)
      codePoint -= 65536, res.push(codePoint >>> 10 & 1023 | 55296), codePoint = 56320 | codePoint & 1023;
    res.push(codePoint), i2 += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  let len2 = codePoints.length;
  if (len2 <= MAX_ARGUMENTS_LENGTH)
    return String.fromCharCode.apply(String, codePoints);
  let res = "", i2 = 0;
  while (i2 < len2)
    res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH));
  return res;
}
function asciiSlice(buf, start, end) {
  let ret = "";
  end = Math.min(buf.length, end);
  for (let i2 = start;i2 < end; ++i2)
    ret += String.fromCharCode(buf[i2] & 127);
  return ret;
}
function latin1Slice(buf, start, end) {
  let ret = "";
  end = Math.min(buf.length, end);
  for (let i2 = start;i2 < end; ++i2)
    ret += String.fromCharCode(buf[i2]);
  return ret;
}
function hexSlice(buf, start, end) {
  let len2 = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len2)
    end = len2;
  let out = "";
  for (let i2 = start;i2 < end; ++i2)
    out += hexSliceLookupTable[buf[i2]];
  return out;
}
function utf16leSlice(buf, start, end) {
  let bytes = buf.slice(start, end), res = "";
  for (let i2 = 0;i2 < bytes.length - 1; i2 += 2)
    res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
  return res;
}
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer2.isBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
function wrtBigUInt64LE(buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7);
  let lo = Number(value & BigInt(4294967295));
  buf[offset++] = lo, lo = lo >> 8, buf[offset++] = lo, lo = lo >> 8, buf[offset++] = lo, lo = lo >> 8, buf[offset++] = lo;
  let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
  return buf[offset++] = hi2, hi2 = hi2 >> 8, buf[offset++] = hi2, hi2 = hi2 >> 8, buf[offset++] = hi2, hi2 = hi2 >> 8, buf[offset++] = hi2, offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7);
  let lo = Number(value & BigInt(4294967295));
  buf[offset + 7] = lo, lo = lo >> 8, buf[offset + 6] = lo, lo = lo >> 8, buf[offset + 5] = lo, lo = lo >> 8, buf[offset + 4] = lo;
  let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
  return buf[offset + 3] = hi2, hi2 = hi2 >> 8, buf[offset + 2] = hi2, hi2 = hi2 >> 8, buf[offset + 1] = hi2, hi2 = hi2 >> 8, buf[offset] = hi2, offset + 8;
}
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (value = +value, offset = offset >>> 0, !noAssert)
    checkIEEE754(buf, value, offset, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000);
  return write(buf, value, offset, littleEndian, 23, 4), offset + 4;
}
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (value = +value, offset = offset >>> 0, !noAssert)
    checkIEEE754(buf, value, offset, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
  return write(buf, value, offset, littleEndian, 52, 8), offset + 8;
}
function addNumericalSeparator(val) {
  let res = "", i2 = val.length, start = val[0] === "-" ? 1 : 0;
  for (;i2 >= start + 4; i2 -= 3)
    res = `_${val.slice(i2 - 3, i2)}${res}`;
  return `${val.slice(0, i2)}${res}`;
}
function checkBounds(buf, offset, byteLength2) {
  if (validateNumber(offset, "offset"), buf[offset] === undefined || buf[offset + byteLength2] === undefined)
    boundsError(offset, buf.length - (byteLength2 + 1));
}
function checkIntBI(value, min, max, buf, offset, byteLength2) {
  if (value > max || value < min) {
    let n = typeof min === "bigint" ? "n" : "", range;
    if (byteLength2 > 3)
      if (min === 0 || min === BigInt(0))
        range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
      else
        range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
    else
      range = `>= ${min}${n} and <= ${max}${n}`;
    throw new ERR_OUT_OF_RANGE("value", range, value);
  }
  checkBounds(buf, offset, byteLength2);
}
function validateNumber(value, name) {
  if (typeof value !== "number")
    throw new ERR_INVALID_ARG_TYPE(name, "number", value);
}
function boundsError(value, length, type) {
  if (Math.floor(value) !== value)
    throw validateNumber(value, type), new ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
  if (length < 0)
    throw new ERR_BUFFER_OUT_OF_BOUNDS;
  throw new ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function base64clean(str) {
  if (str = str.split("=")[0], str = str.trim().replace(INVALID_BASE64_RE, ""), str.length < 2)
    return "";
  while (str.length % 4 !== 0)
    str = str + "=";
  return str;
}
function utf8ToBytes(string, units) {
  units = units || 1 / 0;
  let codePoint, length = string.length, leadSurrogate = null, bytes = [];
  for (let i2 = 0;i2 < length; ++i2) {
    if (codePoint = string.charCodeAt(i2), codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i2 + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    if (leadSurrogate = null, codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else
      throw new Error("Invalid code point");
  }
  return bytes;
}
function asciiToBytes(str) {
  let byteArray = [];
  for (let i2 = 0;i2 < str.length; ++i2)
    byteArray.push(str.charCodeAt(i2) & 255);
  return byteArray;
}
function utf16leToBytes(str, units) {
  let c, hi2, lo, byteArray = [];
  for (let i2 = 0;i2 < str.length; ++i2) {
    if ((units -= 2) < 0)
      break;
    c = str.charCodeAt(i2), hi2 = c >> 8, lo = c % 256, byteArray.push(lo), byteArray.push(hi2);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  let i2;
  for (i2 = 0;i2 < length; ++i2) {
    if (i2 + offset >= dst.length || i2 >= src.length)
      break;
    dst[i2 + offset] = src[i2];
  }
  return i2;
}
function isInstance(obj, type) {
  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function defineBigIntMethod(fn2) {
  return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn2;
}
function BufferBigIntNotDefined() {
  throw new Error("BigInt not supported");
}
function notimpl(name) {
  return () => {
    throw new Error(name + " is not implemented for node:buffer browser polyfill");
  };
}
var lookup, revLookup, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i, len, customInspectSymbol, INSPECT_MAX_BYTES = 50, kMaxLength = 2147483647, kStringMaxLength = 536870888, btoa, atob, File2, Blob2, constants, ERR_BUFFER_OUT_OF_BOUNDS, ERR_INVALID_ARG_TYPE, ERR_OUT_OF_RANGE, MAX_ARGUMENTS_LENGTH = 4096, INVALID_BASE64_RE, hexSliceLookupTable, resolveObjectURL, isUtf8, isAscii = (str) => {
  for (let char of str)
    if (char.charCodeAt(0) > 127)
      return false;
  return true;
}, transcode, buffer_default;
var init_buffer = __esm(() => {
  lookup = [];
  revLookup = [];
  for (i = 0, len = code.length;i < len; ++i)
    lookup[i] = code[i], revLookup[code.charCodeAt(i)] = i;
  revLookup[45] = 62;
  revLookup[95] = 63;
  customInspectSymbol = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  btoa = globalThis.btoa;
  atob = globalThis.atob;
  File2 = globalThis.File;
  Blob2 = globalThis.Blob;
  constants = { MAX_LENGTH: kMaxLength, MAX_STRING_LENGTH: kStringMaxLength };
  ERR_BUFFER_OUT_OF_BOUNDS = E3("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
    if (name)
      return `${name} is outside of buffer bounds`;
    return "Attempt to access memory outside buffer bounds";
  }, RangeError);
  ERR_INVALID_ARG_TYPE = E3("ERR_INVALID_ARG_TYPE", function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
  }, TypeError);
  ERR_OUT_OF_RANGE = E3("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`, received = input;
    if (Number.isInteger(input) && Math.abs(input) > 4294967296)
      received = addNumericalSeparator(String(input));
    else if (typeof input === "bigint") {
      if (received = String(input), input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32)))
        received = addNumericalSeparator(received);
      received += "n";
    }
    return msg += ` It must be ${range}. Received ${received}`, msg;
  }, RangeError);
  Object.defineProperty(Buffer2.prototype, "parent", { enumerable: true, get: function() {
    if (!Buffer2.isBuffer(this))
      return;
    return this.buffer;
  } });
  Object.defineProperty(Buffer2.prototype, "offset", { enumerable: true, get: function() {
    if (!Buffer2.isBuffer(this))
      return;
    return this.byteOffset;
  } });
  Buffer2.poolSize = 8192;
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  Buffer2.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array))
      a = Buffer2.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array))
      b = Buffer2.from(b, b.offset, b.byteLength);
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b)
      return 0;
    let x4 = a.length, y = b.length;
    for (let i2 = 0, len2 = Math.min(x4, y);i2 < len2; ++i2)
      if (a[i2] !== b[i2]) {
        x4 = a[i2], y = b[i2];
        break;
      }
    if (x4 < y)
      return -1;
    if (y < x4)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat(list, length) {
    if (!Array.isArray(list))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0)
      return Buffer2.alloc(0);
    let i2;
    if (length === undefined) {
      length = 0;
      for (i2 = 0;i2 < list.length; ++i2)
        length += list[i2].length;
    }
    let buffer = Buffer2.allocUnsafe(length), pos = 0;
    for (i2 = 0;i2 < list.length; ++i2) {
      let buf = list[i2];
      if (isInstance(buf, Uint8Array))
        if (pos + buf.length > buffer.length) {
          if (!Buffer2.isBuffer(buf))
            buf = Buffer2.from(buf);
          buf.copy(buffer, pos);
        } else
          Uint8Array.prototype.set.call(buffer, buf, pos);
      else if (!Buffer2.isBuffer(buf))
        throw new TypeError('"list" argument must be an Array of Buffers');
      else
        buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer;
  };
  Buffer2.byteLength = byteLength;
  Buffer2.prototype._isBuffer = true;
  Buffer2.prototype.swap16 = function swap16() {
    let len2 = this.length;
    if (len2 % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let i2 = 0;i2 < len2; i2 += 2)
      swap(this, i2, i2 + 1);
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    let len2 = this.length;
    if (len2 % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let i2 = 0;i2 < len2; i2 += 4)
      swap(this, i2, i2 + 3), swap(this, i2 + 1, i2 + 2);
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    let len2 = this.length;
    if (len2 % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let i2 = 0;i2 < len2; i2 += 8)
      swap(this, i2, i2 + 7), swap(this, i2 + 1, i2 + 6), swap(this, i2 + 2, i2 + 5), swap(this, i2 + 3, i2 + 4);
    return this;
  };
  Buffer2.prototype.toString = function toString() {
    let length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b) {
    if (!Buffer2.isBuffer(b))
      throw new TypeError("Argument must be a Buffer");
    if (this === b)
      return true;
    return Buffer2.compare(this, b) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    let str = "", max = INSPECT_MAX_BYTES;
    if (str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim(), this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol)
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array))
      target = Buffer2.from(target, target.offset, target.byteLength);
    if (!Buffer2.isBuffer(target))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined)
      start = 0;
    if (end === undefined)
      end = target ? target.length : 0;
    if (thisStart === undefined)
      thisStart = 0;
    if (thisEnd === undefined)
      thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length)
      throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end)
      return 0;
    if (thisStart >= thisEnd)
      return -1;
    if (start >= end)
      return 1;
    if (start >>>= 0, end >>>= 0, thisStart >>>= 0, thisEnd >>>= 0, this === target)
      return 0;
    let x4 = thisEnd - thisStart, y = end - start, len2 = Math.min(x4, y), thisCopy = this.slice(thisStart, thisEnd), targetCopy = target.slice(start, end);
    for (let i2 = 0;i2 < len2; ++i2)
      if (thisCopy[i2] !== targetCopy[i2]) {
        x4 = thisCopy[i2], y = targetCopy[i2];
        break;
      }
    if (x4 < y)
      return -1;
    if (y < x4)
      return 1;
    return 0;
  };
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  Buffer2.prototype.write = function write2(string, offset, length, encoding) {
    if (offset === undefined)
      encoding = "utf8", length = this.length, offset = 0;
    else if (length === undefined && typeof offset === "string")
      encoding = offset, length = this.length, offset = 0;
    else if (isFinite(offset))
      if (offset = offset >>> 0, isFinite(length)) {
        if (length = length >>> 0, encoding === undefined)
          encoding = "utf8";
      } else
        encoding = length, length = undefined;
    else
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    let remaining = this.length - offset;
    if (length === undefined || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (;; )
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase(), loweredCase = true;
      }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  Buffer2.prototype.slice = function slice(start, end) {
    let len2 = this.length;
    if (start = ~~start, end = end === undefined ? len2 : ~~end, start < 0) {
      if (start += len2, start < 0)
        start = 0;
    } else if (start > len2)
      start = len2;
    if (end < 0) {
      if (end += len2, end < 0)
        end = 0;
    } else if (end > len2)
      end = len2;
    if (end < start)
      end = start;
    let newBuf = this.subarray(start, end);
    return Object.setPrototypeOf(newBuf, Buffer2.prototype), newBuf;
  };
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
    if (offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset], mul = 1, i2 = 0;
    while (++i2 < byteLength2 && (mul *= 256))
      val += this[offset + i2] * mul;
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    if (offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset + --byteLength2], mul = 1;
    while (byteLength2 > 0 && (mul *= 256))
      val += this[offset + --byteLength2] * mul;
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0, validateNumber(offset, "offset");
    let first = this[offset], last = this[offset + 7];
    if (first === undefined || last === undefined)
      boundsError(offset, this.length - 8);
    let lo = first + this[++offset] * 256 + this[++offset] * 65536 + this[++offset] * 16777216, hi2 = this[++offset] + this[++offset] * 256 + this[++offset] * 65536 + last * 16777216;
    return BigInt(lo) + (BigInt(hi2) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0, validateNumber(offset, "offset");
    let first = this[offset], last = this[offset + 7];
    if (first === undefined || last === undefined)
      boundsError(offset, this.length - 8);
    let hi2 = first * 16777216 + this[++offset] * 65536 + this[++offset] * 256 + this[++offset], lo = this[++offset] * 16777216 + this[++offset] * 65536 + this[++offset] * 256 + last;
    return (BigInt(hi2) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
    if (offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset], mul = 1, i2 = 0;
    while (++i2 < byteLength2 && (mul *= 256))
      val += this[offset + i2] * mul;
    if (mul *= 128, val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
    if (offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert)
      checkOffset(offset, byteLength2, this.length);
    let i2 = byteLength2, mul = 1, val = this[offset + --i2];
    while (i2 > 0 && (mul *= 256))
      val += this[offset + --i2] * mul;
    if (mul *= 128, val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 2, this.length);
    let val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 2, this.length);
    let val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0, validateNumber(offset, "offset");
    let first = this[offset], last = this[offset + 7];
    if (first === undefined || last === undefined)
      boundsError(offset, this.length - 8);
    let val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 65536 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 65536 + this[++offset] * 16777216);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0, validateNumber(offset, "offset");
    let first = this[offset], last = this[offset + 7];
    if (first === undefined || last === undefined)
      boundsError(offset, this.length - 8);
    let val = (first << 24) + this[++offset] * 65536 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 16777216 + this[++offset] * 65536 + this[++offset] * 256 + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 4, this.length);
    return read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 4, this.length);
    return read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 8, this.length);
    return read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 8, this.length);
    return read(this, offset, false, 52, 8);
  };
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
    if (value = +value, offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert) {
      let maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let mul = 1, i2 = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength2 && (mul *= 256))
      this[offset + i2] = value / mul & 255;
    return offset + byteLength2;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
    if (value = +value, offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert) {
      let maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let i2 = byteLength2 - 1, mul = 1;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256))
      this[offset + i2] = value / mul & 255;
    return offset + byteLength2;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    return this[offset] = value & 255, offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    return this[offset] = value & 255, this[offset + 1] = value >>> 8, offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    return this[offset] = value >>> 8, this[offset + 1] = value & 255, offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    return this[offset + 3] = value >>> 24, this[offset + 2] = value >>> 16, this[offset + 1] = value >>> 8, this[offset] = value & 255, offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    return this[offset] = value >>> 24, this[offset + 1] = value >>> 16, this[offset + 2] = value >>> 8, this[offset + 3] = value & 255, offset + 4;
  };
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert) {
      let limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i2 = 0, mul = 1, sub = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength2 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0)
        sub = 1;
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert) {
      let limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i2 = byteLength2 - 1, mul = 1, sub = 0;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0)
        sub = 1;
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    return this[offset] = value & 255, offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    return this[offset] = value & 255, this[offset + 1] = value >>> 8, offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    return this[offset] = value >>> 8, this[offset + 1] = value & 255, offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    return this[offset] = value & 255, this[offset + 1] = value >>> 8, this[offset + 2] = value >>> 16, this[offset + 3] = value >>> 24, offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    return this[offset] = value >>> 24, this[offset + 1] = value >>> 16, this[offset + 2] = value >>> 8, this[offset + 3] = value & 255, offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0)
      throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start)
      end = target.length - targetStart + start;
    let len2 = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function")
      this.copyWithin(targetStart, start, end);
    else
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len2;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string")
        encoding = start, start = 0, end = this.length;
      else if (typeof end === "string")
        encoding = end, end = this.length;
      if (encoding !== undefined && typeof encoding !== "string")
        throw new TypeError("encoding must be a string");
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding))
        throw new TypeError("Unknown encoding: " + encoding);
      if (val.length === 1) {
        let code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1")
          val = code2;
      }
    } else if (typeof val === "number")
      val = val & 255;
    else if (typeof val === "boolean")
      val = Number(val);
    if (start < 0 || this.length < start || this.length < end)
      throw new RangeError("Out of range index");
    if (end <= start)
      return this;
    if (start = start >>> 0, end = end === undefined ? this.length : end >>> 0, !val)
      val = 0;
    let i2;
    if (typeof val === "number")
      for (i2 = start;i2 < end; ++i2)
        this[i2] = val;
    else {
      let bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding), len2 = bytes.length;
      if (len2 === 0)
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      for (i2 = 0;i2 < end - start; ++i2)
        this[i2 + start] = bytes[i2 % len2];
    }
    return this;
  };
  INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  hexSliceLookupTable = function() {
    let table = new Array(256);
    for (let i2 = 0;i2 < 16; ++i2) {
      let i16 = i2 * 16;
      for (let j3 = 0;j3 < 16; ++j3)
        table[i16 + j3] = "0123456789abcdef"[i2] + "0123456789abcdef"[j3];
    }
    return table;
  }();
  resolveObjectURL = notimpl("resolveObjectURL");
  isUtf8 = notimpl("isUtf8");
  transcode = notimpl("transcode");
  buffer_default = Buffer2;
});

// node:util
var exports_util = {};
__export(exports_util, {
  types: () => types,
  promisify: () => promisify,
  log: () => log,
  isUndefined: () => isUndefined,
  isSymbol: () => isSymbol,
  isString: () => isString,
  isRegExp: () => isRegExp,
  isPrimitive: () => isPrimitive,
  isObject: () => isObject,
  isNumber: () => isNumber,
  isNullOrUndefined: () => isNullOrUndefined,
  isNull: () => isNull,
  isFunction: () => isFunction,
  isError: () => isError,
  isDate: () => isDate,
  isBuffer: () => isBuffer2,
  isBoolean: () => isBoolean,
  isArray: () => isArray,
  inspect: () => inspect2,
  inherits: () => inherits,
  format: () => format2,
  deprecate: () => deprecate,
  default: () => util_default,
  debuglog: () => debuglog,
  callbackifyOnRejected: () => callbackifyOnRejected,
  callbackify: () => callbackify,
  _extend: () => _extend,
  TextEncoder: () => TextEncoder2,
  TextDecoder: () => TextDecoder2
});
function format2(f2, ...args) {
  if (!isString(f2)) {
    var objects = [f2];
    for (var i2 = 0;i2 < args.length; i2++)
      objects.push(inspect2(args[i2]));
    return objects.join(" ");
  }
  var i2 = 0, len2 = args.length, str = String(f2).replace(formatRegExp, function(x22) {
    if (x22 === "%%")
      return "%";
    if (i2 >= len2)
      return x22;
    switch (x22) {
      case "%s":
        return String(args[i2++]);
      case "%d":
        return Number(args[i2++]);
      case "%j":
        try {
          return JSON.stringify(args[i2++]);
        } catch (_3) {
          return "[Circular]";
        }
      default:
        return x22;
    }
  });
  for (var x4 = args[i2];i2 < len2; x4 = args[++i2])
    if (isNull(x4) || !isObject(x4))
      str += " " + x4;
    else
      str += " " + inspect2(x4);
  return str;
}
function deprecate(fn2, msg) {
  if (typeof process === "undefined" || process?.noDeprecation === true)
    return fn2;
  var warned = false;
  function deprecated(...args) {
    if (!warned) {
      if (process.throwDeprecation)
        throw new Error(msg);
      else if (process.traceDeprecation)
        console.trace(msg);
      else
        console.error(msg);
      warned = true;
    }
    return fn2.apply(this, ...args);
  }
  return deprecated;
}
function stylizeWithColor(str, styleType) {
  var style = inspect2.styles[styleType];
  if (style)
    return "\x1B[" + inspect2.colors[style][0] + "m" + str + "\x1B[" + inspect2.colors[style][1] + "m";
  else
    return str;
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  return array.forEach(function(val, idx) {
    hash[val] = true;
  }), hash;
}
function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== inspect2 && !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret))
      ret = formatValue(ctx, ret, recurseTimes);
    return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive)
    return primitive;
  var keys = Object.keys(value), visibleKeys = arrayToHash(keys);
  if (ctx.showHidden)
    keys = Object.getOwnPropertyNames(value);
  if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0))
    return formatError(value);
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ": " + value.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp(value))
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    if (isDate(value))
      return ctx.stylize(Date.prototype.toString.call(value), "date");
    if (isError(value))
      return formatError(value);
  }
  var base = "", array = false, braces = ["{", "}"];
  if (isArray(value))
    array = true, braces = ["[", "]"];
  if (isFunction(value)) {
    var n = value.name ? ": " + value.name : "";
    base = " [Function" + n + "]";
  }
  if (isRegExp(value))
    base = " " + RegExp.prototype.toString.call(value);
  if (isDate(value))
    base = " " + Date.prototype.toUTCString.call(value);
  if (isError(value))
    base = " " + formatError(value);
  if (keys.length === 0 && (!array || value.length == 0))
    return braces[0] + base + braces[1];
  if (recurseTimes < 0)
    if (isRegExp(value))
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    else
      return ctx.stylize("[Object]", "special");
  ctx.seen.push(value);
  var output;
  if (array)
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  else
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  return ctx.seen.pop(), reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize("undefined", "undefined");
  if (isString(value)) {
    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value))
    return ctx.stylize("" + value, "number");
  if (isBoolean(value))
    return ctx.stylize("" + value, "boolean");
  if (isNull(value))
    return ctx.stylize("null", "null");
}
function formatError(value) {
  return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i2 = 0, l3 = value.length;i2 < l3; ++i2)
    if (hasOwnProperty(value, String(i2)))
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i2), true));
    else
      output.push("");
  return keys.forEach(function(key) {
    if (!key.match(/^\d+$/))
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
  }), output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  if (desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] }, desc.get)
    if (desc.set)
      str = ctx.stylize("[Getter/Setter]", "special");
    else
      str = ctx.stylize("[Getter]", "special");
  else if (desc.set)
    str = ctx.stylize("[Setter]", "special");
  if (!hasOwnProperty(visibleKeys, key))
    name = "[" + key + "]";
  if (!str)
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes))
        str = formatValue(ctx, desc.value, null);
      else
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      if (str.indexOf(`
`) > -1)
        if (array)
          str = str.split(`
`).map(function(line) {
            return "  " + line;
          }).join(`
`).slice(2);
        else
          str = `
` + str.split(`
`).map(function(line) {
            return "   " + line;
          }).join(`
`);
    } else
      str = ctx.stylize("[Circular]", "special");
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/))
      return str;
    if (name = JSON.stringify("" + key), name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/))
      name = name.slice(1, -1), name = ctx.stylize(name, "name");
    else
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), name = ctx.stylize(name, "string");
  }
  return name + ": " + str;
}
function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0, length = output.reduce(function(prev, cur) {
    if (numLinesEst++, cur.indexOf(`
`) >= 0)
      numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length > 60)
    return braces[0] + (base === "" ? "" : base + `
 `) + " " + output.join(`,
  `) + " " + braces[1];
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
function isArray(ar3) {
  return Array.isArray(ar3);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return arg == null;
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isString(arg) {
  return typeof arg === "string";
}
function isSymbol(arg) {
  return typeof arg === "symbol";
}
function isUndefined(arg) {
  return arg === undefined;
}
function isRegExp(re2) {
  return isObject(re2) && objectToString(re2) === "[object RegExp]";
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate(d3) {
  return isObject(d3) && objectToString(d3) === "[object Date]";
}
function isError(e2) {
  return isObject(e2) && (objectToString(e2) === "[object Error]" || e2 instanceof Error);
}
function isFunction(arg) {
  return typeof arg === "function";
}
function isPrimitive(arg) {
  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
}
function isBuffer2(arg) {
  return arg instanceof Buffer;
}
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function pad(n) {
  return n < 10 ? "0" + n.toString(10) : n.toString(10);
}
function timestamp() {
  var d3 = new Date, time = [pad(d3.getHours()), pad(d3.getMinutes()), pad(d3.getSeconds())].join(":");
  return [d3.getDate(), months[d3.getMonth()], time].join(" ");
}
function log(...args) {
  console.log("%s - %s", timestamp(), format2.apply(null, args));
}
function inherits(ctor, superCtor) {
  if (superCtor)
    ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } });
}
function _extend(origin, add) {
  if (!add || !isObject(add))
    return origin;
  var keys = Object.keys(add), i2 = keys.length;
  while (i2--)
    origin[keys[i2]] = add[keys[i2]];
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function callbackifyOnRejected(reason, cb) {
  if (!reason) {
    var newReason = new Error("Promise was rejected with a falsy value");
    newReason.reason = reason, reason = newReason;
  }
  return cb(reason);
}
function callbackify(original) {
  if (typeof original !== "function")
    throw new TypeError('The "original" argument must be of type Function');
  function callbackified(...args) {
    var maybeCb = args.pop();
    if (typeof maybeCb !== "function")
      throw new TypeError("The last argument must be of type Function");
    var self2 = this, cb = function(...args2) {
      return maybeCb.apply(self2, ...args2);
    };
    original.apply(this, args).then(function(ret) {
      process.nextTick(cb.bind(null, null, ret));
    }, function(rej) {
      process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
    });
  }
  return Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original)), Object.defineProperties(callbackified, Object.getOwnPropertyDescriptors(original)), callbackified;
}
var formatRegExp, debuglog, inspect2, types = () => {}, months, promisify, TextEncoder2, TextDecoder2, util_default;
var init_util = __esm(() => {
  formatRegExp = /%[sdj%]/g;
  debuglog = ((debugs = {}, debugEnvRegex = {}, debugEnv) => ((debugEnv = typeof process !== "undefined" && false) && (debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase()), debugEnvRegex = new RegExp("^" + debugEnv + "$", "i"), (set) => {
    if (set = set.toUpperCase(), !debugs[set])
      if (debugEnvRegex.test(set))
        debugs[set] = function(...args) {
          console.error("%s: %s", set, pid, format2.apply(null, ...args));
        };
      else
        debugs[set] = function() {};
    return debugs[set];
  }))();
  inspect2 = ((i2) => (i2.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, i2.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, i2.custom = Symbol.for("nodejs.util.inspect.custom"), i2))(function inspect22(obj, opts, ...rest) {
    var ctx = { seen: [], stylize: stylizeNoColor };
    if (rest.length >= 1)
      ctx.depth = rest[0];
    if (rest.length >= 2)
      ctx.colors = rest[1];
    if (isBoolean(opts))
      ctx.showHidden = opts;
    else if (opts)
      _extend(ctx, opts);
    if (isUndefined(ctx.showHidden))
      ctx.showHidden = false;
    if (isUndefined(ctx.depth))
      ctx.depth = 2;
    if (isUndefined(ctx.colors))
      ctx.colors = false;
    if (ctx.colors)
      ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  });
  months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  promisify = ((x4) => (x4.custom = Symbol.for("nodejs.util.promisify.custom"), x4))(function promisify2(original) {
    if (typeof original !== "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
      var fn2 = original[kCustomPromisifiedSymbol];
      if (typeof fn2 !== "function")
        throw new TypeError('The "nodejs.util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(fn2, kCustomPromisifiedSymbol, { value: fn2, enumerable: false, writable: false, configurable: true }), fn2;
    }
    function fn2(...args) {
      var promiseResolve, promiseReject, promise = new Promise(function(resolve2, reject) {
        promiseResolve = resolve2, promiseReject = reject;
      });
      args.push(function(err, value) {
        if (err)
          promiseReject(err);
        else
          promiseResolve(value);
      });
      try {
        original.apply(this, args);
      } catch (err) {
        promiseReject(err);
      }
      return promise;
    }
    if (Object.setPrototypeOf(fn2, Object.getPrototypeOf(original)), kCustomPromisifiedSymbol)
      Object.defineProperty(fn2, kCustomPromisifiedSymbol, { value: fn2, enumerable: false, writable: false, configurable: true });
    return Object.defineProperties(fn2, Object.getOwnPropertyDescriptors(original));
  });
  ({ TextEncoder: TextEncoder2, TextDecoder: TextDecoder2 } = globalThis);
  util_default = { TextEncoder: TextEncoder2, TextDecoder: TextDecoder2, promisify, log, inherits, _extend, callbackifyOnRejected, callbackify };
});

// node:events
var exports_events = {};
__export(exports_events, {
  setMaxListeners: () => setMaxListeners2,
  once: () => once2,
  listenerCount: () => listenerCount2,
  init: () => EventEmitter,
  getMaxListeners: () => getMaxListeners2,
  getEventListeners: () => getEventListeners,
  default: () => events_default,
  captureRejectionSymbol: () => captureRejectionSymbol,
  addAbortListener: () => addAbortListener,
  EventEmitter: () => EventEmitter
});
function emitError(emitter, args) {
  var { _events: events } = emitter;
  if (args[0] ??= new Error("Unhandled error."), !events)
    throw args[0];
  var errorMonitor = events[kErrorMonitor];
  if (errorMonitor)
    for (var handler of ArrayPrototypeSlice.call(errorMonitor))
      handler.apply(emitter, args);
  var handlers = events.error;
  if (!handlers)
    throw args[0];
  for (var handler of ArrayPrototypeSlice.call(handlers))
    handler.apply(emitter, args);
  return true;
}
function addCatch(emitter, promise, type, args) {
  promise.then(undefined, function(err) {
    queueMicrotask(() => emitUnhandledRejectionOrErr(emitter, err, type, args));
  });
}
function emitUnhandledRejectionOrErr(emitter, err, type, args) {
  if (typeof emitter[kRejection] === "function")
    emitter[kRejection](err, type, ...args);
  else
    try {
      emitter[kCapture] = false, emitter.emit("error", err);
    } finally {
      emitter[kCapture] = true;
    }
}
function overflowWarning(emitter, type, handlers) {
  handlers.warned = true;
  let warn = new Error(`Possible EventEmitter memory leak detected. ${handlers.length} ${String(type)} listeners added to [${emitter.constructor.name}]. Use emitter.setMaxListeners() to increase limit`);
  warn.name = "MaxListenersExceededWarning", warn.emitter = emitter, warn.type = type, warn.count = handlers.length, console.warn(warn);
}
function onceWrapper(type, listener, ...args) {
  this.removeListener(type, listener), listener.apply(this, args);
}
function once2(emitter, type, options) {
  var signal = options?.signal;
  if (validateAbortSignal(signal, "options.signal"), signal?.aborted)
    throw new AbortError(undefined, { cause: signal?.reason });
  let { resolve: resolve2, reject, promise } = $newPromiseCapability(Promise), errorListener = (err) => {
    if (emitter.removeListener(type, resolver), signal != null)
      eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
    reject(err);
  }, resolver = (...args) => {
    if (typeof emitter.removeListener === "function")
      emitter.removeListener("error", errorListener);
    if (signal != null)
      eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
    resolve2(args);
  };
  if (eventTargetAgnosticAddListener(emitter, type, resolver, { once: true }), type !== "error" && typeof emitter.once === "function")
    emitter.once("error", errorListener);
  function abortListener() {
    eventTargetAgnosticRemoveListener(emitter, type, resolver), eventTargetAgnosticRemoveListener(emitter, "error", errorListener), reject(new AbortError(undefined, { cause: signal?.reason }));
  }
  if (signal != null)
    eventTargetAgnosticAddListener(signal, "abort", abortListener, { once: true });
  return promise;
}
function getEventListeners(emitter, type) {
  return emitter.listeners(type);
}
function setMaxListeners2(n, ...eventTargets) {
  validateNumber2(n, "setMaxListeners", 0);
  var length;
  if (eventTargets && (length = eventTargets.length))
    for (let i2 = 0;i2 < length; i2++)
      eventTargets[i2].setMaxListeners(n);
  else
    defaultMaxListeners = n;
}
function listenerCount2(emitter, type) {
  return emitter.listenerCount(type);
}
function eventTargetAgnosticRemoveListener(emitter, name, listener, flags) {
  if (typeof emitter.removeListener === "function")
    emitter.removeListener(name, listener);
  else
    emitter.removeEventListener(name, listener, flags);
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === "function")
    if (flags.once)
      emitter.once(name, listener);
    else
      emitter.on(name, listener);
  else
    emitter.addEventListener(name, listener, flags);
}
function ERR_INVALID_ARG_TYPE2(name, type, value) {
  let err = new TypeError(`The "${name}" argument must be of type ${type}. Received ${value}`);
  return err.code = "ERR_INVALID_ARG_TYPE", err;
}
function ERR_OUT_OF_RANGE2(name, range, value) {
  let err = new RangeError(`The "${name}" argument is out of range. It must be ${range}. Received ${value}`);
  return err.code = "ERR_OUT_OF_RANGE", err;
}
function validateAbortSignal(signal, name) {
  if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal)))
    throw ERR_INVALID_ARG_TYPE2(name, "AbortSignal", signal);
}
function validateNumber2(value, name, min, max) {
  if (typeof value !== "number")
    throw ERR_INVALID_ARG_TYPE2(name, "number", value);
  if (min != null && value < min || max != null && value > max || (min != null || max != null) && Number.isNaN(value))
    throw ERR_OUT_OF_RANGE2(name, `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`, value);
}
function checkListener(listener) {
  if (typeof listener !== "function")
    throw new TypeError("The listener must be a function");
}
function validateBoolean(value, name) {
  if (typeof value !== "boolean")
    throw ERR_INVALID_ARG_TYPE2(name, "boolean", value);
}
function getMaxListeners2(emitterOrTarget) {
  return emitterOrTarget?._maxListeners ?? defaultMaxListeners;
}
function addAbortListener(signal, listener) {
  if (signal === undefined)
    throw ERR_INVALID_ARG_TYPE2("signal", "AbortSignal", signal);
  if (validateAbortSignal(signal, "signal"), typeof listener !== "function")
    throw ERR_INVALID_ARG_TYPE2("listener", "function", listener);
  let removeEventListener;
  if (signal.aborted)
    queueMicrotask(() => listener());
  else
    signal.addEventListener("abort", listener, { __proto__: null, once: true }), removeEventListener = () => {
      signal.removeEventListener("abort", listener);
    };
  return { __proto__: null, [Symbol.dispose]() {
    removeEventListener?.();
  } };
}
var SymbolFor, kCapture, kErrorMonitor, kMaxEventTargetListeners, kMaxEventTargetListenersWarned, kRejection, captureRejectionSymbol, ArrayPrototypeSlice, defaultMaxListeners = 10, EventEmitter = function EventEmitter2(opts) {
  if (this._events === undefined || this._events === this.__proto__._events)
    this._events = { __proto__: null }, this._eventsCount = 0;
  if (this._maxListeners ??= undefined, this[kCapture] = opts?.captureRejections ? Boolean(opts?.captureRejections) : EventEmitterPrototype[kCapture])
    this.emit = emitWithRejectionCapture;
}, EventEmitterPrototype, emitWithoutRejectionCapture = function emit(type, ...args) {
  if (type === "error")
    return emitError(this, args);
  var { _events: events } = this;
  if (events === undefined)
    return false;
  var handlers = events[type];
  if (handlers === undefined)
    return false;
  let maybeClonedHandlers = handlers.length > 1 ? handlers.slice() : handlers;
  for (let i2 = 0, { length } = maybeClonedHandlers;i2 < length; i2++) {
    let handler = maybeClonedHandlers[i2];
    switch (args.length) {
      case 0:
        handler.call(this);
        break;
      case 1:
        handler.call(this, args[0]);
        break;
      case 2:
        handler.call(this, args[0], args[1]);
        break;
      case 3:
        handler.call(this, args[0], args[1], args[2]);
        break;
      default:
        handler.apply(this, args);
        break;
    }
  }
  return true;
}, emitWithRejectionCapture = function emit2(type, ...args) {
  if (type === "error")
    return emitError(this, args);
  var { _events: events } = this;
  if (events === undefined)
    return false;
  var handlers = events[type];
  if (handlers === undefined)
    return false;
  let maybeClonedHandlers = handlers.length > 1 ? handlers.slice() : handlers;
  for (let i2 = 0, { length } = maybeClonedHandlers;i2 < length; i2++) {
    let handler = maybeClonedHandlers[i2], result;
    switch (args.length) {
      case 0:
        result = handler.call(this);
        break;
      case 1:
        result = handler.call(this, args[0]);
        break;
      case 2:
        result = handler.call(this, args[0], args[1]);
        break;
      case 3:
        result = handler.call(this, args[0], args[1], args[2]);
        break;
      default:
        result = handler.apply(this, args);
        break;
    }
    if (result !== undefined && typeof result?.then === "function" && result.then === Promise.prototype.then)
      addCatch(this, result, type, args);
  }
  return true;
}, AbortError, events_default;
var init_events = __esm(() => {
  SymbolFor = Symbol.for;
  kCapture = Symbol("kCapture");
  kErrorMonitor = SymbolFor("events.errorMonitor");
  kMaxEventTargetListeners = Symbol("events.maxEventTargetListeners");
  kMaxEventTargetListenersWarned = Symbol("events.maxEventTargetListenersWarned");
  kRejection = SymbolFor("nodejs.rejection");
  captureRejectionSymbol = SymbolFor("nodejs.rejection");
  ArrayPrototypeSlice = Array.prototype.slice;
  EventEmitterPrototype = EventEmitter.prototype = {};
  EventEmitterPrototype._events = undefined;
  EventEmitterPrototype._eventsCount = 0;
  EventEmitterPrototype._maxListeners = undefined;
  EventEmitterPrototype.setMaxListeners = function setMaxListeners(n) {
    return validateNumber2(n, "setMaxListeners", 0), this._maxListeners = n, this;
  };
  EventEmitterPrototype.constructor = EventEmitter;
  EventEmitterPrototype.getMaxListeners = function getMaxListeners() {
    return this?._maxListeners ?? defaultMaxListeners;
  };
  EventEmitterPrototype.emit = emitWithoutRejectionCapture;
  EventEmitterPrototype.addListener = function addListener(type, fn2) {
    checkListener(fn2);
    var events = this._events;
    if (!events)
      events = this._events = { __proto__: null }, this._eventsCount = 0;
    else if (events.newListener)
      this.emit("newListener", type, fn2.listener ?? fn2);
    var handlers = events[type];
    if (!handlers)
      events[type] = [fn2], this._eventsCount++;
    else {
      handlers.push(fn2);
      var m2 = this._maxListeners ?? defaultMaxListeners;
      if (m2 > 0 && handlers.length > m2 && !handlers.warned)
        overflowWarning(this, type, handlers);
    }
    return this;
  };
  EventEmitterPrototype.on = EventEmitterPrototype.addListener;
  EventEmitterPrototype.prependListener = function prependListener(type, fn2) {
    checkListener(fn2);
    var events = this._events;
    if (!events)
      events = this._events = { __proto__: null }, this._eventsCount = 0;
    else if (events.newListener)
      this.emit("newListener", type, fn2.listener ?? fn2);
    var handlers = events[type];
    if (!handlers)
      events[type] = [fn2], this._eventsCount++;
    else {
      handlers.unshift(fn2);
      var m2 = this._maxListeners ?? defaultMaxListeners;
      if (m2 > 0 && handlers.length > m2 && !handlers.warned)
        overflowWarning(this, type, handlers);
    }
    return this;
  };
  EventEmitterPrototype.once = function once(type, fn2) {
    checkListener(fn2);
    let bound = onceWrapper.bind(this, type, fn2);
    return bound.listener = fn2, this.addListener(type, bound), this;
  };
  EventEmitterPrototype.prependOnceListener = function prependOnceListener(type, fn2) {
    checkListener(fn2);
    let bound = onceWrapper.bind(this, type, fn2);
    return bound.listener = fn2, this.prependListener(type, bound), this;
  };
  EventEmitterPrototype.removeListener = function removeListener(type, fn2) {
    checkListener(fn2);
    var { _events: events } = this;
    if (!events)
      return this;
    var handlers = events[type];
    if (!handlers)
      return this;
    var length = handlers.length;
    let position = -1;
    for (let i2 = length - 1;i2 >= 0; i2--)
      if (handlers[i2] === fn2 || handlers[i2].listener === fn2) {
        position = i2;
        break;
      }
    if (position < 0)
      return this;
    if (position === 0)
      handlers.shift();
    else
      handlers.splice(position, 1);
    if (handlers.length === 0)
      delete events[type], this._eventsCount--;
    return this;
  };
  EventEmitterPrototype.off = EventEmitterPrototype.removeListener;
  EventEmitterPrototype.removeAllListeners = function removeAllListeners(type) {
    var { _events: events } = this;
    if (type && events) {
      if (events[type])
        delete events[type], this._eventsCount--;
    } else
      this._events = { __proto__: null };
    return this;
  };
  EventEmitterPrototype.listeners = function listeners(type) {
    var { _events: events } = this;
    if (!events)
      return [];
    var handlers = events[type];
    if (!handlers)
      return [];
    return handlers.map((x4) => x4.listener ?? x4);
  };
  EventEmitterPrototype.rawListeners = function rawListeners(type) {
    var { _events } = this;
    if (!_events)
      return [];
    var handlers = _events[type];
    if (!handlers)
      return [];
    return handlers.slice();
  };
  EventEmitterPrototype.listenerCount = function listenerCount(type) {
    var { _events: events } = this;
    if (!events)
      return 0;
    return events[type]?.length ?? 0;
  };
  EventEmitterPrototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
  };
  EventEmitterPrototype[kCapture] = false;
  AbortError = class AbortError extends Error {
    constructor(message = "The operation was aborted", options = undefined) {
      if (options !== undefined && typeof options !== "object")
        throw ERR_INVALID_ARG_TYPE2("options", "Object", options);
      super(message, options);
      this.code = "ABORT_ERR", this.name = "AbortError";
    }
  };
  Object.defineProperties(EventEmitter, { captureRejections: { get() {
    return EventEmitterPrototype[kCapture];
  }, set(value) {
    validateBoolean(value, "EventEmitter.captureRejections"), EventEmitterPrototype[kCapture] = value;
  }, enumerable: true }, defaultMaxListeners: { enumerable: true, get: () => {
    return defaultMaxListeners;
  }, set: (arg) => {
    validateNumber2(arg, "defaultMaxListeners", 0), defaultMaxListeners = arg;
  } }, kMaxEventTargetListeners: { value: kMaxEventTargetListeners, enumerable: false, configurable: false, writable: false }, kMaxEventTargetListenersWarned: { value: kMaxEventTargetListenersWarned, enumerable: false, configurable: false, writable: false } });
  Object.assign(EventEmitter, { once: once2, getEventListeners, getMaxListeners: getMaxListeners2, setMaxListeners: setMaxListeners2, EventEmitter, usingDomains: false, captureRejectionSymbol, errorMonitor: kErrorMonitor, addAbortListener, init: EventEmitter, listenerCount: listenerCount2 });
  events_default = EventEmitter;
});

// node:stream
var require_stream = __commonJS((exports, module) => {
  var __commonJS2 = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
  var require_primordials = __commonJS2((exports2, module2) => {

    class AggregateError extends Error {
      constructor(errors) {
        if (!Array.isArray(errors))
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        let message = "";
        for (let i2 = 0;i2 < errors.length; i2++)
          message += `    ${errors[i2].stack}
`;
        super(message);
        this.name = "AggregateError", this.errors = errors;
      }
    }
    module2.exports = { AggregateError, ArrayIsArray(self2) {
      return Array.isArray(self2);
    }, ArrayPrototypeIncludes(self2, el) {
      return self2.includes(el);
    }, ArrayPrototypeIndexOf(self2, el) {
      return self2.indexOf(el);
    }, ArrayPrototypeJoin(self2, sep2) {
      return self2.join(sep2);
    }, ArrayPrototypeMap(self2, fn2) {
      return self2.map(fn2);
    }, ArrayPrototypePop(self2, el) {
      return self2.pop(el);
    }, ArrayPrototypePush(self2, el) {
      return self2.push(el);
    }, ArrayPrototypeSlice(self2, start, end) {
      return self2.slice(start, end);
    }, Error, FunctionPrototypeCall(fn2, thisArgs, ...args) {
      return fn2.call(thisArgs, ...args);
    }, FunctionPrototypeSymbolHasInstance(self2, instance) {
      return Function.prototype[Symbol.hasInstance].call(self2, instance);
    }, MathFloor: Math.floor, Number, NumberIsInteger: Number.isInteger, NumberIsNaN: Number.isNaN, NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER, NumberParseInt: Number.parseInt, ObjectDefineProperties(self2, props) {
      return Object.defineProperties(self2, props);
    }, ObjectDefineProperty(self2, name, prop) {
      return Object.defineProperty(self2, name, prop);
    }, ObjectGetOwnPropertyDescriptor(self2, name) {
      return Object.getOwnPropertyDescriptor(self2, name);
    }, ObjectKeys(obj) {
      return Object.keys(obj);
    }, ObjectSetPrototypeOf(target, proto) {
      return Object.setPrototypeOf(target, proto);
    }, Promise, PromisePrototypeCatch(self2, fn2) {
      return self2.catch(fn2);
    }, PromisePrototypeThen(self2, thenFn, catchFn) {
      return self2.then(thenFn, catchFn);
    }, PromiseReject(err) {
      return Promise.reject(err);
    }, PromiseResolve(val) {
      return Promise.resolve(val);
    }, ReflectApply: Reflect.apply, RegExpPrototypeTest(self2, value) {
      return self2.test(value);
    }, SafeSet: Set, String, StringPrototypeSlice(self2, start, end) {
      return self2.slice(start, end);
    }, StringPrototypeToLowerCase(self2) {
      return self2.toLowerCase();
    }, StringPrototypeToUpperCase(self2) {
      return self2.toUpperCase();
    }, StringPrototypeTrim(self2) {
      return self2.trim();
    }, Symbol, SymbolFor: Symbol.for, SymbolAsyncIterator: Symbol.asyncIterator, SymbolHasInstance: Symbol.hasInstance, SymbolIterator: Symbol.iterator, SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"), SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"), TypedArrayPrototypeSet(self2, buf, len2) {
      return self2.set(buf, len2);
    }, Boolean, Uint8Array };
  });
  var require_inspect = __commonJS2((exports2, module2) => {
    module2.exports = { format(format3, ...args) {
      return format3.replace(/%([sdifj])/g, function(...[_unused, type]) {
        let replacement = args.shift();
        if (type === "f")
          return replacement.toFixed(6);
        else if (type === "j")
          return JSON.stringify(replacement);
        else if (type === "s" && typeof replacement === "object")
          return `${replacement.constructor !== Object ? replacement.constructor.name : ""} {}`.trim();
        else
          return replacement.toString();
      });
    }, inspect(value) {
      switch (typeof value) {
        case "string":
          if (value.includes("'")) {
            if (!value.includes('"'))
              return `"${value}"`;
            else if (!value.includes("`") && !value.includes("${"))
              return `\`${value}\``;
          }
          return `'${value}'`;
        case "number":
          if (isNaN(value))
            return "NaN";
          else if (Object.is(value, -0))
            return String(value);
          return value;
        case "bigint":
          return `${String(value)}n`;
        case "boolean":
        case "undefined":
          return String(value);
        case "object":
          return "{}";
      }
    } };
  });
  var require_errors = __commonJS2((exports2, module2) => {
    var { format: format3, inspect: inspect3 } = require_inspect(), { AggregateError: CustomAggregateError } = require_primordials(), AggregateError = globalThis.AggregateError || CustomAggregateError, kIsNodeError = Symbol("kIsNodeError"), kTypes = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], classRegExp = /^([A-Z][a-z0-9]*)+$/, codes = {};
    function assert(value, message) {
      if (!value)
        throw new codes.ERR_INTERNAL_ASSERTION(message);
    }
    function addNumericalSeparator2(val) {
      let res = "", i2 = val.length, start = val[0] === "-" ? 1 : 0;
      for (;i2 >= start + 4; i2 -= 3)
        res = `_${val.slice(i2 - 3, i2)}${res}`;
      return `${val.slice(0, i2)}${res}`;
    }
    function getMessage(key, msg, args) {
      if (typeof msg === "function")
        return assert(msg.length <= args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`), msg(...args);
      let expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
      if (assert(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`), args.length === 0)
        return msg;
      return format3(msg, ...args);
    }
    function E4(code2, message, Base) {
      if (!Base)
        Base = Error;

      class NodeError extends Base {
        constructor(...args) {
          super(getMessage(code2, message, args));
        }
        toString() {
          return `${this.name} [${code2}]: ${this.message}`;
        }
      }
      Object.defineProperties(NodeError.prototype, { name: { value: Base.name, writable: true, enumerable: false, configurable: true }, toString: { value() {
        return `${this.name} [${code2}]: ${this.message}`;
      }, writable: true, enumerable: false, configurable: true } }), NodeError.prototype.code = code2, NodeError.prototype[kIsNodeError] = true, codes[code2] = NodeError;
    }
    function hideStackFrames(fn2) {
      let hidden = "__node_internal_" + fn2.name;
      return Object.defineProperty(fn2, "name", { value: hidden }), fn2;
    }
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors))
          return outerError.errors.push(innerError), outerError;
        let err = new AggregateError([outerError, innerError], outerError.message);
        return err.code = outerError.code, err;
      }
      return innerError || outerError;
    }

    class AbortError2 extends Error {
      constructor(message = "The operation was aborted", options = undefined) {
        if (options !== undefined && typeof options !== "object")
          throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        super(message, options);
        this.code = "ABORT_ERR", this.name = "AbortError";
      }
    }
    E4("ERR_ASSERTION", "%s", Error);
    E4("ERR_INVALID_ARG_TYPE", (name, expected, actual) => {
      if (assert(typeof name === "string", "'name' must be a string"), !Array.isArray(expected))
        expected = [expected];
      let msg = "The ";
      if (name.endsWith(" argument"))
        msg += `${name} `;
      else
        msg += `"${name}" ${name.includes(".") ? "property" : "argument"} `;
      msg += "must be ";
      let types2 = [], instances = [], other = [];
      for (let value of expected)
        if (assert(typeof value === "string", "All expected entries have to be of type string"), kTypes.includes(value))
          types2.push(value.toLowerCase());
        else if (classRegExp.test(value))
          instances.push(value);
        else
          assert(value !== "object", 'The value "object" should be written as "Object"'), other.push(value);
      if (instances.length > 0) {
        let pos = types2.indexOf("object");
        if (pos !== -1)
          types2.splice(types2, pos, 1), instances.push("Object");
      }
      if (types2.length > 0) {
        switch (types2.length) {
          case 1:
            msg += `of type ${types2[0]}`;
            break;
          case 2:
            msg += `one of type ${types2[0]} or ${types2[1]}`;
            break;
          default: {
            let last = types2.pop();
            msg += `one of type ${types2.join(", ")}, or ${last}`;
          }
        }
        if (instances.length > 0 || other.length > 0)
          msg += " or ";
      }
      if (instances.length > 0) {
        switch (instances.length) {
          case 1:
            msg += `an instance of ${instances[0]}`;
            break;
          case 2:
            msg += `an instance of ${instances[0]} or ${instances[1]}`;
            break;
          default: {
            let last = instances.pop();
            msg += `an instance of ${instances.join(", ")}, or ${last}`;
          }
        }
        if (other.length > 0)
          msg += " or ";
      }
      switch (other.length) {
        case 0:
          break;
        case 1:
          if (other[0].toLowerCase() !== other[0])
            msg += "an ";
          msg += `${other[0]}`;
          break;
        case 2:
          msg += `one of ${other[0]} or ${other[1]}`;
          break;
        default: {
          let last = other.pop();
          msg += `one of ${other.join(", ")}, or ${last}`;
        }
      }
      if (actual == null)
        msg += `. Received ${actual}`;
      else if (typeof actual === "function" && actual.name)
        msg += `. Received function ${actual.name}`;
      else if (typeof actual === "object") {
        var _actual$constructor;
        if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== undefined && _actual$constructor.name)
          msg += `. Received an instance of ${actual.constructor.name}`;
        else {
          let inspected = inspect3(actual, { depth: -1 });
          msg += `. Received ${inspected}`;
        }
      } else {
        let inspected = inspect3(actual, { colors: false });
        if (inspected.length > 25)
          inspected = `${inspected.slice(0, 25)}...`;
        msg += `. Received type ${typeof actual} (${inspected})`;
      }
      return msg;
    }, TypeError);
    E4("ERR_INVALID_ARG_VALUE", (name, value, reason = "is invalid") => {
      let inspected = inspect3(value);
      if (inspected.length > 128)
        inspected = inspected.slice(0, 128) + "...";
      return `The ${name.includes(".") ? "property" : "argument"} '${name}' ${reason}. Received ${inspected}`;
    }, TypeError);
    E4("ERR_INVALID_RETURN_VALUE", (input, name, value) => {
      var _value$constructor;
      let type = value !== null && value !== undefined && (_value$constructor = value.constructor) !== null && _value$constructor !== undefined && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
      return `Expected ${input} to be returned from the "${name}" function but got ${type}.`;
    }, TypeError);
    E4("ERR_MISSING_ARGS", (...args) => {
      assert(args.length > 0, "At least one arg needs to be specified");
      let msg, len2 = args.length;
      switch (args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or "), len2) {
        case 1:
          msg += `The ${args[0]} argument`;
          break;
        case 2:
          msg += `The ${args[0]} and ${args[1]} arguments`;
          break;
        default:
          {
            let last = args.pop();
            msg += `The ${args.join(", ")}, and ${last} arguments`;
          }
          break;
      }
      return `${msg} must be specified`;
    }, TypeError);
    E4("ERR_OUT_OF_RANGE", (str, range, input) => {
      assert(range, 'Missing "range" argument');
      let received;
      if (Number.isInteger(input) && Math.abs(input) > 4294967296)
        received = addNumericalSeparator2(String(input));
      else if (typeof input === "bigint") {
        received = String(input);
        let limit = BigInt(2) ** BigInt(32);
        if (input > limit || input < -limit)
          received = addNumericalSeparator2(received);
        received += "n";
      } else
        received = inspect3(input);
      return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
    }, RangeError);
    E4("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    E4("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    E4("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    E4("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    E4("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    E4("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    E4("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    E4("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    E4("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    E4("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    E4("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    module2.exports = { AbortError: AbortError2, aggregateTwoErrors: hideStackFrames(aggregateTwoErrors), hideStackFrames, codes };
  });
  var require_event_target_shim = __commonJS2((exports2, module2) => {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var privateData = new WeakMap, wrappers = new WeakMap;
    function pd(event) {
      let retv = privateData.get(event);
      return console.assert(retv != null, "'this' is expected an Event object, but got", event), retv;
    }
    function setCancelFlag(data) {
      if (data.passiveListener != null) {
        if (typeof console !== "undefined" && typeof console.error === "function")
          console.error("Unable to preventDefault inside passive event listener invocation.", data.passiveListener);
        return;
      }
      if (!data.event.cancelable)
        return;
      if (data.canceled = true, typeof data.event.preventDefault === "function")
        data.event.preventDefault();
    }
    function Event(eventTarget, event) {
      privateData.set(this, { eventTarget, event, eventPhase: 2, currentTarget: eventTarget, canceled: false, stopped: false, immediateStopped: false, passiveListener: null, timeStamp: event.timeStamp || Date.now() }), Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
      let keys = Object.keys(event);
      for (let i2 = 0;i2 < keys.length; ++i2) {
        let key = keys[i2];
        if (!(key in this))
          Object.defineProperty(this, key, defineRedirectDescriptor(key));
      }
    }
    Event.prototype = { get type() {
      return pd(this).event.type;
    }, get target() {
      return pd(this).eventTarget;
    }, get currentTarget() {
      return pd(this).currentTarget;
    }, composedPath() {
      let currentTarget = pd(this).currentTarget;
      if (currentTarget == null)
        return [];
      return [currentTarget];
    }, get NONE() {
      return 0;
    }, get CAPTURING_PHASE() {
      return 1;
    }, get AT_TARGET() {
      return 2;
    }, get BUBBLING_PHASE() {
      return 3;
    }, get eventPhase() {
      return pd(this).eventPhase;
    }, stopPropagation() {
      let data = pd(this);
      if (data.stopped = true, typeof data.event.stopPropagation === "function")
        data.event.stopPropagation();
    }, stopImmediatePropagation() {
      let data = pd(this);
      if (data.stopped = true, data.immediateStopped = true, typeof data.event.stopImmediatePropagation === "function")
        data.event.stopImmediatePropagation();
    }, get bubbles() {
      return Boolean(pd(this).event.bubbles);
    }, get cancelable() {
      return Boolean(pd(this).event.cancelable);
    }, preventDefault() {
      setCancelFlag(pd(this));
    }, get defaultPrevented() {
      return pd(this).canceled;
    }, get composed() {
      return Boolean(pd(this).event.composed);
    }, get timeStamp() {
      return pd(this).timeStamp;
    }, get srcElement() {
      return pd(this).eventTarget;
    }, get cancelBubble() {
      return pd(this).stopped;
    }, set cancelBubble(value) {
      if (!value)
        return;
      let data = pd(this);
      if (data.stopped = true, typeof data.event.cancelBubble === "boolean")
        data.event.cancelBubble = true;
    }, get returnValue() {
      return !pd(this).canceled;
    }, set returnValue(value) {
      if (!value)
        setCancelFlag(pd(this));
    }, initEvent() {} };
    Object.defineProperty(Event.prototype, "constructor", { value: Event, configurable: true, writable: true });
    if (typeof window !== "undefined" && typeof window.Event !== "undefined")
      Object.setPrototypeOf(Event.prototype, window.Event.prototype), wrappers.set(window.Event.prototype, Event);
    function defineRedirectDescriptor(key) {
      return { get() {
        return pd(this).event[key];
      }, set(value) {
        pd(this).event[key] = value;
      }, configurable: true, enumerable: true };
    }
    function defineCallDescriptor(key) {
      return { value() {
        let event = pd(this).event;
        return event[key].apply(event, arguments);
      }, configurable: true, enumerable: true };
    }
    function defineWrapper(BaseEvent, proto) {
      let keys = Object.keys(proto);
      if (keys.length === 0)
        return BaseEvent;
      function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
      }
      CustomEvent.prototype = Object.create(BaseEvent.prototype, { constructor: { value: CustomEvent, configurable: true, writable: true } });
      for (let i2 = 0;i2 < keys.length; ++i2) {
        let key = keys[i2];
        if (!(key in BaseEvent.prototype)) {
          let isFunc = typeof Object.getOwnPropertyDescriptor(proto, key).value === "function";
          Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));
        }
      }
      return CustomEvent;
    }
    function getWrapper(proto) {
      if (proto == null || proto === Object.prototype)
        return Event;
      let wrapper = wrappers.get(proto);
      if (wrapper == null)
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto), wrappers.set(proto, wrapper);
      return wrapper;
    }
    function wrapEvent(eventTarget, event) {
      return new (getWrapper(Object.getPrototypeOf(event)))(eventTarget, event);
    }
    function isStopped(event) {
      return pd(event).immediateStopped;
    }
    function setEventPhase(event, eventPhase) {
      pd(event).eventPhase = eventPhase;
    }
    function setCurrentTarget(event, currentTarget) {
      pd(event).currentTarget = currentTarget;
    }
    function setPassiveListener(event, passiveListener) {
      pd(event).passiveListener = passiveListener;
    }
    var listenersMap = new WeakMap, CAPTURE = 1, BUBBLE = 2, ATTRIBUTE = 3;
    function isObject2(x4) {
      return x4 !== null && typeof x4 === "object";
    }
    function getListeners(eventTarget) {
      let listeners2 = listenersMap.get(eventTarget);
      if (listeners2 == null)
        throw new TypeError("'this' is expected an EventTarget object, but got another value.");
      return listeners2;
    }
    function defineEventAttributeDescriptor(eventName) {
      return { get() {
        let node = getListeners(this).get(eventName);
        while (node != null) {
          if (node.listenerType === ATTRIBUTE)
            return node.listener;
          node = node.next;
        }
        return null;
      }, set(listener) {
        if (typeof listener !== "function" && !isObject2(listener))
          listener = null;
        let listeners2 = getListeners(this), prev = null, node = listeners2.get(eventName);
        while (node != null) {
          if (node.listenerType === ATTRIBUTE)
            if (prev !== null)
              prev.next = node.next;
            else if (node.next !== null)
              listeners2.set(eventName, node.next);
            else
              listeners2.delete(eventName);
          else
            prev = node;
          node = node.next;
        }
        if (listener !== null) {
          let newNode = { listener, listenerType: ATTRIBUTE, passive: false, once: false, next: null };
          if (prev === null)
            listeners2.set(eventName, newNode);
          else
            prev.next = newNode;
        }
      }, configurable: true, enumerable: true };
    }
    function defineEventAttribute(eventTargetPrototype, eventName) {
      Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));
    }
    function defineCustomEventTarget(eventNames2) {
      function CustomEventTarget() {
        EventTarget.call(this);
      }
      CustomEventTarget.prototype = Object.create(EventTarget.prototype, { constructor: { value: CustomEventTarget, configurable: true, writable: true } });
      for (let i2 = 0;i2 < eventNames2.length; ++i2)
        defineEventAttribute(CustomEventTarget.prototype, eventNames2[i2]);
      return CustomEventTarget;
    }
    function EventTarget() {
      if (this instanceof EventTarget) {
        listenersMap.set(this, new Map);
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0]))
        return defineCustomEventTarget(arguments[0]);
      if (arguments.length > 0) {
        let types2 = new Array(arguments.length);
        for (let i2 = 0;i2 < arguments.length; ++i2)
          types2[i2] = arguments[i2];
        return defineCustomEventTarget(types2);
      }
      throw new TypeError("Cannot call a class as a function");
    }
    EventTarget.prototype = { addEventListener(eventName, listener, options) {
      if (listener == null)
        return;
      if (typeof listener !== "function" && !isObject2(listener))
        throw new TypeError("'listener' should be a function or an object.");
      let listeners2 = getListeners(this), optionsIsObj = isObject2(options), listenerType = (optionsIsObj ? Boolean(options.capture) : Boolean(options)) ? CAPTURE : BUBBLE, newNode = { listener, listenerType, passive: optionsIsObj && Boolean(options.passive), once: optionsIsObj && Boolean(options.once), next: null }, node = listeners2.get(eventName);
      if (node === undefined) {
        listeners2.set(eventName, newNode);
        return;
      }
      let prev = null;
      while (node != null) {
        if (node.listener === listener && node.listenerType === listenerType)
          return;
        prev = node, node = node.next;
      }
      prev.next = newNode;
    }, removeEventListener(eventName, listener, options) {
      if (listener == null)
        return;
      let listeners2 = getListeners(this), listenerType = (isObject2(options) ? Boolean(options.capture) : Boolean(options)) ? CAPTURE : BUBBLE, prev = null, node = listeners2.get(eventName);
      while (node != null) {
        if (node.listener === listener && node.listenerType === listenerType) {
          if (prev !== null)
            prev.next = node.next;
          else if (node.next !== null)
            listeners2.set(eventName, node.next);
          else
            listeners2.delete(eventName);
          return;
        }
        prev = node, node = node.next;
      }
    }, dispatchEvent(event) {
      if (event == null || typeof event.type !== "string")
        throw new TypeError('"event.type" should be a string.');
      let listeners2 = getListeners(this), eventName = event.type, node = listeners2.get(eventName);
      if (node == null)
        return true;
      let wrappedEvent = wrapEvent(this, event), prev = null;
      while (node != null) {
        if (node.once)
          if (prev !== null)
            prev.next = node.next;
          else if (node.next !== null)
            listeners2.set(eventName, node.next);
          else
            listeners2.delete(eventName);
        else
          prev = node;
        if (setPassiveListener(wrappedEvent, node.passive ? node.listener : null), typeof node.listener === "function")
          try {
            node.listener.call(this, wrappedEvent);
          } catch (err) {
            if (typeof console !== "undefined" && typeof console.error === "function")
              console.error(err);
          }
        else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function")
          node.listener.handleEvent(wrappedEvent);
        if (isStopped(wrappedEvent))
          break;
        node = node.next;
      }
      return setPassiveListener(wrappedEvent, null), setEventPhase(wrappedEvent, 0), setCurrentTarget(wrappedEvent, null), !wrappedEvent.defaultPrevented;
    } };
    Object.defineProperty(EventTarget.prototype, "constructor", { value: EventTarget, configurable: true, writable: true });
    if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined")
      Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
    exports2.defineEventAttribute = defineEventAttribute;
    exports2.EventTarget = EventTarget;
    exports2.default = EventTarget;
    module2.exports = EventTarget;
    module2.exports.EventTarget = module2.exports.default = EventTarget;
    module2.exports.defineEventAttribute = defineEventAttribute;
  });
  var require_abort_controller = __commonJS2((exports2, module2) => {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var eventTargetShim = require_event_target_shim();

    class AbortSignal extends eventTargetShim.EventTarget {
      constructor() {
        super();
        throw new TypeError("AbortSignal cannot be constructed directly");
      }
      get aborted() {
        let aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean")
          throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        return aborted;
      }
    }
    eventTargetShim.defineEventAttribute(AbortSignal.prototype, "abort");
    function createAbortSignal() {
      let signal = Object.create(AbortSignal.prototype);
      return eventTargetShim.EventTarget.call(signal), abortedFlags.set(signal, false), signal;
    }
    function abortSignal(signal) {
      if (abortedFlags.get(signal) !== false)
        return;
      abortedFlags.set(signal, true), signal.dispatchEvent({ type: "abort" });
    }
    var abortedFlags = new WeakMap;
    Object.defineProperties(AbortSignal.prototype, { aborted: { enumerable: true } });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol")
      Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, { configurable: true, value: "AbortSignal" });

    class AbortController2 {
      constructor() {
        signals.set(this, createAbortSignal());
      }
      get signal() {
        return getSignal(this);
      }
      abort() {
        abortSignal(getSignal(this));
      }
    }
    var signals = new WeakMap;
    function getSignal(controller) {
      let signal = signals.get(controller);
      if (signal == null)
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
      return signal;
    }
    Object.defineProperties(AbortController2.prototype, { signal: { enumerable: true }, abort: { enumerable: true } });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol")
      Object.defineProperty(AbortController2.prototype, Symbol.toStringTag, { configurable: true, value: "AbortController" });
    exports2.AbortController = AbortController2;
    exports2.AbortSignal = AbortSignal;
    exports2.default = AbortController2;
    module2.exports = AbortController2;
    module2.exports.AbortController = module2.exports.default = AbortController2;
    module2.exports.AbortSignal = AbortSignal;
  });
  var require_util = __commonJS2((exports2, module2) => {
    var bufferModule = (init_buffer(), __toCommonJS(exports_buffer)), { format: format3, inspect: inspect3 } = require_inspect(), { codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3 } } = require_errors(), { kResistStopPropagation, AggregateError, SymbolDispose } = require_primordials(), AbortSignal = globalThis.AbortSignal || require_abort_controller().AbortSignal, AbortController2 = globalThis.AbortController || require_abort_controller().AbortController, AsyncFunction = Object.getPrototypeOf(async function() {}).constructor, Blob3 = globalThis.Blob || bufferModule.Blob, isBlob = typeof Blob3 !== "undefined" ? function isBlob(b) {
      return b instanceof Blob3;
    } : function isBlob(b) {
      return false;
    }, validateAbortSignal2 = (signal, name) => {
      if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal)))
        throw new ERR_INVALID_ARG_TYPE3(name, "AbortSignal", signal);
    }, validateFunction = (value, name) => {
      if (typeof value !== "function")
        throw new ERR_INVALID_ARG_TYPE3(name, "Function", value);
    };
    module2.exports = { AggregateError, kEmptyObject: Object.freeze({}), once(callback) {
      let called = false;
      return function(...args) {
        if (called)
          return;
        called = true, callback.apply(this, args);
      };
    }, createDeferredPromise: function() {
      let resolve2, reject;
      return { promise: new Promise((res, rej) => {
        resolve2 = res, reject = rej;
      }), resolve: resolve2, reject };
    }, promisify(fn2) {
      return new Promise((resolve2, reject) => {
        fn2((err, ...args) => {
          if (err)
            return reject(err);
          return resolve2(...args);
        });
      });
    }, debuglog() {
      return function() {};
    }, format: format3, inspect: inspect3, types: { isAsyncFunction(fn2) {
      return fn2 instanceof AsyncFunction;
    }, isArrayBufferView(arr) {
      return ArrayBuffer.isView(arr);
    } }, isBlob, deprecate(fn2, message) {
      return fn2;
    }, addAbortListener: (init_events(), __toCommonJS(exports_events)).addAbortListener || function addAbortListener(signal, listener) {
      if (signal === undefined)
        throw new ERR_INVALID_ARG_TYPE3("signal", "AbortSignal", signal);
      validateAbortSignal2(signal, "signal"), validateFunction(listener, "listener");
      let removeEventListener;
      if (signal.aborted)
        queueMicrotask(() => listener());
      else
        signal.addEventListener("abort", listener, { __proto__: null, once: true, [kResistStopPropagation]: true }), removeEventListener = () => {
          signal.removeEventListener("abort", listener);
        };
      return { __proto__: null, [SymbolDispose]() {
        var _removeEventListener;
        (_removeEventListener = removeEventListener) === null || _removeEventListener === undefined || _removeEventListener();
      } };
    }, AbortSignalAny: AbortSignal.any || function AbortSignalAny(signals) {
      if (signals.length === 1)
        return signals[0];
      let ac = new AbortController2, abort = () => ac.abort();
      return signals.forEach((signal) => {
        validateAbortSignal2(signal, "signals"), signal.addEventListener("abort", abort, { once: true });
      }), ac.signal.addEventListener("abort", () => {
        signals.forEach((signal) => signal.removeEventListener("abort", abort));
      }, { once: true }), ac.signal;
    } };
    module2.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  });
  var require_validators = __commonJS2((exports2, module2) => {
    var { ArrayIsArray, ArrayPrototypeIncludes, ArrayPrototypeJoin, ArrayPrototypeMap, NumberIsInteger, NumberIsNaN, NumberMAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER, NumberParseInt, ObjectPrototypeHasOwnProperty, RegExpPrototypeExec, String: String2, StringPrototypeToUpperCase, StringPrototypeTrim } = require_primordials(), { hideStackFrames, codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE: ERR_OUT_OF_RANGE3, ERR_UNKNOWN_SIGNAL } } = require_errors(), { normalizeEncoding } = require_util(), { isAsyncFunction, isArrayBufferView } = require_util().types, signals = {};
    function isInt32(value) {
      return value === (value | 0);
    }
    function isUint32(value) {
      return value === value >>> 0;
    }
    var octalReg = /^[0-7]+$/, modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value, name, def) {
      if (typeof value === "undefined")
        value = def;
      if (typeof value === "string") {
        if (RegExpPrototypeExec(octalReg, value) === null)
          throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);
        value = NumberParseInt(value, 8);
      }
      return validateUint32(value, name), value;
    }
    var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE3(name, "number", value);
      if (!NumberIsInteger(value))
        throw new ERR_OUT_OF_RANGE3(name, "an integer", value);
      if (value < min || value > max)
        throw new ERR_OUT_OF_RANGE3(name, `>= ${min} && <= ${max}`, value);
    }), validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE3(name, "number", value);
      if (!NumberIsInteger(value))
        throw new ERR_OUT_OF_RANGE3(name, "an integer", value);
      if (value < min || value > max)
        throw new ERR_OUT_OF_RANGE3(name, `>= ${min} && <= ${max}`, value);
    }), validateUint32 = hideStackFrames((value, name, positive = false) => {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE3(name, "number", value);
      if (!NumberIsInteger(value))
        throw new ERR_OUT_OF_RANGE3(name, "an integer", value);
      let min = positive ? 1 : 0, max = 4294967295;
      if (value < min || value > max)
        throw new ERR_OUT_OF_RANGE3(name, `>= ${min} && <= ${max}`, value);
    });
    function validateString(value, name) {
      if (typeof value !== "string")
        throw new ERR_INVALID_ARG_TYPE3(name, "string", value);
    }
    function validateNumber3(value, name, min = undefined, max) {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE3(name, "number", value);
      if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value))
        throw new ERR_OUT_OF_RANGE3(name, `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`, value);
    }
    var validateOneOf = hideStackFrames((value, name, oneOf) => {
      if (!ArrayPrototypeIncludes(oneOf, value)) {
        let reason = "must be one of: " + ArrayPrototypeJoin(ArrayPrototypeMap(oneOf, (v2) => typeof v2 === "string" ? `'${v2}'` : String2(v2)), ", ");
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateBoolean2(value, name) {
      if (typeof value !== "boolean")
        throw new ERR_INVALID_ARG_TYPE3(name, "boolean", value);
    }
    function getOwnPropertyValueOrDefault(options, key, defaultValue) {
      return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
    }
    var validateObject = hideStackFrames((value, name, options = null) => {
      let allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false), allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
      if (!getOwnPropertyValueOrDefault(options, "nullable", false) && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function"))
        throw new ERR_INVALID_ARG_TYPE3(name, "Object", value);
    }), validateDictionary = hideStackFrames((value, name) => {
      if (value != null && typeof value !== "object" && typeof value !== "function")
        throw new ERR_INVALID_ARG_TYPE3(name, "a dictionary", value);
    }), validateArray = hideStackFrames((value, name, minLength = 0) => {
      if (!ArrayIsArray(value))
        throw new ERR_INVALID_ARG_TYPE3(name, "Array", value);
      if (value.length < minLength) {
        let reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateStringArray(value, name) {
      validateArray(value, name);
      for (let i2 = 0;i2 < value.length; i2++)
        validateString(value[i2], `${name}[${i2}]`);
    }
    function validateBooleanArray(value, name) {
      validateArray(value, name);
      for (let i2 = 0;i2 < value.length; i2++)
        validateBoolean2(value[i2], `${name}[${i2}]`);
    }
    function validateAbortSignalArray(value, name) {
      validateArray(value, name);
      for (let i2 = 0;i2 < value.length; i2++) {
        let signal = value[i2], indexedName = `${name}[${i2}]`;
        if (signal == null)
          throw new ERR_INVALID_ARG_TYPE3(indexedName, "AbortSignal", signal);
        validateAbortSignal2(signal, indexedName);
      }
    }
    function validateSignalName(signal, name = "signal") {
      if (validateString(signal, name), signals[signal] === undefined) {
        if (signals[StringPrototypeToUpperCase(signal)] !== undefined)
          throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
        throw new ERR_UNKNOWN_SIGNAL(signal);
      }
    }
    var validateBuffer = hideStackFrames((buffer, name = "buffer") => {
      if (!isArrayBufferView(buffer))
        throw new ERR_INVALID_ARG_TYPE3(name, ["Buffer", "TypedArray", "DataView"], buffer);
    });
    function validateEncoding(data, encoding) {
      let normalizedEncoding = normalizeEncoding(encoding), length = data.length;
      if (normalizedEncoding === "hex" && length % 2 !== 0)
        throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
    }
    function validatePort(port, name = "Port", allowZero = true) {
      if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero)
        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
      return port | 0;
    }
    var validateAbortSignal2 = hideStackFrames((signal, name) => {
      if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal)))
        throw new ERR_INVALID_ARG_TYPE3(name, "AbortSignal", signal);
    }), validateFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function")
        throw new ERR_INVALID_ARG_TYPE3(name, "Function", value);
    }), validatePlainFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function" || isAsyncFunction(value))
        throw new ERR_INVALID_ARG_TYPE3(name, "Function", value);
    }), validateUndefined = hideStackFrames((value, name) => {
      if (value !== undefined)
        throw new ERR_INVALID_ARG_TYPE3(name, "undefined", value);
    });
    function validateUnion(value, name, union) {
      if (!ArrayPrototypeIncludes(union, value))
        throw new ERR_INVALID_ARG_TYPE3(name, `('${ArrayPrototypeJoin(union, "|")}')`, value);
    }
    var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function validateLinkHeaderFormat(value, name) {
      if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value))
        throw new ERR_INVALID_ARG_VALUE(name, value, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
    }
    function validateLinkHeaderValue(hints) {
      if (typeof hints === "string")
        return validateLinkHeaderFormat(hints, "hints"), hints;
      else if (ArrayIsArray(hints)) {
        let hintsLength = hints.length, result = "";
        if (hintsLength === 0)
          return result;
        for (let i2 = 0;i2 < hintsLength; i2++) {
          let link = hints[i2];
          if (validateLinkHeaderFormat(link, "hints"), result += link, i2 !== hintsLength - 1)
            result += ", ";
        }
        return result;
      }
      throw new ERR_INVALID_ARG_VALUE("hints", hints, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
    }
    module2.exports = { isInt32, isUint32, parseFileMode, validateArray, validateStringArray, validateBooleanArray, validateAbortSignalArray, validateBoolean: validateBoolean2, validateBuffer, validateDictionary, validateEncoding, validateFunction, validateInt32, validateInteger, validateNumber: validateNumber3, validateObject, validateOneOf, validatePlainFunction, validatePort, validateSignalName, validateString, validateUint32, validateUndefined, validateUnion, validateAbortSignal: validateAbortSignal2, validateLinkHeaderValue };
  });
  var require_process = __commonJS2((exports2, module2) => {
    module2.exports = globalThis.process;
  });
  var require_utils = __commonJS2((exports2, module2) => {
    var { SymbolAsyncIterator, SymbolIterator, SymbolFor: SymbolFor2 } = require_primordials(), kIsDestroyed = SymbolFor2("nodejs.stream.destroyed"), kIsErrored = SymbolFor2("nodejs.stream.errored"), kIsReadable = SymbolFor2("nodejs.stream.readable"), kIsWritable = SymbolFor2("nodejs.stream.writable"), kIsDisturbed = SymbolFor2("nodejs.stream.disturbed"), kIsClosedPromise = SymbolFor2("nodejs.webstream.isClosedPromise"), kControllerErrorFunction = SymbolFor2("nodejs.webstream.controllerErrorFunction");
    function isReadableNodeStream(obj, strict = false) {
      var _obj$_readableState;
      return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === undefined ? undefined : _obj$_readableState.readable) !== false) && (!obj._writableState || obj._readableState));
    }
    function isWritableNodeStream(obj) {
      var _obj$_writableState;
      return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === undefined ? undefined : _obj$_writableState.writable) !== false));
    }
    function isDuplexNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
    }
    function isNodeStream(obj) {
      return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
    }
    function isReadableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
    }
    function isWritableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
    }
    function isTransformStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
    }
    function isWebStream(obj) {
      return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
    }
    function isIterable(obj, isAsync) {
      if (obj == null)
        return false;
      if (isAsync === true)
        return typeof obj[SymbolAsyncIterator] === "function";
      if (isAsync === false)
        return typeof obj[SymbolIterator] === "function";
      return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
    }
    function isDestroyed(stream) {
      if (!isNodeStream(stream))
        return null;
      let { _writableState: wState, _readableState: rState } = stream, state = wState || rState;
      return !!(stream.destroyed || stream[kIsDestroyed] || state !== null && state !== undefined && state.destroyed);
    }
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableEnded === true)
        return true;
      let wState = stream._writableState;
      if (wState !== null && wState !== undefined && wState.errored)
        return false;
      if (typeof (wState === null || wState === undefined ? undefined : wState.ended) !== "boolean")
        return null;
      return wState.ended;
    }
    function isWritableFinished(stream, strict) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableFinished === true)
        return true;
      let wState = stream._writableState;
      if (wState !== null && wState !== undefined && wState.errored)
        return false;
      if (typeof (wState === null || wState === undefined ? undefined : wState.finished) !== "boolean")
        return null;
      return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
    }
    function isReadableEnded(stream) {
      if (!isReadableNodeStream(stream))
        return null;
      if (stream.readableEnded === true)
        return true;
      let rState = stream._readableState;
      if (!rState || rState.errored)
        return false;
      if (typeof (rState === null || rState === undefined ? undefined : rState.ended) !== "boolean")
        return null;
      return rState.ended;
    }
    function isReadableFinished(stream, strict) {
      if (!isReadableNodeStream(stream))
        return null;
      let rState = stream._readableState;
      if (rState !== null && rState !== undefined && rState.errored)
        return false;
      if (typeof (rState === null || rState === undefined ? undefined : rState.endEmitted) !== "boolean")
        return null;
      return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
    }
    function isReadable(stream) {
      if (stream && stream[kIsReadable] != null)
        return stream[kIsReadable];
      if (typeof (stream === null || stream === undefined ? undefined : stream.readable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
    }
    function isWritable(stream) {
      if (stream && stream[kIsWritable] != null)
        return stream[kIsWritable];
      if (typeof (stream === null || stream === undefined ? undefined : stream.writable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
    }
    function isFinished(stream, opts) {
      if (!isNodeStream(stream))
        return null;
      if (isDestroyed(stream))
        return true;
      if ((opts === null || opts === undefined ? undefined : opts.readable) !== false && isReadable(stream))
        return false;
      if ((opts === null || opts === undefined ? undefined : opts.writable) !== false && isWritable(stream))
        return false;
      return true;
    }
    function isWritableErrored(stream) {
      var _stream$_writableStat, _stream$_writableStat2;
      if (!isNodeStream(stream))
        return null;
      if (stream.writableErrored)
        return stream.writableErrored;
      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === undefined ? undefined : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== undefined ? _stream$_writableStat : null;
    }
    function isReadableErrored(stream) {
      var _stream$_readableStat, _stream$_readableStat2;
      if (!isNodeStream(stream))
        return null;
      if (stream.readableErrored)
        return stream.readableErrored;
      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === undefined ? undefined : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== undefined ? _stream$_readableStat : null;
    }
    function isClosed(stream) {
      if (!isNodeStream(stream))
        return null;
      if (typeof stream.closed === "boolean")
        return stream.closed;
      let { _writableState: wState, _readableState: rState } = stream;
      if (typeof (wState === null || wState === undefined ? undefined : wState.closed) === "boolean" || typeof (rState === null || rState === undefined ? undefined : rState.closed) === "boolean")
        return (wState === null || wState === undefined ? undefined : wState.closed) || (rState === null || rState === undefined ? undefined : rState.closed);
      if (typeof stream._closed === "boolean" && isOutgoingMessage(stream))
        return stream._closed;
      return null;
    }
    function isOutgoingMessage(stream) {
      return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
    }
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
    }
    function isServerRequest(stream) {
      var _stream$req;
      return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === undefined ? undefined : _stream$req.upgradeOrConnect) === undefined;
    }
    function willEmitClose(stream) {
      if (!isNodeStream(stream))
        return null;
      let { _writableState: wState, _readableState: rState } = stream, state = wState || rState;
      return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
    }
    function isDisturbed(stream) {
      var _stream$kIsDisturbed;
      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== undefined ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
    }
    function isErrored(stream) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== undefined ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== undefined ? _ref5 : stream.writableErrored) !== null && _ref4 !== undefined ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === undefined ? undefined : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== undefined ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === undefined ? undefined : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== undefined ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === undefined ? undefined : _stream$_readableStat4.errored) !== null && _ref !== undefined ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === undefined ? undefined : _stream$_writableStat4.errored));
    }
    module2.exports = { isDestroyed, kIsDestroyed, isDisturbed, kIsDisturbed, isErrored, kIsErrored, isReadable, kIsReadable, kIsClosedPromise, kControllerErrorFunction, kIsWritable, isClosed, isDuplexNodeStream, isFinished, isIterable, isReadableNodeStream, isReadableStream, isReadableEnded, isReadableFinished, isReadableErrored, isNodeStream, isWebStream, isWritable, isWritableNodeStream, isWritableStream, isWritableEnded, isWritableFinished, isWritableErrored, isServerRequest, isServerResponse, willEmitClose, isTransformStream };
  });
  var require_end_of_stream = __commonJS2((exports2, module2) => {
    var process2 = require_process(), { AbortError: AbortError2, codes } = require_errors(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_STREAM_PREMATURE_CLOSE } = codes, { kEmptyObject, once: once3 } = require_util(), { validateAbortSignal: validateAbortSignal2, validateFunction, validateObject, validateBoolean: validateBoolean2 } = require_validators(), { Promise: Promise2, PromisePrototypeThen, SymbolDispose } = require_primordials(), { isClosed, isReadable, isReadableNodeStream, isReadableStream, isReadableFinished, isReadableErrored, isWritable, isWritableNodeStream, isWritableStream, isWritableFinished, isWritableErrored, isNodeStream, willEmitClose: _willEmitClose, kIsClosedPromise } = require_utils(), addAbortListener2;
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    var nop = () => {};
    function eos(stream, options, callback) {
      var _options$readable, _options$writable;
      if (arguments.length === 2)
        callback = options, options = kEmptyObject;
      else if (options == null)
        options = kEmptyObject;
      else
        validateObject(options, "options");
      if (validateFunction(callback, "callback"), validateAbortSignal2(options.signal, "options.signal"), callback = once3(callback), isReadableStream(stream) || isWritableStream(stream))
        return eosWeb(stream, options, callback);
      if (!isNodeStream(stream))
        throw new ERR_INVALID_ARG_TYPE3("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      let readable = (_options$readable = options.readable) !== null && _options$readable !== undefined ? _options$readable : isReadableNodeStream(stream), writable = (_options$writable = options.writable) !== null && _options$writable !== undefined ? _options$writable : isWritableNodeStream(stream), wState = stream._writableState, rState = stream._readableState, onlegacyfinish = () => {
        if (!stream.writable)
          onfinish();
      }, willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable, writableFinished = isWritableFinished(stream, false), onfinish = () => {
        if (writableFinished = true, stream.destroyed)
          willEmitClose = false;
        if (willEmitClose && (!stream.readable || readable))
          return;
        if (!readable || readableFinished)
          callback.call(stream);
      }, readableFinished = isReadableFinished(stream, false), onend = () => {
        if (readableFinished = true, stream.destroyed)
          willEmitClose = false;
        if (willEmitClose && (!stream.writable || writable))
          return;
        if (!writable || writableFinished)
          callback.call(stream);
      }, onerror = (err) => {
        callback.call(stream, err);
      }, closed = isClosed(stream), onclose = () => {
        closed = true;
        let errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean")
          return callback.call(stream, errored);
        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
          if (!isReadableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE);
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE);
        }
        callback.call(stream);
      }, onclosed = () => {
        closed = true;
        let errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean")
          return callback.call(stream, errored);
        callback.call(stream);
      }, onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        if (stream.on("complete", onfinish), !willEmitClose)
          stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !wState)
        stream.on("end", onlegacyfinish), stream.on("close", onlegacyfinish);
      if (!willEmitClose && typeof stream.aborted === "boolean")
        stream.on("aborted", onclose);
      if (stream.on("end", onend), stream.on("finish", onfinish), options.error !== false)
        stream.on("error", onerror);
      if (stream.on("close", onclose), closed)
        process2.nextTick(onclose);
      else if (wState !== null && wState !== undefined && wState.errorEmitted || rState !== null && rState !== undefined && rState.errorEmitted) {
        if (!willEmitClose)
          process2.nextTick(onclosed);
      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false))
        process2.nextTick(onclosed);
      else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false))
        process2.nextTick(onclosed);
      else if (rState && stream.req && stream.aborted)
        process2.nextTick(onclosed);
      let cleanup = () => {
        if (callback = nop, stream.removeListener("aborted", onclose), stream.removeListener("complete", onfinish), stream.removeListener("abort", onclose), stream.removeListener("request", onrequest), stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish), stream.removeListener("close", onlegacyfinish), stream.removeListener("finish", onfinish), stream.removeListener("end", onend), stream.removeListener("error", onerror), stream.removeListener("close", onclose);
      };
      if (options.signal && !closed) {
        let abort = () => {
          let endCallback = callback;
          cleanup(), endCallback.call(stream, new AbortError2(undefined, { cause: options.signal.reason }));
        };
        if (options.signal.aborted)
          process2.nextTick(abort);
        else {
          addAbortListener2 = addAbortListener2 || require_util().addAbortListener;
          let disposable = addAbortListener2(options.signal, abort), originalCallback = callback;
          callback = once3((...args) => {
            disposable[SymbolDispose](), originalCallback.apply(stream, args);
          });
        }
      }
      return cleanup;
    }
    function eosWeb(stream, options, callback) {
      let isAborted = false, abort = nop;
      if (options.signal)
        if (abort = () => {
          isAborted = true, callback.call(stream, new AbortError2(undefined, { cause: options.signal.reason }));
        }, options.signal.aborted)
          process2.nextTick(abort);
        else {
          addAbortListener2 = addAbortListener2 || require_util().addAbortListener;
          let disposable = addAbortListener2(options.signal, abort), originalCallback = callback;
          callback = once3((...args) => {
            disposable[SymbolDispose](), originalCallback.apply(stream, args);
          });
        }
      let resolverFn = (...args) => {
        if (!isAborted)
          process2.nextTick(() => callback.apply(stream, args));
      };
      return PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn), nop;
    }
    function finished(stream, opts) {
      var _opts;
      let autoCleanup = false;
      if (opts === null)
        opts = kEmptyObject;
      if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup)
        validateBoolean2(opts.cleanup, "cleanup"), autoCleanup = opts.cleanup;
      return new Promise2((resolve2, reject) => {
        let cleanup = eos(stream, opts, (err) => {
          if (autoCleanup)
            cleanup();
          if (err)
            reject(err);
          else
            resolve2();
        });
      });
    }
    module2.exports = eos;
    module2.exports.finished = finished;
  });
  var require_destroy = __commonJS2((exports2, module2) => {
    var process2 = require_process(), { aggregateTwoErrors, codes: { ERR_MULTIPLE_CALLBACK }, AbortError: AbortError2 } = require_errors(), { Symbol: Symbol2 } = require_primordials(), { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils(), kDestroy = Symbol2("kDestroy"), kConstruct = Symbol2("kConstruct");
    function checkError(err, w, r) {
      if (err) {
        if (err.stack, w && !w.errored)
          w.errored = err;
        if (r && !r.errored)
          r.errored = err;
      }
    }
    function destroy(err, cb) {
      let r = this._readableState, w = this._writableState, s3 = w || r;
      if (w !== null && w !== undefined && w.destroyed || r !== null && r !== undefined && r.destroyed) {
        if (typeof cb === "function")
          cb();
        return this;
      }
      if (checkError(err, w, r), w)
        w.destroyed = true;
      if (r)
        r.destroyed = true;
      if (!s3.constructed)
        this.once(kDestroy, function(er3) {
          _destroy(this, aggregateTwoErrors(er3, err), cb);
        });
      else
        _destroy(this, err, cb);
      return this;
    }
    function _destroy(self2, err, cb) {
      let called = false;
      function onDestroy(err2) {
        if (called)
          return;
        called = true;
        let { _readableState: r, _writableState: w } = self2;
        if (checkError(err2, w, r), w)
          w.closed = true;
        if (r)
          r.closed = true;
        if (typeof cb === "function")
          cb(err2);
        if (err2)
          process2.nextTick(emitErrorCloseNT, self2, err2);
        else
          process2.nextTick(emitCloseNT, self2);
      }
      try {
        self2._destroy(err || null, onDestroy);
      } catch (err2) {
        onDestroy(err2);
      }
    }
    function emitErrorCloseNT(self2, err) {
      emitErrorNT(self2, err), emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      let { _readableState: r, _writableState: w } = self2;
      if (w)
        w.closeEmitted = true;
      if (r)
        r.closeEmitted = true;
      if (w !== null && w !== undefined && w.emitClose || r !== null && r !== undefined && r.emitClose)
        self2.emit("close");
    }
    function emitErrorNT(self2, err) {
      let { _readableState: r, _writableState: w } = self2;
      if (w !== null && w !== undefined && w.errorEmitted || r !== null && r !== undefined && r.errorEmitted)
        return;
      if (w)
        w.errorEmitted = true;
      if (r)
        r.errorEmitted = true;
      self2.emit("error", err);
    }
    function undestroy() {
      let r = this._readableState, w = this._writableState;
      if (r)
        r.constructed = true, r.closed = false, r.closeEmitted = false, r.destroyed = false, r.errored = null, r.errorEmitted = false, r.reading = false, r.ended = r.readable === false, r.endEmitted = r.readable === false;
      if (w)
        w.constructed = true, w.destroyed = false, w.closed = false, w.closeEmitted = false, w.errored = null, w.errorEmitted = false, w.finalCalled = false, w.prefinished = false, w.ended = w.writable === false, w.ending = w.writable === false, w.finished = w.writable === false;
    }
    function errorOrDestroy(stream, err, sync) {
      let { _readableState: r, _writableState: w } = stream;
      if (w !== null && w !== undefined && w.destroyed || r !== null && r !== undefined && r.destroyed)
        return this;
      if (r !== null && r !== undefined && r.autoDestroy || w !== null && w !== undefined && w.autoDestroy)
        stream.destroy(err);
      else if (err) {
        if (err.stack, w && !w.errored)
          w.errored = err;
        if (r && !r.errored)
          r.errored = err;
        if (sync)
          process2.nextTick(emitErrorNT, stream, err);
        else
          emitErrorNT(stream, err);
      }
    }
    function construct(stream, cb) {
      if (typeof stream._construct !== "function")
        return;
      let { _readableState: r, _writableState: w } = stream;
      if (r)
        r.constructed = false;
      if (w)
        w.constructed = false;
      if (stream.once(kConstruct, cb), stream.listenerCount(kConstruct) > 1)
        return;
      process2.nextTick(constructNT, stream);
    }
    function constructNT(stream) {
      let called = false;
      function onConstruct(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== undefined ? err : new ERR_MULTIPLE_CALLBACK);
          return;
        }
        called = true;
        let { _readableState: r, _writableState: w } = stream, s3 = w || r;
        if (r)
          r.constructed = true;
        if (w)
          w.constructed = true;
        if (s3.destroyed)
          stream.emit(kDestroy, err);
        else if (err)
          errorOrDestroy(stream, err, true);
        else
          process2.nextTick(emitConstructNT, stream);
      }
      try {
        stream._construct((err) => {
          process2.nextTick(onConstruct, err);
        });
      } catch (err) {
        process2.nextTick(onConstruct, err);
      }
    }
    function emitConstructNT(stream) {
      stream.emit(kConstruct);
    }
    function isRequest(stream) {
      return (stream === null || stream === undefined ? undefined : stream.setHeader) && typeof stream.abort === "function";
    }
    function emitCloseLegacy(stream) {
      stream.emit("close");
    }
    function emitErrorCloseLegacy(stream, err) {
      stream.emit("error", err), process2.nextTick(emitCloseLegacy, stream);
    }
    function destroyer(stream, err) {
      if (!stream || isDestroyed(stream))
        return;
      if (!err && !isFinished(stream))
        err = new AbortError2;
      if (isServerRequest(stream))
        stream.socket = null, stream.destroy(err);
      else if (isRequest(stream))
        stream.abort();
      else if (isRequest(stream.req))
        stream.req.abort();
      else if (typeof stream.destroy === "function")
        stream.destroy(err);
      else if (typeof stream.close === "function")
        stream.close();
      else if (err)
        process2.nextTick(emitErrorCloseLegacy, stream, err);
      else
        process2.nextTick(emitCloseLegacy, stream);
      if (!stream.destroyed)
        stream[kIsDestroyed] = true;
    }
    module2.exports = { construct, destroyer, destroy, undestroy, errorOrDestroy };
  });
  var require_legacy = __commonJS2((exports2, module2) => {
    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials(), { EventEmitter: EE } = (init_events(), __toCommonJS(exports_events));
    function Stream(opts) {
      EE.call(this, opts);
    }
    ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
    ObjectSetPrototypeOf(Stream, EE);
    Stream.prototype.pipe = function(dest, options) {
      let source = this;
      function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause)
          source.pause();
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume)
          source.resume();
      }
      if (dest.on("drain", ondrain), !dest._isStdio && (!options || options.end !== false))
        source.on("end", onend), source.on("close", onclose);
      let didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true, dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        if (didOnEnd = true, typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er3) {
        if (cleanup(), EE.listenerCount(this, "error") === 0)
          this.emit("error", er3);
      }
      prependListener2(source, "error", onerror), prependListener2(dest, "error", onerror);
      function cleanup() {
        source.removeListener("data", ondata), dest.removeListener("drain", ondrain), source.removeListener("end", onend), source.removeListener("close", onclose), source.removeListener("error", onerror), dest.removeListener("error", onerror), source.removeListener("end", cleanup), source.removeListener("close", cleanup), dest.removeListener("close", cleanup);
      }
      return source.on("end", cleanup), source.on("close", cleanup), dest.on("close", cleanup), dest.emit("pipe", source), dest;
    };
    function prependListener2(emitter, event, fn2) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn2);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn2);
      else if (ArrayIsArray(emitter._events[event]))
        emitter._events[event].unshift(fn2);
      else
        emitter._events[event] = [fn2, emitter._events[event]];
    }
    module2.exports = { Stream, prependListener: prependListener2 };
  });
  var require_add_abort_signal = __commonJS2((exports2, module2) => {
    var { SymbolDispose } = require_primordials(), { AbortError: AbortError2, codes } = require_errors(), { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils(), eos = require_end_of_stream(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3 } = codes, addAbortListener2, validateAbortSignal2 = (signal, name) => {
      if (typeof signal !== "object" || !("aborted" in signal))
        throw new ERR_INVALID_ARG_TYPE3(name, "AbortSignal", signal);
    };
    module2.exports.addAbortSignal = function addAbortSignal(signal, stream) {
      if (validateAbortSignal2(signal, "signal"), !isNodeStream(stream) && !isWebStream(stream))
        throw new ERR_INVALID_ARG_TYPE3("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      return module2.exports.addAbortSignalNoValidate(signal, stream);
    };
    module2.exports.addAbortSignalNoValidate = function(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal))
        return stream;
      let onAbort = isNodeStream(stream) ? () => {
        stream.destroy(new AbortError2(undefined, { cause: signal.reason }));
      } : () => {
        stream[kControllerErrorFunction](new AbortError2(undefined, { cause: signal.reason }));
      };
      if (signal.aborted)
        onAbort();
      else {
        addAbortListener2 = addAbortListener2 || require_util().addAbortListener;
        let disposable = addAbortListener2(signal, onAbort);
        eos(stream, disposable[SymbolDispose]);
      }
      return stream;
    };
  });
  var require_buffer_list = __commonJS2((exports2, module2) => {
    var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials(), { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(exports_buffer)), { inspect: inspect3 } = require_util();
    module2.exports = class BufferList {
      constructor() {
        this.head = null, this.tail = null, this.length = 0;
      }
      push(v2) {
        let entry = { data: v2, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry, ++this.length;
      }
      unshift(v2) {
        let entry = { data: v2, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry, ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        let ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        return --this.length, ret;
      }
      clear() {
        this.head = this.tail = null, this.length = 0;
      }
      join(s3) {
        if (this.length === 0)
          return "";
        let p2 = this.head, ret = "" + p2.data;
        while ((p2 = p2.next) !== null)
          ret += s3 + p2.data;
        return ret;
      }
      concat(n) {
        if (this.length === 0)
          return Buffer3.alloc(0);
        let ret = Buffer3.allocUnsafe(n >>> 0), p2 = this.head, i2 = 0;
        while (p2)
          TypedArrayPrototypeSet(ret, p2.data, i2), i2 += p2.data.length, p2 = p2.next;
        return ret;
      }
      consume(n, hasStrings) {
        let data = this.head.data;
        if (n < data.length) {
          let slice2 = data.slice(0, n);
          return this.head.data = data.slice(n), slice2;
        }
        if (n === data.length)
          return this.shift();
        return hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (let p2 = this.head;p2; p2 = p2.next)
          yield p2.data;
      }
      _getString(n) {
        let ret = "", p2 = this.head, c = 0;
        do {
          let str = p2.data;
          if (n > str.length)
            ret += str, n -= str.length;
          else {
            if (n === str.length)
              if (ret += str, ++c, p2.next)
                this.head = p2.next;
              else
                this.head = this.tail = null;
            else
              ret += StringPrototypeSlice(str, 0, n), this.head = p2, p2.data = StringPrototypeSlice(str, n);
            break;
          }
          ++c;
        } while ((p2 = p2.next) !== null);
        return this.length -= c, ret;
      }
      _getBuffer(n) {
        let ret = Buffer3.allocUnsafe(n), retLen = n, p2 = this.head, c = 0;
        do {
          let buf = p2.data;
          if (n > buf.length)
            TypedArrayPrototypeSet(ret, buf, retLen - n), n -= buf.length;
          else {
            if (n === buf.length)
              if (TypedArrayPrototypeSet(ret, buf, retLen - n), ++c, p2.next)
                this.head = p2.next;
              else
                this.head = this.tail = null;
            else
              TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n), this.head = p2, p2.data = buf.slice(n);
            break;
          }
          ++c;
        } while ((p2 = p2.next) !== null);
        return this.length -= c, ret;
      }
      [Symbol.for("nodejs.util.inspect.custom")](_3, options) {
        return inspect3(this, { ...options, depth: 0, customInspect: false });
      }
    };
  });
  var require_state = __commonJS2((exports2, module2) => {
    var { MathFloor, NumberIsInteger } = require_primordials(), { validateInteger } = require_validators(), { ERR_INVALID_ARG_VALUE } = require_errors().codes, defaultHighWaterMarkBytes = 16384, defaultHighWaterMarkObjectMode = 16;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
    }
    function setDefaultHighWaterMark(objectMode, value) {
      if (validateInteger(value, "value", 0), objectMode)
        defaultHighWaterMarkObjectMode = value;
      else
        defaultHighWaterMarkBytes = value;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      let hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!NumberIsInteger(hwm) || hwm < 0) {
          let name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
          throw new ERR_INVALID_ARG_VALUE(name, hwm);
        }
        return MathFloor(hwm);
      }
      return getDefaultHighWaterMark(state.objectMode);
    }
    module2.exports = { getHighWaterMark, getDefaultHighWaterMark, setDefaultHighWaterMark };
  });
  var require_safe_buffer = __commonJS2((exports2, module2) => {
    /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    var buffer = (init_buffer(), __toCommonJS(exports_buffer)), Buffer3 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src)
        dst[key] = src[key];
    }
    if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow)
      module2.exports = buffer;
    else
      copyProps(buffer, exports2), exports2.Buffer = SafeBuffer;
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer3(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer3.prototype);
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number")
        throw new TypeError("Argument must not be a number");
      return Buffer3(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill2, encoding) {
      if (typeof size !== "number")
        throw new TypeError("Argument must be a number");
      var buf = Buffer3(size);
      if (fill2 !== undefined)
        if (typeof encoding === "string")
          buf.fill(fill2, encoding);
        else
          buf.fill(fill2);
      else
        buf.fill(0);
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number")
        throw new TypeError("Argument must be a number");
      return Buffer3(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number")
        throw new TypeError("Argument must be a number");
      return buffer.SlowBuffer(size);
    };
  });
  var require_string_decoder = __commonJS2((exports2) => {
    var Buffer3 = require_safe_buffer().Buffer, isEncoding2 = Buffer3.isEncoding || function(encoding) {
      switch (encoding = "" + encoding, encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true)
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase(), retried = true;
        }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer3.isEncoding === isEncoding2 || !isEncoding2(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text, this.end = utf16End, nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast, nb = 4;
          break;
        case "base64":
          this.text = base64Text, this.end = base64End, nb = 3;
          break;
        default:
          this.write = simpleWrite, this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer3.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r, i2;
      if (this.lastNeed) {
        if (r = this.fillLast(buf), r === undefined)
          return "";
        i2 = this.lastNeed, this.lastNeed = 0;
      } else
        i2 = 0;
      if (i2 < buf.length)
        return r ? r + this.text(buf, i2) : this.text(buf, i2);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length)
        return buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length), this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i2) {
      var j3 = buf.length - 1;
      if (j3 < i2)
        return 0;
      var nb = utf8CheckByte(buf[j3]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j3 < i2 || nb === -2)
        return 0;
      if (nb = utf8CheckByte(buf[j3]), nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j3 < i2 || nb === -2)
        return 0;
      if (nb = utf8CheckByte(buf[j3]), nb >= 0) {
        if (nb > 0)
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p2) {
      if ((buf[0] & 192) !== 128)
        return self2.lastNeed = 0, "";
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128)
          return self2.lastNeed = 1, "";
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128)
            return self2.lastNeed = 2, "";
        }
      }
    }
    function utf8FillLast(buf) {
      var p2 = this.lastTotal - this.lastNeed, r = utf8CheckExtraBytes(this, buf, p2);
      if (r !== undefined)
        return r;
      if (this.lastNeed <= buf.length)
        return buf.copy(this.lastChar, p2, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      buf.copy(this.lastChar, p2, 0, buf.length), this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i2) {
      var total = utf8CheckIncomplete(this, buf, i2);
      if (!this.lastNeed)
        return buf.toString("utf8", i2);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      return buf.copy(this.lastChar, 0, end), buf.toString("utf8", i2, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "";
      return r;
    }
    function utf16Text(buf, i2) {
      if ((buf.length - i2) % 2 === 0) {
        var r = buf.toString("utf16le", i2);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = buf[buf.length - 2], this.lastChar[1] = buf[buf.length - 1], r.slice(0, -1);
        }
        return r;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = buf[buf.length - 1], buf.toString("utf16le", i2, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i2) {
      var n = (buf.length - i2) % 3;
      if (n === 0)
        return buf.toString("base64", i2);
      if (this.lastNeed = 3 - n, this.lastTotal = 3, n === 1)
        this.lastChar[0] = buf[buf.length - 1];
      else
        this.lastChar[0] = buf[buf.length - 2], this.lastChar[1] = buf[buf.length - 1];
      return buf.toString("base64", i2, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  });
  var require_from = __commonJS2((exports2, module2) => {
    var process2 = require_process(), { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials(), { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(exports_buffer)), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_STREAM_NULL_VALUES } = require_errors().codes;
    function from2(Readable, iterable, opts) {
      let iterator;
      if (typeof iterable === "string" || iterable instanceof Buffer3)
        return new Readable({ objectMode: true, ...opts, read() {
          this.push(iterable), this.push(null);
        } });
      let isAsync;
      if (iterable && iterable[SymbolAsyncIterator])
        isAsync = true, iterator = iterable[SymbolAsyncIterator]();
      else if (iterable && iterable[SymbolIterator])
        isAsync = false, iterator = iterable[SymbolIterator]();
      else
        throw new ERR_INVALID_ARG_TYPE3("iterable", ["Iterable"], iterable);
      let readable = new Readable({ objectMode: true, highWaterMark: 1, ...opts }), reading = false;
      readable._read = function() {
        if (!reading)
          reading = true, next();
      }, readable._destroy = function(error, cb) {
        PromisePrototypeThen(close(error), () => process2.nextTick(cb, error), (e2) => process2.nextTick(cb, e2 || error));
      };
      async function close(error) {
        let hadError = error !== undefined && error !== null, hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
          let { value, done } = await iterator.throw(error);
          if (await value, done)
            return;
        }
        if (typeof iterator.return === "function") {
          let { value } = await iterator.return();
          await value;
        }
      }
      async function next() {
        for (;; ) {
          try {
            let { value, done } = isAsync ? await iterator.next() : iterator.next();
            if (done)
              readable.push(null);
            else {
              let res = value && typeof value.then === "function" ? await value : value;
              if (res === null)
                throw reading = false, new ERR_STREAM_NULL_VALUES;
              else if (readable.push(res))
                continue;
              else
                reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
          break;
        }
      }
      return readable;
    }
    module2.exports = from2;
  });
  var require_readable = __commonJS2((exports2, module2) => {
    var process2 = require_process(), { ArrayPrototypeIndexOf, NumberIsInteger, NumberIsNaN, NumberParseInt, ObjectDefineProperties, ObjectKeys, ObjectSetPrototypeOf, Promise: Promise2, SafeSet, SymbolAsyncDispose, SymbolAsyncIterator, Symbol: Symbol2 } = require_primordials();
    module2.exports = Readable;
    Readable.ReadableState = ReadableState;
    var { EventEmitter: EE } = (init_events(), __toCommonJS(exports_events)), { Stream, prependListener: prependListener2 } = require_legacy(), { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(exports_buffer)), { addAbortSignal } = require_add_abort_signal(), eos = require_end_of_stream(), debug = require_util().debuglog("stream", (fn2) => {
      debug = fn2;
    }), BufferList = require_buffer_list(), destroyImpl = require_destroy(), { getHighWaterMark, getDefaultHighWaterMark } = require_state(), { aggregateTwoErrors, codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_METHOD_NOT_IMPLEMENTED, ERR_OUT_OF_RANGE: ERR_OUT_OF_RANGE3, ERR_STREAM_PUSH_AFTER_EOF, ERR_STREAM_UNSHIFT_AFTER_END_EVENT }, AbortError: AbortError2 } = require_errors(), { validateObject } = require_validators(), kPaused = Symbol2("kPaused"), { StringDecoder } = require_string_decoder(), from2 = require_from();
    ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Readable, Stream);
    var nop = () => {}, { errorOrDestroy } = destroyImpl, kObjectMode = 1, kEnded = 2, kEndEmitted = 4, kReading = 8, kConstructed = 16, kSync = 32, kNeedReadable = 64, kEmittedReadable = 128, kReadableListening = 256, kResumeScheduled = 512, kErrorEmitted = 1024, kEmitClose = 2048, kAutoDestroy = 4096, kDestroyed = 8192, kClosed = 16384, kCloseEmitted = 32768, kMultiAwaitDrain = 65536, kReadingMore = 131072, kDataEmitted = 262144;
    function makeBitMapDescriptor(bit) {
      return { enumerable: false, get() {
        return (this.state & bit) !== 0;
      }, set(value) {
        if (value)
          this.state |= bit;
        else
          this.state &= ~bit;
      } };
    }
    ObjectDefineProperties(ReadableState.prototype, { objectMode: makeBitMapDescriptor(kObjectMode), ended: makeBitMapDescriptor(kEnded), endEmitted: makeBitMapDescriptor(kEndEmitted), reading: makeBitMapDescriptor(kReading), constructed: makeBitMapDescriptor(kConstructed), sync: makeBitMapDescriptor(kSync), needReadable: makeBitMapDescriptor(kNeedReadable), emittedReadable: makeBitMapDescriptor(kEmittedReadable), readableListening: makeBitMapDescriptor(kReadableListening), resumeScheduled: makeBitMapDescriptor(kResumeScheduled), errorEmitted: makeBitMapDescriptor(kErrorEmitted), emitClose: makeBitMapDescriptor(kEmitClose), autoDestroy: makeBitMapDescriptor(kAutoDestroy), destroyed: makeBitMapDescriptor(kDestroyed), closed: makeBitMapDescriptor(kClosed), closeEmitted: makeBitMapDescriptor(kCloseEmitted), multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain), readingMore: makeBitMapDescriptor(kReadingMore), dataEmitted: makeBitMapDescriptor(kDataEmitted) });
    function ReadableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      if (this.state = kEmitClose | kAutoDestroy | kConstructed | kSync, options && options.objectMode)
        this.state |= kObjectMode;
      if (isDuplex && options && options.readableObjectMode)
        this.state |= kObjectMode;
      if (this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false), this.buffer = new BufferList, this.length = 0, this.pipes = [], this.flowing = null, this[kPaused] = null, options && options.emitClose === false)
        this.state &= ~kEmitClose;
      if (options && options.autoDestroy === false)
        this.state &= ~kAutoDestroy;
      if (this.errored = null, this.defaultEncoding = options && options.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.decoder = null, this.encoding = null, options && options.encoding)
        this.decoder = new StringDecoder(options.encoding), this.encoding = options.encoding;
    }
    function Readable(options) {
      if (!(this instanceof Readable))
        return new Readable(options);
      let isDuplex = this instanceof require_duplex();
      if (this._readableState = new ReadableState(options, this, isDuplex), options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal && !isDuplex)
          addAbortSignal(options.signal, this);
      }
      Stream.call(this, options), destroyImpl.construct(this, () => {
        if (this._readableState.needReadable)
          maybeReadMore(this, this._readableState);
      });
    }
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    Readable.prototype[SymbolAsyncDispose] = function() {
      let error;
      if (!this.destroyed)
        error = this.readableEnded ? null : new AbortError2, this.destroy(error);
      return new Promise2((resolve2, reject) => eos(this, (err) => err && err !== error ? reject(err) : resolve2(null)));
    };
    Readable.prototype.push = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, true);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront) {
      debug("readableAddChunk", chunk);
      let state = stream._readableState, err;
      if ((state.state & kObjectMode) === 0) {
        if (typeof chunk === "string") {
          if (encoding = encoding || state.defaultEncoding, state.encoding !== encoding)
            if (addToFront && state.encoding)
              chunk = Buffer3.from(chunk, encoding).toString(state.encoding);
            else
              chunk = Buffer3.from(chunk, encoding), encoding = "";
        } else if (chunk instanceof Buffer3)
          encoding = "";
        else if (Stream._isUint8Array(chunk))
          chunk = Stream._uint8ArrayToBuffer(chunk), encoding = "";
        else if (chunk != null)
          err = new ERR_INVALID_ARG_TYPE3("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      if (err)
        errorOrDestroy(stream, err);
      else if (chunk === null)
        state.state &= ~kReading, onEofChunk(stream, state);
      else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0)
        if (addToFront)
          if ((state.state & kEndEmitted) !== 0)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT);
          else if (state.destroyed || state.errored)
            return false;
          else
            addChunk(stream, state, chunk, true);
        else if (state.ended)
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF);
        else if (state.destroyed || state.errored)
          return false;
        else if (state.state &= ~kReading, state.decoder && !encoding)
          if (chunk = state.decoder.write(chunk), state.objectMode || chunk.length !== 0)
            addChunk(stream, state, chunk, false);
          else
            maybeReadMore(stream, state);
        else
          addChunk(stream, state, chunk, false);
      else if (!addToFront)
        state.state &= ~kReading, maybeReadMore(stream, state);
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if ((state.state & kMultiAwaitDrain) !== 0)
          state.awaitDrainWriters.clear();
        else
          state.awaitDrainWriters = null;
        state.dataEmitted = true, stream.emit("data", chunk);
      } else {
        if (state.length += state.objectMode ? 1 : chunk.length, addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if ((state.state & kNeedReadable) !== 0)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    Readable.prototype.isPaused = function() {
      let state = this._readableState;
      return state[kPaused] === true || state.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      let decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder, this._readableState.encoding = this._readableState.decoder.encoding;
      let buffer = this._readableState.buffer, content = "";
      for (let data of buffer)
        content += decoder.write(data);
      if (buffer.clear(), content !== "")
        buffer.push(content);
      return this._readableState.length = content.length, this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n > MAX_HWM)
        throw new ERR_OUT_OF_RANGE3("size", "<= 1GiB", n);
      else
        n--, n |= n >>> 1, n |= n >>> 2, n |= n >>> 4, n |= n >>> 8, n |= n >>> 16, n++;
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if ((state.state & kObjectMode) !== 0)
        return 1;
      if (NumberIsNaN(n)) {
        if (state.flowing && state.length)
          return state.buffer.first().length;
        return state.length;
      }
      if (n <= state.length)
        return n;
      return state.ended ? state.length : 0;
    }
    Readable.prototype.read = function(n) {
      if (debug("read", n), n === undefined)
        n = NaN;
      else if (!NumberIsInteger(n))
        n = NumberParseInt(n, 10);
      let state = this._readableState, nOrig = n;
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n !== 0)
        state.state &= ~kEmittedReadable;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        if (debug("read: emitReadable", state.length, state.ended), state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      if (n = howMuchToRead(n, state), n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      let doRead = (state.state & kNeedReadable) !== 0;
      if (debug("need readable", doRead), state.length === 0 || state.length - n < state.highWaterMark)
        doRead = true, debug("length less than watermark", doRead);
      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed)
        doRead = false, debug("reading, ended or constructing", doRead);
      else if (doRead) {
        if (debug("do read"), state.state |= kReading | kSync, state.length === 0)
          state.state |= kNeedReadable;
        try {
          this._read(state.highWaterMark);
        } catch (err) {
          errorOrDestroy(this, err);
        }
        if (state.state &= ~kSync, !state.reading)
          n = howMuchToRead(nOrig, state);
      }
      let ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null)
        state.needReadable = state.length <= state.highWaterMark, n = 0;
      else if (state.length -= n, state.multiAwaitDrain)
        state.awaitDrainWriters.clear();
      else
        state.awaitDrainWriters = null;
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null && !state.errorEmitted && !state.closeEmitted)
        state.dataEmitted = true, this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (debug("onEofChunk"), state.ended)
        return;
      if (state.decoder) {
        let chunk = state.decoder.end();
        if (chunk && chunk.length)
          state.buffer.push(chunk), state.length += state.objectMode ? 1 : chunk.length;
      }
      if (state.ended = true, state.sync)
        emitReadable(stream);
      else
        state.needReadable = false, state.emittedReadable = true, emitReadable_(stream);
    }
    function emitReadable(stream) {
      let state = stream._readableState;
      if (debug("emitReadable", state.needReadable, state.emittedReadable), state.needReadable = false, !state.emittedReadable)
        debug("emitReadable", state.flowing), state.emittedReadable = true, process2.nextTick(emitReadable_, stream);
    }
    function emitReadable_(stream) {
      let state = stream._readableState;
      if (debug("emitReadable_", state.destroyed, state.length, state.ended), !state.destroyed && !state.errored && (state.length || state.ended))
        stream.emit("readable"), state.emittedReadable = false;
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark, flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore && state.constructed)
        state.readingMore = true, process2.nextTick(maybeReadMore_, stream, state);
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        let len2 = state.length;
        if (debug("maybeReadMore read 0"), stream.read(0), len2 === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      let src = this, state = this._readableState;
      if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain)
          state.multiAwaitDrain = true, state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
      }
      state.pipes.push(dest), debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
      let endFn = (!pipeOpts || pipeOpts.end !== false) && dest !== process2.stdout && dest !== process2.stderr ? onend : unpipe;
      if (state.endEmitted)
        process2.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        if (debug("onunpipe"), readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false)
            unpipeInfo.hasUnpiped = true, cleanup();
        }
      }
      function onend() {
        debug("onend"), dest.end();
      }
      let ondrain, cleanedUp = false;
      function cleanup() {
        if (debug("cleanup"), dest.removeListener("close", onclose), dest.removeListener("finish", onfinish), ondrain)
          dest.removeListener("drain", ondrain);
        if (dest.removeListener("error", onerror), dest.removeListener("unpipe", onunpipe), src.removeListener("end", onend), src.removeListener("end", unpipe), src.removeListener("data", ondata), cleanedUp = true, ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      function pause() {
        if (!cleanedUp) {
          if (state.pipes.length === 1 && state.pipes[0] === dest)
            debug("false write response, pause", 0), state.awaitDrainWriters = dest, state.multiAwaitDrain = false;
          else if (state.pipes.length > 1 && state.pipes.includes(dest))
            debug("false write response, pause", state.awaitDrainWriters.size), state.awaitDrainWriters.add(dest);
          src.pause();
        }
        if (!ondrain)
          ondrain = pipeOnDrain(src, dest), dest.on("drain", ondrain);
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        let ret = dest.write(chunk);
        if (debug("dest.write", ret), ret === false)
          pause();
      }
      function onerror(er3) {
        if (debug("onerror", er3), unpipe(), dest.removeListener("error", onerror), dest.listenerCount("error") === 0) {
          let s3 = dest._writableState || dest._readableState;
          if (s3 && !s3.errorEmitted)
            errorOrDestroy(dest, er3);
          else
            dest.emit("error", er3);
        }
      }
      prependListener2(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish), unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish"), dest.removeListener("close", onclose), unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe"), src.unpipe(dest);
      }
      if (dest.emit("pipe", src), dest.writableNeedDrain === true)
        pause();
      else if (!state.flowing)
        debug("pipe resume"), src.resume();
      return dest;
    };
    function pipeOnDrain(src, dest) {
      return function pipeOnDrainFunctionResult() {
        let state = src._readableState;
        if (state.awaitDrainWriters === dest)
          debug("pipeOnDrain", 1), state.awaitDrainWriters = null;
        else if (state.multiAwaitDrain)
          debug("pipeOnDrain", state.awaitDrainWriters.size), state.awaitDrainWriters.delete(dest);
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data"))
          src.resume();
      };
    }
    Readable.prototype.unpipe = function(dest) {
      let state = this._readableState, unpipeInfo = { hasUnpiped: false };
      if (state.pipes.length === 0)
        return this;
      if (!dest) {
        let dests = state.pipes;
        state.pipes = [], this.pause();
        for (let i2 = 0;i2 < dests.length; i2++)
          dests[i2].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      let index = ArrayPrototypeIndexOf(state.pipes, dest);
      if (index === -1)
        return this;
      if (state.pipes.splice(index, 1), state.pipes.length === 0)
        this.pause();
      return dest.emit("unpipe", this, unpipeInfo), this;
    };
    Readable.prototype.on = function(ev, fn2) {
      let res = Stream.prototype.on.call(this, ev, fn2), state = this._readableState;
      if (ev === "data") {
        if (state.readableListening = this.listenerCount("readable") > 0, state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          if (state.readableListening = state.needReadable = true, state.flowing = false, state.emittedReadable = false, debug("on readable", state.length, state.reading), state.length)
            emitReadable(this);
          else if (!state.reading)
            process2.nextTick(nReadingNextTick, this);
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn2) {
      let res = Stream.prototype.removeListener.call(this, ev, fn2);
      if (ev === "readable")
        process2.nextTick(updateReadableListening, this);
      return res;
    };
    Readable.prototype.off = Readable.prototype.removeListener;
    Readable.prototype.removeAllListeners = function(ev) {
      let res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === undefined)
        process2.nextTick(updateReadableListening, this);
      return res;
    };
    function updateReadableListening(self2) {
      let state = self2._readableState;
      if (state.readableListening = self2.listenerCount("readable") > 0, state.resumeScheduled && state[kPaused] === false)
        state.flowing = true;
      else if (self2.listenerCount("data") > 0)
        self2.resume();
      else if (!state.readableListening)
        state.flowing = null;
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0"), self2.read(0);
    }
    Readable.prototype.resume = function() {
      let state = this._readableState;
      if (!state.flowing)
        debug("resume"), state.flowing = !state.readableListening, resume(this, state);
      return state[kPaused] = false, this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled)
        state.resumeScheduled = true, process2.nextTick(resume_, stream, state);
    }
    function resume_(stream, state) {
      if (debug("resume", state.reading), !state.reading)
        stream.read(0);
      if (state.resumeScheduled = false, stream.emit("resume"), flow(stream), state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      if (debug("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false)
        debug("pause"), this._readableState.flowing = false, this.emit("pause");
      return this._readableState[kPaused] = true, this;
    };
    function flow(stream) {
      let state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      let paused = false;
      stream.on("data", (chunk) => {
        if (!this.push(chunk) && stream.pause)
          paused = true, stream.pause();
      }), stream.on("end", () => {
        this.push(null);
      }), stream.on("error", (err) => {
        errorOrDestroy(this, err);
      }), stream.on("close", () => {
        this.destroy();
      }), stream.on("destroy", () => {
        this.destroy();
      }), this._read = () => {
        if (paused && stream.resume)
          paused = false, stream.resume();
      };
      let streamKeys = ObjectKeys(stream);
      for (let j3 = 1;j3 < streamKeys.length; j3++) {
        let i2 = streamKeys[j3];
        if (this[i2] === undefined && typeof stream[i2] === "function")
          this[i2] = stream[i2].bind(stream);
      }
      return this;
    };
    Readable.prototype[SymbolAsyncIterator] = function() {
      return streamToAsyncIterator(this);
    };
    Readable.prototype.iterator = function(options) {
      if (options !== undefined)
        validateObject(options, "options");
      return streamToAsyncIterator(this, options);
    };
    function streamToAsyncIterator(stream, options) {
      if (typeof stream.read !== "function")
        stream = Readable.wrap(stream, { objectMode: true });
      let iter = createAsyncIterator(stream, options);
      return iter.stream = stream, iter;
    }
    async function* createAsyncIterator(stream, options) {
      let callback = nop;
      function next(resolve2) {
        if (this === stream)
          callback(), callback = nop;
        else
          callback = resolve2;
      }
      stream.on("readable", next);
      let error, cleanup = eos(stream, { writable: false }, (err) => {
        error = err ? aggregateTwoErrors(error, err) : null, callback(), callback = nop;
      });
      try {
        while (true) {
          let chunk = stream.destroyed ? null : stream.read();
          if (chunk !== null)
            yield chunk;
          else if (error)
            throw error;
          else if (error === null)
            return;
          else
            await new Promise2(next);
        }
      } catch (err) {
        throw error = aggregateTwoErrors(error, err), error;
      } finally {
        if ((error || (options === null || options === undefined ? undefined : options.destroyOnReturn) !== false) && (error === undefined || stream._readableState.autoDestroy))
          destroyImpl.destroyer(stream, null);
        else
          stream.off("readable", next), cleanup();
      }
    }
    ObjectDefineProperties(Readable.prototype, { readable: { __proto__: null, get() {
      let r = this._readableState;
      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
    }, set(val) {
      if (this._readableState)
        this._readableState.readable = !!val;
    } }, readableDidRead: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.dataEmitted;
    } }, readableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
    } }, readableHighWaterMark: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } }, readableBuffer: { __proto__: null, enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } }, readableFlowing: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(state) {
      if (this._readableState)
        this._readableState.flowing = state;
    } }, readableLength: { __proto__: null, enumerable: false, get() {
      return this._readableState.length;
    } }, readableObjectMode: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.objectMode : false;
    } }, readableEncoding: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.encoding : null;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.errored : null;
    } }, closed: { __proto__: null, get() {
      return this._readableState ? this._readableState.closed : false;
    } }, destroyed: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.destroyed : false;
    }, set(value) {
      if (!this._readableState)
        return;
      this._readableState.destroyed = value;
    } }, readableEnded: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.endEmitted : false;
    } } });
    ObjectDefineProperties(ReadableState.prototype, { pipesCount: { __proto__: null, get() {
      return this.pipes.length;
    } }, paused: { __proto__: null, get() {
      return this[kPaused] !== false;
    }, set(value) {
      this[kPaused] = !!value;
    } } });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      let ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else
        ret = state.buffer.consume(n, state.decoder);
      return ret;
    }
    function endReadable(stream) {
      let state = stream._readableState;
      if (debug("endReadable", state.endEmitted), !state.endEmitted)
        state.ended = true, process2.nextTick(endReadableNT, state, stream);
    }
    function endReadableNT(state, stream) {
      if (debug("endReadableNT", state.endEmitted, state.length), !state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        if (state.endEmitted = true, stream.emit("end"), stream.writable && stream.allowHalfOpen === false)
          process2.nextTick(endWritableNT, stream);
        else if (state.autoDestroy) {
          let wState = stream._writableState;
          if (!wState || wState.autoDestroy && (wState.finished || wState.writable === false))
            stream.destroy();
        }
      }
    }
    function endWritableNT(stream) {
      if (stream.writable && !stream.writableEnded && !stream.destroyed)
        stream.end();
    }
    Readable.from = function(iterable, opts) {
      return from2(Readable, iterable, opts);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === undefined)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Readable.fromWeb = function(readableStream, options) {
      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
    };
    Readable.toWeb = function(streamReadable, options) {
      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
    };
    Readable.wrap = function(src, options) {
      var _ref, _src$readableObjectMo;
      return new Readable({ objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== undefined ? _src$readableObjectMo : src.objectMode) !== null && _ref !== undefined ? _ref : true, ...options, destroy(err, callback) {
        destroyImpl.destroyer(src, err), callback(err);
      } }).wrap(src);
    };
  });
  var require_writable = __commonJS2((exports2, module2) => {
    var process2 = require_process(), { ArrayPrototypeSlice: ArrayPrototypeSlice2, Error: Error2, FunctionPrototypeSymbolHasInstance, ObjectDefineProperty, ObjectDefineProperties, ObjectSetPrototypeOf, StringPrototypeToLowerCase, Symbol: Symbol2, SymbolHasInstance } = require_primordials();
    module2.exports = Writable;
    Writable.WritableState = WritableState;
    var { EventEmitter: EE } = (init_events(), __toCommonJS(exports_events)), Stream = require_legacy().Stream, { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(exports_buffer)), destroyImpl = require_destroy(), { addAbortSignal } = require_add_abort_signal(), { getHighWaterMark, getDefaultHighWaterMark } = require_state(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED, ERR_STREAM_ALREADY_FINISHED, ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING } = require_errors().codes, { errorOrDestroy } = destroyImpl;
    ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Writable, Stream);
    function nop() {}
    var kOnFinished = Symbol2("kOnFinished");
    function WritableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      if (this.objectMode = !!(options && options.objectMode), isDuplex)
        this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      let noDecode = !!(options && options.decodeStrings === false);
      this.decodeStrings = !noDecode, this.defaultEncoding = options && options.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = onwrite.bind(undefined, stream), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, resetBuffer(this), this.pendingcb = 0, this.constructed = true, this.prefinished = false, this.errorEmitted = false, this.emitClose = !options || options.emitClose !== false, this.autoDestroy = !options || options.autoDestroy !== false, this.errored = null, this.closed = false, this.closeEmitted = false, this[kOnFinished] = [];
    }
    function resetBuffer(state) {
      state.buffered = [], state.bufferedIndex = 0, state.allBuffers = true, state.allNoop = true;
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      return ArrayPrototypeSlice2(this.buffered, this.bufferedIndex);
    };
    ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", { __proto__: null, get() {
      return this.buffered.length - this.bufferedIndex;
    } });
    function Writable(options) {
      let isDuplex = this instanceof require_duplex();
      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))
        return new Writable(options);
      if (this._writableState = new WritableState(options, this, isDuplex), options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal)
          addAbortSignal(options.signal, this);
      }
      Stream.call(this, options), destroyImpl.construct(this, () => {
        let state = this._writableState;
        if (!state.writing)
          clearBuffer(this, state);
        finishMaybe(this, state);
      });
    }
    ObjectDefineProperty(Writable, SymbolHasInstance, { __proto__: null, value: function(object) {
      if (FunctionPrototypeSymbolHasInstance(this, object))
        return true;
      if (this !== Writable)
        return false;
      return object && object._writableState instanceof WritableState;
    } });
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE);
    };
    function _write(stream, chunk, encoding, cb) {
      let state = stream._writableState;
      if (typeof encoding === "function")
        cb = encoding, encoding = state.defaultEncoding;
      else {
        if (!encoding)
          encoding = state.defaultEncoding;
        else if (encoding !== "buffer" && !Buffer3.isEncoding(encoding))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        if (typeof cb !== "function")
          cb = nop;
      }
      if (chunk === null)
        throw new ERR_STREAM_NULL_VALUES;
      else if (!state.objectMode)
        if (typeof chunk === "string") {
          if (state.decodeStrings !== false)
            chunk = Buffer3.from(chunk, encoding), encoding = "buffer";
        } else if (chunk instanceof Buffer3)
          encoding = "buffer";
        else if (Stream._isUint8Array(chunk))
          chunk = Stream._uint8ArrayToBuffer(chunk), encoding = "buffer";
        else
          throw new ERR_INVALID_ARG_TYPE3("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      let err;
      if (state.ending)
        err = new ERR_STREAM_WRITE_AFTER_END;
      else if (state.destroyed)
        err = new ERR_STREAM_DESTROYED("write");
      if (err)
        return process2.nextTick(cb, err), errorOrDestroy(stream, err, true), err;
      return state.pendingcb++, writeOrBuffer(stream, state, chunk, encoding, cb);
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      return _write(this, chunk, encoding, cb) === true;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      let state = this._writableState;
      if (state.corked) {
        if (state.corked--, !state.writing)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = StringPrototypeToLowerCase(encoding);
      if (!Buffer3.isEncoding(encoding))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      return this._writableState.defaultEncoding = encoding, this;
    };
    function writeOrBuffer(stream, state, chunk, encoding, callback) {
      let len2 = state.objectMode ? 1 : chunk.length;
      state.length += len2;
      let ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked || state.errored || !state.constructed) {
        if (state.buffered.push({ chunk, encoding, callback }), state.allBuffers && encoding !== "buffer")
          state.allBuffers = false;
        if (state.allNoop && callback !== nop)
          state.allNoop = false;
      } else
        state.writelen = len2, state.writecb = callback, state.writing = true, state.sync = true, stream._write(chunk, encoding, state.onwrite), state.sync = false;
      return ret && !state.errored && !state.destroyed;
    }
    function doWrite(stream, state, writev, len2, chunk, encoding, cb) {
      if (state.writelen = len2, state.writecb = cb, state.writing = true, state.sync = true, state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, er3, cb) {
      --state.pendingcb, cb(er3), errorBuffer(state), errorOrDestroy(stream, er3);
    }
    function onwrite(stream, er3) {
      let state = stream._writableState, sync = state.sync, cb = state.writecb;
      if (typeof cb !== "function") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK);
        return;
      }
      if (state.writing = false, state.writecb = null, state.length -= state.writelen, state.writelen = 0, er3) {
        if (er3.stack, !state.errored)
          state.errored = er3;
        if (stream._readableState && !stream._readableState.errored)
          stream._readableState.errored = er3;
        if (sync)
          process2.nextTick(onwriteError, stream, state, er3, cb);
        else
          onwriteError(stream, state, er3, cb);
      } else {
        if (state.buffered.length > state.bufferedIndex)
          clearBuffer(stream, state);
        if (sync)
          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb)
            state.afterWriteTickInfo.count++;
          else
            state.afterWriteTickInfo = { count: 1, cb, stream, state }, process2.nextTick(afterWriteTick, state.afterWriteTickInfo);
        else
          afterWrite(stream, state, 1, cb);
      }
    }
    function afterWriteTick({ stream, state, count, cb }) {
      return state.afterWriteTickInfo = null, afterWrite(stream, state, count, cb);
    }
    function afterWrite(stream, state, count, cb) {
      if (!state.ending && !stream.destroyed && state.length === 0 && state.needDrain)
        state.needDrain = false, stream.emit("drain");
      while (count-- > 0)
        state.pendingcb--, cb();
      if (state.destroyed)
        errorBuffer(state);
      finishMaybe(stream, state);
    }
    function errorBuffer(state) {
      if (state.writing)
        return;
      for (let n = state.bufferedIndex;n < state.buffered.length; ++n) {
        var _state$errored;
        let { chunk, callback } = state.buffered[n], len2 = state.objectMode ? 1 : chunk.length;
        state.length -= len2, callback((_state$errored = state.errored) !== null && _state$errored !== undefined ? _state$errored : new ERR_STREAM_DESTROYED("write"));
      }
      let onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i2 = 0;i2 < onfinishCallbacks.length; i2++) {
        var _state$errored2;
        onfinishCallbacks[i2]((_state$errored2 = state.errored) !== null && _state$errored2 !== undefined ? _state$errored2 : new ERR_STREAM_DESTROYED("end"));
      }
      resetBuffer(state);
    }
    function clearBuffer(stream, state) {
      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed)
        return;
      let { buffered, bufferedIndex, objectMode } = state, bufferedLength = buffered.length - bufferedIndex;
      if (!bufferedLength)
        return;
      let i2 = bufferedIndex;
      if (state.bufferProcessing = true, bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        let callback = state.allNoop ? nop : (err) => {
          for (let n = i2;n < buffered.length; ++n)
            buffered[n].callback(err);
        }, chunks = state.allNoop && i2 === 0 ? buffered : ArrayPrototypeSlice2(buffered, i2);
        chunks.allBuffers = state.allBuffers, doWrite(stream, state, true, state.length, chunks, "", callback), resetBuffer(state);
      } else {
        do {
          let { chunk, encoding, callback } = buffered[i2];
          buffered[i2++] = null;
          let len2 = objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len2, chunk, encoding, callback);
        } while (i2 < buffered.length && !state.writing);
        if (i2 === buffered.length)
          resetBuffer(state);
        else if (i2 > 256)
          buffered.splice(0, i2), state.bufferedIndex = 0;
        else
          state.bufferedIndex = i2;
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      if (this._writev)
        this._writev([{ chunk, encoding }], cb);
      else
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      let state = this._writableState;
      if (typeof chunk === "function")
        cb = chunk, chunk = null, encoding = null;
      else if (typeof encoding === "function")
        cb = encoding, encoding = null;
      let err;
      if (chunk !== null && chunk !== undefined) {
        let ret = _write(this, chunk, encoding);
        if (ret instanceof Error2)
          err = ret;
      }
      if (state.corked)
        state.corked = 1, this.uncork();
      if (err)
        ;
      else if (!state.errored && !state.ending)
        state.ending = true, finishMaybe(this, state, true), state.ended = true;
      else if (state.finished)
        err = new ERR_STREAM_ALREADY_FINISHED("end");
      else if (state.destroyed)
        err = new ERR_STREAM_DESTROYED("end");
      if (typeof cb === "function")
        if (err || state.finished)
          process2.nextTick(cb, err);
        else
          state[kOnFinished].push(cb);
      return this;
    };
    function needFinish(state) {
      return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
    }
    function callFinal(stream, state) {
      let called = false;
      function onFinish(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== undefined ? err : ERR_MULTIPLE_CALLBACK());
          return;
        }
        if (called = true, state.pendingcb--, err) {
          let onfinishCallbacks = state[kOnFinished].splice(0);
          for (let i2 = 0;i2 < onfinishCallbacks.length; i2++)
            onfinishCallbacks[i2](err);
          errorOrDestroy(stream, err, state.sync);
        } else if (needFinish(state))
          state.prefinished = true, stream.emit("prefinish"), state.pendingcb++, process2.nextTick(finish, stream, state);
      }
      state.sync = true, state.pendingcb++;
      try {
        stream._final(onFinish);
      } catch (err) {
        onFinish(err);
      }
      state.sync = false;
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled)
        if (typeof stream._final === "function" && !state.destroyed)
          state.finalCalled = true, callFinal(stream, state);
        else
          state.prefinished = true, stream.emit("prefinish");
    }
    function finishMaybe(stream, state, sync) {
      if (needFinish(state)) {
        if (prefinish(stream, state), state.pendingcb === 0) {
          if (sync)
            state.pendingcb++, process2.nextTick((stream2, state2) => {
              if (needFinish(state2))
                finish(stream2, state2);
              else
                state2.pendingcb--;
            }, stream, state);
          else if (needFinish(state))
            state.pendingcb++, finish(stream, state);
        }
      }
    }
    function finish(stream, state) {
      state.pendingcb--, state.finished = true;
      let onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i2 = 0;i2 < onfinishCallbacks.length; i2++)
        onfinishCallbacks[i2]();
      if (stream.emit("finish"), state.autoDestroy) {
        let rState = stream._readableState;
        if (!rState || rState.autoDestroy && (rState.endEmitted || rState.readable === false))
          stream.destroy();
      }
    }
    ObjectDefineProperties(Writable.prototype, { closed: { __proto__: null, get() {
      return this._writableState ? this._writableState.closed : false;
    } }, destroyed: { __proto__: null, get() {
      return this._writableState ? this._writableState.destroyed : false;
    }, set(value) {
      if (this._writableState)
        this._writableState.destroyed = value;
    } }, writable: { __proto__: null, get() {
      let w = this._writableState;
      return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
    }, set(val) {
      if (this._writableState)
        this._writableState.writable = !!val;
    } }, writableFinished: { __proto__: null, get() {
      return this._writableState ? this._writableState.finished : false;
    } }, writableObjectMode: { __proto__: null, get() {
      return this._writableState ? this._writableState.objectMode : false;
    } }, writableBuffer: { __proto__: null, get() {
      return this._writableState && this._writableState.getBuffer();
    } }, writableEnded: { __proto__: null, get() {
      return this._writableState ? this._writableState.ending : false;
    } }, writableNeedDrain: { __proto__: null, get() {
      let wState = this._writableState;
      if (!wState)
        return false;
      return !wState.destroyed && !wState.ending && wState.needDrain;
    } }, writableHighWaterMark: { __proto__: null, get() {
      return this._writableState && this._writableState.highWaterMark;
    } }, writableCorked: { __proto__: null, get() {
      return this._writableState ? this._writableState.corked : 0;
    } }, writableLength: { __proto__: null, get() {
      return this._writableState && this._writableState.length;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._writableState ? this._writableState.errored : null;
    } }, writableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
    } } });
    var destroy = destroyImpl.destroy;
    Writable.prototype.destroy = function(err, cb) {
      let state = this._writableState;
      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length))
        process2.nextTick(errorBuffer, state);
      return destroy.call(this, err, cb), this;
    };
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Writable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === undefined)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Writable.fromWeb = function(writableStream, options) {
      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
    };
    Writable.toWeb = function(streamWritable) {
      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
    };
  });
  var require_duplexify = __commonJS2((exports2, module2) => {
    var process2 = require_process(), bufferModule = (init_buffer(), __toCommonJS(exports_buffer)), { isReadable, isWritable, isIterable, isNodeStream, isReadableNodeStream, isWritableNodeStream, isDuplexNodeStream, isReadableStream, isWritableStream } = require_utils(), eos = require_end_of_stream(), { AbortError: AbortError2, codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_INVALID_RETURN_VALUE } } = require_errors(), { destroyer } = require_destroy(), Duplex = require_duplex(), Readable = require_readable(), Writable = require_writable(), { createDeferredPromise } = require_util(), from2 = require_from(), Blob3 = globalThis.Blob || bufferModule.Blob, isBlob = typeof Blob3 !== "undefined" ? function isBlob(b) {
      return b instanceof Blob3;
    } : function isBlob(b) {
      return false;
    }, AbortController2 = globalThis.AbortController || require_abort_controller().AbortController, { FunctionPrototypeCall } = require_primordials();

    class Duplexify extends Duplex {
      constructor(options) {
        super(options);
        if ((options === null || options === undefined ? undefined : options.readable) === false)
          this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true;
        if ((options === null || options === undefined ? undefined : options.writable) === false)
          this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true;
      }
    }
    module2.exports = function duplexify(body, name) {
      if (isDuplexNodeStream(body))
        return body;
      if (isReadableNodeStream(body))
        return _duplexify({ readable: body });
      if (isWritableNodeStream(body))
        return _duplexify({ writable: body });
      if (isNodeStream(body))
        return _duplexify({ writable: false, readable: false });
      if (isReadableStream(body))
        return _duplexify({ readable: Readable.fromWeb(body) });
      if (isWritableStream(body))
        return _duplexify({ writable: Writable.fromWeb(body) });
      if (typeof body === "function") {
        let { value, write: write3, final, destroy } = fromAsyncGen(body);
        if (isIterable(value))
          return from2(Duplexify, value, { objectMode: true, write: write3, final, destroy });
        let then2 = value === null || value === undefined ? undefined : value.then;
        if (typeof then2 === "function") {
          let d3, promise = FunctionPrototypeCall(then2, value, (val) => {
            if (val != null)
              throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
          }, (err) => {
            destroyer(d3, err);
          });
          return d3 = new Duplexify({ objectMode: true, readable: false, write: write3, final(cb) {
            final(async () => {
              try {
                await promise, process2.nextTick(cb, null);
              } catch (err) {
                process2.nextTick(cb, err);
              }
            });
          }, destroy });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
      }
      if (isBlob(body))
        return duplexify(body.arrayBuffer());
      if (isIterable(body))
        return from2(Duplexify, body, { objectMode: true, writable: false });
      if (isReadableStream(body === null || body === undefined ? undefined : body.readable) && isWritableStream(body === null || body === undefined ? undefined : body.writable))
        return Duplexify.fromWeb(body);
      if (typeof (body === null || body === undefined ? undefined : body.writable) === "object" || typeof (body === null || body === undefined ? undefined : body.readable) === "object") {
        let readable = body !== null && body !== undefined && body.readable ? isReadableNodeStream(body === null || body === undefined ? undefined : body.readable) ? body === null || body === undefined ? undefined : body.readable : duplexify(body.readable) : undefined, writable = body !== null && body !== undefined && body.writable ? isWritableNodeStream(body === null || body === undefined ? undefined : body.writable) ? body === null || body === undefined ? undefined : body.writable : duplexify(body.writable) : undefined;
        return _duplexify({ readable, writable });
      }
      let then = body === null || body === undefined ? undefined : body.then;
      if (typeof then === "function") {
        let d3;
        return FunctionPrototypeCall(then, body, (val) => {
          if (val != null)
            d3.push(val);
          d3.push(null);
        }, (err) => {
          destroyer(d3, err);
        }), d3 = new Duplexify({ objectMode: true, writable: false, read() {} });
      }
      throw new ERR_INVALID_ARG_TYPE3(name, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], body);
    };
    function fromAsyncGen(fn2) {
      let { promise, resolve: resolve2 } = createDeferredPromise(), ac = new AbortController2, signal = ac.signal;
      return { value: fn2(async function* () {
        while (true) {
          let _promise = promise;
          promise = null;
          let { chunk, done, cb } = await _promise;
          if (process2.nextTick(cb), done)
            return;
          if (signal.aborted)
            throw new AbortError2(undefined, { cause: signal.reason });
          ({ promise, resolve: resolve2 } = createDeferredPromise()), yield chunk;
        }
      }(), { signal }), write(chunk, encoding, cb) {
        let _resolve = resolve2;
        resolve2 = null, _resolve({ chunk, done: false, cb });
      }, final(cb) {
        let _resolve = resolve2;
        resolve2 = null, _resolve({ done: true, cb });
      }, destroy(err, cb) {
        ac.abort(), cb(err);
      } };
    }
    function _duplexify(pair) {
      let r = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable, w = pair.writable, readable = !!isReadable(r), writable = !!isWritable(w), ondrain, onfinish, onreadable, onclose, d3;
      function onfinished(err) {
        let cb = onclose;
        if (onclose = null, cb)
          cb(err);
        else if (err)
          d3.destroy(err);
      }
      if (d3 = new Duplexify({ readableObjectMode: !!(r !== null && r !== undefined && r.readableObjectMode), writableObjectMode: !!(w !== null && w !== undefined && w.writableObjectMode), readable, writable }), writable)
        eos(w, (err) => {
          if (writable = false, err)
            destroyer(r, err);
          onfinished(err);
        }), d3._write = function(chunk, encoding, callback) {
          if (w.write(chunk, encoding))
            callback();
          else
            ondrain = callback;
        }, d3._final = function(callback) {
          w.end(), onfinish = callback;
        }, w.on("drain", function() {
          if (ondrain) {
            let cb = ondrain;
            ondrain = null, cb();
          }
        }), w.on("finish", function() {
          if (onfinish) {
            let cb = onfinish;
            onfinish = null, cb();
          }
        });
      if (readable)
        eos(r, (err) => {
          if (readable = false, err)
            destroyer(r, err);
          onfinished(err);
        }), r.on("readable", function() {
          if (onreadable) {
            let cb = onreadable;
            onreadable = null, cb();
          }
        }), r.on("end", function() {
          d3.push(null);
        }), d3._read = function() {
          while (true) {
            let buf = r.read();
            if (buf === null) {
              onreadable = d3._read;
              return;
            }
            if (!d3.push(buf))
              return;
          }
        };
      return d3._destroy = function(err, callback) {
        if (!err && onclose !== null)
          err = new AbortError2;
        if (onreadable = null, ondrain = null, onfinish = null, onclose === null)
          callback(err);
        else
          onclose = callback, destroyer(w, err), destroyer(r, err);
      }, d3;
    }
  });
  var require_duplex = __commonJS2((exports2, module2) => {
    var { ObjectDefineProperties, ObjectGetOwnPropertyDescriptor, ObjectKeys, ObjectSetPrototypeOf } = require_primordials();
    module2.exports = Duplex;
    var Readable = require_readable(), Writable = require_writable();
    ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);
    ObjectSetPrototypeOf(Duplex, Readable);
    {
      let keys = ObjectKeys(Writable.prototype);
      for (let i2 = 0;i2 < keys.length; i2++) {
        let method = keys[i2];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      if (Readable.call(this, options), Writable.call(this, options), options) {
        if (this.allowHalfOpen = options.allowHalfOpen !== false, options.readable === false)
          this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true;
        if (options.writable === false)
          this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true;
      } else
        this.allowHalfOpen = true;
    }
    ObjectDefineProperties(Duplex.prototype, { writable: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable") }, writableHighWaterMark: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark") }, writableObjectMode: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode") }, writableBuffer: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer") }, writableLength: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength") }, writableFinished: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished") }, writableCorked: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked") }, writableEnded: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded") }, writableNeedDrain: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain") }, destroyed: { __proto__: null, get() {
      if (this._readableState === undefined || this._writableState === undefined)
        return false;
      return this._readableState.destroyed && this._writableState.destroyed;
    }, set(value) {
      if (this._readableState && this._writableState)
        this._readableState.destroyed = value, this._writableState.destroyed = value;
    } } });
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === undefined)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Duplex.fromWeb = function(pair, options) {
      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
    };
    Duplex.toWeb = function(duplex) {
      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
    };
    var duplexify;
    Duplex.from = function(body) {
      if (!duplexify)
        duplexify = require_duplexify();
      return duplexify(body, "body");
    };
  });
  var require_transform = __commonJS2((exports2, module2) => {
    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
    module2.exports = Transform;
    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors().codes, Duplex = require_duplex(), { getHighWaterMark } = require_state();
    ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
    ObjectSetPrototypeOf(Transform, Duplex);
    var kCallback = Symbol2("kCallback");
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      let readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
      if (readableHighWaterMark === 0)
        options = { ...options, highWaterMark: null, readableHighWaterMark, writableHighWaterMark: options.writableHighWaterMark || 0 };
      if (Duplex.call(this, options), this._readableState.sync = false, this[kCallback] = null, options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function final(cb) {
      if (typeof this._flush === "function" && !this.destroyed)
        this._flush((er3, data) => {
          if (er3) {
            if (cb)
              cb(er3);
            else
              this.destroy(er3);
            return;
          }
          if (data != null)
            this.push(data);
          if (this.push(null), cb)
            cb();
        });
      else if (this.push(null), cb)
        cb();
    }
    function prefinish() {
      if (this._final !== final)
        final.call(this);
    }
    Transform.prototype._final = final;
    Transform.prototype._transform = function(chunk, encoding, callback) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    Transform.prototype._write = function(chunk, encoding, callback) {
      let rState = this._readableState, wState = this._writableState, length = rState.length;
      this._transform(chunk, encoding, (err, val) => {
        if (err) {
          callback(err);
          return;
        }
        if (val != null)
          this.push(val);
        if (wState.ended || length === rState.length || rState.length < rState.highWaterMark)
          callback();
        else
          this[kCallback] = callback;
      });
    };
    Transform.prototype._read = function() {
      if (this[kCallback]) {
        let callback = this[kCallback];
        this[kCallback] = null, callback();
      }
    };
  });
  var require_passthrough = __commonJS2((exports2, module2) => {
    var { ObjectSetPrototypeOf } = require_primordials();
    module2.exports = PassThrough;
    var Transform = require_transform();
    ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
    ObjectSetPrototypeOf(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  });
  var require_pipeline = __commonJS2((exports2, module2) => {
    var process2 = require_process(), { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator, SymbolDispose } = require_primordials(), eos = require_end_of_stream(), { once: once3 } = require_util(), destroyImpl = require_destroy(), Duplex = require_duplex(), { aggregateTwoErrors, codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS, ERR_STREAM_DESTROYED, ERR_STREAM_PREMATURE_CLOSE }, AbortError: AbortError2 } = require_errors(), { validateFunction, validateAbortSignal: validateAbortSignal2 } = require_validators(), { isIterable, isReadable, isReadableNodeStream, isNodeStream, isTransformStream, isWebStream, isReadableStream, isReadableFinished } = require_utils(), AbortController2 = globalThis.AbortController || require_abort_controller().AbortController, PassThrough, Readable, addAbortListener2;
    function destroyer(stream, reading, writing) {
      let finished = false;
      stream.on("close", () => {
        finished = true;
      });
      let cleanup = eos(stream, { readable: reading, writable: writing }, (err) => {
        finished = !err;
      });
      return { destroy: (err) => {
        if (finished)
          return;
        finished = true, destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
      }, cleanup };
    }
    function popCallback(streams) {
      return validateFunction(streams[streams.length - 1], "streams[stream.length - 1]"), streams.pop();
    }
    function makeAsyncIterable(val) {
      if (isIterable(val))
        return val;
      else if (isReadableNodeStream(val))
        return fromReadable(val);
      throw new ERR_INVALID_ARG_TYPE3("val", ["Readable", "Iterable", "AsyncIterable"], val);
    }
    async function* fromReadable(val) {
      if (!Readable)
        Readable = require_readable();
      yield* Readable.prototype[SymbolAsyncIterator].call(val);
    }
    async function pumpToNode(iterable, writable, finish, { end }) {
      let error, onresolve = null, resume = (err) => {
        if (err)
          error = err;
        if (onresolve) {
          let callback = onresolve;
          onresolve = null, callback();
        }
      }, wait = () => new Promise2((resolve2, reject) => {
        if (error)
          reject(error);
        else
          onresolve = () => {
            if (error)
              reject(error);
            else
              resolve2();
          };
      });
      writable.on("drain", resume);
      let cleanup = eos(writable, { readable: false }, resume);
      try {
        if (writable.writableNeedDrain)
          await wait();
        for await (let chunk of iterable)
          if (!writable.write(chunk))
            await wait();
        if (end)
          writable.end(), await wait();
        finish();
      } catch (err) {
        finish(error !== err ? aggregateTwoErrors(error, err) : err);
      } finally {
        cleanup(), writable.off("drain", resume);
      }
    }
    async function pumpToWeb(readable, writable, finish, { end }) {
      if (isTransformStream(writable))
        writable = writable.writable;
      let writer = writable.getWriter();
      try {
        for await (let chunk of readable)
          await writer.ready, writer.write(chunk).catch(() => {});
        if (await writer.ready, end)
          await writer.close();
        finish();
      } catch (err) {
        try {
          await writer.abort(err), finish(err);
        } catch (err2) {
          finish(err2);
        }
      }
    }
    function pipeline(...streams) {
      return pipelineImpl(streams, once3(popCallback(streams)));
    }
    function pipelineImpl(streams, callback, opts) {
      if (streams.length === 1 && ArrayIsArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2)
        throw new ERR_MISSING_ARGS("streams");
      let ac = new AbortController2, signal = ac.signal, outerSignal = opts === null || opts === undefined ? undefined : opts.signal, lastStreamCleanup = [];
      validateAbortSignal2(outerSignal, "options.signal");
      function abort() {
        finishImpl(new AbortError2);
      }
      addAbortListener2 = addAbortListener2 || require_util().addAbortListener;
      let disposable;
      if (outerSignal)
        disposable = addAbortListener2(outerSignal, abort);
      let error, value, destroys = [], finishCount = 0;
      function finish(err) {
        finishImpl(err, --finishCount === 0);
      }
      function finishImpl(err, final) {
        var _disposable;
        if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE"))
          error = err;
        if (!error && !final)
          return;
        while (destroys.length)
          destroys.shift()(error);
        if ((_disposable = disposable) === null || _disposable === undefined || _disposable[SymbolDispose](), ac.abort(), final) {
          if (!error)
            lastStreamCleanup.forEach((fn2) => fn2());
          process2.nextTick(callback, error, value);
        }
      }
      let ret;
      for (let i2 = 0;i2 < streams.length; i2++) {
        let stream = streams[i2], reading = i2 < streams.length - 1, writing = i2 > 0, end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false, isLastStream = i2 === streams.length - 1;
        if (isNodeStream(stream)) {
          let onError2 = function(err) {
            if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE")
              finish(err);
          };
          var onError = onError2;
          if (end) {
            let { destroy, cleanup } = destroyer(stream, reading, writing);
            if (destroys.push(destroy), isReadable(stream) && isLastStream)
              lastStreamCleanup.push(cleanup);
          }
          if (stream.on("error", onError2), isReadable(stream) && isLastStream)
            lastStreamCleanup.push(() => {
              stream.removeListener("error", onError2);
            });
        }
        if (i2 === 0)
          if (typeof stream === "function") {
            if (ret = stream({ signal }), !isIterable(ret))
              throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
          } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream))
            ret = stream;
          else
            ret = Duplex.from(stream);
        else if (typeof stream === "function") {
          if (isTransformStream(ret)) {
            var _ret;
            ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable);
          } else
            ret = makeAsyncIterable(ret);
          if (ret = stream(ret, { signal }), reading) {
            if (!isIterable(ret, true))
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i2 - 1}]`, ret);
          } else {
            var _ret2;
            if (!PassThrough)
              PassThrough = require_passthrough();
            let pt3 = new PassThrough({ objectMode: true }), then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then;
            if (typeof then === "function")
              finishCount++, then.call(ret, (val) => {
                if (value = val, val != null)
                  pt3.write(val);
                if (end)
                  pt3.end();
                process2.nextTick(finish);
              }, (err) => {
                pt3.destroy(err), process2.nextTick(finish, err);
              });
            else if (isIterable(ret, true))
              finishCount++, pumpToNode(ret, pt3, finish, { end });
            else if (isReadableStream(ret) || isTransformStream(ret)) {
              let toRead = ret.readable || ret;
              finishCount++, pumpToNode(toRead, pt3, finish, { end });
            } else
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
            ret = pt3;
            let { destroy, cleanup } = destroyer(ret, false, true);
            if (destroys.push(destroy), isLastStream)
              lastStreamCleanup.push(cleanup);
          }
        } else if (isNodeStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount += 2;
            let cleanup = pipe(ret, stream, finish, { end });
            if (isReadable(stream) && isLastStream)
              lastStreamCleanup.push(cleanup);
          } else if (isTransformStream(ret) || isReadableStream(ret)) {
            let toRead = ret.readable || ret;
            finishCount++, pumpToNode(toRead, stream, finish, { end });
          } else if (isIterable(ret))
            finishCount++, pumpToNode(ret, stream, finish, { end });
          else
            throw new ERR_INVALID_ARG_TYPE3("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
          ret = stream;
        } else if (isWebStream(stream)) {
          if (isReadableNodeStream(ret))
            finishCount++, pumpToWeb(makeAsyncIterable(ret), stream, finish, { end });
          else if (isReadableStream(ret) || isIterable(ret))
            finishCount++, pumpToWeb(ret, stream, finish, { end });
          else if (isTransformStream(ret))
            finishCount++, pumpToWeb(ret.readable, stream, finish, { end });
          else
            throw new ERR_INVALID_ARG_TYPE3("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
          ret = stream;
        } else
          ret = Duplex.from(stream);
      }
      if (signal !== null && signal !== undefined && signal.aborted || outerSignal !== null && outerSignal !== undefined && outerSignal.aborted)
        process2.nextTick(abort);
      return ret;
    }
    function pipe(src, dst, finish, { end }) {
      let ended = false;
      if (dst.on("close", () => {
        if (!ended)
          finish(new ERR_STREAM_PREMATURE_CLOSE);
      }), src.pipe(dst, { end: false }), end) {
        let endFn2 = function() {
          ended = true, dst.end();
        };
        var endFn = endFn2;
        if (isReadableFinished(src))
          process2.nextTick(endFn2);
        else
          src.once("end", endFn2);
      } else
        finish();
      return eos(src, { readable: true, writable: false }, (err) => {
        let rState = src._readableState;
        if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted)
          src.once("end", finish).once("error", finish);
        else
          finish(err);
      }), eos(dst, { readable: false, writable: true }, finish);
    }
    module2.exports = { pipelineImpl, pipeline };
  });
  var require_compose = __commonJS2((exports2, module2) => {
    var { pipeline } = require_pipeline(), Duplex = require_duplex(), { destroyer } = require_destroy(), { isNodeStream, isReadable, isWritable, isWebStream, isTransformStream, isWritableStream, isReadableStream } = require_utils(), { AbortError: AbortError2, codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS } } = require_errors(), eos = require_end_of_stream();
    module2.exports = function compose(...streams) {
      if (streams.length === 0)
        throw new ERR_MISSING_ARGS("streams");
      if (streams.length === 1)
        return Duplex.from(streams[0]);
      let orgStreams = [...streams];
      if (typeof streams[0] === "function")
        streams[0] = Duplex.from(streams[0]);
      if (typeof streams[streams.length - 1] === "function") {
        let idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
      }
      for (let n = 0;n < streams.length; ++n) {
        if (!isNodeStream(streams[n]) && !isWebStream(streams[n]))
          continue;
        if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n])))
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
        if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n])))
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
      }
      let ondrain, onfinish, onreadable, onclose, d3;
      function onfinished(err) {
        let cb = onclose;
        if (onclose = null, cb)
          cb(err);
        else if (err)
          d3.destroy(err);
        else if (!readable && !writable)
          d3.destroy();
      }
      let head = streams[0], tail = pipeline(streams, onfinished), writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head)), readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
      if (d3 = new Duplex({ writableObjectMode: !!(head !== null && head !== undefined && head.writableObjectMode), readableObjectMode: !!(tail !== null && tail !== undefined && tail.readableObjectMode), writable, readable }), writable) {
        if (isNodeStream(head))
          d3._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding))
              callback();
            else
              ondrain = callback;
          }, d3._final = function(callback) {
            head.end(), onfinish = callback;
          }, head.on("drain", function() {
            if (ondrain) {
              let cb = ondrain;
              ondrain = null, cb();
            }
          });
        else if (isWebStream(head)) {
          let writer = (isTransformStream(head) ? head.writable : head).getWriter();
          d3._write = async function(chunk, encoding, callback) {
            try {
              await writer.ready, writer.write(chunk).catch(() => {}), callback();
            } catch (err) {
              callback(err);
            }
          }, d3._final = async function(callback) {
            try {
              await writer.ready, writer.close().catch(() => {}), onfinish = callback;
            } catch (err) {
              callback(err);
            }
          };
        }
        let toRead = isTransformStream(tail) ? tail.readable : tail;
        eos(toRead, () => {
          if (onfinish) {
            let cb = onfinish;
            onfinish = null, cb();
          }
        });
      }
      if (readable) {
        if (isNodeStream(tail))
          tail.on("readable", function() {
            if (onreadable) {
              let cb = onreadable;
              onreadable = null, cb();
            }
          }), tail.on("end", function() {
            d3.push(null);
          }), d3._read = function() {
            while (true) {
              let buf = tail.read();
              if (buf === null) {
                onreadable = d3._read;
                return;
              }
              if (!d3.push(buf))
                return;
            }
          };
        else if (isWebStream(tail)) {
          let reader = (isTransformStream(tail) ? tail.readable : tail).getReader();
          d3._read = async function() {
            while (true)
              try {
                let { value, done } = await reader.read();
                if (!d3.push(value))
                  return;
                if (done) {
                  d3.push(null);
                  return;
                }
              } catch {
                return;
              }
          };
        }
      }
      return d3._destroy = function(err, callback) {
        if (!err && onclose !== null)
          err = new AbortError2;
        if (onreadable = null, ondrain = null, onfinish = null, onclose === null)
          callback(err);
        else if (onclose = callback, isNodeStream(tail))
          destroyer(tail, err);
      }, d3;
    };
  });
  var require_operators = __commonJS2((exports2, module2) => {
    var AbortController2 = globalThis.AbortController || require_abort_controller().AbortController, { codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE: ERR_OUT_OF_RANGE3 }, AbortError: AbortError2 } = require_errors(), { validateAbortSignal: validateAbortSignal2, validateInteger, validateObject } = require_validators(), kWeakHandler = require_primordials().Symbol("kWeak"), kResistStopPropagation = require_primordials().Symbol("kResistStopPropagation"), { finished } = require_end_of_stream(), staticCompose = require_compose(), { addAbortSignalNoValidate } = require_add_abort_signal(), { isWritable, isNodeStream } = require_utils(), { deprecate: deprecate2 } = require_util(), { ArrayPrototypePush, Boolean: Boolean2, MathFloor, Number: Number2, NumberIsNaN, Promise: Promise2, PromiseReject, PromiseResolve, PromisePrototypeThen, Symbol: Symbol2 } = require_primordials(), kEmpty = Symbol2("kEmpty"), kEof = Symbol2("kEof");
    function compose(stream, options) {
      if (options != null)
        validateObject(options, "options");
      if ((options === null || options === undefined ? undefined : options.signal) != null)
        validateAbortSignal2(options.signal, "options.signal");
      if (isNodeStream(stream) && !isWritable(stream))
        throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
      let composedStream = staticCompose(this, stream);
      if (options !== null && options !== undefined && options.signal)
        addAbortSignalNoValidate(options.signal, composedStream);
      return composedStream;
    }
    function map(fn2, options) {
      if (typeof fn2 !== "function")
        throw new ERR_INVALID_ARG_TYPE3("fn", ["Function", "AsyncFunction"], fn2);
      if (options != null)
        validateObject(options, "options");
      if ((options === null || options === undefined ? undefined : options.signal) != null)
        validateAbortSignal2(options.signal, "options.signal");
      let concurrency = 1;
      if ((options === null || options === undefined ? undefined : options.concurrency) != null)
        concurrency = MathFloor(options.concurrency);
      let highWaterMark = concurrency - 1;
      if ((options === null || options === undefined ? undefined : options.highWaterMark) != null)
        highWaterMark = MathFloor(options.highWaterMark);
      return validateInteger(concurrency, "options.concurrency", 1), validateInteger(highWaterMark, "options.highWaterMark", 0), highWaterMark += concurrency, async function* map() {
        let signal = require_util().AbortSignalAny([options === null || options === undefined ? undefined : options.signal].filter(Boolean2)), stream = this, queue = [], signalOpt = { signal }, next, resume, done = false, cnt = 0;
        function onCatch() {
          done = true, afterItemProcessed();
        }
        function afterItemProcessed() {
          cnt -= 1, maybeResume();
        }
        function maybeResume() {
          if (resume && !done && cnt < concurrency && queue.length < highWaterMark)
            resume(), resume = null;
        }
        async function pump() {
          try {
            for await (let val of stream) {
              if (done)
                return;
              if (signal.aborted)
                throw new AbortError2;
              try {
                if (val = fn2(val, signalOpt), val === kEmpty)
                  continue;
                val = PromiseResolve(val);
              } catch (err) {
                val = PromiseReject(err);
              }
              if (cnt += 1, PromisePrototypeThen(val, afterItemProcessed, onCatch), queue.push(val), next)
                next(), next = null;
              if (!done && (queue.length >= highWaterMark || cnt >= concurrency))
                await new Promise2((resolve2) => {
                  resume = resolve2;
                });
            }
            queue.push(kEof);
          } catch (err) {
            let val = PromiseReject(err);
            PromisePrototypeThen(val, afterItemProcessed, onCatch), queue.push(val);
          } finally {
            if (done = true, next)
              next(), next = null;
          }
        }
        pump();
        try {
          while (true) {
            while (queue.length > 0) {
              let val = await queue[0];
              if (val === kEof)
                return;
              if (signal.aborted)
                throw new AbortError2;
              if (val !== kEmpty)
                yield val;
              queue.shift(), maybeResume();
            }
            await new Promise2((resolve2) => {
              next = resolve2;
            });
          }
        } finally {
          if (done = true, resume)
            resume(), resume = null;
        }
      }.call(this);
    }
    function asIndexedPairs(options = undefined) {
      if (options != null)
        validateObject(options, "options");
      if ((options === null || options === undefined ? undefined : options.signal) != null)
        validateAbortSignal2(options.signal, "options.signal");
      return async function* asIndexedPairs() {
        let index = 0;
        for await (let val of this) {
          var _options$signal;
          if (options !== null && options !== undefined && (_options$signal = options.signal) !== null && _options$signal !== undefined && _options$signal.aborted)
            throw new AbortError2({ cause: options.signal.reason });
          yield [index++, val];
        }
      }.call(this);
    }
    async function some(fn2, options = undefined) {
      for await (let unused of filter.call(this, fn2, options))
        return true;
      return false;
    }
    async function every(fn2, options = undefined) {
      if (typeof fn2 !== "function")
        throw new ERR_INVALID_ARG_TYPE3("fn", ["Function", "AsyncFunction"], fn2);
      return !await some.call(this, async (...args) => {
        return !await fn2(...args);
      }, options);
    }
    async function find(fn2, options) {
      for await (let result of filter.call(this, fn2, options))
        return result;
      return;
    }
    async function forEach(fn2, options) {
      if (typeof fn2 !== "function")
        throw new ERR_INVALID_ARG_TYPE3("fn", ["Function", "AsyncFunction"], fn2);
      async function forEachFn(value, options2) {
        return await fn2(value, options2), kEmpty;
      }
      for await (let unused of map.call(this, forEachFn, options))
        ;
    }
    function filter(fn2, options) {
      if (typeof fn2 !== "function")
        throw new ERR_INVALID_ARG_TYPE3("fn", ["Function", "AsyncFunction"], fn2);
      async function filterFn(value, options2) {
        if (await fn2(value, options2))
          return value;
        return kEmpty;
      }
      return map.call(this, filterFn, options);
    }

    class ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    }
    async function reduce(reducer, initialValue, options) {
      var _options$signal2;
      if (typeof reducer !== "function")
        throw new ERR_INVALID_ARG_TYPE3("reducer", ["Function", "AsyncFunction"], reducer);
      if (options != null)
        validateObject(options, "options");
      if ((options === null || options === undefined ? undefined : options.signal) != null)
        validateAbortSignal2(options.signal, "options.signal");
      let hasInitialValue = arguments.length > 1;
      if (options !== null && options !== undefined && (_options$signal2 = options.signal) !== null && _options$signal2 !== undefined && _options$signal2.aborted) {
        let err = new AbortError2(undefined, { cause: options.signal.reason });
        throw this.once("error", () => {}), await finished(this.destroy(err)), err;
      }
      let ac = new AbortController2, signal = ac.signal;
      if (options !== null && options !== undefined && options.signal) {
        let opts = { once: true, [kWeakHandler]: this, [kResistStopPropagation]: true };
        options.signal.addEventListener("abort", () => ac.abort(), opts);
      }
      let gotAnyItemFromStream = false;
      try {
        for await (let value of this) {
          var _options$signal3;
          if (gotAnyItemFromStream = true, options !== null && options !== undefined && (_options$signal3 = options.signal) !== null && _options$signal3 !== undefined && _options$signal3.aborted)
            throw new AbortError2;
          if (!hasInitialValue)
            initialValue = value, hasInitialValue = true;
          else
            initialValue = await reducer(initialValue, value, { signal });
        }
        if (!gotAnyItemFromStream && !hasInitialValue)
          throw new ReduceAwareErrMissingArgs;
      } finally {
        ac.abort();
      }
      return initialValue;
    }
    async function toArray(options) {
      if (options != null)
        validateObject(options, "options");
      if ((options === null || options === undefined ? undefined : options.signal) != null)
        validateAbortSignal2(options.signal, "options.signal");
      let result = [];
      for await (let val of this) {
        var _options$signal4;
        if (options !== null && options !== undefined && (_options$signal4 = options.signal) !== null && _options$signal4 !== undefined && _options$signal4.aborted)
          throw new AbortError2(undefined, { cause: options.signal.reason });
        ArrayPrototypePush(result, val);
      }
      return result;
    }
    function flatMap(fn2, options) {
      let values = map.call(this, fn2, options);
      return async function* flatMap() {
        for await (let val of values)
          yield* val;
      }.call(this);
    }
    function toIntegerOrInfinity(number) {
      if (number = Number2(number), NumberIsNaN(number))
        return 0;
      if (number < 0)
        throw new ERR_OUT_OF_RANGE3("number", ">= 0", number);
      return number;
    }
    function drop(number, options = undefined) {
      if (options != null)
        validateObject(options, "options");
      if ((options === null || options === undefined ? undefined : options.signal) != null)
        validateAbortSignal2(options.signal, "options.signal");
      return number = toIntegerOrInfinity(number), async function* drop() {
        var _options$signal5;
        if (options !== null && options !== undefined && (_options$signal5 = options.signal) !== null && _options$signal5 !== undefined && _options$signal5.aborted)
          throw new AbortError2;
        for await (let val of this) {
          var _options$signal6;
          if (options !== null && options !== undefined && (_options$signal6 = options.signal) !== null && _options$signal6 !== undefined && _options$signal6.aborted)
            throw new AbortError2;
          if (number-- <= 0)
            yield val;
        }
      }.call(this);
    }
    function take(number, options = undefined) {
      if (options != null)
        validateObject(options, "options");
      if ((options === null || options === undefined ? undefined : options.signal) != null)
        validateAbortSignal2(options.signal, "options.signal");
      return number = toIntegerOrInfinity(number), async function* take() {
        var _options$signal7;
        if (options !== null && options !== undefined && (_options$signal7 = options.signal) !== null && _options$signal7 !== undefined && _options$signal7.aborted)
          throw new AbortError2;
        for await (let val of this) {
          var _options$signal8;
          if (options !== null && options !== undefined && (_options$signal8 = options.signal) !== null && _options$signal8 !== undefined && _options$signal8.aborted)
            throw new AbortError2;
          if (number-- > 0)
            yield val;
          if (number <= 0)
            return;
        }
      }.call(this);
    }
    module2.exports.streamReturningOperators = { asIndexedPairs: deprecate2(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."), drop, filter, flatMap, map, take, compose };
    module2.exports.promiseReturningOperators = { every, forEach, reduce, toArray, some, find };
  });
  var require_promises = __commonJS2((exports2, module2) => {
    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials(), { isIterable, isNodeStream, isWebStream } = require_utils(), { pipelineImpl: pl } = require_pipeline(), { finished } = require_end_of_stream();
    require_stream2();
    function pipeline(...streams) {
      return new Promise2((resolve2, reject) => {
        let signal, end, lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
          let options = ArrayPrototypePop(streams);
          signal = options.signal, end = options.end;
        }
        pl(streams, (err, value) => {
          if (err)
            reject(err);
          else
            resolve2(value);
        }, { signal, end });
      });
    }
    module2.exports = { finished, pipeline };
  });
  var require_stream2 = __commonJS2((exports2, module2) => {
    var { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(exports_buffer)), { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials(), { promisify: { custom: customPromisify } } = require_util(), { streamReturningOperators, promiseReturningOperators } = require_operators(), { codes: { ERR_ILLEGAL_CONSTRUCTOR } } = require_errors(), compose = require_compose(), { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state(), { pipeline } = require_pipeline(), { destroyer } = require_destroy(), eos = require_end_of_stream(), promises = require_promises(), utils = require_utils(), Stream = module2.exports = require_legacy().Stream;
    Stream.isDestroyed = utils.isDestroyed;
    Stream.isDisturbed = utils.isDisturbed;
    Stream.isErrored = utils.isErrored;
    Stream.isReadable = utils.isReadable;
    Stream.isWritable = utils.isWritable;
    Stream.Readable = require_readable();
    for (let key of ObjectKeys(streamReturningOperators)) {
      let fn2 = function(...args) {
        if (new.target)
          throw ERR_ILLEGAL_CONSTRUCTOR();
        return Stream.Readable.from(ReflectApply(op, this, args));
      }, op = streamReturningOperators[key];
      ObjectDefineProperty(fn2, "name", { __proto__: null, value: op.name }), ObjectDefineProperty(fn2, "length", { __proto__: null, value: op.length }), ObjectDefineProperty(Stream.Readable.prototype, key, { __proto__: null, value: fn2, enumerable: false, configurable: true, writable: true });
    }
    for (let key of ObjectKeys(promiseReturningOperators)) {
      let fn2 = function(...args) {
        if (new.target)
          throw ERR_ILLEGAL_CONSTRUCTOR();
        return ReflectApply(op, this, args);
      }, op = promiseReturningOperators[key];
      ObjectDefineProperty(fn2, "name", { __proto__: null, value: op.name }), ObjectDefineProperty(fn2, "length", { __proto__: null, value: op.length }), ObjectDefineProperty(Stream.Readable.prototype, key, { __proto__: null, value: fn2, enumerable: false, configurable: true, writable: true });
    }
    Stream.Writable = require_writable();
    Stream.Duplex = require_duplex();
    Stream.Transform = require_transform();
    Stream.PassThrough = require_passthrough();
    Stream.pipeline = pipeline;
    var { addAbortSignal } = require_add_abort_signal();
    Stream.addAbortSignal = addAbortSignal;
    Stream.finished = eos;
    Stream.destroy = destroyer;
    Stream.compose = compose;
    Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
    Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
    ObjectDefineProperty(Stream, "promises", { __proto__: null, configurable: true, enumerable: true, get() {
      return promises;
    } });
    ObjectDefineProperty(pipeline, customPromisify, { __proto__: null, enumerable: true, get() {
      return promises.pipeline;
    } });
    ObjectDefineProperty(eos, customPromisify, { __proto__: null, enumerable: true, get() {
      return promises.finished;
    } });
    Stream.Stream = Stream;
    Stream._isUint8Array = function isUint8Array(value) {
      return value instanceof Uint8Array;
    };
    Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    };
  });
  var require_ours = __commonJS2((exports2, module2) => {
    var Stream = require_stream();
    {
      let CustomStream = require_stream2(), promises = require_promises(), originalDestroy = CustomStream.Readable.destroy;
      module2.exports = CustomStream.Readable, module2.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer, module2.exports._isUint8Array = CustomStream._isUint8Array, module2.exports.isDisturbed = CustomStream.isDisturbed, module2.exports.isErrored = CustomStream.isErrored, module2.exports.isReadable = CustomStream.isReadable, module2.exports.Readable = CustomStream.Readable, module2.exports.Writable = CustomStream.Writable, module2.exports.Duplex = CustomStream.Duplex, module2.exports.Transform = CustomStream.Transform, module2.exports.PassThrough = CustomStream.PassThrough, module2.exports.addAbortSignal = CustomStream.addAbortSignal, module2.exports.finished = CustomStream.finished, module2.exports.destroy = CustomStream.destroy, module2.exports.destroy = originalDestroy, module2.exports.pipeline = CustomStream.pipeline, module2.exports.compose = CustomStream.compose, Object.defineProperty(CustomStream, "promises", { configurable: true, enumerable: true, get() {
        return promises;
      } }), module2.exports.Stream = CustomStream.Stream;
    }
    module2.exports.default = module2.exports;
  });
  module.exports = require_ours();
});

// node:crypto
var exports_crypto = {};
__export(exports_crypto, {
  webcrypto: () => webcrypto,
  rng: () => rng2,
  randomUUID: () => randomUUID,
  randomFillSync: () => randomFillSync2,
  randomFill: () => randomFill2,
  randomBytes: () => randomBytes2,
  publicEncrypt: () => publicEncrypt2,
  publicDecrypt: () => publicDecrypt2,
  pseudoRandomBytes: () => pseudoRandomBytes2,
  prng: () => prng2,
  privateEncrypt: () => privateEncrypt2,
  privateDecrypt: () => privateDecrypt2,
  pbkdf2Sync: () => pbkdf2Sync2,
  pbkdf2: () => pbkdf22,
  listCiphers: () => listCiphers2,
  getRandomValues: () => getRandomValues,
  getHashes: () => getHashes2,
  getDiffieHellman: () => getDiffieHellman2,
  getCurves: () => getCurves,
  getCiphers: () => getCiphers2,
  default: () => crypto_default,
  createVerify: () => createVerify2,
  createSign: () => createSign2,
  createHmac: () => createHmac2,
  createHash: () => createHash2,
  createECDH: () => createECDH2,
  createDiffieHellmanGroup: () => createDiffieHellmanGroup2,
  createDiffieHellman: () => createDiffieHellman2,
  createDecipheriv: () => createDecipheriv2,
  createDecipher: () => createDecipher2,
  createCredentials: () => createCredentials2,
  createCipheriv: () => createCipheriv2,
  createCipher: () => createCipher2,
  constants: () => constants2,
  Verify: () => Verify2,
  Sign: () => Sign2,
  Hmac: () => Hmac2,
  Hash: () => Hash2,
  DiffieHellmanGroup: () => DiffieHellmanGroup2,
  DiffieHellman: () => DiffieHellman2,
  Decipheriv: () => Decipheriv2,
  Decipher: () => Decipher2,
  DEFAULT_ENCODING: () => DEFAULT_ENCODING,
  Cipheriv: () => Cipheriv2,
  Cipher: () => Cipher2
});
function getCurves() {
  return hardcoded_curves;
}
var __create2, __getProtoOf2, __defProp2, __getOwnPropNames2, __hasOwnProp2, __toESM2 = (mod, isNodeMode, target) => {
  target = mod != null ? __create2(__getProtoOf2(mod)) : {};
  let to = isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames2(mod))
    if (!__hasOwnProp2.call(to, key))
      __defProp2(to, key, { get: () => mod[key], enumerable: true });
  return to;
}, __commonJS2 = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports), require_randombytes, require_create_hash, require_create_hmac, require_algorithms, require_precondition, require_default_encoding, require_safe_buffer, require_to_buffer, require_sync, require_async, require_pbkdf2, require_browserify_cipher, require_diffie_hellman, require_browserify_sign, require_package, require_bn, require_minimalistic_assert, require_utils, require_utils2, require_brorand, require_base, require_inherits_browser, require_inherits, require_short, require_mont, require_edwards, require_curve, require_utils3, require_common, require_common2, require_1, require_256, require_224, require_512, require_384, require_sha, require_ripemd, require_hmac, require_hash, require_secp256k1, require_curves, require_hmac_drbg, require_key, require_signature, require_ec, require_key2, require_signature2, require_eddsa, require_elliptic, require_bn2, require_browser, require_create_ecdh, require_bn3, require_api, require_reporter, require_buffer, require_node, require_base2, require_der, require_constants, require_der2, require_pem, require_decoders, require_der3, require_pem2, require_encoders, require_asn1, require_certificate, require_asn12, require_aesid, require_hash_base, require_md5, require_evp_bytestokey, require_browserify_aes, require_fixProc, require_parse_asn1, require_mgf, require_xor, require_bn4, require_withPublic, require_bn5, require_browserify_rsa, require_publicEncrypt, require_privateDecrypt, require_browser2, require_public_encrypt, require_browser3, require_randomfill, require_crypto_browserify, cryptoBrowserify, prng2, pseudoRandomBytes2, rng2, randomBytes2, Hash2, createHash2, Hmac2, createHmac2, getHashes2, pbkdf22, pbkdf2Sync2, Cipher2, createCipher2, Cipheriv2, createCipheriv2, Decipher2, createDecipher2, Decipheriv2, createDecipheriv2, getCiphers2, listCiphers2, DiffieHellmanGroup2, createDiffieHellmanGroup2, getDiffieHellman2, createDiffieHellman2, DiffieHellman2, createSign2, Sign2, createVerify2, Verify2, createECDH2, publicEncrypt2, privateEncrypt2, publicDecrypt2, privateDecrypt2, randomFill2, randomFillSync2, createCredentials2, constants2, DEFAULT_ENCODING = "buffer", getRandomValues = (array) => {
  return crypto.getRandomValues(array);
}, randomUUID = () => {
  return crypto.randomUUID();
}, hardcoded_curves, webcrypto, crypto_default;
var init_crypto = __esm(() => {
  __create2 = Object.create;
  ({ getPrototypeOf: __getProtoOf2, defineProperty: __defProp2, getOwnPropertyNames: __getOwnPropNames2 } = Object);
  __hasOwnProp2 = Object.prototype.hasOwnProperty;
  require_randombytes = __commonJS2((exports, module) => {
    module.exports = (init_crypto(), __toCommonJS(exports_crypto)).randomBytes;
  });
  require_create_hash = __commonJS2((exports, module) => {
    module.exports = (init_crypto(), __toCommonJS(exports_crypto)).createHash;
  });
  require_create_hmac = __commonJS2((exports, module) => {
    module.exports = (init_crypto(), __toCommonJS(exports_crypto)).createHmac;
  });
  require_algorithms = __commonJS2((exports, module) => {
    module.exports = { sha224WithRSAEncryption: { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption: { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption: { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption: { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256: { sign: "ecdsa", hash: "sha256", id: "" }, sha224: { sign: "ecdsa", hash: "sha224", id: "" }, sha384: { sign: "ecdsa", hash: "sha384", id: "" }, sha512: { sign: "ecdsa", hash: "sha512", id: "" }, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA: { sign: "dsa", hash: "sha1", id: "" }, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA: { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption: { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } };
  });
  require_precondition = __commonJS2((exports, module) => {
    var MAX_ALLOC = Math.pow(2, 30) - 1;
    module.exports = function(iterations, keylen) {
      if (typeof iterations !== "number")
        throw new TypeError("Iterations not a number");
      if (iterations < 0)
        throw new TypeError("Bad iterations");
      if (typeof keylen !== "number")
        throw new TypeError("Key length not a number");
      if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen)
        throw new TypeError("Bad key length");
    };
  });
  require_default_encoding = __commonJS2((exports, module) => {
    var defaultEncoding;
    if (globalThis.process && globalThis.process.browser)
      defaultEncoding = "utf-8";
    else if (globalThis.process && globalThis.process.version)
      pVersionMajor = parseInt(process.version.split(".")[0].slice(1), 10), defaultEncoding = pVersionMajor >= 6 ? "utf-8" : "binary";
    else
      defaultEncoding = "utf-8";
    var pVersionMajor;
    module.exports = defaultEncoding;
  });
  require_safe_buffer = __commonJS2((exports, module) => {
    /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    var buffer = (init_buffer(), __toCommonJS(exports_buffer)), Buffer22 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src)
        dst[key] = src[key];
    }
    if (Buffer22.from && Buffer22.alloc && Buffer22.allocUnsafe && Buffer22.allocUnsafeSlow)
      module.exports = buffer;
    else
      copyProps(buffer, exports), exports.Buffer = SafeBuffer;
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer22(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer22.prototype);
    copyProps(Buffer22, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number")
        throw new TypeError("Argument must not be a number");
      return Buffer22(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill2, encoding) {
      if (typeof size !== "number")
        throw new TypeError("Argument must be a number");
      var buf = Buffer22(size);
      if (fill2 !== undefined)
        if (typeof encoding === "string")
          buf.fill(fill2, encoding);
        else
          buf.fill(fill2);
      else
        buf.fill(0);
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number")
        throw new TypeError("Argument must be a number");
      return Buffer22(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number")
        throw new TypeError("Argument must be a number");
      return buffer.SlowBuffer(size);
    };
  });
  require_to_buffer = __commonJS2((exports, module) => {
    var Buffer22 = require_safe_buffer().Buffer;
    module.exports = function(thing, encoding, name) {
      if (Buffer22.isBuffer(thing))
        return thing;
      else if (typeof thing === "string")
        return Buffer22.from(thing, encoding);
      else if (ArrayBuffer.isView(thing))
        return Buffer22.from(thing.buffer);
      else
        throw new TypeError(name + " must be a string, a Buffer, a typed array or a DataView");
    };
  });
  require_sync = __commonJS2((exports, module) => {
    var sizes = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 }, createHmac = require_create_hmac(), Buffer22 = require_safe_buffer().Buffer, checkParameters = require_precondition(), defaultEncoding = require_default_encoding(), toBuffer = require_to_buffer();
    function pbkdf2(password, salt, iterations, keylen, digest) {
      checkParameters(iterations, keylen), password = toBuffer(password, defaultEncoding, "Password"), salt = toBuffer(salt, defaultEncoding, "Salt"), digest = digest || "sha1";
      var DK = Buffer22.allocUnsafe(keylen), block1 = Buffer22.allocUnsafe(salt.length + 4);
      salt.copy(block1, 0, 0, salt.length);
      var destPos = 0, hLen = sizes[digest], l3 = Math.ceil(keylen / hLen);
      for (var i2 = 1;i2 <= l3; i2++) {
        block1.writeUInt32BE(i2, salt.length);
        var T2 = createHmac(digest, password).update(block1).digest(), U3 = T2;
        for (var j3 = 1;j3 < iterations; j3++) {
          U3 = createHmac(digest, password).update(U3).digest();
          for (var k4 = 0;k4 < hLen; k4++)
            T2[k4] ^= U3[k4];
        }
        T2.copy(DK, destPos), destPos += hLen;
      }
      return DK;
    }
    module.exports = pbkdf2;
  });
  require_async = __commonJS2((exports, module) => {
    var Buffer22 = require_safe_buffer().Buffer, checkParameters = require_precondition(), defaultEncoding = require_default_encoding(), sync = require_sync(), toBuffer = require_to_buffer(), ZERO_BUF, subtle = globalThis.crypto && globalThis.crypto.subtle, toBrowser = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, checks = [];
    function checkNative(algo) {
      if (globalThis.process && !globalThis.process.browser)
        return Promise.resolve(false);
      if (!subtle || !subtle.importKey || !subtle.deriveBits)
        return Promise.resolve(false);
      if (checks[algo] !== undefined)
        return checks[algo];
      ZERO_BUF = ZERO_BUF || Buffer22.alloc(8);
      var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(function() {
        return true;
      }).catch(function() {
        return false;
      });
      return checks[algo] = prom, prom;
    }
    var nextTick;
    function getNextTick() {
      if (nextTick)
        return nextTick;
      if (globalThis.process && globalThis.process.nextTick)
        nextTick = globalThis.process.nextTick;
      else if (globalThis.queueMicrotask)
        nextTick = globalThis.queueMicrotask;
      else if (globalThis.setImmediate)
        nextTick = globalThis.setImmediate;
      else
        nextTick = globalThis.setTimeout;
      return nextTick;
    }
    function browserPbkdf2(password, salt, iterations, length, algo) {
      return subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(key) {
        return subtle.deriveBits({ name: "PBKDF2", salt, iterations, hash: { name: algo } }, key, length << 3);
      }).then(function(res) {
        return Buffer22.from(res);
      });
    }
    function resolvePromise(promise, callback) {
      promise.then(function(out) {
        getNextTick()(function() {
          callback(null, out);
        });
      }, function(e2) {
        getNextTick()(function() {
          callback(e2);
        });
      });
    }
    module.exports = function(password, salt, iterations, keylen, digest, callback) {
      if (typeof digest === "function")
        callback = digest, digest = undefined;
      digest = digest || "sha1";
      var algo = toBrowser[digest.toLowerCase()];
      if (!algo || typeof globalThis.Promise !== "function") {
        getNextTick()(function() {
          var out;
          try {
            out = sync(password, salt, iterations, keylen, digest);
          } catch (e2) {
            return callback(e2);
          }
          callback(null, out);
        });
        return;
      }
      if (checkParameters(iterations, keylen), password = toBuffer(password, defaultEncoding, "Password"), salt = toBuffer(salt, defaultEncoding, "Salt"), typeof callback !== "function")
        throw new Error("No callback provided to pbkdf2");
      resolvePromise(checkNative(algo).then(function(resp) {
        if (resp)
          return browserPbkdf2(password, salt, iterations, keylen, algo);
        return sync(password, salt, iterations, keylen, digest);
      }), callback);
    };
  });
  require_pbkdf2 = __commonJS2((exports) => {
    var native = (init_crypto(), __toCommonJS(exports_crypto)), checkParameters = require_precondition(), defaultEncoding = require_default_encoding(), toBuffer = require_to_buffer();
    function nativePBKDF2(password, salt, iterations, keylen, digest, callback) {
      if (checkParameters(iterations, keylen), password = toBuffer(password, defaultEncoding, "Password"), salt = toBuffer(salt, defaultEncoding, "Salt"), typeof digest === "function")
        callback = digest, digest = "sha1";
      if (typeof callback !== "function")
        throw new Error("No callback provided to pbkdf2");
      return native.pbkdf2(password, salt, iterations, keylen, digest, callback);
    }
    function nativePBKDF2Sync(password, salt, iterations, keylen, digest) {
      return checkParameters(iterations, keylen), password = toBuffer(password, defaultEncoding, "Password"), salt = toBuffer(salt, defaultEncoding, "Salt"), digest = digest || "sha1", native.pbkdf2Sync(password, salt, iterations, keylen, digest);
    }
    if (!native.pbkdf2Sync || native.pbkdf2Sync.toString().indexOf("keylen, digest") === -1)
      exports.pbkdf2Sync = require_sync(), exports.pbkdf2 = require_async();
    else
      exports.pbkdf2Sync = nativePBKDF2Sync, exports.pbkdf2 = nativePBKDF2;
  });
  require_browserify_cipher = __commonJS2((exports) => {
    var crypto2 = (init_crypto(), __toCommonJS(exports_crypto));
    exports.createCipher = exports.Cipher = crypto2.createCipher;
    exports.createCipheriv = exports.Cipheriv = crypto2.createCipheriv;
    exports.createDecipher = exports.Decipher = crypto2.createDecipher;
    exports.createDecipheriv = exports.Decipheriv = crypto2.createDecipheriv;
    exports.listCiphers = exports.getCiphers = crypto2.getCiphers;
  });
  require_diffie_hellman = __commonJS2((exports) => {
    var crypto2 = (init_crypto(), __toCommonJS(exports_crypto));
    exports.DiffieHellmanGroup = crypto2.DiffieHellmanGroup;
    exports.createDiffieHellmanGroup = crypto2.createDiffieHellmanGroup;
    exports.getDiffieHellman = crypto2.getDiffieHellman;
    exports.createDiffieHellman = crypto2.createDiffieHellman;
    exports.DiffieHellman = crypto2.DiffieHellman;
  });
  require_browserify_sign = __commonJS2((exports) => {
    var crypto2 = (init_crypto(), __toCommonJS(exports_crypto));
    exports.createSign = crypto2.createSign;
    exports.Sign = crypto2.Sign;
    exports.createVerify = crypto2.createVerify;
    exports.Verify = crypto2.Verify;
  });
  require_package = __commonJS2((exports, module) => {
    module.exports = { name: "elliptic", version: "6.6.1", description: "EC cryptography", main: "lib/elliptic.js", files: ["lib"], scripts: { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, repository: { type: "git", url: "git@github.com:indutny/elliptic" }, keywords: ["EC", "Elliptic", "curve", "Cryptography"], author: "Fedor Indutny <fedor@indutny.com>", license: "MIT", bugs: { url: "https://github.com/indutny/elliptic/issues" }, homepage: "https://github.com/indutny/elliptic", devDependencies: { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, dependencies: { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" } };
  });
  require_bn = __commonJS2((exports, module) => {
    (function(module2, exports2) {
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number))
          return number;
        if (this.negative = 0, this.words = null, this.length = 0, this.red = null, number !== null) {
          if (base === "le" || base === "be")
            endian = base, base = 10;
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object")
        module2.exports = BN;
      else
        exports2.BN = BN;
      BN.BN = BN, BN.wordSize = 26;
      var Buffer22;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined")
          Buffer22 = window.Buffer;
        else
          Buffer22 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer;
      } catch (e2) {}
      BN.isBN = function isBN(num) {
        if (num instanceof BN)
          return true;
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      }, BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      }, BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      }, BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number")
          return this._initNumber(number, base, endian);
        if (typeof number === "object")
          return this._initArray(number, base, endian);
        if (base === "hex")
          base = 16;
        assert(base === (base | 0) && base >= 2 && base <= 36), number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-")
          start++, this.negative = 1;
        if (start < number.length) {
          if (base === 16)
            this._parseHex(number, start, endian);
          else if (this._parseBase(number, base, start), endian === "le")
            this._initArray(this.toArray(), base, endian);
        }
      }, BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0)
          this.negative = 1, number = -number;
        if (number < 67108864)
          this.words = [number & 67108863], this.length = 1;
        else if (number < 4503599627370496)
          this.words = [number & 67108863, number / 67108864 & 67108863], this.length = 2;
        else
          assert(number < 9007199254740992), this.words = [number & 67108863, number / 67108864 & 67108863, 1], this.length = 3;
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      }, BN.prototype._initArray = function _initArray(number, base, endian) {
        if (assert(typeof number.length === "number"), number.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(number.length / 3), this.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          this.words[i2] = 0;
        var j3, w, off = 0;
        if (endian === "be") {
          for (i2 = number.length - 1, j3 = 0;i2 >= 0; i2 -= 3)
            if (w = number[i2] | number[i2 - 1] << 8 | number[i2 - 2] << 16, this.words[j3] |= w << off & 67108863, this.words[j3 + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
              off -= 26, j3++;
        } else if (endian === "le") {
          for (i2 = 0, j3 = 0;i2 < number.length; i2 += 3)
            if (w = number[i2] | number[i2 + 1] << 8 | number[i2 + 2] << 16, this.words[j3] |= w << off & 67108863, this.words[j3 + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
              off -= 26, j3++;
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 65 && c <= 70)
          return c - 55;
        else if (c >= 97 && c <= 102)
          return c - 87;
        else
          return c - 48 & 15;
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound)
          r |= parseHex4Bits(string, index - 1) << 4;
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6), this.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          this.words[i2] = 0;
        var off = 0, j3 = 0, w;
        if (endian === "be")
          for (i2 = number.length - 1;i2 >= start; i2 -= 2)
            if (w = parseHexByte(number, start, i2) << off, this.words[j3] |= w & 67108863, off >= 18)
              off -= 18, j3 += 1, this.words[j3] |= w >>> 26;
            else
              off += 8;
        else {
          var parseLength = number.length - start;
          for (i2 = parseLength % 2 === 0 ? start + 1 : start;i2 < number.length; i2 += 2)
            if (w = parseHexByte(number, start, i2) << off, this.words[j3] |= w & 67108863, off >= 18)
              off -= 18, j3 += 1, this.words[j3] |= w >>> 26;
            else
              off += 8;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0, len2 = Math.min(str.length, end);
        for (var i2 = start;i2 < len2; i2++) {
          var c = str.charCodeAt(i2) - 48;
          if (r *= mul, c >= 49)
            r += c - 49 + 10;
          else if (c >= 17)
            r += c - 17 + 10;
          else
            r += c;
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0], this.length = 1;
        for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base)
          limbLen++;
        limbLen--, limbPow = limbPow / base | 0;
        var total = number.length - start, mod = total % limbLen, end = Math.min(total, total - mod) + start, word = 0;
        for (var i2 = start;i2 < end; i2 += limbLen)
          if (word = parseBase(number, i2, i2 + limbLen, base), this.imuln(limbPow), this.words[0] + word < 67108864)
            this.words[0] += word;
          else
            this._iaddn(word);
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i2, number.length, base);
          for (i2 = 0;i2 < mod; i2++)
            pow *= base;
          if (this.imuln(pow), this.words[0] + word < 67108864)
            this.words[0] += word;
          else
            this._iaddn(word);
        }
        this.strip();
      }, BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          dest.words[i2] = this.words[i2];
        dest.length = this.length, dest.negative = this.negative, dest.red = this.red;
      }, BN.prototype.clone = function clone() {
        var r = new BN(null);
        return this.copy(r), r;
      }, BN.prototype._expand = function _expand(size) {
        while (this.length < size)
          this.words[this.length++] = 0;
        return this;
      }, BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0)
          this.length--;
        return this._normSign();
      }, BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0)
          this.negative = 0;
        return this;
      }, BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      if (BN.prototype.toString = function toString(base, padding) {
        base = base || 10, padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0, carry = 0;
          for (var i2 = 0;i2 < this.length; i2++) {
            var w = this.words[i2], word = ((w << off | carry) & 16777215).toString(16);
            if (carry = w >>> 24 - off & 16777215, off += 2, off >= 26)
              off -= 26, i2--;
            if (carry !== 0 || i2 !== this.length - 1)
              out = zeros[6 - word.length] + word + out;
            else
              out = word + out;
          }
          if (carry !== 0)
            out = carry.toString(16) + out;
          while (out.length % padding !== 0)
            out = "0" + out;
          if (this.negative !== 0)
            out = "-" + out;
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base], groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            if (c = c.idivn(groupBase), !c.isZero())
              out = zeros[groupSize - r.length] + r + out;
            else
              out = r + out;
          }
          if (this.isZero())
            out = "0" + out;
          while (out.length % padding !== 0)
            out = "0" + out;
          if (this.negative !== 0)
            out = "-" + out;
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      }, BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2)
          ret += this.words[1] * 67108864;
        else if (this.length === 3 && this.words[2] === 1)
          ret += 4503599627370496 + this.words[1] * 67108864;
        else if (this.length > 2)
          assert(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -ret : ret;
      }, BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      }, BN.prototype.toBuffer = function toBuffer(endian, length) {
        return assert(typeof Buffer22 !== "undefined"), this.toArrayLike(Buffer22, endian, length);
      }, BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      }, BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength2 = this.byteLength(), reqLength = length || Math.max(1, byteLength2);
        assert(byteLength2 <= reqLength, "byte array longer than desired length"), assert(reqLength > 0, "Requested array length <= 0"), this.strip();
        var littleEndian = endian === "le", res = new ArrayType(reqLength), b, i2, q3 = this.clone();
        if (!littleEndian) {
          for (i2 = 0;i2 < reqLength - byteLength2; i2++)
            res[i2] = 0;
          for (i2 = 0;!q3.isZero(); i2++)
            b = q3.andln(255), q3.iushrn(8), res[reqLength - i2 - 1] = b;
        } else {
          for (i2 = 0;!q3.isZero(); i2++)
            b = q3.andln(255), q3.iushrn(8), res[i2] = b;
          for (;i2 < reqLength; i2++)
            res[i2] = 0;
        }
        return res;
      }, Math.clz32)
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      else
        BN.prototype._countBits = function _countBits(w) {
          var t2 = w, r = 0;
          if (t2 >= 4096)
            r += 13, t2 >>>= 13;
          if (t2 >= 64)
            r += 7, t2 >>>= 7;
          if (t2 >= 8)
            r += 4, t2 >>>= 4;
          if (t2 >= 2)
            r += 2, t2 >>>= 2;
          return r + t2;
        };
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t2 = w, r = 0;
        if ((t2 & 8191) === 0)
          r += 13, t2 >>>= 13;
        if ((t2 & 127) === 0)
          r += 7, t2 >>>= 7;
        if ((t2 & 15) === 0)
          r += 4, t2 >>>= 4;
        if ((t2 & 3) === 0)
          r += 2, t2 >>>= 2;
        if ((t2 & 1) === 0)
          r++;
        return r;
      }, BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1], hi2 = this._countBits(w);
        return (this.length - 1) * 26 + hi2;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0;bit < w.length; bit++) {
          var off = bit / 26 | 0, wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i2 = 0;i2 < this.length; i2++) {
          var b = this._zeroBits(this.words[i2]);
          if (r += b, b !== 26)
            break;
        }
        return r;
      }, BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      }, BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0)
          return this.abs().inotn(width).iaddn(1);
        return this.clone();
      }, BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1))
          return this.notn(width).iaddn(1).ineg();
        return this.clone();
      }, BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      }, BN.prototype.neg = function neg() {
        return this.clone().ineg();
      }, BN.prototype.ineg = function ineg() {
        if (!this.isZero())
          this.negative ^= 1;
        return this;
      }, BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length)
          this.words[this.length++] = 0;
        for (var i2 = 0;i2 < num.length; i2++)
          this.words[i2] = this.words[i2] | num.words[i2];
        return this.strip();
      }, BN.prototype.ior = function ior(num) {
        return assert((this.negative | num.negative) === 0), this.iuor(num);
      }, BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      }, BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      }, BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length)
          b = num;
        else
          b = this;
        for (var i2 = 0;i2 < b.length; i2++)
          this.words[i2] = this.words[i2] & num.words[i2];
        return this.length = b.length, this.strip();
      }, BN.prototype.iand = function iand(num) {
        return assert((this.negative | num.negative) === 0), this.iuand(num);
      }, BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      }, BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      }, BN.prototype.iuxor = function iuxor(num) {
        var a, b;
        if (this.length > num.length)
          a = this, b = num;
        else
          a = num, b = this;
        for (var i2 = 0;i2 < b.length; i2++)
          this.words[i2] = a.words[i2] ^ b.words[i2];
        if (this !== a)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        return this.length = a.length, this.strip();
      }, BN.prototype.ixor = function ixor(num) {
        return assert((this.negative | num.negative) === 0), this.iuxor(num);
      }, BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      }, BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      }, BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0, bitsLeft = width % 26;
        if (this._expand(bytesNeeded), bitsLeft > 0)
          bytesNeeded--;
        for (var i2 = 0;i2 < bytesNeeded; i2++)
          this.words[i2] = ~this.words[i2] & 67108863;
        if (bitsLeft > 0)
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        return this.strip();
      }, BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      }, BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0, wbit = bit % 26;
        if (this._expand(off + 1), val)
          this.words[off] = this.words[off] | 1 << wbit;
        else
          this.words[off] = this.words[off] & ~(1 << wbit);
        return this.strip();
      }, BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0)
          return this.negative = 0, r = this.isub(num), this.negative ^= 1, this._normSign();
        else if (this.negative === 0 && num.negative !== 0)
          return num.negative = 0, r = this.isub(num), num.negative = 1, r._normSign();
        var a, b;
        if (this.length > num.length)
          a = this, b = num;
        else
          a = num, b = this;
        var carry = 0;
        for (var i2 = 0;i2 < b.length; i2++)
          r = (a.words[i2] | 0) + (b.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
        for (;carry !== 0 && i2 < a.length; i2++)
          r = (a.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
        if (this.length = a.length, carry !== 0)
          this.words[this.length] = carry, this.length++;
        else if (a !== this)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        return this;
      }, BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0)
          return num.negative = 0, res = this.sub(num), num.negative ^= 1, res;
        else if (num.negative === 0 && this.negative !== 0)
          return this.negative = 0, res = num.sub(this), this.negative = 1, res;
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      }, BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          return num.negative = 1, r._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(num), this.negative = 1, this._normSign();
        var cmp = this.cmp(num);
        if (cmp === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var a, b;
        if (cmp > 0)
          a = this, b = num;
        else
          a = num, b = this;
        var carry = 0;
        for (var i2 = 0;i2 < b.length; i2++)
          r = (a.words[i2] | 0) - (b.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
        for (;carry !== 0 && i2 < a.length; i2++)
          r = (a.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
        if (carry === 0 && i2 < a.length && a !== this)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        if (this.length = Math.max(this.length, i2), a !== this)
          this.negative = 1;
        return this.strip();
      }, BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len2 = self2.length + num.length | 0;
        out.length = len2, len2 = len2 - 1 | 0;
        var a = self2.words[0] | 0, b = num.words[0] | 0, r = a * b, lo = r & 67108863, carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k4 = 1;k4 < len2; k4++) {
          var ncarry = carry >>> 26, rword = carry & 67108863, maxJ = Math.min(k4, num.length - 1);
          for (var j3 = Math.max(0, k4 - self2.length + 1);j3 <= maxJ; j3++) {
            var i2 = k4 - j3 | 0;
            a = self2.words[i2] | 0, b = num.words[j3] | 0, r = a * b + rword, ncarry += r / 67108864 | 0, rword = r & 67108863;
          }
          out.words[k4] = rword | 0, carry = ncarry | 0;
        }
        if (carry !== 0)
          out.words[k4] = carry | 0;
        else
          out.length--;
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo(self2, num, out) {
        var a = self2.words, b = num.words, o = out.words, c = 0, lo, mid, hi2, a0 = a[0] | 0, al0 = a0 & 8191, ah0 = a0 >>> 13, a1 = a[1] | 0, al1 = a1 & 8191, ah1 = a1 >>> 13, a2 = a[2] | 0, al2 = a2 & 8191, ah2 = a2 >>> 13, a3 = a[3] | 0, al3 = a3 & 8191, ah3 = a3 >>> 13, a4 = a[4] | 0, al4 = a4 & 8191, ah4 = a4 >>> 13, a5 = a[5] | 0, al5 = a5 & 8191, ah5 = a5 >>> 13, a6 = a[6] | 0, al6 = a6 & 8191, ah6 = a6 >>> 13, a7 = a[7] | 0, al7 = a7 & 8191, ah7 = a7 >>> 13, a8 = a[8] | 0, al8 = a8 & 8191, ah8 = a8 >>> 13, a9 = a[9] | 0, al9 = a9 & 8191, ah9 = a9 >>> 13, b0 = b[0] | 0, bl0 = b0 & 8191, bh0 = b0 >>> 13, b1 = b[1] | 0, bl1 = b1 & 8191, bh1 = b1 >>> 13, b2 = b[2] | 0, bl2 = b2 & 8191, bh2 = b2 >>> 13, b3 = b[3] | 0, bl3 = b3 & 8191, bh3 = b3 >>> 13, b4 = b[4] | 0, bl4 = b4 & 8191, bh4 = b4 >>> 13, b5 = b[5] | 0, bl5 = b5 & 8191, bh5 = b5 >>> 13, b6 = b[6] | 0, bl6 = b6 & 8191, bh6 = b6 >>> 13, b7 = b[7] | 0, bl7 = b7 & 8191, bh7 = b7 >>> 13, b8 = b[8] | 0, bl8 = b8 & 8191, bh8 = b8 >>> 13, b9 = b[9] | 0, bl9 = b9 & 8191, bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative, out.length = 19, lo = Math.imul(al0, bl0), mid = Math.imul(al0, bh0), mid = mid + Math.imul(ah0, bl0) | 0, hi2 = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w0 >>> 26) | 0, w0 &= 67108863, lo = Math.imul(al1, bl0), mid = Math.imul(al1, bh0), mid = mid + Math.imul(ah1, bl0) | 0, hi2 = Math.imul(ah1, bh0), lo = lo + Math.imul(al0, bl1) | 0, mid = mid + Math.imul(al0, bh1) | 0, mid = mid + Math.imul(ah0, bl1) | 0, hi2 = hi2 + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w1 >>> 26) | 0, w1 &= 67108863, lo = Math.imul(al2, bl0), mid = Math.imul(al2, bh0), mid = mid + Math.imul(ah2, bl0) | 0, hi2 = Math.imul(ah2, bh0), lo = lo + Math.imul(al1, bl1) | 0, mid = mid + Math.imul(al1, bh1) | 0, mid = mid + Math.imul(ah1, bl1) | 0, hi2 = hi2 + Math.imul(ah1, bh1) | 0, lo = lo + Math.imul(al0, bl2) | 0, mid = mid + Math.imul(al0, bh2) | 0, mid = mid + Math.imul(ah0, bl2) | 0, hi2 = hi2 + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w2 >>> 26) | 0, w2 &= 67108863, lo = Math.imul(al3, bl0), mid = Math.imul(al3, bh0), mid = mid + Math.imul(ah3, bl0) | 0, hi2 = Math.imul(ah3, bh0), lo = lo + Math.imul(al2, bl1) | 0, mid = mid + Math.imul(al2, bh1) | 0, mid = mid + Math.imul(ah2, bl1) | 0, hi2 = hi2 + Math.imul(ah2, bh1) | 0, lo = lo + Math.imul(al1, bl2) | 0, mid = mid + Math.imul(al1, bh2) | 0, mid = mid + Math.imul(ah1, bl2) | 0, hi2 = hi2 + Math.imul(ah1, bh2) | 0, lo = lo + Math.imul(al0, bl3) | 0, mid = mid + Math.imul(al0, bh3) | 0, mid = mid + Math.imul(ah0, bl3) | 0, hi2 = hi2 + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w3 >>> 26) | 0, w3 &= 67108863, lo = Math.imul(al4, bl0), mid = Math.imul(al4, bh0), mid = mid + Math.imul(ah4, bl0) | 0, hi2 = Math.imul(ah4, bh0), lo = lo + Math.imul(al3, bl1) | 0, mid = mid + Math.imul(al3, bh1) | 0, mid = mid + Math.imul(ah3, bl1) | 0, hi2 = hi2 + Math.imul(ah3, bh1) | 0, lo = lo + Math.imul(al2, bl2) | 0, mid = mid + Math.imul(al2, bh2) | 0, mid = mid + Math.imul(ah2, bl2) | 0, hi2 = hi2 + Math.imul(ah2, bh2) | 0, lo = lo + Math.imul(al1, bl3) | 0, mid = mid + Math.imul(al1, bh3) | 0, mid = mid + Math.imul(ah1, bl3) | 0, hi2 = hi2 + Math.imul(ah1, bh3) | 0, lo = lo + Math.imul(al0, bl4) | 0, mid = mid + Math.imul(al0, bh4) | 0, mid = mid + Math.imul(ah0, bl4) | 0, hi2 = hi2 + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w4 >>> 26) | 0, w4 &= 67108863, lo = Math.imul(al5, bl0), mid = Math.imul(al5, bh0), mid = mid + Math.imul(ah5, bl0) | 0, hi2 = Math.imul(ah5, bh0), lo = lo + Math.imul(al4, bl1) | 0, mid = mid + Math.imul(al4, bh1) | 0, mid = mid + Math.imul(ah4, bl1) | 0, hi2 = hi2 + Math.imul(ah4, bh1) | 0, lo = lo + Math.imul(al3, bl2) | 0, mid = mid + Math.imul(al3, bh2) | 0, mid = mid + Math.imul(ah3, bl2) | 0, hi2 = hi2 + Math.imul(ah3, bh2) | 0, lo = lo + Math.imul(al2, bl3) | 0, mid = mid + Math.imul(al2, bh3) | 0, mid = mid + Math.imul(ah2, bl3) | 0, hi2 = hi2 + Math.imul(ah2, bh3) | 0, lo = lo + Math.imul(al1, bl4) | 0, mid = mid + Math.imul(al1, bh4) | 0, mid = mid + Math.imul(ah1, bl4) | 0, hi2 = hi2 + Math.imul(ah1, bh4) | 0, lo = lo + Math.imul(al0, bl5) | 0, mid = mid + Math.imul(al0, bh5) | 0, mid = mid + Math.imul(ah0, bl5) | 0, hi2 = hi2 + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w5 >>> 26) | 0, w5 &= 67108863, lo = Math.imul(al6, bl0), mid = Math.imul(al6, bh0), mid = mid + Math.imul(ah6, bl0) | 0, hi2 = Math.imul(ah6, bh0), lo = lo + Math.imul(al5, bl1) | 0, mid = mid + Math.imul(al5, bh1) | 0, mid = mid + Math.imul(ah5, bl1) | 0, hi2 = hi2 + Math.imul(ah5, bh1) | 0, lo = lo + Math.imul(al4, bl2) | 0, mid = mid + Math.imul(al4, bh2) | 0, mid = mid + Math.imul(ah4, bl2) | 0, hi2 = hi2 + Math.imul(ah4, bh2) | 0, lo = lo + Math.imul(al3, bl3) | 0, mid = mid + Math.imul(al3, bh3) | 0, mid = mid + Math.imul(ah3, bl3) | 0, hi2 = hi2 + Math.imul(ah3, bh3) | 0, lo = lo + Math.imul(al2, bl4) | 0, mid = mid + Math.imul(al2, bh4) | 0, mid = mid + Math.imul(ah2, bl4) | 0, hi2 = hi2 + Math.imul(ah2, bh4) | 0, lo = lo + Math.imul(al1, bl5) | 0, mid = mid + Math.imul(al1, bh5) | 0, mid = mid + Math.imul(ah1, bl5) | 0, hi2 = hi2 + Math.imul(ah1, bh5) | 0, lo = lo + Math.imul(al0, bl6) | 0, mid = mid + Math.imul(al0, bh6) | 0, mid = mid + Math.imul(ah0, bl6) | 0, hi2 = hi2 + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w6 >>> 26) | 0, w6 &= 67108863, lo = Math.imul(al7, bl0), mid = Math.imul(al7, bh0), mid = mid + Math.imul(ah7, bl0) | 0, hi2 = Math.imul(ah7, bh0), lo = lo + Math.imul(al6, bl1) | 0, mid = mid + Math.imul(al6, bh1) | 0, mid = mid + Math.imul(ah6, bl1) | 0, hi2 = hi2 + Math.imul(ah6, bh1) | 0, lo = lo + Math.imul(al5, bl2) | 0, mid = mid + Math.imul(al5, bh2) | 0, mid = mid + Math.imul(ah5, bl2) | 0, hi2 = hi2 + Math.imul(ah5, bh2) | 0, lo = lo + Math.imul(al4, bl3) | 0, mid = mid + Math.imul(al4, bh3) | 0, mid = mid + Math.imul(ah4, bl3) | 0, hi2 = hi2 + Math.imul(ah4, bh3) | 0, lo = lo + Math.imul(al3, bl4) | 0, mid = mid + Math.imul(al3, bh4) | 0, mid = mid + Math.imul(ah3, bl4) | 0, hi2 = hi2 + Math.imul(ah3, bh4) | 0, lo = lo + Math.imul(al2, bl5) | 0, mid = mid + Math.imul(al2, bh5) | 0, mid = mid + Math.imul(ah2, bl5) | 0, hi2 = hi2 + Math.imul(ah2, bh5) | 0, lo = lo + Math.imul(al1, bl6) | 0, mid = mid + Math.imul(al1, bh6) | 0, mid = mid + Math.imul(ah1, bl6) | 0, hi2 = hi2 + Math.imul(ah1, bh6) | 0, lo = lo + Math.imul(al0, bl7) | 0, mid = mid + Math.imul(al0, bh7) | 0, mid = mid + Math.imul(ah0, bl7) | 0, hi2 = hi2 + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w7 >>> 26) | 0, w7 &= 67108863, lo = Math.imul(al8, bl0), mid = Math.imul(al8, bh0), mid = mid + Math.imul(ah8, bl0) | 0, hi2 = Math.imul(ah8, bh0), lo = lo + Math.imul(al7, bl1) | 0, mid = mid + Math.imul(al7, bh1) | 0, mid = mid + Math.imul(ah7, bl1) | 0, hi2 = hi2 + Math.imul(ah7, bh1) | 0, lo = lo + Math.imul(al6, bl2) | 0, mid = mid + Math.imul(al6, bh2) | 0, mid = mid + Math.imul(ah6, bl2) | 0, hi2 = hi2 + Math.imul(ah6, bh2) | 0, lo = lo + Math.imul(al5, bl3) | 0, mid = mid + Math.imul(al5, bh3) | 0, mid = mid + Math.imul(ah5, bl3) | 0, hi2 = hi2 + Math.imul(ah5, bh3) | 0, lo = lo + Math.imul(al4, bl4) | 0, mid = mid + Math.imul(al4, bh4) | 0, mid = mid + Math.imul(ah4, bl4) | 0, hi2 = hi2 + Math.imul(ah4, bh4) | 0, lo = lo + Math.imul(al3, bl5) | 0, mid = mid + Math.imul(al3, bh5) | 0, mid = mid + Math.imul(ah3, bl5) | 0, hi2 = hi2 + Math.imul(ah3, bh5) | 0, lo = lo + Math.imul(al2, bl6) | 0, mid = mid + Math.imul(al2, bh6) | 0, mid = mid + Math.imul(ah2, bl6) | 0, hi2 = hi2 + Math.imul(ah2, bh6) | 0, lo = lo + Math.imul(al1, bl7) | 0, mid = mid + Math.imul(al1, bh7) | 0, mid = mid + Math.imul(ah1, bl7) | 0, hi2 = hi2 + Math.imul(ah1, bh7) | 0, lo = lo + Math.imul(al0, bl8) | 0, mid = mid + Math.imul(al0, bh8) | 0, mid = mid + Math.imul(ah0, bl8) | 0, hi2 = hi2 + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0, w8 &= 67108863, lo = Math.imul(al9, bl0), mid = Math.imul(al9, bh0), mid = mid + Math.imul(ah9, bl0) | 0, hi2 = Math.imul(ah9, bh0), lo = lo + Math.imul(al8, bl1) | 0, mid = mid + Math.imul(al8, bh1) | 0, mid = mid + Math.imul(ah8, bl1) | 0, hi2 = hi2 + Math.imul(ah8, bh1) | 0, lo = lo + Math.imul(al7, bl2) | 0, mid = mid + Math.imul(al7, bh2) | 0, mid = mid + Math.imul(ah7, bl2) | 0, hi2 = hi2 + Math.imul(ah7, bh2) | 0, lo = lo + Math.imul(al6, bl3) | 0, mid = mid + Math.imul(al6, bh3) | 0, mid = mid + Math.imul(ah6, bl3) | 0, hi2 = hi2 + Math.imul(ah6, bh3) | 0, lo = lo + Math.imul(al5, bl4) | 0, mid = mid + Math.imul(al5, bh4) | 0, mid = mid + Math.imul(ah5, bl4) | 0, hi2 = hi2 + Math.imul(ah5, bh4) | 0, lo = lo + Math.imul(al4, bl5) | 0, mid = mid + Math.imul(al4, bh5) | 0, mid = mid + Math.imul(ah4, bl5) | 0, hi2 = hi2 + Math.imul(ah4, bh5) | 0, lo = lo + Math.imul(al3, bl6) | 0, mid = mid + Math.imul(al3, bh6) | 0, mid = mid + Math.imul(ah3, bl6) | 0, hi2 = hi2 + Math.imul(ah3, bh6) | 0, lo = lo + Math.imul(al2, bl7) | 0, mid = mid + Math.imul(al2, bh7) | 0, mid = mid + Math.imul(ah2, bl7) | 0, hi2 = hi2 + Math.imul(ah2, bh7) | 0, lo = lo + Math.imul(al1, bl8) | 0, mid = mid + Math.imul(al1, bh8) | 0, mid = mid + Math.imul(ah1, bl8) | 0, hi2 = hi2 + Math.imul(ah1, bh8) | 0, lo = lo + Math.imul(al0, bl9) | 0, mid = mid + Math.imul(al0, bh9) | 0, mid = mid + Math.imul(ah0, bl9) | 0, hi2 = hi2 + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0, w9 &= 67108863, lo = Math.imul(al9, bl1), mid = Math.imul(al9, bh1), mid = mid + Math.imul(ah9, bl1) | 0, hi2 = Math.imul(ah9, bh1), lo = lo + Math.imul(al8, bl2) | 0, mid = mid + Math.imul(al8, bh2) | 0, mid = mid + Math.imul(ah8, bl2) | 0, hi2 = hi2 + Math.imul(ah8, bh2) | 0, lo = lo + Math.imul(al7, bl3) | 0, mid = mid + Math.imul(al7, bh3) | 0, mid = mid + Math.imul(ah7, bl3) | 0, hi2 = hi2 + Math.imul(ah7, bh3) | 0, lo = lo + Math.imul(al6, bl4) | 0, mid = mid + Math.imul(al6, bh4) | 0, mid = mid + Math.imul(ah6, bl4) | 0, hi2 = hi2 + Math.imul(ah6, bh4) | 0, lo = lo + Math.imul(al5, bl5) | 0, mid = mid + Math.imul(al5, bh5) | 0, mid = mid + Math.imul(ah5, bl5) | 0, hi2 = hi2 + Math.imul(ah5, bh5) | 0, lo = lo + Math.imul(al4, bl6) | 0, mid = mid + Math.imul(al4, bh6) | 0, mid = mid + Math.imul(ah4, bl6) | 0, hi2 = hi2 + Math.imul(ah4, bh6) | 0, lo = lo + Math.imul(al3, bl7) | 0, mid = mid + Math.imul(al3, bh7) | 0, mid = mid + Math.imul(ah3, bl7) | 0, hi2 = hi2 + Math.imul(ah3, bh7) | 0, lo = lo + Math.imul(al2, bl8) | 0, mid = mid + Math.imul(al2, bh8) | 0, mid = mid + Math.imul(ah2, bl8) | 0, hi2 = hi2 + Math.imul(ah2, bh8) | 0, lo = lo + Math.imul(al1, bl9) | 0, mid = mid + Math.imul(al1, bh9) | 0, mid = mid + Math.imul(ah1, bl9) | 0, hi2 = hi2 + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0, w10 &= 67108863, lo = Math.imul(al9, bl2), mid = Math.imul(al9, bh2), mid = mid + Math.imul(ah9, bl2) | 0, hi2 = Math.imul(ah9, bh2), lo = lo + Math.imul(al8, bl3) | 0, mid = mid + Math.imul(al8, bh3) | 0, mid = mid + Math.imul(ah8, bl3) | 0, hi2 = hi2 + Math.imul(ah8, bh3) | 0, lo = lo + Math.imul(al7, bl4) | 0, mid = mid + Math.imul(al7, bh4) | 0, mid = mid + Math.imul(ah7, bl4) | 0, hi2 = hi2 + Math.imul(ah7, bh4) | 0, lo = lo + Math.imul(al6, bl5) | 0, mid = mid + Math.imul(al6, bh5) | 0, mid = mid + Math.imul(ah6, bl5) | 0, hi2 = hi2 + Math.imul(ah6, bh5) | 0, lo = lo + Math.imul(al5, bl6) | 0, mid = mid + Math.imul(al5, bh6) | 0, mid = mid + Math.imul(ah5, bl6) | 0, hi2 = hi2 + Math.imul(ah5, bh6) | 0, lo = lo + Math.imul(al4, bl7) | 0, mid = mid + Math.imul(al4, bh7) | 0, mid = mid + Math.imul(ah4, bl7) | 0, hi2 = hi2 + Math.imul(ah4, bh7) | 0, lo = lo + Math.imul(al3, bl8) | 0, mid = mid + Math.imul(al3, bh8) | 0, mid = mid + Math.imul(ah3, bl8) | 0, hi2 = hi2 + Math.imul(ah3, bh8) | 0, lo = lo + Math.imul(al2, bl9) | 0, mid = mid + Math.imul(al2, bh9) | 0, mid = mid + Math.imul(ah2, bl9) | 0, hi2 = hi2 + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0, w11 &= 67108863, lo = Math.imul(al9, bl3), mid = Math.imul(al9, bh3), mid = mid + Math.imul(ah9, bl3) | 0, hi2 = Math.imul(ah9, bh3), lo = lo + Math.imul(al8, bl4) | 0, mid = mid + Math.imul(al8, bh4) | 0, mid = mid + Math.imul(ah8, bl4) | 0, hi2 = hi2 + Math.imul(ah8, bh4) | 0, lo = lo + Math.imul(al7, bl5) | 0, mid = mid + Math.imul(al7, bh5) | 0, mid = mid + Math.imul(ah7, bl5) | 0, hi2 = hi2 + Math.imul(ah7, bh5) | 0, lo = lo + Math.imul(al6, bl6) | 0, mid = mid + Math.imul(al6, bh6) | 0, mid = mid + Math.imul(ah6, bl6) | 0, hi2 = hi2 + Math.imul(ah6, bh6) | 0, lo = lo + Math.imul(al5, bl7) | 0, mid = mid + Math.imul(al5, bh7) | 0, mid = mid + Math.imul(ah5, bl7) | 0, hi2 = hi2 + Math.imul(ah5, bh7) | 0, lo = lo + Math.imul(al4, bl8) | 0, mid = mid + Math.imul(al4, bh8) | 0, mid = mid + Math.imul(ah4, bl8) | 0, hi2 = hi2 + Math.imul(ah4, bh8) | 0, lo = lo + Math.imul(al3, bl9) | 0, mid = mid + Math.imul(al3, bh9) | 0, mid = mid + Math.imul(ah3, bl9) | 0, hi2 = hi2 + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0, w12 &= 67108863, lo = Math.imul(al9, bl4), mid = Math.imul(al9, bh4), mid = mid + Math.imul(ah9, bl4) | 0, hi2 = Math.imul(ah9, bh4), lo = lo + Math.imul(al8, bl5) | 0, mid = mid + Math.imul(al8, bh5) | 0, mid = mid + Math.imul(ah8, bl5) | 0, hi2 = hi2 + Math.imul(ah8, bh5) | 0, lo = lo + Math.imul(al7, bl6) | 0, mid = mid + Math.imul(al7, bh6) | 0, mid = mid + Math.imul(ah7, bl6) | 0, hi2 = hi2 + Math.imul(ah7, bh6) | 0, lo = lo + Math.imul(al6, bl7) | 0, mid = mid + Math.imul(al6, bh7) | 0, mid = mid + Math.imul(ah6, bl7) | 0, hi2 = hi2 + Math.imul(ah6, bh7) | 0, lo = lo + Math.imul(al5, bl8) | 0, mid = mid + Math.imul(al5, bh8) | 0, mid = mid + Math.imul(ah5, bl8) | 0, hi2 = hi2 + Math.imul(ah5, bh8) | 0, lo = lo + Math.imul(al4, bl9) | 0, mid = mid + Math.imul(al4, bh9) | 0, mid = mid + Math.imul(ah4, bl9) | 0, hi2 = hi2 + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0, w13 &= 67108863, lo = Math.imul(al9, bl5), mid = Math.imul(al9, bh5), mid = mid + Math.imul(ah9, bl5) | 0, hi2 = Math.imul(ah9, bh5), lo = lo + Math.imul(al8, bl6) | 0, mid = mid + Math.imul(al8, bh6) | 0, mid = mid + Math.imul(ah8, bl6) | 0, hi2 = hi2 + Math.imul(ah8, bh6) | 0, lo = lo + Math.imul(al7, bl7) | 0, mid = mid + Math.imul(al7, bh7) | 0, mid = mid + Math.imul(ah7, bl7) | 0, hi2 = hi2 + Math.imul(ah7, bh7) | 0, lo = lo + Math.imul(al6, bl8) | 0, mid = mid + Math.imul(al6, bh8) | 0, mid = mid + Math.imul(ah6, bl8) | 0, hi2 = hi2 + Math.imul(ah6, bh8) | 0, lo = lo + Math.imul(al5, bl9) | 0, mid = mid + Math.imul(al5, bh9) | 0, mid = mid + Math.imul(ah5, bl9) | 0, hi2 = hi2 + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0, w14 &= 67108863, lo = Math.imul(al9, bl6), mid = Math.imul(al9, bh6), mid = mid + Math.imul(ah9, bl6) | 0, hi2 = Math.imul(ah9, bh6), lo = lo + Math.imul(al8, bl7) | 0, mid = mid + Math.imul(al8, bh7) | 0, mid = mid + Math.imul(ah8, bl7) | 0, hi2 = hi2 + Math.imul(ah8, bh7) | 0, lo = lo + Math.imul(al7, bl8) | 0, mid = mid + Math.imul(al7, bh8) | 0, mid = mid + Math.imul(ah7, bl8) | 0, hi2 = hi2 + Math.imul(ah7, bh8) | 0, lo = lo + Math.imul(al6, bl9) | 0, mid = mid + Math.imul(al6, bh9) | 0, mid = mid + Math.imul(ah6, bl9) | 0, hi2 = hi2 + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0, w15 &= 67108863, lo = Math.imul(al9, bl7), mid = Math.imul(al9, bh7), mid = mid + Math.imul(ah9, bl7) | 0, hi2 = Math.imul(ah9, bh7), lo = lo + Math.imul(al8, bl8) | 0, mid = mid + Math.imul(al8, bh8) | 0, mid = mid + Math.imul(ah8, bl8) | 0, hi2 = hi2 + Math.imul(ah8, bh8) | 0, lo = lo + Math.imul(al7, bl9) | 0, mid = mid + Math.imul(al7, bh9) | 0, mid = mid + Math.imul(ah7, bl9) | 0, hi2 = hi2 + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0, w16 &= 67108863, lo = Math.imul(al9, bl8), mid = Math.imul(al9, bh8), mid = mid + Math.imul(ah9, bl8) | 0, hi2 = Math.imul(ah9, bh8), lo = lo + Math.imul(al8, bl9) | 0, mid = mid + Math.imul(al8, bh9) | 0, mid = mid + Math.imul(ah8, bl9) | 0, hi2 = hi2 + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0, w17 &= 67108863, lo = Math.imul(al9, bl9), mid = Math.imul(al9, bh9), mid = mid + Math.imul(ah9, bl9) | 0, hi2 = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        if (c = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0, w18 &= 67108863, o[0] = w0, o[1] = w1, o[2] = w2, o[3] = w3, o[4] = w4, o[5] = w5, o[6] = w6, o[7] = w7, o[8] = w8, o[9] = w9, o[10] = w10, o[11] = w11, o[12] = w12, o[13] = w13, o[14] = w14, o[15] = w15, o[16] = w16, o[17] = w17, o[18] = w18, c !== 0)
          o[19] = c, out.length++;
        return out;
      };
      if (!Math.imul)
        comb10MulTo = smallMulTo;
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative, out.length = self2.length + num.length;
        var carry = 0, hncarry = 0;
        for (var k4 = 0;k4 < out.length - 1; k4++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863, maxJ = Math.min(k4, num.length - 1);
          for (var j3 = Math.max(0, k4 - self2.length + 1);j3 <= maxJ; j3++) {
            var i2 = k4 - j3, a = self2.words[i2] | 0, b = num.words[j3] | 0, r = a * b, lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0, lo = lo + rword | 0, rword = lo & 67108863, ncarry = ncarry + (lo >>> 26) | 0, hncarry += ncarry >>> 26, ncarry &= 67108863;
          }
          out.words[k4] = rword, carry = ncarry, ncarry = hncarry;
        }
        if (carry !== 0)
          out.words[k4] = carry;
        else
          out.length--;
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM;
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res, len2 = this.length + num.length;
        if (this.length === 10 && num.length === 10)
          res = comb10MulTo(this, num, out);
        else if (len2 < 63)
          res = smallMulTo(this, num, out);
        else if (len2 < 1024)
          res = bigMulTo(this, num, out);
        else
          res = jumboMulTo(this, num, out);
        return res;
      };
      function FFTM(x4, y) {
        this.x = x4, this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N3) {
        var t2 = new Array(N3), l3 = BN.prototype._countBits(N3) - 1;
        for (var i2 = 0;i2 < N3; i2++)
          t2[i2] = this.revBin(i2, l3, N3);
        return t2;
      }, FFTM.prototype.revBin = function revBin(x4, l3, N3) {
        if (x4 === 0 || x4 === N3 - 1)
          return x4;
        var rb = 0;
        for (var i2 = 0;i2 < l3; i2++)
          rb |= (x4 & 1) << l3 - i2 - 1, x4 >>= 1;
        return rb;
      }, FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N3) {
        for (var i2 = 0;i2 < N3; i2++)
          rtws[i2] = rws[rbt[i2]], itws[i2] = iws[rbt[i2]];
      }, FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N3, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N3);
        for (var s3 = 1;s3 < N3; s3 <<= 1) {
          var l3 = s3 << 1, rtwdf = Math.cos(2 * Math.PI / l3), itwdf = Math.sin(2 * Math.PI / l3);
          for (var p2 = 0;p2 < N3; p2 += l3) {
            var rtwdf_ = rtwdf, itwdf_ = itwdf;
            for (var j3 = 0;j3 < s3; j3++) {
              var re2 = rtws[p2 + j3], ie4 = itws[p2 + j3], ro = rtws[p2 + j3 + s3], io = itws[p2 + j3 + s3], rx = rtwdf_ * ro - itwdf_ * io;
              if (io = rtwdf_ * io + itwdf_ * ro, ro = rx, rtws[p2 + j3] = re2 + ro, itws[p2 + j3] = ie4 + io, rtws[p2 + j3 + s3] = re2 - ro, itws[p2 + j3 + s3] = ie4 - io, j3 !== l3)
                rx = rtwdf * rtwdf_ - itwdf * itwdf_, itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_, rtwdf_ = rx;
            }
          }
        }
      }, FFTM.prototype.guessLen13b = function guessLen13b(n, m2) {
        var N3 = Math.max(m2, n) | 1, odd = N3 & 1, i2 = 0;
        for (N3 = N3 / 2 | 0;N3; N3 = N3 >>> 1)
          i2++;
        return 1 << i2 + 1 + odd;
      }, FFTM.prototype.conjugate = function conjugate(rws, iws, N3) {
        if (N3 <= 1)
          return;
        for (var i2 = 0;i2 < N3 / 2; i2++) {
          var t2 = rws[i2];
          rws[i2] = rws[N3 - i2 - 1], rws[N3 - i2 - 1] = t2, t2 = iws[i2], iws[i2] = -iws[N3 - i2 - 1], iws[N3 - i2 - 1] = -t2;
        }
      }, FFTM.prototype.normalize13b = function normalize13b(ws, N3) {
        var carry = 0;
        for (var i2 = 0;i2 < N3 / 2; i2++) {
          var w = Math.round(ws[2 * i2 + 1] / N3) * 8192 + Math.round(ws[2 * i2] / N3) + carry;
          if (ws[i2] = w & 67108863, w < 67108864)
            carry = 0;
          else
            carry = w / 67108864 | 0;
        }
        return ws;
      }, FFTM.prototype.convert13b = function convert13b(ws, len2, rws, N3) {
        var carry = 0;
        for (var i2 = 0;i2 < len2; i2++)
          carry = carry + (ws[i2] | 0), rws[2 * i2] = carry & 8191, carry = carry >>> 13, rws[2 * i2 + 1] = carry & 8191, carry = carry >>> 13;
        for (i2 = 2 * len2;i2 < N3; ++i2)
          rws[i2] = 0;
        assert(carry === 0), assert((carry & -8192) === 0);
      }, FFTM.prototype.stub = function stub(N3) {
        var ph = new Array(N3);
        for (var i2 = 0;i2 < N3; i2++)
          ph[i2] = 0;
        return ph;
      }, FFTM.prototype.mulp = function mulp(x4, y, out) {
        var N3 = 2 * this.guessLen13b(x4.length, y.length), rbt = this.makeRBT(N3), _3 = this.stub(N3), rws = new Array(N3), rwst = new Array(N3), iwst = new Array(N3), nrws = new Array(N3), nrwst = new Array(N3), niwst = new Array(N3), rmws = out.words;
        rmws.length = N3, this.convert13b(x4.words, x4.length, rws, N3), this.convert13b(y.words, y.length, nrws, N3), this.transform(rws, _3, rwst, iwst, N3, rbt), this.transform(nrws, _3, nrwst, niwst, N3, rbt);
        for (var i2 = 0;i2 < N3; i2++) {
          var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
          iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2], rwst[i2] = rx;
        }
        return this.conjugate(rwst, iwst, N3), this.transform(rwst, iwst, rmws, _3, N3, rbt), this.conjugate(rmws, _3, N3), this.normalize13b(rmws, N3), out.negative = x4.negative ^ y.negative, out.length = x4.length + y.length, out.strip();
      }, BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        return out.words = new Array(this.length + num.length), this.mulTo(num, out);
      }, BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        return out.words = new Array(this.length + num.length), jumboMulTo(this, num, out);
      }, BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      }, BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number"), assert(num < 67108864);
        var carry = 0;
        for (var i2 = 0;i2 < this.length; i2++) {
          var w = (this.words[i2] | 0) * num, lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26, carry += w / 67108864 | 0, carry += lo >>> 26, this.words[i2] = lo & 67108863;
        }
        if (carry !== 0)
          this.words[i2] = carry, this.length++;
        return this.length = num === 0 ? 1 : this.length, this;
      }, BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      }, BN.prototype.sqr = function sqr() {
        return this.mul(this);
      }, BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      }, BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i2 = 0;i2 < w.length; i2++, res = res.sqr())
          if (w[i2] !== 0)
            break;
        if (++i2 < w.length)
          for (var q3 = res.sqr();i2 < w.length; i2++, q3 = q3.sqr()) {
            if (w[i2] === 0)
              continue;
            res = res.mul(q3);
          }
        return res;
      }, BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26, s3 = (bits - r) / 26, carryMask = 67108863 >>> 26 - r << 26 - r, i2;
        if (r !== 0) {
          var carry = 0;
          for (i2 = 0;i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask, c = (this.words[i2] | 0) - newCarry << r;
            this.words[i2] = c | carry, carry = newCarry >>> 26 - r;
          }
          if (carry)
            this.words[i2] = carry, this.length++;
        }
        if (s3 !== 0) {
          for (i2 = this.length - 1;i2 >= 0; i2--)
            this.words[i2 + s3] = this.words[i2];
          for (i2 = 0;i2 < s3; i2++)
            this.words[i2] = 0;
          this.length += s3;
        }
        return this.strip();
      }, BN.prototype.ishln = function ishln(bits) {
        return assert(this.negative === 0), this.iushln(bits);
      }, BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint)
          h = (hint - hint % 26) / 26;
        else
          h = 0;
        var r = bits % 26, s3 = Math.min((bits - r) / 26, this.length), mask = 67108863 ^ 67108863 >>> r << r, maskedWords = extended;
        if (h -= s3, h = Math.max(0, h), maskedWords) {
          for (var i2 = 0;i2 < s3; i2++)
            maskedWords.words[i2] = this.words[i2];
          maskedWords.length = s3;
        }
        if (s3 === 0)
          ;
        else if (this.length > s3) {
          this.length -= s3;
          for (i2 = 0;i2 < this.length; i2++)
            this.words[i2] = this.words[i2 + s3];
        } else
          this.words[0] = 0, this.length = 1;
        var carry = 0;
        for (i2 = this.length - 1;i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r | word >>> r, carry = word & mask;
        }
        if (maskedWords && carry !== 0)
          maskedWords.words[maskedWords.length++] = carry;
        if (this.length === 0)
          this.words[0] = 0, this.length = 1;
        return this.strip();
      }, BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        return assert(this.negative === 0), this.iushrn(bits, hint, extended);
      }, BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      }, BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      }, BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      }, BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      }, BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26, s3 = (bit - r) / 26, q3 = 1 << r;
        if (this.length <= s3)
          return false;
        var w = this.words[s3];
        return !!(w & q3);
      }, BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26, s3 = (bits - r) / 26;
        if (assert(this.negative === 0, "imaskn works only with positive numbers"), this.length <= s3)
          return this;
        if (r !== 0)
          s3++;
        if (this.length = Math.min(s3, this.length), r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      }, BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      }, BN.prototype.iaddn = function iaddn(num) {
        if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num)
            return this.words[0] = num - (this.words[0] | 0), this.negative = 0, this;
          return this.negative = 0, this.isubn(num), this.negative = 1, this;
        }
        return this._iaddn(num);
      }, BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0;i2 < this.length && this.words[i2] >= 67108864; i2++)
          if (this.words[i2] -= 67108864, i2 === this.length - 1)
            this.words[i2 + 1] = 1;
          else
            this.words[i2 + 1]++;
        return this.length = Math.max(this.length, i2 + 1), this;
      }, BN.prototype.isubn = function isubn(num) {
        if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(num), this.negative = 1, this;
        if (this.words[0] -= num, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var i2 = 0;i2 < this.length && this.words[i2] < 0; i2++)
            this.words[i2] += 67108864, this.words[i2 + 1] -= 1;
        return this.strip();
      }, BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      }, BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      }, BN.prototype.iabs = function iabs() {
        return this.negative = 0, this;
      }, BN.prototype.abs = function abs() {
        return this.clone().iabs();
      }, BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len2 = num.length + shift, i2;
        this._expand(len2);
        var w, carry = 0;
        for (i2 = 0;i2 < num.length; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul;
          w -= right & 67108863, carry = (w >> 26) - (right / 67108864 | 0), this.words[i2 + shift] = w & 67108863;
        }
        for (;i2 < this.length - shift; i2++)
          w = (this.words[i2 + shift] | 0) + carry, carry = w >> 26, this.words[i2 + shift] = w & 67108863;
        if (carry === 0)
          return this.strip();
        assert(carry === -1), carry = 0;
        for (i2 = 0;i2 < this.length; i2++)
          w = -(this.words[i2] | 0) + carry, carry = w >> 26, this.words[i2] = w & 67108863;
        return this.negative = 1, this.strip();
      }, BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length, a = this.clone(), b = num, bhi = b.words[b.length - 1] | 0, bhiBits = this._countBits(bhi);
        if (shift = 26 - bhiBits, shift !== 0)
          b = b.ushln(shift), a.iushln(shift), bhi = b.words[b.length - 1] | 0;
        var m2 = a.length - b.length, q3;
        if (mode !== "mod") {
          q3 = new BN(null), q3.length = m2 + 1, q3.words = new Array(q3.length);
          for (var i2 = 0;i2 < q3.length; i2++)
            q3.words[i2] = 0;
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m2);
        if (diff.negative === 0) {
          if (a = diff, q3)
            q3.words[m2] = 1;
        }
        for (var j3 = m2 - 1;j3 >= 0; j3--) {
          var qj = (a.words[b.length + j3] | 0) * 67108864 + (a.words[b.length + j3 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863), a._ishlnsubmul(b, qj, j3);
          while (a.negative !== 0)
            if (qj--, a.negative = 0, a._ishlnsubmul(b, 1, j3), !a.isZero())
              a.negative ^= 1;
          if (q3)
            q3.words[j3] = qj;
        }
        if (q3)
          q3.strip();
        if (a.strip(), mode !== "div" && shift !== 0)
          a.iushrn(shift);
        return { div: q3 || null, mod: a };
      }, BN.prototype.divmod = function divmod(num, mode, positive) {
        if (assert(!num.isZero()), this.isZero())
          return { div: new BN(0), mod: new BN(0) };
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          if (res = this.neg().divmod(num, mode), mode !== "mod")
            div = res.div.neg();
          if (mode !== "div") {
            if (mod = res.mod.neg(), positive && mod.negative !== 0)
              mod.iadd(num);
          }
          return { div, mod };
        }
        if (this.negative === 0 && num.negative !== 0) {
          if (res = this.divmod(num.neg(), mode), mode !== "mod")
            div = res.div.neg();
          return { div, mod: res.mod };
        }
        if ((this.negative & num.negative) !== 0) {
          if (res = this.neg().divmod(num.neg(), mode), mode !== "div") {
            if (mod = res.mod.neg(), positive && mod.negative !== 0)
              mod.isub(num);
          }
          return { div: res.div, mod };
        }
        if (num.length > this.length || this.cmp(num) < 0)
          return { div: new BN(0), mod: this };
        if (num.length === 1) {
          if (mode === "div")
            return { div: this.divn(num.words[0]), mod: null };
          if (mode === "mod")
            return { div: null, mod: new BN(this.modn(num.words[0])) };
          return { div: this.divn(num.words[0]), mod: new BN(this.modn(num.words[0])) };
        }
        return this._wordDiv(num, mode);
      }, BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      }, BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      }, BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      }, BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod, half = num.ushrn(1), r2 = num.andln(1), cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      }, BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p2 = 67108864 % num, acc = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--)
          acc = (p2 * acc + (this.words[i2] | 0)) % num;
        return acc;
      }, BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--) {
          var w = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w / num | 0, carry = w % num;
        }
        return this.strip();
      }, BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      }, BN.prototype.egcd = function egcd(p2) {
        assert(p2.negative === 0), assert(!p2.isZero());
        var x4 = this, y = p2.clone();
        if (x4.negative !== 0)
          x4 = x4.umod(p2);
        else
          x4 = x4.clone();
        var A3 = new BN(1), B3 = new BN(0), C2 = new BN(0), D2 = new BN(1), g2 = 0;
        while (x4.isEven() && y.isEven())
          x4.iushrn(1), y.iushrn(1), ++g2;
        var yp = y.clone(), xp = x4.clone();
        while (!x4.isZero()) {
          for (var i2 = 0, im = 1;(x4.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            x4.iushrn(i2);
            while (i2-- > 0) {
              if (A3.isOdd() || B3.isOdd())
                A3.iadd(yp), B3.isub(xp);
              A3.iushrn(1), B3.iushrn(1);
            }
          }
          for (var j3 = 0, jm = 1;(y.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
            ;
          if (j3 > 0) {
            y.iushrn(j3);
            while (j3-- > 0) {
              if (C2.isOdd() || D2.isOdd())
                C2.iadd(yp), D2.isub(xp);
              C2.iushrn(1), D2.iushrn(1);
            }
          }
          if (x4.cmp(y) >= 0)
            x4.isub(y), A3.isub(C2), B3.isub(D2);
          else
            y.isub(x4), C2.isub(A3), D2.isub(B3);
        }
        return { a: C2, b: D2, gcd: y.iushln(g2) };
      }, BN.prototype._invmp = function _invmp(p2) {
        assert(p2.negative === 0), assert(!p2.isZero());
        var a = this, b = p2.clone();
        if (a.negative !== 0)
          a = a.umod(p2);
        else
          a = a.clone();
        var x1 = new BN(1), x22 = new BN(0), delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i2 = 0, im = 1;(a.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            a.iushrn(i2);
            while (i2-- > 0) {
              if (x1.isOdd())
                x1.iadd(delta);
              x1.iushrn(1);
            }
          }
          for (var j3 = 0, jm = 1;(b.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
            ;
          if (j3 > 0) {
            b.iushrn(j3);
            while (j3-- > 0) {
              if (x22.isOdd())
                x22.iadd(delta);
              x22.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0)
            a.isub(b), x1.isub(x22);
          else
            b.isub(a), x22.isub(x1);
        }
        var res;
        if (a.cmpn(1) === 0)
          res = x1;
        else
          res = x22;
        if (res.cmpn(0) < 0)
          res.iadd(p2);
        return res;
      }, BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone(), b = num.clone();
        a.negative = 0, b.negative = 0;
        for (var shift = 0;a.isEven() && b.isEven(); shift++)
          a.iushrn(1), b.iushrn(1);
        do {
          while (a.isEven())
            a.iushrn(1);
          while (b.isEven())
            b.iushrn(1);
          var r = a.cmp(b);
          if (r < 0) {
            var t2 = a;
            a = b, b = t2;
          } else if (r === 0 || b.cmpn(1) === 0)
            break;
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      }, BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      }, BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      }, BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      }, BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      }, BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26, s3 = (bit - r) / 26, q3 = 1 << r;
        if (this.length <= s3)
          return this._expand(s3 + 1), this.words[s3] |= q3, this;
        var carry = q3;
        for (var i2 = s3;carry !== 0 && i2 < this.length; i2++) {
          var w = this.words[i2] | 0;
          w += carry, carry = w >>> 26, w &= 67108863, this.words[i2] = w;
        }
        if (carry !== 0)
          this.words[i2] = carry, this.length++;
        return this;
      }, BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      }, BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1)
          res = 1;
        else {
          if (negative)
            num = -num;
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--) {
          var a = this.words[i2] | 0, b = num.words[i2] | 0;
          if (a === b)
            continue;
          if (a < b)
            res = -1;
          else if (a > b)
            res = 1;
          break;
        }
        return res;
      }, BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      }, BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      }, BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      }, BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      }, BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      }, BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      }, BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      }, BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      }, BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      }, BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      }, BN.red = function red(num) {
        return new Red(num);
      }, BN.prototype.toRed = function toRed(ctx) {
        return assert(!this.red, "Already a number in reduction context"), assert(this.negative === 0, "red works only with positives"), ctx.convertTo(this)._forceRed(ctx);
      }, BN.prototype.fromRed = function fromRed() {
        return assert(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, BN.prototype._forceRed = function _forceRed(ctx) {
        return this.red = ctx, this;
      }, BN.prototype.forceRed = function forceRed(ctx) {
        return assert(!this.red, "Already a number in reduction context"), this._forceRed(ctx);
      }, BN.prototype.redAdd = function redAdd(num) {
        return assert(this.red, "redAdd works only with red numbers"), this.red.add(this, num);
      }, BN.prototype.redIAdd = function redIAdd(num) {
        return assert(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, num);
      }, BN.prototype.redSub = function redSub(num) {
        return assert(this.red, "redSub works only with red numbers"), this.red.sub(this, num);
      }, BN.prototype.redISub = function redISub(num) {
        return assert(this.red, "redISub works only with red numbers"), this.red.isub(this, num);
      }, BN.prototype.redShl = function redShl(num) {
        return assert(this.red, "redShl works only with red numbers"), this.red.shl(this, num);
      }, BN.prototype.redMul = function redMul(num) {
        return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.mul(this, num);
      }, BN.prototype.redIMul = function redIMul(num) {
        return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.imul(this, num);
      }, BN.prototype.redSqr = function redSqr() {
        return assert(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, BN.prototype.redISqr = function redISqr() {
        return assert(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, BN.prototype.redSqrt = function redSqrt() {
        return assert(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, BN.prototype.redInvm = function redInvm() {
        return assert(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, BN.prototype.redNeg = function redNeg() {
        return assert(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, BN.prototype.redPow = function redPow(num) {
        return assert(this.red && !num.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, num);
      };
      var primes = { k256: null, p224: null, p192: null, p25519: null };
      function MPrime(name, p2) {
        this.name = name, this.p = new BN(p2, 16), this.n = this.p.bitLength(), this.k = new BN(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        return tmp.words = new Array(Math.ceil(this.n / 13)), tmp;
      }, MPrime.prototype.ireduce = function ireduce(num) {
        var r = num, rlen;
        do
          this.split(r, this.tmp), r = this.imulK(r), r = r.iadd(this.tmp), rlen = r.bitLength();
        while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0)
          r.words[0] = 0, r.length = 1;
        else if (cmp > 0)
          r.isub(this.p);
        else if (r.strip !== undefined)
          r.strip();
        else
          r._strip();
        return r;
      }, MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      }, MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      inherits2(K256, MPrime), K256.prototype.split = function split(input, output) {
        var mask = 4194303, outLen = Math.min(input.length, 9);
        for (var i2 = 0;i2 < outLen; i2++)
          output.words[i2] = input.words[i2];
        if (output.length = outLen, input.length <= 9) {
          input.words[0] = 0, input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i2 = 10;i2 < input.length; i2++) {
          var next = input.words[i2] | 0;
          input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22, prev = next;
        }
        if (prev >>>= 22, input.words[i2 - 10] = prev, prev === 0 && input.length > 10)
          input.length -= 10;
        else
          input.length -= 9;
      }, K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0, num.words[num.length + 1] = 0, num.length += 2;
        var lo = 0;
        for (var i2 = 0;i2 < num.length; i2++) {
          var w = num.words[i2] | 0;
          lo += w * 977, num.words[i2] = lo & 67108863, lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          if (num.length--, num.words[num.length - 1] === 0)
            num.length--;
        }
        return num;
      };
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      inherits2(P25519, MPrime), P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0;i2 < num.length; i2++) {
          var hi2 = (num.words[i2] | 0) * 19 + carry, lo = hi2 & 67108863;
          hi2 >>>= 26, num.words[i2] = lo, carry = hi2;
        }
        if (carry !== 0)
          num.words[num.length++] = carry;
        return num;
      }, BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime;
        if (name === "k256")
          prime = new K256;
        else if (name === "p224")
          prime = new P224;
        else if (name === "p192")
          prime = new P192;
        else if (name === "p25519")
          prime = new P25519;
        else
          throw new Error("Unknown prime " + name);
        return primes[name] = prime, prime;
      };
      function Red(m2) {
        if (typeof m2 === "string") {
          var prime = BN._prime(m2);
          this.m = prime.p, this.prime = prime;
        } else
          assert(m2.gtn(1), "modulus must be greater than 1"), this.m = m2, this.prime = null;
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives"), assert(a.red, "red works only with red numbers");
      }, Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives"), assert(a.red && a.red === b.red, "red works only with red numbers");
      }, Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      }, Red.prototype.neg = function neg(a) {
        if (a.isZero())
          return a.clone();
        return this.m.sub(a)._forceRed(this);
      }, Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0)
          res.isub(this.m);
        return res._forceRed(this);
      }, Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0)
          res.isub(this.m);
        return res;
      }, Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0)
          res.iadd(this.m);
        return res._forceRed(this);
      }, Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0)
          res.iadd(this.m);
        return res;
      }, Red.prototype.shl = function shl(a, num) {
        return this._verify1(a), this.imod(a.ushln(num));
      }, Red.prototype.imul = function imul(a, b) {
        return this._verify2(a, b), this.imod(a.imul(b));
      }, Red.prototype.mul = function mul(a, b) {
        return this._verify2(a, b), this.imod(a.mul(b));
      }, Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      }, Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      }, Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        if (assert(mod3 % 2 === 1), mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q3 = this.m.subn(1), s3 = 0;
        while (!q3.isZero() && q3.andln(1) === 0)
          s3++, q3.iushrn(1);
        assert(!q3.isZero());
        var one = new BN(1).toRed(this), nOne = one.redNeg(), lpow = this.m.subn(1).iushrn(1), z2 = this.m.bitLength();
        z2 = new BN(2 * z2 * z2).toRed(this);
        while (this.pow(z2, lpow).cmp(nOne) !== 0)
          z2.redIAdd(nOne);
        var c = this.pow(z2, q3), r = this.pow(a, q3.addn(1).iushrn(1)), t2 = this.pow(a, q3), m2 = s3;
        while (t2.cmp(one) !== 0) {
          var tmp = t2;
          for (var i2 = 0;tmp.cmp(one) !== 0; i2++)
            tmp = tmp.redSqr();
          assert(i2 < m2);
          var b = this.pow(c, new BN(1).iushln(m2 - i2 - 1));
          r = r.redMul(b), c = b.redSqr(), t2 = t2.redMul(c), m2 = i2;
        }
        return r;
      }, Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0)
          return inv.negative = 0, this.imod(inv).redNeg();
        else
          return this.imod(inv);
      }, Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4, wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this), wnd[1] = a;
        for (var i2 = 2;i2 < wnd.length; i2++)
          wnd[i2] = this.mul(wnd[i2 - 1], a);
        var res = wnd[0], current = 0, currentLen = 0, start = num.bitLength() % 26;
        if (start === 0)
          start = 26;
        for (i2 = num.length - 1;i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j3 = start - 1;j3 >= 0; j3--) {
            var bit = word >> j3 & 1;
            if (res !== wnd[0])
              res = this.sqr(res);
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            if (current <<= 1, current |= bit, currentLen++, currentLen !== windowSize && (i2 !== 0 || j3 !== 0))
              continue;
            res = this.mul(res, wnd[current]), currentLen = 0, current = 0;
          }
          start = 26;
        }
        return res;
      }, Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      }, Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        return res.red = null, res;
      }, BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m2) {
        if (Red.call(this, m2), this.shift = this.m.bitLength(), this.shift % 26 !== 0)
          this.shift += 26 - this.shift % 26;
        this.r = new BN(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red), Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      }, Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        return r.red = null, r;
      }, Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero())
          return a.words[0] = 0, a.length = 1, a;
        var t2 = a.imul(b), c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t2.isub(c).iushrn(this.shift), res = u;
        if (u.cmp(this.m) >= 0)
          res = u.isub(this.m);
        else if (u.cmpn(0) < 0)
          res = u.iadd(this.m);
        return res._forceRed(this);
      }, Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t2 = a.mul(b), c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t2.isub(c).iushrn(this.shift), res = u;
        if (u.cmp(this.m) >= 0)
          res = u.isub(this.m);
        else if (u.cmpn(0) < 0)
          res = u.iadd(this.m);
        return res._forceRed(this);
      }, Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  });
  require_minimalistic_assert = __commonJS2((exports, module) => {
    module.exports = assert;
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert.equal = function assertEqual(l3, r, msg) {
      if (l3 != r)
        throw new Error(msg || "Assertion failed: " + l3 + " != " + r);
    };
  });
  require_utils = __commonJS2((exports) => {
    var utils = exports;
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i2 = 0;i2 < msg.length; i2++)
          res[i2] = msg[i2] | 0;
        return res;
      }
      if (enc === "hex") {
        if (msg = msg.replace(/[^a-z0-9]+/ig, ""), msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i2 = 0;i2 < msg.length; i2 += 2)
          res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
      } else
        for (var i2 = 0;i2 < msg.length; i2++) {
          var c = msg.charCodeAt(i2), hi2 = c >> 8, lo = c & 255;
          if (hi2)
            res.push(hi2, lo);
          else
            res.push(lo);
        }
      return res;
    }
    utils.toArray = toArray;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils.zero2 = zero2;
    function toHex(msg) {
      var res = "";
      for (var i2 = 0;i2 < msg.length; i2++)
        res += zero2(msg[i2].toString(16));
      return res;
    }
    utils.toHex = toHex;
    utils.encode = function encode(arr, enc) {
      if (enc === "hex")
        return toHex(arr);
      else
        return arr;
    };
  });
  require_utils2 = __commonJS2((exports) => {
    var utils = exports, BN = require_bn(), minAssert = require_minimalistic_assert(), minUtils = require_utils();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1), i2;
      for (i2 = 0;i2 < naf.length; i2 += 1)
        naf[i2] = 0;
      var ws = 1 << w + 1, k4 = num.clone();
      for (i2 = 0;i2 < naf.length; i2++) {
        var z2, mod = k4.andln(ws - 1);
        if (k4.isOdd()) {
          if (mod > (ws >> 1) - 1)
            z2 = (ws >> 1) - mod;
          else
            z2 = mod;
          k4.isubn(z2);
        } else
          z2 = 0;
        naf[i2] = z2, k4.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k22) {
      var jsf = [[], []];
      k1 = k1.clone(), k22 = k22.clone();
      var d1 = 0, d22 = 0, m8;
      while (k1.cmpn(-d1) > 0 || k22.cmpn(-d22) > 0) {
        var m14 = k1.andln(3) + d1 & 3, m24 = k22.andln(3) + d22 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0)
          u1 = 0;
        else if (m8 = k1.andln(7) + d1 & 7, (m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0)
          u2 = 0;
        else if (m8 = k22.andln(7) + d22 & 7, (m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
        if (jsf[1].push(u2), 2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d22 === u2 + 1)
          d22 = 1 - d22;
        k1.iushrn(1), k22.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
      var key = "_" + name;
      obj.prototype[name] = function cachedProperty() {
        return this[key] !== undefined ? this[key] : this[key] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  });
  require_brorand = __commonJS2((exports, module) => {
    var r;
    module.exports = function rand(len2) {
      if (!r)
        r = new Rand(null);
      return r.generate(len2);
    };
    function Rand(rand) {
      this.rand = rand;
    }
    module.exports.Rand = Rand;
    Rand.prototype.generate = function generate(len2) {
      return this._rand(len2);
    };
    Rand.prototype._rand = function _rand(n) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n);
      var res = new Uint8Array(n);
      for (var i2 = 0;i2 < res.length; i2++)
        res[i2] = this.rand.getByte();
      return res;
    };
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues)
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          return self.crypto.getRandomValues(arr), arr;
        };
      else if (self.msCrypto && self.msCrypto.getRandomValues)
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          return self.msCrypto.getRandomValues(arr), arr;
        };
      else if (typeof window === "object")
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
    } else
      try {
        if (crypto2 = (init_crypto(), __toCommonJS(exports_crypto)), typeof crypto2.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = function _rand(n) {
          return crypto2.randomBytes(n);
        };
      } catch (e2) {}
    var crypto2;
  });
  require_base = __commonJS2((exports, module) => {
    var BN = require_bn(), utils = require_utils2(), getNAF = utils.getNAF, getJSF = utils.getJSF, assert = utils.assert;
    function BaseCurve(type, conf) {
      this.type = type, this.p = new BN(conf.p, 16), this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p), this.zero = new BN(0).toRed(this.red), this.one = new BN(1).toRed(this.red), this.two = new BN(2).toRed(this.red), this.n = conf.n && new BN(conf.n, 16), this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0)
        this.redN = null;
      else
        this._maxwellTrick = true, this.redN = this.n.toRed(this.red);
    }
    module.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p2, k4) {
      assert(p2.precomputed);
      var doubles = p2._getDoubles(), naf = getNAF(k4, 1, this._bitLength), I2 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I2 /= 3;
      var repr = [], j3, nafW;
      for (j3 = 0;j3 < naf.length; j3 += doubles.step) {
        nafW = 0;
        for (var l3 = j3 + doubles.step - 1;l3 >= j3; l3--)
          nafW = (nafW << 1) + naf[l3];
        repr.push(nafW);
      }
      var a = this.jpoint(null, null, null), b = this.jpoint(null, null, null);
      for (var i2 = I2;i2 > 0; i2--) {
        for (j3 = 0;j3 < repr.length; j3++)
          if (nafW = repr[j3], nafW === i2)
            b = b.mixedAdd(doubles.points[j3]);
          else if (nafW === -i2)
            b = b.mixedAdd(doubles.points[j3].neg());
        a = a.add(b);
      }
      return a.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p2, k4) {
      var w = 4, nafPoints = p2._getNAFPoints(w);
      w = nafPoints.wnd;
      var wnd = nafPoints.points, naf = getNAF(k4, w, this._bitLength), acc = this.jpoint(null, null, null);
      for (var i2 = naf.length - 1;i2 >= 0; i2--) {
        for (var l3 = 0;i2 >= 0 && naf[i2] === 0; i2--)
          l3++;
        if (i2 >= 0)
          l3++;
        if (acc = acc.dblp(l3), i2 < 0)
          break;
        var z2 = naf[i2];
        if (assert(z2 !== 0), p2.type === "affine")
          if (z2 > 0)
            acc = acc.mixedAdd(wnd[z2 - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z2 - 1 >> 1].neg());
        else if (z2 > 0)
          acc = acc.add(wnd[z2 - 1 >> 1]);
        else
          acc = acc.add(wnd[-z2 - 1 >> 1].neg());
      }
      return p2.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len2, jacobianResult) {
      var wndWidth = this._wnafT1, wnd = this._wnafT2, naf = this._wnafT3, max = 0, i2, j3, p2;
      for (i2 = 0;i2 < len2; i2++) {
        p2 = points[i2];
        var nafPoints = p2._getNAFPoints(defW);
        wndWidth[i2] = nafPoints.wnd, wnd[i2] = nafPoints.points;
      }
      for (i2 = len2 - 1;i2 >= 1; i2 -= 2) {
        var a = i2 - 1, b = i2;
        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
          naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength), naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength), max = Math.max(naf[a].length, max), max = Math.max(naf[b].length, max);
          continue;
        }
        var comb = [points[a], null, null, points[b]];
        if (points[a].y.cmp(points[b].y) === 0)
          comb[1] = points[a].add(points[b]), comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        else if (points[a].y.cmp(points[b].y.redNeg()) === 0)
          comb[1] = points[a].toJ().mixedAdd(points[b]), comb[2] = points[a].add(points[b].neg());
        else
          comb[1] = points[a].toJ().mixedAdd(points[b]), comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        var index = [-3, -1, -5, -7, 0, 7, 5, 1, 3], jsf = getJSF(coeffs[a], coeffs[b]);
        max = Math.max(jsf[0].length, max), naf[a] = new Array(max), naf[b] = new Array(max);
        for (j3 = 0;j3 < max; j3++) {
          var ja2 = jsf[0][j3] | 0, jb = jsf[1][j3] | 0;
          naf[a][j3] = index[(ja2 + 1) * 3 + (jb + 1)], naf[b][j3] = 0, wnd[a] = comb;
        }
      }
      var acc = this.jpoint(null, null, null), tmp = this._wnafT4;
      for (i2 = max;i2 >= 0; i2--) {
        var k4 = 0;
        while (i2 >= 0) {
          var zero = true;
          for (j3 = 0;j3 < len2; j3++)
            if (tmp[j3] = naf[j3][i2] | 0, tmp[j3] !== 0)
              zero = false;
          if (!zero)
            break;
          k4++, i2--;
        }
        if (i2 >= 0)
          k4++;
        if (acc = acc.dblp(k4), i2 < 0)
          break;
        for (j3 = 0;j3 < len2; j3++) {
          var z2 = tmp[j3];
          if (z2 === 0)
            continue;
          else if (z2 > 0)
            p2 = wnd[j3][z2 - 1 >> 1];
          else if (z2 < 0)
            p2 = wnd[j3][-z2 - 1 >> 1].neg();
          if (p2.type === "affine")
            acc = acc.mixedAdd(p2);
          else
            acc = acc.add(p2);
        }
      }
      for (i2 = 0;i2 < len2; i2++)
        wnd[i2] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type) {
      this.curve = curve, this.type = type, this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils.toArray(bytes, enc);
      var len2 = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len2) {
        if (bytes[0] === 6)
          assert(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(bytes.slice(1, 1 + len2), bytes.slice(1 + len2, 1 + 2 * len2));
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len2)
        return this.pointFromX(bytes.slice(1, 1 + len2), bytes[0] === 3);
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len2 = this.curve.p.byteLength(), x4 = this.getX().toArray("be", len2);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x4);
      return [4].concat(x4, this.getY().toArray("be", len2));
    };
    BasePoint.prototype.encode = function encode(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = { doubles: null, naf: null, beta: null };
      return precomputed.naf = this._getNAFPoints(8), precomputed.doubles = this._getDoubles(4, power), precomputed.beta = this._getBeta(), this.precomputed = precomputed, this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k4) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k4.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this], acc = this;
      for (var i2 = 0;i2 < power; i2 += step) {
        for (var j3 = 0;j3 < step; j3++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return { step, points: doubles };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this], max = (1 << wnd) - 1, dbl = max === 1 ? null : this.dbl();
      for (var i2 = 1;i2 < max; i2++)
        res[i2] = res[i2 - 1].add(dbl);
      return { wnd, points: res };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k4) {
      var r = this;
      for (var i2 = 0;i2 < k4; i2++)
        r = r.dbl();
      return r;
    };
  });
  require_inherits_browser = __commonJS2((exports, module) => {
    if (typeof Object.create === "function")
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor)
          ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } });
      };
    else
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {};
          TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
        }
      };
  });
  require_inherits = __commonJS2((exports, module) => {
    try {
      if (util = (init_util(), __toCommonJS(exports_util)), typeof util.inherits !== "function")
        throw "";
      module.exports = util.inherits;
    } catch (e2) {
      module.exports = require_inherits_browser();
    }
    var util;
  });
  require_short = __commonJS2((exports, module) => {
    var utils = require_utils2(), BN = require_bn(), inherits2 = require_inherits(), Base = require_base(), assert = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf), this.a = new BN(conf.a, 16).toRed(this.red), this.b = new BN(conf.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(conf), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
    }
    inherits2(ShortCurve, Base);
    module.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta, lambda;
      if (conf.beta)
        beta = new BN(conf.beta, 16).toRed(this.red);
      else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1], beta = beta.toRed(this.red);
      }
      if (conf.lambda)
        lambda = new BN(conf.lambda, 16);
      else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0)
          lambda = lambdas[0];
        else
          lambda = lambdas[1], assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
      }
      var basis;
      if (conf.basis)
        basis = conf.basis.map(function(vec) {
          return { a: new BN(vec.a, 16), b: new BN(vec.b, 16) };
        });
      else
        basis = this._getEndoBasis(lambda);
      return { beta, lambda, basis };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN.mont(num), tinv = new BN(2).toRed(red).redInvm(), ntinv = tinv.redNeg(), s3 = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv), l1 = ntinv.redAdd(s3).fromRed(), l22 = ntinv.redSub(s3).fromRed();
      return [l1, l22];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), u = lambda, v2 = this.n.clone(), x1 = new BN(1), y1 = new BN(0), x22 = new BN(0), y2 = new BN(1), a0, b0, a1, b1, a2, b2, prevR, i2 = 0, r, x4;
      while (u.cmpn(0) !== 0) {
        var q3 = v2.div(u);
        r = v2.sub(q3.mul(u)), x4 = x22.sub(q3.mul(x1));
        var y = y2.sub(q3.mul(y1));
        if (!a1 && r.cmp(aprxSqrt) < 0)
          a0 = prevR.neg(), b0 = x1, a1 = r.neg(), b1 = x4;
        else if (a1 && ++i2 === 2)
          break;
        prevR = r, v2 = u, u = r, x22 = x1, x1 = x4, y2 = y1, y1 = y;
      }
      a2 = r.neg(), b2 = x4;
      var len1 = a1.sqr().add(b1.sqr()), len2 = a2.sqr().add(b2.sqr());
      if (len2.cmp(len1) >= 0)
        a2 = a0, b2 = b0;
      if (a1.negative)
        a1 = a1.neg(), b1 = b1.neg();
      if (a2.negative)
        a2 = a2.neg(), b2 = b2.neg();
      return [{ a: a1, b: b1 }, { a: a2, b: b2 }];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k4) {
      var basis = this.endo.basis, v1 = basis[0], v2 = basis[1], c1 = v2.b.mul(k4).divRound(this.n), c2 = v1.b.neg().mul(k4).divRound(this.n), p1 = c1.mul(v1.a), p2 = c2.mul(v2.a), q1 = c1.mul(v1.b), q22 = c2.mul(v2.b), k1 = k4.sub(p1).sub(p2), k22 = q1.add(q22).neg();
      return { k1, k2: k22 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x4, odd) {
      if (x4 = new BN(x4, 16), !x4.red)
        x4 = x4.toRed(this.red);
      var y2 = x4.redSqr().redMul(x4).redIAdd(x4.redMul(this.a)).redIAdd(this.b), y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x4, y);
    };
    ShortCurve.prototype.validate = function validate(point) {
      if (point.inf)
        return true;
      var { x: x4, y } = point, ax = this.a.redMul(x4), rhs = x4.redSqr().redMul(x4).redIAdd(ax).redIAdd(this.b);
      return y.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1, ncoeffs = this._endoWnafT2;
      for (var i2 = 0;i2 < points.length; i2++) {
        var split = this._endoSplit(coeffs[i2]), p2 = points[i2], beta = p2._getBeta();
        if (split.k1.negative)
          split.k1.ineg(), p2 = p2.neg(true);
        if (split.k2.negative)
          split.k2.ineg(), beta = beta.neg(true);
        npoints[i2 * 2] = p2, npoints[i2 * 2 + 1] = beta, ncoeffs[i2 * 2] = split.k1, ncoeffs[i2 * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i2 * 2, jacobianResult);
      for (var j3 = 0;j3 < i2 * 2; j3++)
        npoints[j3] = null, ncoeffs[j3] = null;
      return res;
    };
    function Point(curve, x4, y, isRed) {
      if (Base.BasePoint.call(this, curve, "affine"), x4 === null && y === null)
        this.x = null, this.y = null, this.inf = true;
      else {
        if (this.x = new BN(x4, 16), this.y = new BN(y, 16), isRed)
          this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits2(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x4, y, isRed) {
      return new Point(this, x4, y, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve, endoMul = function(p2) {
          return curve.point(p2.x.redMul(curve.endo.beta), p2.y);
        };
        pre.beta = beta, beta.precomputed = { beta: null, naf: pre.naf && { wnd: pre.naf.wnd, points: pre.naf.points.map(endoMul) }, doubles: pre.doubles && { step: pre.doubles.step, points: pre.doubles.points.map(endoMul) } };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      return res.precomputed = { beta: null, doubles: pre.doubles && { step: pre.doubles.step, points: [res].concat(pre.doubles.points.map(obj2point)) }, naf: pre.naf && { wnd: pre.naf.wnd, points: [res].concat(pre.naf.points.map(obj2point)) } }, res;
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p2) {
      if (this.inf)
        return p2;
      if (p2.inf)
        return this;
      if (this.eq(p2))
        return this.dbl();
      if (this.neg().eq(p2))
        return this.curve.point(null, null);
      if (this.x.cmp(p2.x) === 0)
        return this.curve.point(null, null);
      var c = this.y.redSub(p2.y);
      if (c.cmpn(0) !== 0)
        c = c.redMul(this.x.redSub(p2.x).redInvm());
      var nx = c.redSqr().redISub(this.x).redISub(p2.x), ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a = this.curve.a, x22 = this.x.redSqr(), dyinv = ys1.redInvm(), c = x22.redAdd(x22).redIAdd(x22).redIAdd(a).redMul(dyinv), nx = c.redSqr().redISub(this.x.redAdd(this.x)), ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k4) {
      if (k4 = new BN(k4, 16), this.isInfinity())
        return this;
      else if (this._hasDoubles(k4))
        return this.curve._fixedNafMul(this, k4);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k4]);
      else
        return this.curve._wnafMul(this, k4);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p2, k22) {
      var points = [this, p2], coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p2, k22) {
      var points = [this, p2], coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p2) {
      return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed, negate = function(p2) {
          return p2.neg();
        };
        res.precomputed = { naf: pre.naf && { wnd: pre.naf.wnd, points: pre.naf.points.map(negate) }, doubles: pre.doubles && { step: pre.doubles.step, points: pre.doubles.points.map(negate) } };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x4, y, z2) {
      if (Base.BasePoint.call(this, curve, "jacobian"), x4 === null && y === null && z2 === null)
        this.x = this.curve.one, this.y = this.curve.one, this.z = new BN(0);
      else
        this.x = new BN(x4, 16), this.y = new BN(y, 16), this.z = new BN(z2, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits2(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x4, y, z2) {
      return new JPoint(this, x4, y, z2);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm(), zinv2 = zinv.redSqr(), ax = this.x.redMul(zinv2), ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p2) {
      if (this.isInfinity())
        return p2;
      if (p2.isInfinity())
        return this;
      var pz2 = p2.z.redSqr(), z2 = this.z.redSqr(), u1 = this.x.redMul(pz2), u2 = p2.x.redMul(z2), s1 = this.y.redMul(pz2.redMul(p2.z)), s22 = p2.y.redMul(z2.redMul(this.z)), h = u1.redSub(u2), r = s1.redSub(s22);
      if (h.cmpn(0) === 0)
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      var h2 = h.redSqr(), h3 = h2.redMul(h), v2 = u1.redMul(h2), nx = r.redSqr().redIAdd(h3).redISub(v2).redISub(v2), ny = r.redMul(v2.redISub(nx)).redISub(s1.redMul(h3)), nz = this.z.redMul(p2.z).redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p2) {
      if (this.isInfinity())
        return p2.toJ();
      if (p2.isInfinity())
        return this;
      var z2 = this.z.redSqr(), u1 = this.x, u2 = p2.x.redMul(z2), s1 = this.y, s22 = p2.y.redMul(z2).redMul(this.z), h = u1.redSub(u2), r = s1.redSub(s22);
      if (h.cmpn(0) === 0)
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      var h2 = h.redSqr(), h3 = h2.redMul(h), v2 = u1.redMul(h2), nx = r.redSqr().redIAdd(h3).redISub(v2).redISub(v2), ny = r.redMul(v2.redISub(nx)).redISub(s1.redMul(h3)), nz = this.z.redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i2;
      if (this.curve.zeroA || this.curve.threeA) {
        var r = this;
        for (i2 = 0;i2 < pow; i2++)
          r = r.dbl();
        return r;
      }
      var a = this.curve.a, tinv = this.curve.tinv, jx = this.x, jy = this.y, jz = this.z, jz4 = jz.redSqr().redSqr(), jyd = jy.redAdd(jy);
      for (i2 = 0;i2 < pow; i2++) {
        var jx2 = jx.redSqr(), jyd2 = jyd.redSqr(), jyd4 = jyd2.redSqr(), c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4)), t1 = jx.redMul(jyd2), nx = c.redSqr().redISub(t1.redAdd(t1)), t2 = t1.redISub(nx), dny = c.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i2 + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx, jz = nz, jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx, ny, nz;
      if (this.zOne) {
        var xx = this.x.redSqr(), yy = this.y.redSqr(), yyyy = yy.redSqr(), s3 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s3 = s3.redIAdd(s3);
        var m2 = xx.redAdd(xx).redIAdd(xx), t2 = m2.redSqr().redISub(s3).redISub(s3), yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8), yyyy8 = yyyy8.redIAdd(yyyy8), nx = t2, ny = m2.redMul(s3.redISub(t2)).redISub(yyyy8), nz = this.y.redAdd(this.y);
      } else {
        var a = this.x.redSqr(), b = this.y.redSqr(), c = b.redSqr(), d3 = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
        d3 = d3.redIAdd(d3);
        var e2 = a.redAdd(a).redIAdd(a), f2 = e2.redSqr(), c8 = c.redIAdd(c);
        c8 = c8.redIAdd(c8), c8 = c8.redIAdd(c8), nx = f2.redISub(d3).redISub(d3), ny = e2.redMul(d3.redISub(nx)).redISub(c8), nz = this.y.redMul(this.z), nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx, ny, nz;
      if (this.zOne) {
        var xx = this.x.redSqr(), yy = this.y.redSqr(), yyyy = yy.redSqr(), s3 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s3 = s3.redIAdd(s3);
        var m2 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a), t2 = m2.redSqr().redISub(s3).redISub(s3);
        nx = t2;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8), yyyy8 = yyyy8.redIAdd(yyyy8), ny = m2.redMul(s3.redISub(t2)).redISub(yyyy8), nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr(), gamma = this.y.redSqr(), beta = this.x.redMul(gamma), alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8), nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8), ggamma8 = ggamma8.redIAdd(ggamma8), ggamma8 = ggamma8.redIAdd(ggamma8), ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a = this.curve.a, jx = this.x, jy = this.y, jz = this.z, jz4 = jz.redSqr().redSqr(), jx2 = jx.redSqr(), jy2 = jy.redSqr(), c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4)), jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2), nx = c.redSqr().redISub(t1.redAdd(t1)), t2 = t1.redISub(nx), jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8), jyd8 = jyd8.redIAdd(jyd8), jyd8 = jyd8.redIAdd(jyd8);
      var ny = c.redMul(t2).redISub(jyd8), nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr(), yy = this.y.redSqr(), zz = this.z.redSqr(), yyyy = yy.redSqr(), m2 = xx.redAdd(xx).redIAdd(xx), mm = m2.redSqr(), e2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e2 = e2.redIAdd(e2), e2 = e2.redAdd(e2).redIAdd(e2), e2 = e2.redISub(mm);
      var ee3 = e2.redSqr(), t2 = yyyy.redIAdd(yyyy);
      t2 = t2.redIAdd(t2), t2 = t2.redIAdd(t2), t2 = t2.redIAdd(t2);
      var u = m2.redIAdd(e2).redSqr().redISub(mm).redISub(ee3).redISub(t2), yyu4 = yy.redMul(u);
      yyu4 = yyu4.redIAdd(yyu4), yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee3).redISub(yyu4);
      nx = nx.redIAdd(nx), nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u.redMul(t2.redISub(u)).redISub(e2.redMul(ee3)));
      ny = ny.redIAdd(ny), ny = ny.redIAdd(ny), ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e2).redSqr().redISub(zz).redISub(ee3);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k4, kbase) {
      return k4 = new BN(k4, kbase), this.curve._wnafMul(this, k4);
    };
    JPoint.prototype.eq = function eq(p2) {
      if (p2.type === "affine")
        return this.eq(p2.toJ());
      if (this === p2)
        return true;
      var z2 = this.z.redSqr(), pz2 = p2.z.redSqr();
      if (this.x.redMul(pz2).redISub(p2.x.redMul(z2)).cmpn(0) !== 0)
        return false;
      var z3 = z2.redMul(this.z), pz3 = pz2.redMul(p2.z);
      return this.y.redMul(pz3).redISub(p2.y.redMul(z3)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x4) {
      var zs = this.z.redSqr(), rx = x4.toRed(this.curve.red).redMul(zs);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x4.clone(), t2 = this.curve.redN.redMul(zs);
      for (;; ) {
        if (xc.iadd(this.curve.n), xc.cmp(this.curve.p) >= 0)
          return false;
        if (rx.redIAdd(t2), this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  });
  require_mont = __commonJS2((exports, module) => {
    var BN = require_bn(), inherits2 = require_inherits(), Base = require_base(), utils = require_utils2();
    function MontCurve(conf) {
      Base.call(this, "mont", conf), this.a = new BN(conf.a, 16).toRed(this.red), this.b = new BN(conf.b, 16).toRed(this.red), this.i4 = new BN(4).toRed(this.red).redInvm(), this.two = new BN(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits2(MontCurve, Base);
    module.exports = MontCurve;
    MontCurve.prototype.validate = function validate(point) {
      var x4 = point.normalize().x, x22 = x4.redSqr(), rhs = x22.redMul(x4).redAdd(x22.redMul(this.a)).redAdd(x4), y = rhs.redSqrt();
      return y.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x4, z2) {
      if (Base.BasePoint.call(this, curve, "projective"), x4 === null && z2 === null)
        this.x = this.curve.one, this.z = this.curve.zero;
      else {
        if (this.x = new BN(x4, 16), this.z = new BN(z2, 16), !this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits2(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      return this.point(utils.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x4, z2) {
      return new Point(this, x4, z2);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {};
    Point.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
      var a = this.x.redAdd(this.z), aa2 = a.redSqr(), b = this.x.redSub(this.z), bb = b.redSqr(), c = aa2.redSub(bb), nx = aa2.redMul(bb), nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
      return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p2, diff) {
      var a = this.x.redAdd(this.z), b = this.x.redSub(this.z), c = p2.x.redAdd(p2.z), d3 = p2.x.redSub(p2.z), da2 = d3.redMul(a), cb = c.redMul(b), nx = diff.z.redMul(da2.redAdd(cb).redSqr()), nz = diff.x.redMul(da2.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k4) {
      var t2 = k4.clone(), a = this, b = this.curve.point(null, null), c = this;
      for (var bits = [];t2.cmpn(0) !== 0; t2.iushrn(1))
        bits.push(t2.andln(1));
      for (var i2 = bits.length - 1;i2 >= 0; i2--)
        if (bits[i2] === 0)
          a = a.diffAdd(b, c), b = b.dbl();
        else
          b = a.diffAdd(b, c), a = a.dbl();
      return b;
    };
    Point.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
      return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
    };
    Point.prototype.getX = function getX() {
      return this.normalize(), this.x.fromRed();
    };
  });
  require_edwards = __commonJS2((exports, module) => {
    var utils = require_utils2(), BN = require_bn(), inherits2 = require_inherits(), Base = require_base(), assert = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1, this.mOneA = this.twisted && (conf.a | 0) === -1, this.extended = this.mOneA, Base.call(this, "edwards", conf), this.a = new BN(conf.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN(conf.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN(conf.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (conf.c | 0) === 1;
    }
    inherits2(EdwardsCurve, Base);
    module.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x4, y, z2, t2) {
      return this.point(x4, y, z2, t2);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x4, odd) {
      if (x4 = new BN(x4, 16), !x4.red)
        x4 = x4.toRed(this.red);
      var x22 = x4.redSqr(), rhs = this.c2.redSub(this.a.redMul(x22)), lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22)), y2 = rhs.redMul(lhs.redInvm()), y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x4, y);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
      if (y = new BN(y, 16), !y.red)
        y = y.toRed(this.red);
      var y2 = y.redSqr(), lhs = y2.redSub(this.c2), rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a), x22 = lhs.redMul(rhs.redInvm());
      if (x22.cmp(this.zero) === 0)
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y);
      var x4 = x22.redSqrt();
      if (x4.redSqr().redSub(x22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x4.fromRed().isOdd() !== odd)
        x4 = x4.redNeg();
      return this.point(x4, y);
    };
    EdwardsCurve.prototype.validate = function validate(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x22 = point.x.redSqr(), y2 = point.y.redSqr(), lhs = x22.redMul(this.a).redAdd(y2), rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x22).redMul(y2)));
      return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x4, y, z2, t2) {
      if (Base.BasePoint.call(this, curve, "projective"), x4 === null && y === null && z2 === null)
        this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true;
      else {
        if (this.x = new BN(x4, 16), this.y = new BN(y, 16), this.z = z2 ? new BN(z2, 16) : this.curve.one, this.t = t2 && new BN(t2, 16), !this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        if (this.zOne = this.z === this.curve.one, this.curve.extended && !this.t) {
          if (this.t = this.x.redMul(this.y), !this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits2(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x4, y, z2, t2) {
      return new Point(this, x4, y, z2, t2);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
      var a = this.x.redSqr(), b = this.y.redSqr(), c = this.z.redSqr();
      c = c.redIAdd(c);
      var d3 = this.curve._mulA(a), e2 = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b), g2 = d3.redAdd(b), f2 = g2.redSub(c), h = d3.redSub(b), nx = e2.redMul(f2), ny = g2.redMul(h), nt3 = e2.redMul(h), nz = f2.redMul(g2);
      return this.curve.point(nx, ny, nz, nt3);
    };
    Point.prototype._projDbl = function _projDbl() {
      var b = this.x.redAdd(this.y).redSqr(), c = this.x.redSqr(), d3 = this.y.redSqr(), nx, ny, nz, e2, h, j3;
      if (this.curve.twisted) {
        e2 = this.curve._mulA(c);
        var f2 = e2.redAdd(d3);
        if (this.zOne)
          nx = b.redSub(c).redSub(d3).redMul(f2.redSub(this.curve.two)), ny = f2.redMul(e2.redSub(d3)), nz = f2.redSqr().redSub(f2).redSub(f2);
        else
          h = this.z.redSqr(), j3 = f2.redSub(h).redISub(h), nx = b.redSub(c).redISub(d3).redMul(j3), ny = f2.redMul(e2.redSub(d3)), nz = f2.redMul(j3);
      } else
        e2 = c.redAdd(d3), h = this.curve._mulC(this.z).redSqr(), j3 = e2.redSub(h).redSub(h), nx = this.curve._mulC(b.redISub(e2)).redMul(j3), ny = this.curve._mulC(e2).redMul(c.redISub(d3)), nz = e2.redMul(j3);
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p2) {
      var a = this.y.redSub(this.x).redMul(p2.y.redSub(p2.x)), b = this.y.redAdd(this.x).redMul(p2.y.redAdd(p2.x)), c = this.t.redMul(this.curve.dd).redMul(p2.t), d3 = this.z.redMul(p2.z.redAdd(p2.z)), e2 = b.redSub(a), f2 = d3.redSub(c), g2 = d3.redAdd(c), h = b.redAdd(a), nx = e2.redMul(f2), ny = g2.redMul(h), nt3 = e2.redMul(h), nz = f2.redMul(g2);
      return this.curve.point(nx, ny, nz, nt3);
    };
    Point.prototype._projAdd = function _projAdd(p2) {
      var a = this.z.redMul(p2.z), b = a.redSqr(), c = this.x.redMul(p2.x), d3 = this.y.redMul(p2.y), e2 = this.curve.d.redMul(c).redMul(d3), f2 = b.redSub(e2), g2 = b.redAdd(e2), tmp = this.x.redAdd(this.y).redMul(p2.x.redAdd(p2.y)).redISub(c).redISub(d3), nx = a.redMul(f2).redMul(tmp), ny, nz;
      if (this.curve.twisted)
        ny = a.redMul(g2).redMul(d3.redSub(this.curve._mulA(c))), nz = f2.redMul(g2);
      else
        ny = a.redMul(g2).redMul(d3.redSub(c)), nz = this.curve._mulC(f2).redMul(g2);
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p2) {
      if (this.isInfinity())
        return p2;
      if (p2.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p2);
      else
        return this._projAdd(p2);
    };
    Point.prototype.mul = function mul(k4) {
      if (this._hasDoubles(k4))
        return this.curve._fixedNafMul(this, k4);
      else
        return this.curve._wnafMul(this, k4);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p2, k22) {
      return this.curve._wnafMulAdd(1, [this, p2], [k1, k22], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p2, k22) {
      return this.curve._wnafMulAdd(1, [this, p2], [k1, k22], 2, true);
    };
    Point.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi2 = this.z.redInvm();
      if (this.x = this.x.redMul(zi2), this.y = this.y.redMul(zi2), this.t)
        this.t = this.t.redMul(zi2);
      return this.z = this.curve.one, this.zOne = true, this;
    };
    Point.prototype.neg = function neg() {
      return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    };
    Point.prototype.getX = function getX() {
      return this.normalize(), this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.normalize(), this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x4) {
      var rx = x4.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x4.clone(), t2 = this.curve.redN.redMul(this.z);
      for (;; ) {
        if (xc.iadd(this.curve.n), xc.cmp(this.curve.p) >= 0)
          return false;
        if (rx.redIAdd(t2), this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
  });
  require_curve = __commonJS2((exports) => {
    var curve = exports;
    curve.base = require_base();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  });
  require_utils3 = __commonJS2((exports) => {
    var assert = require_minimalistic_assert(), inherits2 = require_inherits();
    exports.inherits = inherits2;
    function isSurrogatePair(msg, i2) {
      if ((msg.charCodeAt(i2) & 64512) !== 55296)
        return false;
      if (i2 < 0 || i2 + 1 >= msg.length)
        return false;
      return (msg.charCodeAt(i2 + 1) & 64512) === 56320;
    }
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p2 = 0;
          for (var i2 = 0;i2 < msg.length; i2++) {
            var c = msg.charCodeAt(i2);
            if (c < 128)
              res[p2++] = c;
            else if (c < 2048)
              res[p2++] = c >> 6 | 192, res[p2++] = c & 63 | 128;
            else if (isSurrogatePair(msg, i2))
              c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i2) & 1023), res[p2++] = c >> 18 | 240, res[p2++] = c >> 12 & 63 | 128, res[p2++] = c >> 6 & 63 | 128, res[p2++] = c & 63 | 128;
            else
              res[p2++] = c >> 12 | 224, res[p2++] = c >> 6 & 63 | 128, res[p2++] = c & 63 | 128;
          }
        } else if (enc === "hex") {
          if (msg = msg.replace(/[^a-z0-9]+/ig, ""), msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i2 = 0;i2 < msg.length; i2 += 2)
            res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
        }
      } else
        for (i2 = 0;i2 < msg.length; i2++)
          res[i2] = msg[i2] | 0;
      return res;
    }
    exports.toArray = toArray;
    function toHex(msg) {
      var res = "";
      for (var i2 = 0;i2 < msg.length; i2++)
        res += zero2(msg[i2].toString(16));
      return res;
    }
    exports.toHex = toHex;
    function htonl(w) {
      var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
      return res >>> 0;
    }
    exports.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i2 = 0;i2 < msg.length; i2++) {
        var w = msg[i2];
        if (endian === "little")
          w = htonl(w);
        res += zero8(w.toString(16));
      }
      return res;
    }
    exports.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len2 = end - start;
      assert(len2 % 4 === 0);
      var res = new Array(len2 / 4);
      for (var i2 = 0, k4 = start;i2 < res.length; i2++, k4 += 4) {
        var w;
        if (endian === "big")
          w = msg[k4] << 24 | msg[k4 + 1] << 16 | msg[k4 + 2] << 8 | msg[k4 + 3];
        else
          w = msg[k4 + 3] << 24 | msg[k4 + 2] << 16 | msg[k4 + 1] << 8 | msg[k4];
        res[i2] = w >>> 0;
      }
      return res;
    }
    exports.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i2 = 0, k4 = 0;i2 < msg.length; i2++, k4 += 4) {
        var m2 = msg[i2];
        if (endian === "big")
          res[k4] = m2 >>> 24, res[k4 + 1] = m2 >>> 16 & 255, res[k4 + 2] = m2 >>> 8 & 255, res[k4 + 3] = m2 & 255;
        else
          res[k4 + 3] = m2 >>> 24, res[k4 + 2] = m2 >>> 16 & 255, res[k4 + 1] = m2 >>> 8 & 255, res[k4] = m2 & 255;
      }
      return res;
    }
    exports.split32 = split32;
    function rotr32(w, b) {
      return w >>> b | w << 32 - b;
    }
    exports.rotr32 = rotr32;
    function rotl32(w, b) {
      return w << b | w >>> 32 - b;
    }
    exports.rotl32 = rotl32;
    function sum32(a, b) {
      return a + b >>> 0;
    }
    exports.sum32 = sum32;
    function sum32_3(a, b, c) {
      return a + b + c >>> 0;
    }
    exports.sum32_3 = sum32_3;
    function sum32_4(a, b, c, d3) {
      return a + b + c + d3 >>> 0;
    }
    exports.sum32_4 = sum32_4;
    function sum32_5(a, b, c, d3, e2) {
      return a + b + c + d3 + e2 >>> 0;
    }
    exports.sum32_5 = sum32_5;
    function sum64(buf, pos, ah, al) {
      var bh = buf[pos], bl = buf[pos + 1], lo = al + bl >>> 0, hi2 = (lo < al ? 1 : 0) + ah + bh;
      buf[pos] = hi2 >>> 0, buf[pos + 1] = lo;
    }
    exports.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo = al + bl >>> 0, hi2 = (lo < al ? 1 : 0) + ah + bh;
      return hi2 >>> 0;
    }
    exports.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }
    exports.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0, lo = al;
      lo = lo + bl >>> 0, carry += lo < al ? 1 : 0, lo = lo + cl >>> 0, carry += lo < cl ? 1 : 0, lo = lo + dl >>> 0, carry += lo < dl ? 1 : 0;
      var hi2 = ah + bh + ch + dh + carry;
      return hi2 >>> 0;
    }
    exports.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }
    exports.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0, lo = al;
      lo = lo + bl >>> 0, carry += lo < al ? 1 : 0, lo = lo + cl >>> 0, carry += lo < cl ? 1 : 0, lo = lo + dl >>> 0, carry += lo < dl ? 1 : 0, lo = lo + el >>> 0, carry += lo < el ? 1 : 0;
      var hi2 = ah + bh + ch + dh + eh + carry;
      return hi2 >>> 0;
    }
    exports.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }
    exports.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r = al << 32 - num | ah >>> num;
      return r >>> 0;
    }
    exports.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    exports.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports.shr64_lo = shr64_lo;
  });
  require_common = __commonJS2((exports) => {
    var utils = require_utils3(), assert = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
    }
    exports.BlockHash = BlockHash;
    BlockHash.prototype.update = function update(msg, enc) {
      if (msg = utils.toArray(msg, enc), !this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      if (this.pendingTotal += msg.length, this.pending.length >= this._delta8) {
        msg = this.pending;
        var r = msg.length % this._delta8;
        if (this.pending = msg.slice(msg.length - r, msg.length), this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r, this.endian);
        for (var i2 = 0;i2 < msg.length; i2 += this._delta32)
          this._update(msg, i2, i2 + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest(enc) {
      return this.update(this._pad()), assert(this.pending === null), this._digest(enc);
    };
    BlockHash.prototype._pad = function pad() {
      var len2 = this.pendingTotal, bytes = this._delta8, k4 = bytes - (len2 + this.padLength) % bytes, res = new Array(k4 + this.padLength);
      res[0] = 128;
      for (var i2 = 1;i2 < k4; i2++)
        res[i2] = 0;
      if (len2 <<= 3, this.endian === "big") {
        for (var t2 = 8;t2 < this.padLength; t2++)
          res[i2++] = 0;
        res[i2++] = 0, res[i2++] = 0, res[i2++] = 0, res[i2++] = 0, res[i2++] = len2 >>> 24 & 255, res[i2++] = len2 >>> 16 & 255, res[i2++] = len2 >>> 8 & 255, res[i2++] = len2 & 255;
      } else {
        res[i2++] = len2 & 255, res[i2++] = len2 >>> 8 & 255, res[i2++] = len2 >>> 16 & 255, res[i2++] = len2 >>> 24 & 255, res[i2++] = 0, res[i2++] = 0, res[i2++] = 0, res[i2++] = 0;
        for (t2 = 8;t2 < this.padLength; t2++)
          res[i2++] = 0;
      }
      return res;
    };
  });
  require_common2 = __commonJS2((exports) => {
    var utils = require_utils3(), rotr32 = utils.rotr32;
    function ft_1(s3, x4, y, z2) {
      if (s3 === 0)
        return ch32(x4, y, z2);
      if (s3 === 1 || s3 === 3)
        return p32(x4, y, z2);
      if (s3 === 2)
        return maj32(x4, y, z2);
    }
    exports.ft_1 = ft_1;
    function ch32(x4, y, z2) {
      return x4 & y ^ ~x4 & z2;
    }
    exports.ch32 = ch32;
    function maj32(x4, y, z2) {
      return x4 & y ^ x4 & z2 ^ y & z2;
    }
    exports.maj32 = maj32;
    function p32(x4, y, z2) {
      return x4 ^ y ^ z2;
    }
    exports.p32 = p32;
    function s0_256(x4) {
      return rotr32(x4, 2) ^ rotr32(x4, 13) ^ rotr32(x4, 22);
    }
    exports.s0_256 = s0_256;
    function s1_256(x4) {
      return rotr32(x4, 6) ^ rotr32(x4, 11) ^ rotr32(x4, 25);
    }
    exports.s1_256 = s1_256;
    function g0_256(x4) {
      return rotr32(x4, 7) ^ rotr32(x4, 18) ^ x4 >>> 3;
    }
    exports.g0_256 = g0_256;
    function g1_256(x4) {
      return rotr32(x4, 17) ^ rotr32(x4, 19) ^ x4 >>> 10;
    }
    exports.g1_256 = g1_256;
  });
  require_1 = __commonJS2((exports, module) => {
    var utils = require_utils3(), common = require_common(), shaCommon = require_common2(), rotl32 = utils.rotl32, sum32 = utils.sum32, sum32_5 = utils.sum32_5, ft_1 = shaCommon.ft_1, BlockHash = common.BlockHash, sha1_K = [1518500249, 1859775393, 2400959708, 3395469782];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1;
      BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
    }
    utils.inherits(SHA1, BlockHash);
    module.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W3 = this.W;
      for (var i2 = 0;i2 < 16; i2++)
        W3[i2] = msg[start + i2];
      for (;i2 < W3.length; i2++)
        W3[i2] = rotl32(W3[i2 - 3] ^ W3[i2 - 8] ^ W3[i2 - 14] ^ W3[i2 - 16], 1);
      var a = this.h[0], b = this.h[1], c = this.h[2], d3 = this.h[3], e2 = this.h[4];
      for (i2 = 0;i2 < W3.length; i2++) {
        var s3 = ~~(i2 / 20), t2 = sum32_5(rotl32(a, 5), ft_1(s3, b, c, d3), e2, W3[i2], sha1_K[s3]);
        e2 = d3, d3 = c, c = rotl32(b, 30), b = a, a = t2;
      }
      this.h[0] = sum32(this.h[0], a), this.h[1] = sum32(this.h[1], b), this.h[2] = sum32(this.h[2], c), this.h[3] = sum32(this.h[3], d3), this.h[4] = sum32(this.h[4], e2);
    };
    SHA1.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  });
  require_256 = __commonJS2((exports, module) => {
    var utils = require_utils3(), common = require_common(), shaCommon = require_common2(), assert = require_minimalistic_assert(), sum32 = utils.sum32, sum32_4 = utils.sum32_4, sum32_5 = utils.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash = common.BlockHash, sha256_K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256;
      BlockHash.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = sha256_K, this.W = new Array(64);
    }
    utils.inherits(SHA256, BlockHash);
    module.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = function _update(msg, start) {
      var W3 = this.W;
      for (var i2 = 0;i2 < 16; i2++)
        W3[i2] = msg[start + i2];
      for (;i2 < W3.length; i2++)
        W3[i2] = sum32_4(g1_256(W3[i2 - 2]), W3[i2 - 7], g0_256(W3[i2 - 15]), W3[i2 - 16]);
      var a = this.h[0], b = this.h[1], c = this.h[2], d3 = this.h[3], e2 = this.h[4], f2 = this.h[5], g2 = this.h[6], h = this.h[7];
      assert(this.k.length === W3.length);
      for (i2 = 0;i2 < W3.length; i2++) {
        var T1 = sum32_5(h, s1_256(e2), ch32(e2, f2, g2), this.k[i2], W3[i2]), T2 = sum32(s0_256(a), maj32(a, b, c));
        h = g2, g2 = f2, f2 = e2, e2 = sum32(d3, T1), d3 = c, c = b, b = a, a = sum32(T1, T2);
      }
      this.h[0] = sum32(this.h[0], a), this.h[1] = sum32(this.h[1], b), this.h[2] = sum32(this.h[2], c), this.h[3] = sum32(this.h[3], d3), this.h[4] = sum32(this.h[4], e2), this.h[5] = sum32(this.h[5], f2), this.h[6] = sum32(this.h[6], g2), this.h[7] = sum32(this.h[7], h);
    };
    SHA256.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  });
  require_224 = __commonJS2((exports, module) => {
    var utils = require_utils3(), SHA256 = require_256();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224;
      SHA256.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
    }
    utils.inherits(SHA224, SHA256);
    module.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    };
  });
  require_512 = __commonJS2((exports, module) => {
    var utils = require_utils3(), common = require_common(), assert = require_minimalistic_assert(), rotr64_hi = utils.rotr64_hi, rotr64_lo = utils.rotr64_lo, shr64_hi = utils.shr64_hi, shr64_lo = utils.shr64_lo, sum64 = utils.sum64, sum64_hi = utils.sum64_hi, sum64_lo = utils.sum64_lo, sum64_4_hi = utils.sum64_4_hi, sum64_4_lo = utils.sum64_4_lo, sum64_5_hi = utils.sum64_5_hi, sum64_5_lo = utils.sum64_5_lo, BlockHash = common.BlockHash, sha512_K = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512;
      BlockHash.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = sha512_K, this.W = new Array(160);
    }
    utils.inherits(SHA512, BlockHash);
    module.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W3 = this.W;
      for (var i2 = 0;i2 < 32; i2++)
        W3[i2] = msg[start + i2];
      for (;i2 < W3.length; i2 += 2) {
        var c0_hi = g1_512_hi(W3[i2 - 4], W3[i2 - 3]), c0_lo = g1_512_lo(W3[i2 - 4], W3[i2 - 3]), c1_hi = W3[i2 - 14], c1_lo = W3[i2 - 13], c2_hi = g0_512_hi(W3[i2 - 30], W3[i2 - 29]), c2_lo = g0_512_lo(W3[i2 - 30], W3[i2 - 29]), c3_hi = W3[i2 - 32], c3_lo = W3[i2 - 31];
        W3[i2] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo), W3[i2 + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
      }
    };
    SHA512.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W3 = this.W, ah = this.h[0], al = this.h[1], bh = this.h[2], bl = this.h[3], ch = this.h[4], cl = this.h[5], dh = this.h[6], dl = this.h[7], eh = this.h[8], el = this.h[9], fh = this.h[10], fl = this.h[11], gh = this.h[12], gl = this.h[13], hh = this.h[14], hl = this.h[15];
      assert(this.k.length === W3.length);
      for (var i2 = 0;i2 < W3.length; i2 += 2) {
        var c0_hi = hh, c0_lo = hl, c1_hi = s1_512_hi(eh, el), c1_lo = s1_512_lo(eh, el), c2_hi = ch64_hi(eh, el, fh, fl, gh, gl), c2_lo = ch64_lo(eh, el, fh, fl, gh, gl), c3_hi = this.k[i2], c3_lo = this.k[i2 + 1], c4_hi = W3[i2], c4_lo = W3[i2 + 1], T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo), T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        c0_hi = s0_512_hi(ah, al), c0_lo = s0_512_lo(ah, al), c1_hi = maj64_hi(ah, al, bh, bl, ch, cl), c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo), T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh, hl = gl, gh = fh, gl = fl, fh = eh, fl = el, eh = sum64_hi(dh, dl, T1_hi, T1_lo), el = sum64_lo(dl, dl, T1_hi, T1_lo), dh = ch, dl = cl, ch = bh, cl = bl, bh = ah, bl = al, ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo), al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al), sum64(this.h, 2, bh, bl), sum64(this.h, 4, ch, cl), sum64(this.h, 6, dh, dl), sum64(this.h, 8, eh, el), sum64(this.h, 10, fh, fl), sum64(this.h, 12, gh, gl), sum64(this.h, 14, hh, hl);
    };
    SHA512.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ ~xh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ ~xl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ xh & zh ^ yh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ xl & zl ^ yl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28), c1_hi = rotr64_hi(xl, xh, 2), c2_hi = rotr64_hi(xl, xh, 7), r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28), c1_lo = rotr64_lo(xl, xh, 2), c2_lo = rotr64_lo(xl, xh, 7), r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14), c1_hi = rotr64_hi(xh, xl, 18), c2_hi = rotr64_hi(xl, xh, 9), r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14), c1_lo = rotr64_lo(xh, xl, 18), c2_lo = rotr64_lo(xl, xh, 9), r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1), c1_hi = rotr64_hi(xh, xl, 8), c2_hi = shr64_hi(xh, xl, 7), r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1), c1_lo = rotr64_lo(xh, xl, 8), c2_lo = shr64_lo(xh, xl, 7), r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19), c1_hi = rotr64_hi(xl, xh, 29), c2_hi = shr64_hi(xh, xl, 6), r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19), c1_lo = rotr64_lo(xl, xh, 29), c2_lo = shr64_lo(xh, xl, 6), r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
  });
  require_384 = __commonJS2((exports, module) => {
    var utils = require_utils3(), SHA512 = require_512();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384;
      SHA512.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
    }
    utils.inherits(SHA384, SHA512);
    module.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    };
  });
  require_sha = __commonJS2((exports) => {
    exports.sha1 = require_1();
    exports.sha224 = require_224();
    exports.sha256 = require_256();
    exports.sha384 = require_384();
    exports.sha512 = require_512();
  });
  require_ripemd = __commonJS2((exports) => {
    var utils = require_utils3(), common = require_common(), rotl32 = utils.rotl32, sum32 = utils.sum32, sum32_3 = utils.sum32_3, sum32_4 = utils.sum32_4, BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160;
      BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
    }
    utils.inherits(RIPEMD160, BlockHash);
    exports.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update(msg, start) {
      var A3 = this.h[0], B3 = this.h[1], C2 = this.h[2], D2 = this.h[3], E4 = this.h[4], Ah = A3, Bh = B3, Ch = C2, Dh = D2, Eh = E4;
      for (var j3 = 0;j3 < 80; j3++) {
        var T2 = sum32(rotl32(sum32_4(A3, f2(j3, B3, C2, D2), msg[r[j3] + start], K4(j3)), s3[j3]), E4);
        A3 = E4, E4 = D2, D2 = rotl32(C2, 10), C2 = B3, B3 = T2, T2 = sum32(rotl32(sum32_4(Ah, f2(79 - j3, Bh, Ch, Dh), msg[rh[j3] + start], Kh(j3)), sh[j3]), Eh), Ah = Eh, Eh = Dh, Dh = rotl32(Ch, 10), Ch = Bh, Bh = T2;
      }
      T2 = sum32_3(this.h[1], C2, Dh), this.h[1] = sum32_3(this.h[2], D2, Eh), this.h[2] = sum32_3(this.h[3], E4, Ah), this.h[3] = sum32_3(this.h[4], A3, Bh), this.h[4] = sum32_3(this.h[0], B3, Ch), this.h[0] = T2;
    };
    RIPEMD160.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    };
    function f2(j3, x4, y, z2) {
      if (j3 <= 15)
        return x4 ^ y ^ z2;
      else if (j3 <= 31)
        return x4 & y | ~x4 & z2;
      else if (j3 <= 47)
        return (x4 | ~y) ^ z2;
      else if (j3 <= 63)
        return x4 & z2 | y & ~z2;
      else
        return x4 ^ (y | ~z2);
    }
    function K4(j3) {
      if (j3 <= 15)
        return 0;
      else if (j3 <= 31)
        return 1518500249;
      else if (j3 <= 47)
        return 1859775393;
      else if (j3 <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh(j3) {
      if (j3 <= 15)
        return 1352829926;
      else if (j3 <= 31)
        return 1548603684;
      else if (j3 <= 47)
        return 1836072691;
      else if (j3 <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], rh = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], s3 = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], sh = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
  });
  require_hmac = __commonJS2((exports, module) => {
    var utils = require_utils3(), assert = require_minimalistic_assert();
    function Hmac(hash, key, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash, key, enc);
      this.Hash = hash, this.blockSize = hash.blockSize / 8, this.outSize = hash.outSize / 8, this.inner = null, this.outer = null, this._init(utils.toArray(key, enc));
    }
    module.exports = Hmac;
    Hmac.prototype._init = function init(key) {
      if (key.length > this.blockSize)
        key = new this.Hash().update(key).digest();
      assert(key.length <= this.blockSize);
      for (var i2 = key.length;i2 < this.blockSize; i2++)
        key.push(0);
      for (i2 = 0;i2 < key.length; i2++)
        key[i2] ^= 54;
      this.inner = new this.Hash().update(key);
      for (i2 = 0;i2 < key.length; i2++)
        key[i2] ^= 106;
      this.outer = new this.Hash().update(key);
    };
    Hmac.prototype.update = function update(msg, enc) {
      return this.inner.update(msg, enc), this;
    };
    Hmac.prototype.digest = function digest(enc) {
      return this.outer.update(this.inner.digest()), this.outer.digest(enc);
    };
  });
  require_hash = __commonJS2((exports) => {
    var hash = exports;
    hash.utils = require_utils3();
    hash.common = require_common();
    hash.sha = require_sha();
    hash.ripemd = require_ripemd();
    hash.hmac = require_hmac();
    hash.sha1 = hash.sha.sha1;
    hash.sha256 = hash.sha.sha256;
    hash.sha224 = hash.sha.sha224;
    hash.sha384 = hash.sha.sha384;
    hash.sha512 = hash.sha.sha512;
    hash.ripemd160 = hash.ripemd.ripemd160;
  });
  require_secp256k1 = __commonJS2((exports, module) => {
    module.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
  });
  require_curves = __commonJS2((exports) => {
    var curves = exports, hash = require_hash(), curve = require_curve(), utils = require_utils2(), assert = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g, this.n = this.curve.n, this.hash = options.hash, assert(this.g.validate(), "Invalid curve"), assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
      Object.defineProperty(curves, name, { configurable: true, enumerable: true, get: function() {
        var curve2 = new PresetCurve(options);
        return Object.defineProperty(curves, name, { configurable: true, enumerable: true, value: curve2 }), curve2;
      } });
    }
    defineCurve("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: hash.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] });
    defineCurve("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: hash.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] });
    defineCurve("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: hash.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] });
    defineCurve("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: hash.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] });
    defineCurve("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: hash.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] });
    defineCurve("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: hash.sha256, gRed: false, g: ["9"] });
    defineCurve("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: hash.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e2) {
      pre = undefined;
    }
    defineCurve("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: hash.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", pre] });
  });
  require_hmac_drbg = __commonJS2((exports, module) => {
    var hash = require_hash(), utils = require_utils(), assert = require_minimalistic_assert();
    function HmacDRBG(options) {
      if (!(this instanceof HmacDRBG))
        return new HmacDRBG(options);
      this.hash = options.hash, this.predResist = !!options.predResist, this.outLen = this.hash.outSize, this.minEntropy = options.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
      var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex"), nonce = utils.toArray(options.nonce, options.nonceEnc || "hex"), pers = utils.toArray(options.pers, options.persEnc || "hex");
      assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(entropy, nonce, pers);
    }
    module.exports = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
      for (var i2 = 0;i2 < this.V.length; i2++)
        this.K[i2] = 0, this.V[i2] = 1;
      this._update(seed), this._reseed = 1, this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac() {
      return new hash.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      if (this.K = kmac.digest(), this.V = this._hmac().update(this.V).digest(), !seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest(), this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
      if (typeof entropyEnc !== "string")
        addEnc = add, add = entropyEnc, entropyEnc = null;
      entropy = utils.toArray(entropy, entropyEnc), add = utils.toArray(add, addEnc), assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(entropy.concat(add || [])), this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate(len2, enc, add, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string")
        addEnc = add, add = enc, enc = null;
      if (add)
        add = utils.toArray(add, addEnc || "hex"), this._update(add);
      var temp = [];
      while (temp.length < len2)
        this.V = this._hmac().update(this.V).digest(), temp = temp.concat(this.V);
      var res = temp.slice(0, len2);
      return this._update(add), this._reseed++, utils.encode(res, enc);
    };
  });
  require_key = __commonJS2((exports, module) => {
    var BN = require_bn(), utils = require_utils2(), assert = utils.assert;
    function KeyPair(ec, options) {
      if (this.ec = ec, this.priv = null, this.pub = null, options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec, { pub, pubEnc: enc });
    };
    KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec, { priv, privEnc: enc });
    };
    KeyPair.prototype.validate = function validate() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string")
        enc = compact, compact = null;
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN(key, enc || 16), this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont")
          assert(key.x, "Need x coordinate");
        else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards")
          assert(key.x && key.y, "Need both x and y coordinate");
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate())
        assert(pub.validate(), "public point not validated");
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify(msg, signature, options) {
      return this.ec.verify(msg, signature, this, undefined, options);
    };
    KeyPair.prototype.inspect = function inspect() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  });
  require_signature = __commonJS2((exports, module) => {
    var BN = require_bn(), utils = require_utils2(), assert = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      if (assert(options.r && options.s, "Signature without r or s"), this.r = new BN(options.r, 16), this.s = new BN(options.s, 16), options.recoveryParam === undefined)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p2) {
      var initial = buf[p2.place++];
      if (!(initial & 128))
        return initial;
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4)
        return false;
      if (buf[p2.place] === 0)
        return false;
      var val = 0;
      for (var i2 = 0, off = p2.place;i2 < octetLen; i2++, off++)
        val <<= 8, val |= buf[off], val >>>= 0;
      if (val <= 127)
        return false;
      return p2.place = off, val;
    }
    function rmPadding(buf) {
      var i2 = 0, len2 = buf.length - 1;
      while (!buf[i2] && !(buf[i2 + 1] & 128) && i2 < len2)
        i2++;
      if (i2 === 0)
        return buf;
      return buf.slice(i2);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils.toArray(data, enc);
      var p2 = new Position;
      if (data[p2.place++] !== 48)
        return false;
      var len2 = getLength(data, p2);
      if (len2 === false)
        return false;
      if (len2 + p2.place !== data.length)
        return false;
      if (data[p2.place++] !== 2)
        return false;
      var rlen = getLength(data, p2);
      if (rlen === false)
        return false;
      if ((data[p2.place] & 128) !== 0)
        return false;
      var r = data.slice(p2.place, rlen + p2.place);
      if (p2.place += rlen, data[p2.place++] !== 2)
        return false;
      var slen = getLength(data, p2);
      if (slen === false)
        return false;
      if (data.length !== slen + p2.place)
        return false;
      if ((data[p2.place] & 128) !== 0)
        return false;
      var s3 = data.slice(p2.place, slen + p2.place);
      if (r[0] === 0)
        if (r[1] & 128)
          r = r.slice(1);
        else
          return false;
      if (s3[0] === 0)
        if (s3[1] & 128)
          s3 = s3.slice(1);
        else
          return false;
      return this.r = new BN(r), this.s = new BN(s3), this.recoveryParam = null, true;
    };
    function constructLength(arr, len2) {
      if (len2 < 128) {
        arr.push(len2);
        return;
      }
      var octets = 1 + (Math.log(len2) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets)
        arr.push(len2 >>> (octets << 3) & 255);
      arr.push(len2);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r = this.r.toArray(), s3 = this.s.toArray();
      if (r[0] & 128)
        r = [0].concat(r);
      if (s3[0] & 128)
        s3 = [0].concat(s3);
      r = rmPadding(r), s3 = rmPadding(s3);
      while (!s3[0] && !(s3[1] & 128))
        s3 = s3.slice(1);
      var arr = [2];
      constructLength(arr, r.length), arr = arr.concat(r), arr.push(2), constructLength(arr, s3.length);
      var backHalf = arr.concat(s3), res = [48];
      return constructLength(res, backHalf.length), res = res.concat(backHalf), utils.encode(res, enc);
    };
  });
  require_ec = __commonJS2((exports, module) => {
    var BN = require_bn(), HmacDRBG = require_hmac_drbg(), utils = require_utils2(), curves = require_curves(), rand = require_brorand(), assert = utils.assert, KeyPair = require_key(), Signature = require_signature();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string")
        assert(Object.prototype.hasOwnProperty.call(curves, options), "Unknown curve " + options), options = curves[options];
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = options.curve.g, this.g.precompute(options.curve.n.bitLength() + 1), this.hash = options.hash || options.curve.hash;
    }
    module.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({ hash: this.hash, pers: options.pers, persEnc: options.persEnc || "utf8", entropy: options.entropy || rand(this.hash.hmacStrength), entropyEnc: options.entropy && options.entropyEnc || "utf8", nonce: this.n.toArray() }), bytes = this.n.byteLength(), ns2 = this.n.sub(new BN(2));
      for (;; ) {
        var priv = new BN(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        return priv.iaddn(1), this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly, bitLength) {
      var byteLength2;
      if (BN.isBN(msg) || typeof msg === "number")
        msg = new BN(msg, 16), byteLength2 = msg.byteLength();
      else if (typeof msg === "object")
        byteLength2 = msg.length, msg = new BN(msg, 16);
      else {
        var str = msg.toString();
        byteLength2 = str.length + 1 >>> 1, msg = new BN(str, 16);
      }
      if (typeof bitLength !== "number")
        bitLength = byteLength2 * 8;
      var delta = bitLength - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign(msg, key, enc, options) {
      if (typeof enc === "object")
        options = enc, enc = null;
      if (!options)
        options = {};
      if (typeof msg !== "string" && typeof msg !== "number" && !BN.isBN(msg)) {
        assert(typeof msg === "object" && msg && typeof msg.length === "number", "Expected message to be an array-like, a hex string, or a BN instance"), assert(msg.length >>> 0 === msg.length);
        for (var i2 = 0;i2 < msg.length; i2++)
          assert((msg[i2] & 255) === msg[i2]);
      }
      key = this.keyFromPrivate(key, enc), msg = this._truncateToN(msg, false, options.msgBitLength), assert(!msg.isNeg(), "Can not sign a negative message");
      var bytes = this.n.byteLength(), bkey = key.getPrivate().toArray("be", bytes), nonce = msg.toArray("be", bytes);
      assert(new BN(nonce).eq(msg), "Can not sign message");
      var drbg = new HmacDRBG({ hash: this.hash, entropy: bkey, nonce, pers: options.pers, persEnc: options.persEnc || "utf8" }), ns1 = this.n.sub(new BN(1));
      for (var iter = 0;; iter++) {
        var k4 = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        if (k4 = this._truncateToN(k4, true), k4.cmpn(1) <= 0 || k4.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k4);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX(), r = kpX.umod(this.n);
        if (r.cmpn(0) === 0)
          continue;
        var s3 = k4.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
        if (s3 = s3.umod(this.n), s3.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
        if (options.canonical && s3.cmp(this.nh) > 0)
          s3 = this.n.sub(s3), recoveryParam ^= 1;
        return new Signature({ r, s: s3, recoveryParam });
      }
    };
    EC.prototype.verify = function verify(msg, signature, key, enc, options) {
      if (!options)
        options = {};
      msg = this._truncateToN(msg, false, options.msgBitLength), key = this.keyFromPublic(key, enc), signature = new Signature(signature, "hex");
      var { r, s: s3 } = signature;
      if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
        return false;
      if (s3.cmpn(1) < 0 || s3.cmp(this.n) >= 0)
        return false;
      var sinv = s3.invm(this.n), u1 = sinv.mul(msg).umod(this.n), u2 = sinv.mul(r).umod(this.n), p2;
      if (!this.curve._maxwellTrick) {
        if (p2 = this.g.mulAdd(u1, key.getPublic(), u2), p2.isInfinity())
          return false;
        return p2.getX().umod(this.n).cmp(r) === 0;
      }
      if (p2 = this.g.jmulAdd(u1, key.getPublic(), u2), p2.isInfinity())
        return false;
      return p2.eqXToP(r);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j3, enc) {
      assert((3 & j3) === j3, "The recovery param is more than two bits"), signature = new Signature(signature, enc);
      var n = this.n, e2 = new BN(msg), r = signature.r, s3 = signature.s, isYOdd = j3 & 1, isSecondKey = j3 >> 1;
      if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
      else
        r = this.curve.pointFromX(r, isYOdd);
      var rInv = signature.r.invm(n), s1 = n.sub(e2).mul(rInv).umod(n), s22 = s3.mul(rInv).umod(n);
      return this.g.mulAdd(s1, r, s22);
    };
    EC.prototype.getKeyRecoveryParam = function(e2, signature, Q4, enc) {
      if (signature = new Signature(signature, enc), signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i2 = 0;i2 < 4; i2++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e2, signature, i2);
        } catch (e22) {
          continue;
        }
        if (Qprime.eq(Q4))
          return i2;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  });
  require_key2 = __commonJS2((exports, module) => {
    var utils = require_utils2(), assert = utils.assert, parseBytes = utils.parseBytes, cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
      if (this.eddsa = eddsa, this._secret = parseBytes(params.secret), eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa, hash = this.hash(), lastIx = eddsa.encodingLength - 1, a = hash.slice(0, eddsa.encodingLength);
      return a[0] &= 248, a[lastIx] &= 127, a[lastIx] |= 64, a;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign(message) {
      return assert(this._secret, "KeyPair can only verify"), this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      return assert(this._secret, "KeyPair is public only"), utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module.exports = KeyPair;
  });
  require_signature2 = __commonJS2((exports, module) => {
    var BN = require_bn(), utils = require_utils2(), assert = utils.assert, cachedProperty = utils.cachedProperty, parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
      if (this.eddsa = eddsa, typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig))
        assert(sig.length === eddsa.encodingLength * 2, "Signature has invalid size"), sig = { R: sig.slice(0, eddsa.encodingLength), S: sig.slice(eddsa.encodingLength) };
      if (assert(sig.R && sig.S, "Signature without R or S"), eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded, this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module.exports = Signature;
  });
  require_eddsa = __commonJS2((exports, module) => {
    var hash = require_hash(), curves = require_curves(), utils = require_utils2(), assert = utils.assert, parseBytes = utils.parseBytes, KeyPair = require_key2(), Signature = require_signature2();
    function EDDSA(curve) {
      if (assert(curve === "ed25519", "only tested with ed25519 so far"), !(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve, this.curve = curve, this.g = curve.g, this.g.precompute(curve.n.bitLength() + 1), this.pointClass = curve.point().constructor, this.encodingLength = Math.ceil(curve.n.bitLength() / 8), this.hash = hash.sha512;
    }
    module.exports = EDDSA;
    EDDSA.prototype.sign = function sign(message, secret) {
      message = parseBytes(message);
      var key = this.keyFromSecret(secret), r = this.hashInt(key.messagePrefix(), message), R3 = this.g.mul(r), Rencoded = this.encodePoint(R3), s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv()), S2 = r.add(s_).umod(this.curve.n);
      return this.makeSignature({ R: R3, S: S2, Rencoded });
    };
    EDDSA.prototype.verify = function verify(message, sig, pub) {
      if (message = parseBytes(message), sig = this.makeSignature(sig), sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg())
        return false;
      var key = this.keyFromPublic(pub), h = this.hashInt(sig.Rencoded(), key.pubBytes(), message), SG = this.g.mul(sig.S()), RplusAh = sig.R().add(key.pub().mul(h));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash2 = this.hash();
      for (var i2 = 0;i2 < arguments.length; i2++)
        hash2.update(arguments[i2]);
      return utils.intFromLE(hash2.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      return enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0, enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
      bytes = utils.parseBytes(bytes);
      var lastIx = bytes.length - 1, normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & -129), xIsOdd = (bytes[lastIx] & 128) !== 0, y = utils.intFromLE(normed);
      return this.curve.pointFromY(y, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  });
  require_elliptic = __commonJS2((exports) => {
    var elliptic = exports;
    elliptic.version = require_package().version;
    elliptic.utils = require_utils2();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  });
  require_bn2 = __commonJS2((exports, module) => {
    (function(module2, exports2) {
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number))
          return number;
        if (this.negative = 0, this.words = null, this.length = 0, this.red = null, number !== null) {
          if (base === "le" || base === "be")
            endian = base, base = 10;
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object")
        module2.exports = BN;
      else
        exports2.BN = BN;
      BN.BN = BN, BN.wordSize = 26;
      var Buffer22;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined")
          Buffer22 = window.Buffer;
        else
          Buffer22 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer;
      } catch (e2) {}
      BN.isBN = function isBN(num) {
        if (num instanceof BN)
          return true;
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      }, BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      }, BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      }, BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number")
          return this._initNumber(number, base, endian);
        if (typeof number === "object")
          return this._initArray(number, base, endian);
        if (base === "hex")
          base = 16;
        assert(base === (base | 0) && base >= 2 && base <= 36), number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-")
          start++, this.negative = 1;
        if (start < number.length) {
          if (base === 16)
            this._parseHex(number, start, endian);
          else if (this._parseBase(number, base, start), endian === "le")
            this._initArray(this.toArray(), base, endian);
        }
      }, BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0)
          this.negative = 1, number = -number;
        if (number < 67108864)
          this.words = [number & 67108863], this.length = 1;
        else if (number < 4503599627370496)
          this.words = [number & 67108863, number / 67108864 & 67108863], this.length = 2;
        else
          assert(number < 9007199254740992), this.words = [number & 67108863, number / 67108864 & 67108863, 1], this.length = 3;
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      }, BN.prototype._initArray = function _initArray(number, base, endian) {
        if (assert(typeof number.length === "number"), number.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(number.length / 3), this.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          this.words[i2] = 0;
        var j3, w, off = 0;
        if (endian === "be") {
          for (i2 = number.length - 1, j3 = 0;i2 >= 0; i2 -= 3)
            if (w = number[i2] | number[i2 - 1] << 8 | number[i2 - 2] << 16, this.words[j3] |= w << off & 67108863, this.words[j3 + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
              off -= 26, j3++;
        } else if (endian === "le") {
          for (i2 = 0, j3 = 0;i2 < number.length; i2 += 3)
            if (w = number[i2] | number[i2 + 1] << 8 | number[i2 + 2] << 16, this.words[j3] |= w << off & 67108863, this.words[j3 + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
              off -= 26, j3++;
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 65 && c <= 70)
          return c - 55;
        else if (c >= 97 && c <= 102)
          return c - 87;
        else
          return c - 48 & 15;
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound)
          r |= parseHex4Bits(string, index - 1) << 4;
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6), this.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          this.words[i2] = 0;
        var off = 0, j3 = 0, w;
        if (endian === "be")
          for (i2 = number.length - 1;i2 >= start; i2 -= 2)
            if (w = parseHexByte(number, start, i2) << off, this.words[j3] |= w & 67108863, off >= 18)
              off -= 18, j3 += 1, this.words[j3] |= w >>> 26;
            else
              off += 8;
        else {
          var parseLength = number.length - start;
          for (i2 = parseLength % 2 === 0 ? start + 1 : start;i2 < number.length; i2 += 2)
            if (w = parseHexByte(number, start, i2) << off, this.words[j3] |= w & 67108863, off >= 18)
              off -= 18, j3 += 1, this.words[j3] |= w >>> 26;
            else
              off += 8;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0, len2 = Math.min(str.length, end);
        for (var i2 = start;i2 < len2; i2++) {
          var c = str.charCodeAt(i2) - 48;
          if (r *= mul, c >= 49)
            r += c - 49 + 10;
          else if (c >= 17)
            r += c - 17 + 10;
          else
            r += c;
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0], this.length = 1;
        for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base)
          limbLen++;
        limbLen--, limbPow = limbPow / base | 0;
        var total = number.length - start, mod = total % limbLen, end = Math.min(total, total - mod) + start, word = 0;
        for (var i2 = start;i2 < end; i2 += limbLen)
          if (word = parseBase(number, i2, i2 + limbLen, base), this.imuln(limbPow), this.words[0] + word < 67108864)
            this.words[0] += word;
          else
            this._iaddn(word);
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i2, number.length, base);
          for (i2 = 0;i2 < mod; i2++)
            pow *= base;
          if (this.imuln(pow), this.words[0] + word < 67108864)
            this.words[0] += word;
          else
            this._iaddn(word);
        }
        this.strip();
      }, BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          dest.words[i2] = this.words[i2];
        dest.length = this.length, dest.negative = this.negative, dest.red = this.red;
      }, BN.prototype.clone = function clone() {
        var r = new BN(null);
        return this.copy(r), r;
      }, BN.prototype._expand = function _expand(size) {
        while (this.length < size)
          this.words[this.length++] = 0;
        return this;
      }, BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0)
          this.length--;
        return this._normSign();
      }, BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0)
          this.negative = 0;
        return this;
      }, BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      if (BN.prototype.toString = function toString(base, padding) {
        base = base || 10, padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0, carry = 0;
          for (var i2 = 0;i2 < this.length; i2++) {
            var w = this.words[i2], word = ((w << off | carry) & 16777215).toString(16);
            if (carry = w >>> 24 - off & 16777215, off += 2, off >= 26)
              off -= 26, i2--;
            if (carry !== 0 || i2 !== this.length - 1)
              out = zeros[6 - word.length] + word + out;
            else
              out = word + out;
          }
          if (carry !== 0)
            out = carry.toString(16) + out;
          while (out.length % padding !== 0)
            out = "0" + out;
          if (this.negative !== 0)
            out = "-" + out;
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base], groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            if (c = c.idivn(groupBase), !c.isZero())
              out = zeros[groupSize - r.length] + r + out;
            else
              out = r + out;
          }
          if (this.isZero())
            out = "0" + out;
          while (out.length % padding !== 0)
            out = "0" + out;
          if (this.negative !== 0)
            out = "-" + out;
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      }, BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2)
          ret += this.words[1] * 67108864;
        else if (this.length === 3 && this.words[2] === 1)
          ret += 4503599627370496 + this.words[1] * 67108864;
        else if (this.length > 2)
          assert(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -ret : ret;
      }, BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      }, BN.prototype.toBuffer = function toBuffer(endian, length) {
        return assert(typeof Buffer22 !== "undefined"), this.toArrayLike(Buffer22, endian, length);
      }, BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      }, BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength2 = this.byteLength(), reqLength = length || Math.max(1, byteLength2);
        assert(byteLength2 <= reqLength, "byte array longer than desired length"), assert(reqLength > 0, "Requested array length <= 0"), this.strip();
        var littleEndian = endian === "le", res = new ArrayType(reqLength), b, i2, q3 = this.clone();
        if (!littleEndian) {
          for (i2 = 0;i2 < reqLength - byteLength2; i2++)
            res[i2] = 0;
          for (i2 = 0;!q3.isZero(); i2++)
            b = q3.andln(255), q3.iushrn(8), res[reqLength - i2 - 1] = b;
        } else {
          for (i2 = 0;!q3.isZero(); i2++)
            b = q3.andln(255), q3.iushrn(8), res[i2] = b;
          for (;i2 < reqLength; i2++)
            res[i2] = 0;
        }
        return res;
      }, Math.clz32)
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      else
        BN.prototype._countBits = function _countBits(w) {
          var t2 = w, r = 0;
          if (t2 >= 4096)
            r += 13, t2 >>>= 13;
          if (t2 >= 64)
            r += 7, t2 >>>= 7;
          if (t2 >= 8)
            r += 4, t2 >>>= 4;
          if (t2 >= 2)
            r += 2, t2 >>>= 2;
          return r + t2;
        };
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t2 = w, r = 0;
        if ((t2 & 8191) === 0)
          r += 13, t2 >>>= 13;
        if ((t2 & 127) === 0)
          r += 7, t2 >>>= 7;
        if ((t2 & 15) === 0)
          r += 4, t2 >>>= 4;
        if ((t2 & 3) === 0)
          r += 2, t2 >>>= 2;
        if ((t2 & 1) === 0)
          r++;
        return r;
      }, BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1], hi2 = this._countBits(w);
        return (this.length - 1) * 26 + hi2;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0;bit < w.length; bit++) {
          var off = bit / 26 | 0, wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i2 = 0;i2 < this.length; i2++) {
          var b = this._zeroBits(this.words[i2]);
          if (r += b, b !== 26)
            break;
        }
        return r;
      }, BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      }, BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0)
          return this.abs().inotn(width).iaddn(1);
        return this.clone();
      }, BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1))
          return this.notn(width).iaddn(1).ineg();
        return this.clone();
      }, BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      }, BN.prototype.neg = function neg() {
        return this.clone().ineg();
      }, BN.prototype.ineg = function ineg() {
        if (!this.isZero())
          this.negative ^= 1;
        return this;
      }, BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length)
          this.words[this.length++] = 0;
        for (var i2 = 0;i2 < num.length; i2++)
          this.words[i2] = this.words[i2] | num.words[i2];
        return this.strip();
      }, BN.prototype.ior = function ior(num) {
        return assert((this.negative | num.negative) === 0), this.iuor(num);
      }, BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      }, BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      }, BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length)
          b = num;
        else
          b = this;
        for (var i2 = 0;i2 < b.length; i2++)
          this.words[i2] = this.words[i2] & num.words[i2];
        return this.length = b.length, this.strip();
      }, BN.prototype.iand = function iand(num) {
        return assert((this.negative | num.negative) === 0), this.iuand(num);
      }, BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      }, BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      }, BN.prototype.iuxor = function iuxor(num) {
        var a, b;
        if (this.length > num.length)
          a = this, b = num;
        else
          a = num, b = this;
        for (var i2 = 0;i2 < b.length; i2++)
          this.words[i2] = a.words[i2] ^ b.words[i2];
        if (this !== a)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        return this.length = a.length, this.strip();
      }, BN.prototype.ixor = function ixor(num) {
        return assert((this.negative | num.negative) === 0), this.iuxor(num);
      }, BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      }, BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      }, BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0, bitsLeft = width % 26;
        if (this._expand(bytesNeeded), bitsLeft > 0)
          bytesNeeded--;
        for (var i2 = 0;i2 < bytesNeeded; i2++)
          this.words[i2] = ~this.words[i2] & 67108863;
        if (bitsLeft > 0)
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        return this.strip();
      }, BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      }, BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0, wbit = bit % 26;
        if (this._expand(off + 1), val)
          this.words[off] = this.words[off] | 1 << wbit;
        else
          this.words[off] = this.words[off] & ~(1 << wbit);
        return this.strip();
      }, BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0)
          return this.negative = 0, r = this.isub(num), this.negative ^= 1, this._normSign();
        else if (this.negative === 0 && num.negative !== 0)
          return num.negative = 0, r = this.isub(num), num.negative = 1, r._normSign();
        var a, b;
        if (this.length > num.length)
          a = this, b = num;
        else
          a = num, b = this;
        var carry = 0;
        for (var i2 = 0;i2 < b.length; i2++)
          r = (a.words[i2] | 0) + (b.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
        for (;carry !== 0 && i2 < a.length; i2++)
          r = (a.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
        if (this.length = a.length, carry !== 0)
          this.words[this.length] = carry, this.length++;
        else if (a !== this)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        return this;
      }, BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0)
          return num.negative = 0, res = this.sub(num), num.negative ^= 1, res;
        else if (num.negative === 0 && this.negative !== 0)
          return this.negative = 0, res = num.sub(this), this.negative = 1, res;
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      }, BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          return num.negative = 1, r._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(num), this.negative = 1, this._normSign();
        var cmp = this.cmp(num);
        if (cmp === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var a, b;
        if (cmp > 0)
          a = this, b = num;
        else
          a = num, b = this;
        var carry = 0;
        for (var i2 = 0;i2 < b.length; i2++)
          r = (a.words[i2] | 0) - (b.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
        for (;carry !== 0 && i2 < a.length; i2++)
          r = (a.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
        if (carry === 0 && i2 < a.length && a !== this)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        if (this.length = Math.max(this.length, i2), a !== this)
          this.negative = 1;
        return this.strip();
      }, BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len2 = self2.length + num.length | 0;
        out.length = len2, len2 = len2 - 1 | 0;
        var a = self2.words[0] | 0, b = num.words[0] | 0, r = a * b, lo = r & 67108863, carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k4 = 1;k4 < len2; k4++) {
          var ncarry = carry >>> 26, rword = carry & 67108863, maxJ = Math.min(k4, num.length - 1);
          for (var j3 = Math.max(0, k4 - self2.length + 1);j3 <= maxJ; j3++) {
            var i2 = k4 - j3 | 0;
            a = self2.words[i2] | 0, b = num.words[j3] | 0, r = a * b + rword, ncarry += r / 67108864 | 0, rword = r & 67108863;
          }
          out.words[k4] = rword | 0, carry = ncarry | 0;
        }
        if (carry !== 0)
          out.words[k4] = carry | 0;
        else
          out.length--;
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo(self2, num, out) {
        var a = self2.words, b = num.words, o = out.words, c = 0, lo, mid, hi2, a0 = a[0] | 0, al0 = a0 & 8191, ah0 = a0 >>> 13, a1 = a[1] | 0, al1 = a1 & 8191, ah1 = a1 >>> 13, a2 = a[2] | 0, al2 = a2 & 8191, ah2 = a2 >>> 13, a3 = a[3] | 0, al3 = a3 & 8191, ah3 = a3 >>> 13, a4 = a[4] | 0, al4 = a4 & 8191, ah4 = a4 >>> 13, a5 = a[5] | 0, al5 = a5 & 8191, ah5 = a5 >>> 13, a6 = a[6] | 0, al6 = a6 & 8191, ah6 = a6 >>> 13, a7 = a[7] | 0, al7 = a7 & 8191, ah7 = a7 >>> 13, a8 = a[8] | 0, al8 = a8 & 8191, ah8 = a8 >>> 13, a9 = a[9] | 0, al9 = a9 & 8191, ah9 = a9 >>> 13, b0 = b[0] | 0, bl0 = b0 & 8191, bh0 = b0 >>> 13, b1 = b[1] | 0, bl1 = b1 & 8191, bh1 = b1 >>> 13, b2 = b[2] | 0, bl2 = b2 & 8191, bh2 = b2 >>> 13, b3 = b[3] | 0, bl3 = b3 & 8191, bh3 = b3 >>> 13, b4 = b[4] | 0, bl4 = b4 & 8191, bh4 = b4 >>> 13, b5 = b[5] | 0, bl5 = b5 & 8191, bh5 = b5 >>> 13, b6 = b[6] | 0, bl6 = b6 & 8191, bh6 = b6 >>> 13, b7 = b[7] | 0, bl7 = b7 & 8191, bh7 = b7 >>> 13, b8 = b[8] | 0, bl8 = b8 & 8191, bh8 = b8 >>> 13, b9 = b[9] | 0, bl9 = b9 & 8191, bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative, out.length = 19, lo = Math.imul(al0, bl0), mid = Math.imul(al0, bh0), mid = mid + Math.imul(ah0, bl0) | 0, hi2 = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w0 >>> 26) | 0, w0 &= 67108863, lo = Math.imul(al1, bl0), mid = Math.imul(al1, bh0), mid = mid + Math.imul(ah1, bl0) | 0, hi2 = Math.imul(ah1, bh0), lo = lo + Math.imul(al0, bl1) | 0, mid = mid + Math.imul(al0, bh1) | 0, mid = mid + Math.imul(ah0, bl1) | 0, hi2 = hi2 + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w1 >>> 26) | 0, w1 &= 67108863, lo = Math.imul(al2, bl0), mid = Math.imul(al2, bh0), mid = mid + Math.imul(ah2, bl0) | 0, hi2 = Math.imul(ah2, bh0), lo = lo + Math.imul(al1, bl1) | 0, mid = mid + Math.imul(al1, bh1) | 0, mid = mid + Math.imul(ah1, bl1) | 0, hi2 = hi2 + Math.imul(ah1, bh1) | 0, lo = lo + Math.imul(al0, bl2) | 0, mid = mid + Math.imul(al0, bh2) | 0, mid = mid + Math.imul(ah0, bl2) | 0, hi2 = hi2 + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w2 >>> 26) | 0, w2 &= 67108863, lo = Math.imul(al3, bl0), mid = Math.imul(al3, bh0), mid = mid + Math.imul(ah3, bl0) | 0, hi2 = Math.imul(ah3, bh0), lo = lo + Math.imul(al2, bl1) | 0, mid = mid + Math.imul(al2, bh1) | 0, mid = mid + Math.imul(ah2, bl1) | 0, hi2 = hi2 + Math.imul(ah2, bh1) | 0, lo = lo + Math.imul(al1, bl2) | 0, mid = mid + Math.imul(al1, bh2) | 0, mid = mid + Math.imul(ah1, bl2) | 0, hi2 = hi2 + Math.imul(ah1, bh2) | 0, lo = lo + Math.imul(al0, bl3) | 0, mid = mid + Math.imul(al0, bh3) | 0, mid = mid + Math.imul(ah0, bl3) | 0, hi2 = hi2 + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w3 >>> 26) | 0, w3 &= 67108863, lo = Math.imul(al4, bl0), mid = Math.imul(al4, bh0), mid = mid + Math.imul(ah4, bl0) | 0, hi2 = Math.imul(ah4, bh0), lo = lo + Math.imul(al3, bl1) | 0, mid = mid + Math.imul(al3, bh1) | 0, mid = mid + Math.imul(ah3, bl1) | 0, hi2 = hi2 + Math.imul(ah3, bh1) | 0, lo = lo + Math.imul(al2, bl2) | 0, mid = mid + Math.imul(al2, bh2) | 0, mid = mid + Math.imul(ah2, bl2) | 0, hi2 = hi2 + Math.imul(ah2, bh2) | 0, lo = lo + Math.imul(al1, bl3) | 0, mid = mid + Math.imul(al1, bh3) | 0, mid = mid + Math.imul(ah1, bl3) | 0, hi2 = hi2 + Math.imul(ah1, bh3) | 0, lo = lo + Math.imul(al0, bl4) | 0, mid = mid + Math.imul(al0, bh4) | 0, mid = mid + Math.imul(ah0, bl4) | 0, hi2 = hi2 + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w4 >>> 26) | 0, w4 &= 67108863, lo = Math.imul(al5, bl0), mid = Math.imul(al5, bh0), mid = mid + Math.imul(ah5, bl0) | 0, hi2 = Math.imul(ah5, bh0), lo = lo + Math.imul(al4, bl1) | 0, mid = mid + Math.imul(al4, bh1) | 0, mid = mid + Math.imul(ah4, bl1) | 0, hi2 = hi2 + Math.imul(ah4, bh1) | 0, lo = lo + Math.imul(al3, bl2) | 0, mid = mid + Math.imul(al3, bh2) | 0, mid = mid + Math.imul(ah3, bl2) | 0, hi2 = hi2 + Math.imul(ah3, bh2) | 0, lo = lo + Math.imul(al2, bl3) | 0, mid = mid + Math.imul(al2, bh3) | 0, mid = mid + Math.imul(ah2, bl3) | 0, hi2 = hi2 + Math.imul(ah2, bh3) | 0, lo = lo + Math.imul(al1, bl4) | 0, mid = mid + Math.imul(al1, bh4) | 0, mid = mid + Math.imul(ah1, bl4) | 0, hi2 = hi2 + Math.imul(ah1, bh4) | 0, lo = lo + Math.imul(al0, bl5) | 0, mid = mid + Math.imul(al0, bh5) | 0, mid = mid + Math.imul(ah0, bl5) | 0, hi2 = hi2 + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w5 >>> 26) | 0, w5 &= 67108863, lo = Math.imul(al6, bl0), mid = Math.imul(al6, bh0), mid = mid + Math.imul(ah6, bl0) | 0, hi2 = Math.imul(ah6, bh0), lo = lo + Math.imul(al5, bl1) | 0, mid = mid + Math.imul(al5, bh1) | 0, mid = mid + Math.imul(ah5, bl1) | 0, hi2 = hi2 + Math.imul(ah5, bh1) | 0, lo = lo + Math.imul(al4, bl2) | 0, mid = mid + Math.imul(al4, bh2) | 0, mid = mid + Math.imul(ah4, bl2) | 0, hi2 = hi2 + Math.imul(ah4, bh2) | 0, lo = lo + Math.imul(al3, bl3) | 0, mid = mid + Math.imul(al3, bh3) | 0, mid = mid + Math.imul(ah3, bl3) | 0, hi2 = hi2 + Math.imul(ah3, bh3) | 0, lo = lo + Math.imul(al2, bl4) | 0, mid = mid + Math.imul(al2, bh4) | 0, mid = mid + Math.imul(ah2, bl4) | 0, hi2 = hi2 + Math.imul(ah2, bh4) | 0, lo = lo + Math.imul(al1, bl5) | 0, mid = mid + Math.imul(al1, bh5) | 0, mid = mid + Math.imul(ah1, bl5) | 0, hi2 = hi2 + Math.imul(ah1, bh5) | 0, lo = lo + Math.imul(al0, bl6) | 0, mid = mid + Math.imul(al0, bh6) | 0, mid = mid + Math.imul(ah0, bl6) | 0, hi2 = hi2 + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w6 >>> 26) | 0, w6 &= 67108863, lo = Math.imul(al7, bl0), mid = Math.imul(al7, bh0), mid = mid + Math.imul(ah7, bl0) | 0, hi2 = Math.imul(ah7, bh0), lo = lo + Math.imul(al6, bl1) | 0, mid = mid + Math.imul(al6, bh1) | 0, mid = mid + Math.imul(ah6, bl1) | 0, hi2 = hi2 + Math.imul(ah6, bh1) | 0, lo = lo + Math.imul(al5, bl2) | 0, mid = mid + Math.imul(al5, bh2) | 0, mid = mid + Math.imul(ah5, bl2) | 0, hi2 = hi2 + Math.imul(ah5, bh2) | 0, lo = lo + Math.imul(al4, bl3) | 0, mid = mid + Math.imul(al4, bh3) | 0, mid = mid + Math.imul(ah4, bl3) | 0, hi2 = hi2 + Math.imul(ah4, bh3) | 0, lo = lo + Math.imul(al3, bl4) | 0, mid = mid + Math.imul(al3, bh4) | 0, mid = mid + Math.imul(ah3, bl4) | 0, hi2 = hi2 + Math.imul(ah3, bh4) | 0, lo = lo + Math.imul(al2, bl5) | 0, mid = mid + Math.imul(al2, bh5) | 0, mid = mid + Math.imul(ah2, bl5) | 0, hi2 = hi2 + Math.imul(ah2, bh5) | 0, lo = lo + Math.imul(al1, bl6) | 0, mid = mid + Math.imul(al1, bh6) | 0, mid = mid + Math.imul(ah1, bl6) | 0, hi2 = hi2 + Math.imul(ah1, bh6) | 0, lo = lo + Math.imul(al0, bl7) | 0, mid = mid + Math.imul(al0, bh7) | 0, mid = mid + Math.imul(ah0, bl7) | 0, hi2 = hi2 + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w7 >>> 26) | 0, w7 &= 67108863, lo = Math.imul(al8, bl0), mid = Math.imul(al8, bh0), mid = mid + Math.imul(ah8, bl0) | 0, hi2 = Math.imul(ah8, bh0), lo = lo + Math.imul(al7, bl1) | 0, mid = mid + Math.imul(al7, bh1) | 0, mid = mid + Math.imul(ah7, bl1) | 0, hi2 = hi2 + Math.imul(ah7, bh1) | 0, lo = lo + Math.imul(al6, bl2) | 0, mid = mid + Math.imul(al6, bh2) | 0, mid = mid + Math.imul(ah6, bl2) | 0, hi2 = hi2 + Math.imul(ah6, bh2) | 0, lo = lo + Math.imul(al5, bl3) | 0, mid = mid + Math.imul(al5, bh3) | 0, mid = mid + Math.imul(ah5, bl3) | 0, hi2 = hi2 + Math.imul(ah5, bh3) | 0, lo = lo + Math.imul(al4, bl4) | 0, mid = mid + Math.imul(al4, bh4) | 0, mid = mid + Math.imul(ah4, bl4) | 0, hi2 = hi2 + Math.imul(ah4, bh4) | 0, lo = lo + Math.imul(al3, bl5) | 0, mid = mid + Math.imul(al3, bh5) | 0, mid = mid + Math.imul(ah3, bl5) | 0, hi2 = hi2 + Math.imul(ah3, bh5) | 0, lo = lo + Math.imul(al2, bl6) | 0, mid = mid + Math.imul(al2, bh6) | 0, mid = mid + Math.imul(ah2, bl6) | 0, hi2 = hi2 + Math.imul(ah2, bh6) | 0, lo = lo + Math.imul(al1, bl7) | 0, mid = mid + Math.imul(al1, bh7) | 0, mid = mid + Math.imul(ah1, bl7) | 0, hi2 = hi2 + Math.imul(ah1, bh7) | 0, lo = lo + Math.imul(al0, bl8) | 0, mid = mid + Math.imul(al0, bh8) | 0, mid = mid + Math.imul(ah0, bl8) | 0, hi2 = hi2 + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0, w8 &= 67108863, lo = Math.imul(al9, bl0), mid = Math.imul(al9, bh0), mid = mid + Math.imul(ah9, bl0) | 0, hi2 = Math.imul(ah9, bh0), lo = lo + Math.imul(al8, bl1) | 0, mid = mid + Math.imul(al8, bh1) | 0, mid = mid + Math.imul(ah8, bl1) | 0, hi2 = hi2 + Math.imul(ah8, bh1) | 0, lo = lo + Math.imul(al7, bl2) | 0, mid = mid + Math.imul(al7, bh2) | 0, mid = mid + Math.imul(ah7, bl2) | 0, hi2 = hi2 + Math.imul(ah7, bh2) | 0, lo = lo + Math.imul(al6, bl3) | 0, mid = mid + Math.imul(al6, bh3) | 0, mid = mid + Math.imul(ah6, bl3) | 0, hi2 = hi2 + Math.imul(ah6, bh3) | 0, lo = lo + Math.imul(al5, bl4) | 0, mid = mid + Math.imul(al5, bh4) | 0, mid = mid + Math.imul(ah5, bl4) | 0, hi2 = hi2 + Math.imul(ah5, bh4) | 0, lo = lo + Math.imul(al4, bl5) | 0, mid = mid + Math.imul(al4, bh5) | 0, mid = mid + Math.imul(ah4, bl5) | 0, hi2 = hi2 + Math.imul(ah4, bh5) | 0, lo = lo + Math.imul(al3, bl6) | 0, mid = mid + Math.imul(al3, bh6) | 0, mid = mid + Math.imul(ah3, bl6) | 0, hi2 = hi2 + Math.imul(ah3, bh6) | 0, lo = lo + Math.imul(al2, bl7) | 0, mid = mid + Math.imul(al2, bh7) | 0, mid = mid + Math.imul(ah2, bl7) | 0, hi2 = hi2 + Math.imul(ah2, bh7) | 0, lo = lo + Math.imul(al1, bl8) | 0, mid = mid + Math.imul(al1, bh8) | 0, mid = mid + Math.imul(ah1, bl8) | 0, hi2 = hi2 + Math.imul(ah1, bh8) | 0, lo = lo + Math.imul(al0, bl9) | 0, mid = mid + Math.imul(al0, bh9) | 0, mid = mid + Math.imul(ah0, bl9) | 0, hi2 = hi2 + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0, w9 &= 67108863, lo = Math.imul(al9, bl1), mid = Math.imul(al9, bh1), mid = mid + Math.imul(ah9, bl1) | 0, hi2 = Math.imul(ah9, bh1), lo = lo + Math.imul(al8, bl2) | 0, mid = mid + Math.imul(al8, bh2) | 0, mid = mid + Math.imul(ah8, bl2) | 0, hi2 = hi2 + Math.imul(ah8, bh2) | 0, lo = lo + Math.imul(al7, bl3) | 0, mid = mid + Math.imul(al7, bh3) | 0, mid = mid + Math.imul(ah7, bl3) | 0, hi2 = hi2 + Math.imul(ah7, bh3) | 0, lo = lo + Math.imul(al6, bl4) | 0, mid = mid + Math.imul(al6, bh4) | 0, mid = mid + Math.imul(ah6, bl4) | 0, hi2 = hi2 + Math.imul(ah6, bh4) | 0, lo = lo + Math.imul(al5, bl5) | 0, mid = mid + Math.imul(al5, bh5) | 0, mid = mid + Math.imul(ah5, bl5) | 0, hi2 = hi2 + Math.imul(ah5, bh5) | 0, lo = lo + Math.imul(al4, bl6) | 0, mid = mid + Math.imul(al4, bh6) | 0, mid = mid + Math.imul(ah4, bl6) | 0, hi2 = hi2 + Math.imul(ah4, bh6) | 0, lo = lo + Math.imul(al3, bl7) | 0, mid = mid + Math.imul(al3, bh7) | 0, mid = mid + Math.imul(ah3, bl7) | 0, hi2 = hi2 + Math.imul(ah3, bh7) | 0, lo = lo + Math.imul(al2, bl8) | 0, mid = mid + Math.imul(al2, bh8) | 0, mid = mid + Math.imul(ah2, bl8) | 0, hi2 = hi2 + Math.imul(ah2, bh8) | 0, lo = lo + Math.imul(al1, bl9) | 0, mid = mid + Math.imul(al1, bh9) | 0, mid = mid + Math.imul(ah1, bl9) | 0, hi2 = hi2 + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0, w10 &= 67108863, lo = Math.imul(al9, bl2), mid = Math.imul(al9, bh2), mid = mid + Math.imul(ah9, bl2) | 0, hi2 = Math.imul(ah9, bh2), lo = lo + Math.imul(al8, bl3) | 0, mid = mid + Math.imul(al8, bh3) | 0, mid = mid + Math.imul(ah8, bl3) | 0, hi2 = hi2 + Math.imul(ah8, bh3) | 0, lo = lo + Math.imul(al7, bl4) | 0, mid = mid + Math.imul(al7, bh4) | 0, mid = mid + Math.imul(ah7, bl4) | 0, hi2 = hi2 + Math.imul(ah7, bh4) | 0, lo = lo + Math.imul(al6, bl5) | 0, mid = mid + Math.imul(al6, bh5) | 0, mid = mid + Math.imul(ah6, bl5) | 0, hi2 = hi2 + Math.imul(ah6, bh5) | 0, lo = lo + Math.imul(al5, bl6) | 0, mid = mid + Math.imul(al5, bh6) | 0, mid = mid + Math.imul(ah5, bl6) | 0, hi2 = hi2 + Math.imul(ah5, bh6) | 0, lo = lo + Math.imul(al4, bl7) | 0, mid = mid + Math.imul(al4, bh7) | 0, mid = mid + Math.imul(ah4, bl7) | 0, hi2 = hi2 + Math.imul(ah4, bh7) | 0, lo = lo + Math.imul(al3, bl8) | 0, mid = mid + Math.imul(al3, bh8) | 0, mid = mid + Math.imul(ah3, bl8) | 0, hi2 = hi2 + Math.imul(ah3, bh8) | 0, lo = lo + Math.imul(al2, bl9) | 0, mid = mid + Math.imul(al2, bh9) | 0, mid = mid + Math.imul(ah2, bl9) | 0, hi2 = hi2 + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0, w11 &= 67108863, lo = Math.imul(al9, bl3), mid = Math.imul(al9, bh3), mid = mid + Math.imul(ah9, bl3) | 0, hi2 = Math.imul(ah9, bh3), lo = lo + Math.imul(al8, bl4) | 0, mid = mid + Math.imul(al8, bh4) | 0, mid = mid + Math.imul(ah8, bl4) | 0, hi2 = hi2 + Math.imul(ah8, bh4) | 0, lo = lo + Math.imul(al7, bl5) | 0, mid = mid + Math.imul(al7, bh5) | 0, mid = mid + Math.imul(ah7, bl5) | 0, hi2 = hi2 + Math.imul(ah7, bh5) | 0, lo = lo + Math.imul(al6, bl6) | 0, mid = mid + Math.imul(al6, bh6) | 0, mid = mid + Math.imul(ah6, bl6) | 0, hi2 = hi2 + Math.imul(ah6, bh6) | 0, lo = lo + Math.imul(al5, bl7) | 0, mid = mid + Math.imul(al5, bh7) | 0, mid = mid + Math.imul(ah5, bl7) | 0, hi2 = hi2 + Math.imul(ah5, bh7) | 0, lo = lo + Math.imul(al4, bl8) | 0, mid = mid + Math.imul(al4, bh8) | 0, mid = mid + Math.imul(ah4, bl8) | 0, hi2 = hi2 + Math.imul(ah4, bh8) | 0, lo = lo + Math.imul(al3, bl9) | 0, mid = mid + Math.imul(al3, bh9) | 0, mid = mid + Math.imul(ah3, bl9) | 0, hi2 = hi2 + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0, w12 &= 67108863, lo = Math.imul(al9, bl4), mid = Math.imul(al9, bh4), mid = mid + Math.imul(ah9, bl4) | 0, hi2 = Math.imul(ah9, bh4), lo = lo + Math.imul(al8, bl5) | 0, mid = mid + Math.imul(al8, bh5) | 0, mid = mid + Math.imul(ah8, bl5) | 0, hi2 = hi2 + Math.imul(ah8, bh5) | 0, lo = lo + Math.imul(al7, bl6) | 0, mid = mid + Math.imul(al7, bh6) | 0, mid = mid + Math.imul(ah7, bl6) | 0, hi2 = hi2 + Math.imul(ah7, bh6) | 0, lo = lo + Math.imul(al6, bl7) | 0, mid = mid + Math.imul(al6, bh7) | 0, mid = mid + Math.imul(ah6, bl7) | 0, hi2 = hi2 + Math.imul(ah6, bh7) | 0, lo = lo + Math.imul(al5, bl8) | 0, mid = mid + Math.imul(al5, bh8) | 0, mid = mid + Math.imul(ah5, bl8) | 0, hi2 = hi2 + Math.imul(ah5, bh8) | 0, lo = lo + Math.imul(al4, bl9) | 0, mid = mid + Math.imul(al4, bh9) | 0, mid = mid + Math.imul(ah4, bl9) | 0, hi2 = hi2 + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0, w13 &= 67108863, lo = Math.imul(al9, bl5), mid = Math.imul(al9, bh5), mid = mid + Math.imul(ah9, bl5) | 0, hi2 = Math.imul(ah9, bh5), lo = lo + Math.imul(al8, bl6) | 0, mid = mid + Math.imul(al8, bh6) | 0, mid = mid + Math.imul(ah8, bl6) | 0, hi2 = hi2 + Math.imul(ah8, bh6) | 0, lo = lo + Math.imul(al7, bl7) | 0, mid = mid + Math.imul(al7, bh7) | 0, mid = mid + Math.imul(ah7, bl7) | 0, hi2 = hi2 + Math.imul(ah7, bh7) | 0, lo = lo + Math.imul(al6, bl8) | 0, mid = mid + Math.imul(al6, bh8) | 0, mid = mid + Math.imul(ah6, bl8) | 0, hi2 = hi2 + Math.imul(ah6, bh8) | 0, lo = lo + Math.imul(al5, bl9) | 0, mid = mid + Math.imul(al5, bh9) | 0, mid = mid + Math.imul(ah5, bl9) | 0, hi2 = hi2 + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0, w14 &= 67108863, lo = Math.imul(al9, bl6), mid = Math.imul(al9, bh6), mid = mid + Math.imul(ah9, bl6) | 0, hi2 = Math.imul(ah9, bh6), lo = lo + Math.imul(al8, bl7) | 0, mid = mid + Math.imul(al8, bh7) | 0, mid = mid + Math.imul(ah8, bl7) | 0, hi2 = hi2 + Math.imul(ah8, bh7) | 0, lo = lo + Math.imul(al7, bl8) | 0, mid = mid + Math.imul(al7, bh8) | 0, mid = mid + Math.imul(ah7, bl8) | 0, hi2 = hi2 + Math.imul(ah7, bh8) | 0, lo = lo + Math.imul(al6, bl9) | 0, mid = mid + Math.imul(al6, bh9) | 0, mid = mid + Math.imul(ah6, bl9) | 0, hi2 = hi2 + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0, w15 &= 67108863, lo = Math.imul(al9, bl7), mid = Math.imul(al9, bh7), mid = mid + Math.imul(ah9, bl7) | 0, hi2 = Math.imul(ah9, bh7), lo = lo + Math.imul(al8, bl8) | 0, mid = mid + Math.imul(al8, bh8) | 0, mid = mid + Math.imul(ah8, bl8) | 0, hi2 = hi2 + Math.imul(ah8, bh8) | 0, lo = lo + Math.imul(al7, bl9) | 0, mid = mid + Math.imul(al7, bh9) | 0, mid = mid + Math.imul(ah7, bl9) | 0, hi2 = hi2 + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0, w16 &= 67108863, lo = Math.imul(al9, bl8), mid = Math.imul(al9, bh8), mid = mid + Math.imul(ah9, bl8) | 0, hi2 = Math.imul(ah9, bh8), lo = lo + Math.imul(al8, bl9) | 0, mid = mid + Math.imul(al8, bh9) | 0, mid = mid + Math.imul(ah8, bl9) | 0, hi2 = hi2 + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0, w17 &= 67108863, lo = Math.imul(al9, bl9), mid = Math.imul(al9, bh9), mid = mid + Math.imul(ah9, bl9) | 0, hi2 = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        if (c = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0, w18 &= 67108863, o[0] = w0, o[1] = w1, o[2] = w2, o[3] = w3, o[4] = w4, o[5] = w5, o[6] = w6, o[7] = w7, o[8] = w8, o[9] = w9, o[10] = w10, o[11] = w11, o[12] = w12, o[13] = w13, o[14] = w14, o[15] = w15, o[16] = w16, o[17] = w17, o[18] = w18, c !== 0)
          o[19] = c, out.length++;
        return out;
      };
      if (!Math.imul)
        comb10MulTo = smallMulTo;
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative, out.length = self2.length + num.length;
        var carry = 0, hncarry = 0;
        for (var k4 = 0;k4 < out.length - 1; k4++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863, maxJ = Math.min(k4, num.length - 1);
          for (var j3 = Math.max(0, k4 - self2.length + 1);j3 <= maxJ; j3++) {
            var i2 = k4 - j3, a = self2.words[i2] | 0, b = num.words[j3] | 0, r = a * b, lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0, lo = lo + rword | 0, rword = lo & 67108863, ncarry = ncarry + (lo >>> 26) | 0, hncarry += ncarry >>> 26, ncarry &= 67108863;
          }
          out.words[k4] = rword, carry = ncarry, ncarry = hncarry;
        }
        if (carry !== 0)
          out.words[k4] = carry;
        else
          out.length--;
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM;
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res, len2 = this.length + num.length;
        if (this.length === 10 && num.length === 10)
          res = comb10MulTo(this, num, out);
        else if (len2 < 63)
          res = smallMulTo(this, num, out);
        else if (len2 < 1024)
          res = bigMulTo(this, num, out);
        else
          res = jumboMulTo(this, num, out);
        return res;
      };
      function FFTM(x4, y) {
        this.x = x4, this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N3) {
        var t2 = new Array(N3), l3 = BN.prototype._countBits(N3) - 1;
        for (var i2 = 0;i2 < N3; i2++)
          t2[i2] = this.revBin(i2, l3, N3);
        return t2;
      }, FFTM.prototype.revBin = function revBin(x4, l3, N3) {
        if (x4 === 0 || x4 === N3 - 1)
          return x4;
        var rb = 0;
        for (var i2 = 0;i2 < l3; i2++)
          rb |= (x4 & 1) << l3 - i2 - 1, x4 >>= 1;
        return rb;
      }, FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N3) {
        for (var i2 = 0;i2 < N3; i2++)
          rtws[i2] = rws[rbt[i2]], itws[i2] = iws[rbt[i2]];
      }, FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N3, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N3);
        for (var s3 = 1;s3 < N3; s3 <<= 1) {
          var l3 = s3 << 1, rtwdf = Math.cos(2 * Math.PI / l3), itwdf = Math.sin(2 * Math.PI / l3);
          for (var p2 = 0;p2 < N3; p2 += l3) {
            var rtwdf_ = rtwdf, itwdf_ = itwdf;
            for (var j3 = 0;j3 < s3; j3++) {
              var re2 = rtws[p2 + j3], ie4 = itws[p2 + j3], ro = rtws[p2 + j3 + s3], io = itws[p2 + j3 + s3], rx = rtwdf_ * ro - itwdf_ * io;
              if (io = rtwdf_ * io + itwdf_ * ro, ro = rx, rtws[p2 + j3] = re2 + ro, itws[p2 + j3] = ie4 + io, rtws[p2 + j3 + s3] = re2 - ro, itws[p2 + j3 + s3] = ie4 - io, j3 !== l3)
                rx = rtwdf * rtwdf_ - itwdf * itwdf_, itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_, rtwdf_ = rx;
            }
          }
        }
      }, FFTM.prototype.guessLen13b = function guessLen13b(n, m2) {
        var N3 = Math.max(m2, n) | 1, odd = N3 & 1, i2 = 0;
        for (N3 = N3 / 2 | 0;N3; N3 = N3 >>> 1)
          i2++;
        return 1 << i2 + 1 + odd;
      }, FFTM.prototype.conjugate = function conjugate(rws, iws, N3) {
        if (N3 <= 1)
          return;
        for (var i2 = 0;i2 < N3 / 2; i2++) {
          var t2 = rws[i2];
          rws[i2] = rws[N3 - i2 - 1], rws[N3 - i2 - 1] = t2, t2 = iws[i2], iws[i2] = -iws[N3 - i2 - 1], iws[N3 - i2 - 1] = -t2;
        }
      }, FFTM.prototype.normalize13b = function normalize13b(ws, N3) {
        var carry = 0;
        for (var i2 = 0;i2 < N3 / 2; i2++) {
          var w = Math.round(ws[2 * i2 + 1] / N3) * 8192 + Math.round(ws[2 * i2] / N3) + carry;
          if (ws[i2] = w & 67108863, w < 67108864)
            carry = 0;
          else
            carry = w / 67108864 | 0;
        }
        return ws;
      }, FFTM.prototype.convert13b = function convert13b(ws, len2, rws, N3) {
        var carry = 0;
        for (var i2 = 0;i2 < len2; i2++)
          carry = carry + (ws[i2] | 0), rws[2 * i2] = carry & 8191, carry = carry >>> 13, rws[2 * i2 + 1] = carry & 8191, carry = carry >>> 13;
        for (i2 = 2 * len2;i2 < N3; ++i2)
          rws[i2] = 0;
        assert(carry === 0), assert((carry & -8192) === 0);
      }, FFTM.prototype.stub = function stub(N3) {
        var ph = new Array(N3);
        for (var i2 = 0;i2 < N3; i2++)
          ph[i2] = 0;
        return ph;
      }, FFTM.prototype.mulp = function mulp(x4, y, out) {
        var N3 = 2 * this.guessLen13b(x4.length, y.length), rbt = this.makeRBT(N3), _3 = this.stub(N3), rws = new Array(N3), rwst = new Array(N3), iwst = new Array(N3), nrws = new Array(N3), nrwst = new Array(N3), niwst = new Array(N3), rmws = out.words;
        rmws.length = N3, this.convert13b(x4.words, x4.length, rws, N3), this.convert13b(y.words, y.length, nrws, N3), this.transform(rws, _3, rwst, iwst, N3, rbt), this.transform(nrws, _3, nrwst, niwst, N3, rbt);
        for (var i2 = 0;i2 < N3; i2++) {
          var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
          iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2], rwst[i2] = rx;
        }
        return this.conjugate(rwst, iwst, N3), this.transform(rwst, iwst, rmws, _3, N3, rbt), this.conjugate(rmws, _3, N3), this.normalize13b(rmws, N3), out.negative = x4.negative ^ y.negative, out.length = x4.length + y.length, out.strip();
      }, BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        return out.words = new Array(this.length + num.length), this.mulTo(num, out);
      }, BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        return out.words = new Array(this.length + num.length), jumboMulTo(this, num, out);
      }, BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      }, BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number"), assert(num < 67108864);
        var carry = 0;
        for (var i2 = 0;i2 < this.length; i2++) {
          var w = (this.words[i2] | 0) * num, lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26, carry += w / 67108864 | 0, carry += lo >>> 26, this.words[i2] = lo & 67108863;
        }
        if (carry !== 0)
          this.words[i2] = carry, this.length++;
        return this.length = num === 0 ? 1 : this.length, this;
      }, BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      }, BN.prototype.sqr = function sqr() {
        return this.mul(this);
      }, BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      }, BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i2 = 0;i2 < w.length; i2++, res = res.sqr())
          if (w[i2] !== 0)
            break;
        if (++i2 < w.length)
          for (var q3 = res.sqr();i2 < w.length; i2++, q3 = q3.sqr()) {
            if (w[i2] === 0)
              continue;
            res = res.mul(q3);
          }
        return res;
      }, BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26, s3 = (bits - r) / 26, carryMask = 67108863 >>> 26 - r << 26 - r, i2;
        if (r !== 0) {
          var carry = 0;
          for (i2 = 0;i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask, c = (this.words[i2] | 0) - newCarry << r;
            this.words[i2] = c | carry, carry = newCarry >>> 26 - r;
          }
          if (carry)
            this.words[i2] = carry, this.length++;
        }
        if (s3 !== 0) {
          for (i2 = this.length - 1;i2 >= 0; i2--)
            this.words[i2 + s3] = this.words[i2];
          for (i2 = 0;i2 < s3; i2++)
            this.words[i2] = 0;
          this.length += s3;
        }
        return this.strip();
      }, BN.prototype.ishln = function ishln(bits) {
        return assert(this.negative === 0), this.iushln(bits);
      }, BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint)
          h = (hint - hint % 26) / 26;
        else
          h = 0;
        var r = bits % 26, s3 = Math.min((bits - r) / 26, this.length), mask = 67108863 ^ 67108863 >>> r << r, maskedWords = extended;
        if (h -= s3, h = Math.max(0, h), maskedWords) {
          for (var i2 = 0;i2 < s3; i2++)
            maskedWords.words[i2] = this.words[i2];
          maskedWords.length = s3;
        }
        if (s3 === 0)
          ;
        else if (this.length > s3) {
          this.length -= s3;
          for (i2 = 0;i2 < this.length; i2++)
            this.words[i2] = this.words[i2 + s3];
        } else
          this.words[0] = 0, this.length = 1;
        var carry = 0;
        for (i2 = this.length - 1;i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r | word >>> r, carry = word & mask;
        }
        if (maskedWords && carry !== 0)
          maskedWords.words[maskedWords.length++] = carry;
        if (this.length === 0)
          this.words[0] = 0, this.length = 1;
        return this.strip();
      }, BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        return assert(this.negative === 0), this.iushrn(bits, hint, extended);
      }, BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      }, BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      }, BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      }, BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      }, BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26, s3 = (bit - r) / 26, q3 = 1 << r;
        if (this.length <= s3)
          return false;
        var w = this.words[s3];
        return !!(w & q3);
      }, BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26, s3 = (bits - r) / 26;
        if (assert(this.negative === 0, "imaskn works only with positive numbers"), this.length <= s3)
          return this;
        if (r !== 0)
          s3++;
        if (this.length = Math.min(s3, this.length), r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      }, BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      }, BN.prototype.iaddn = function iaddn(num) {
        if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num)
            return this.words[0] = num - (this.words[0] | 0), this.negative = 0, this;
          return this.negative = 0, this.isubn(num), this.negative = 1, this;
        }
        return this._iaddn(num);
      }, BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0;i2 < this.length && this.words[i2] >= 67108864; i2++)
          if (this.words[i2] -= 67108864, i2 === this.length - 1)
            this.words[i2 + 1] = 1;
          else
            this.words[i2 + 1]++;
        return this.length = Math.max(this.length, i2 + 1), this;
      }, BN.prototype.isubn = function isubn(num) {
        if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(num), this.negative = 1, this;
        if (this.words[0] -= num, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var i2 = 0;i2 < this.length && this.words[i2] < 0; i2++)
            this.words[i2] += 67108864, this.words[i2 + 1] -= 1;
        return this.strip();
      }, BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      }, BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      }, BN.prototype.iabs = function iabs() {
        return this.negative = 0, this;
      }, BN.prototype.abs = function abs() {
        return this.clone().iabs();
      }, BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len2 = num.length + shift, i2;
        this._expand(len2);
        var w, carry = 0;
        for (i2 = 0;i2 < num.length; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul;
          w -= right & 67108863, carry = (w >> 26) - (right / 67108864 | 0), this.words[i2 + shift] = w & 67108863;
        }
        for (;i2 < this.length - shift; i2++)
          w = (this.words[i2 + shift] | 0) + carry, carry = w >> 26, this.words[i2 + shift] = w & 67108863;
        if (carry === 0)
          return this.strip();
        assert(carry === -1), carry = 0;
        for (i2 = 0;i2 < this.length; i2++)
          w = -(this.words[i2] | 0) + carry, carry = w >> 26, this.words[i2] = w & 67108863;
        return this.negative = 1, this.strip();
      }, BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length, a = this.clone(), b = num, bhi = b.words[b.length - 1] | 0, bhiBits = this._countBits(bhi);
        if (shift = 26 - bhiBits, shift !== 0)
          b = b.ushln(shift), a.iushln(shift), bhi = b.words[b.length - 1] | 0;
        var m2 = a.length - b.length, q3;
        if (mode !== "mod") {
          q3 = new BN(null), q3.length = m2 + 1, q3.words = new Array(q3.length);
          for (var i2 = 0;i2 < q3.length; i2++)
            q3.words[i2] = 0;
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m2);
        if (diff.negative === 0) {
          if (a = diff, q3)
            q3.words[m2] = 1;
        }
        for (var j3 = m2 - 1;j3 >= 0; j3--) {
          var qj = (a.words[b.length + j3] | 0) * 67108864 + (a.words[b.length + j3 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863), a._ishlnsubmul(b, qj, j3);
          while (a.negative !== 0)
            if (qj--, a.negative = 0, a._ishlnsubmul(b, 1, j3), !a.isZero())
              a.negative ^= 1;
          if (q3)
            q3.words[j3] = qj;
        }
        if (q3)
          q3.strip();
        if (a.strip(), mode !== "div" && shift !== 0)
          a.iushrn(shift);
        return { div: q3 || null, mod: a };
      }, BN.prototype.divmod = function divmod(num, mode, positive) {
        if (assert(!num.isZero()), this.isZero())
          return { div: new BN(0), mod: new BN(0) };
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          if (res = this.neg().divmod(num, mode), mode !== "mod")
            div = res.div.neg();
          if (mode !== "div") {
            if (mod = res.mod.neg(), positive && mod.negative !== 0)
              mod.iadd(num);
          }
          return { div, mod };
        }
        if (this.negative === 0 && num.negative !== 0) {
          if (res = this.divmod(num.neg(), mode), mode !== "mod")
            div = res.div.neg();
          return { div, mod: res.mod };
        }
        if ((this.negative & num.negative) !== 0) {
          if (res = this.neg().divmod(num.neg(), mode), mode !== "div") {
            if (mod = res.mod.neg(), positive && mod.negative !== 0)
              mod.isub(num);
          }
          return { div: res.div, mod };
        }
        if (num.length > this.length || this.cmp(num) < 0)
          return { div: new BN(0), mod: this };
        if (num.length === 1) {
          if (mode === "div")
            return { div: this.divn(num.words[0]), mod: null };
          if (mode === "mod")
            return { div: null, mod: new BN(this.modn(num.words[0])) };
          return { div: this.divn(num.words[0]), mod: new BN(this.modn(num.words[0])) };
        }
        return this._wordDiv(num, mode);
      }, BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      }, BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      }, BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      }, BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod, half = num.ushrn(1), r2 = num.andln(1), cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      }, BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p2 = 67108864 % num, acc = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--)
          acc = (p2 * acc + (this.words[i2] | 0)) % num;
        return acc;
      }, BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--) {
          var w = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w / num | 0, carry = w % num;
        }
        return this.strip();
      }, BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      }, BN.prototype.egcd = function egcd(p2) {
        assert(p2.negative === 0), assert(!p2.isZero());
        var x4 = this, y = p2.clone();
        if (x4.negative !== 0)
          x4 = x4.umod(p2);
        else
          x4 = x4.clone();
        var A3 = new BN(1), B3 = new BN(0), C2 = new BN(0), D2 = new BN(1), g2 = 0;
        while (x4.isEven() && y.isEven())
          x4.iushrn(1), y.iushrn(1), ++g2;
        var yp = y.clone(), xp = x4.clone();
        while (!x4.isZero()) {
          for (var i2 = 0, im = 1;(x4.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            x4.iushrn(i2);
            while (i2-- > 0) {
              if (A3.isOdd() || B3.isOdd())
                A3.iadd(yp), B3.isub(xp);
              A3.iushrn(1), B3.iushrn(1);
            }
          }
          for (var j3 = 0, jm = 1;(y.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
            ;
          if (j3 > 0) {
            y.iushrn(j3);
            while (j3-- > 0) {
              if (C2.isOdd() || D2.isOdd())
                C2.iadd(yp), D2.isub(xp);
              C2.iushrn(1), D2.iushrn(1);
            }
          }
          if (x4.cmp(y) >= 0)
            x4.isub(y), A3.isub(C2), B3.isub(D2);
          else
            y.isub(x4), C2.isub(A3), D2.isub(B3);
        }
        return { a: C2, b: D2, gcd: y.iushln(g2) };
      }, BN.prototype._invmp = function _invmp(p2) {
        assert(p2.negative === 0), assert(!p2.isZero());
        var a = this, b = p2.clone();
        if (a.negative !== 0)
          a = a.umod(p2);
        else
          a = a.clone();
        var x1 = new BN(1), x22 = new BN(0), delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i2 = 0, im = 1;(a.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            a.iushrn(i2);
            while (i2-- > 0) {
              if (x1.isOdd())
                x1.iadd(delta);
              x1.iushrn(1);
            }
          }
          for (var j3 = 0, jm = 1;(b.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
            ;
          if (j3 > 0) {
            b.iushrn(j3);
            while (j3-- > 0) {
              if (x22.isOdd())
                x22.iadd(delta);
              x22.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0)
            a.isub(b), x1.isub(x22);
          else
            b.isub(a), x22.isub(x1);
        }
        var res;
        if (a.cmpn(1) === 0)
          res = x1;
        else
          res = x22;
        if (res.cmpn(0) < 0)
          res.iadd(p2);
        return res;
      }, BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone(), b = num.clone();
        a.negative = 0, b.negative = 0;
        for (var shift = 0;a.isEven() && b.isEven(); shift++)
          a.iushrn(1), b.iushrn(1);
        do {
          while (a.isEven())
            a.iushrn(1);
          while (b.isEven())
            b.iushrn(1);
          var r = a.cmp(b);
          if (r < 0) {
            var t2 = a;
            a = b, b = t2;
          } else if (r === 0 || b.cmpn(1) === 0)
            break;
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      }, BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      }, BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      }, BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      }, BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      }, BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26, s3 = (bit - r) / 26, q3 = 1 << r;
        if (this.length <= s3)
          return this._expand(s3 + 1), this.words[s3] |= q3, this;
        var carry = q3;
        for (var i2 = s3;carry !== 0 && i2 < this.length; i2++) {
          var w = this.words[i2] | 0;
          w += carry, carry = w >>> 26, w &= 67108863, this.words[i2] = w;
        }
        if (carry !== 0)
          this.words[i2] = carry, this.length++;
        return this;
      }, BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      }, BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1)
          res = 1;
        else {
          if (negative)
            num = -num;
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--) {
          var a = this.words[i2] | 0, b = num.words[i2] | 0;
          if (a === b)
            continue;
          if (a < b)
            res = -1;
          else if (a > b)
            res = 1;
          break;
        }
        return res;
      }, BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      }, BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      }, BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      }, BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      }, BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      }, BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      }, BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      }, BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      }, BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      }, BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      }, BN.red = function red(num) {
        return new Red(num);
      }, BN.prototype.toRed = function toRed(ctx) {
        return assert(!this.red, "Already a number in reduction context"), assert(this.negative === 0, "red works only with positives"), ctx.convertTo(this)._forceRed(ctx);
      }, BN.prototype.fromRed = function fromRed() {
        return assert(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, BN.prototype._forceRed = function _forceRed(ctx) {
        return this.red = ctx, this;
      }, BN.prototype.forceRed = function forceRed(ctx) {
        return assert(!this.red, "Already a number in reduction context"), this._forceRed(ctx);
      }, BN.prototype.redAdd = function redAdd(num) {
        return assert(this.red, "redAdd works only with red numbers"), this.red.add(this, num);
      }, BN.prototype.redIAdd = function redIAdd(num) {
        return assert(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, num);
      }, BN.prototype.redSub = function redSub(num) {
        return assert(this.red, "redSub works only with red numbers"), this.red.sub(this, num);
      }, BN.prototype.redISub = function redISub(num) {
        return assert(this.red, "redISub works only with red numbers"), this.red.isub(this, num);
      }, BN.prototype.redShl = function redShl(num) {
        return assert(this.red, "redShl works only with red numbers"), this.red.shl(this, num);
      }, BN.prototype.redMul = function redMul(num) {
        return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.mul(this, num);
      }, BN.prototype.redIMul = function redIMul(num) {
        return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.imul(this, num);
      }, BN.prototype.redSqr = function redSqr() {
        return assert(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, BN.prototype.redISqr = function redISqr() {
        return assert(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, BN.prototype.redSqrt = function redSqrt() {
        return assert(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, BN.prototype.redInvm = function redInvm() {
        return assert(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, BN.prototype.redNeg = function redNeg() {
        return assert(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, BN.prototype.redPow = function redPow(num) {
        return assert(this.red && !num.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, num);
      };
      var primes = { k256: null, p224: null, p192: null, p25519: null };
      function MPrime(name, p2) {
        this.name = name, this.p = new BN(p2, 16), this.n = this.p.bitLength(), this.k = new BN(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        return tmp.words = new Array(Math.ceil(this.n / 13)), tmp;
      }, MPrime.prototype.ireduce = function ireduce(num) {
        var r = num, rlen;
        do
          this.split(r, this.tmp), r = this.imulK(r), r = r.iadd(this.tmp), rlen = r.bitLength();
        while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0)
          r.words[0] = 0, r.length = 1;
        else if (cmp > 0)
          r.isub(this.p);
        else if (r.strip !== undefined)
          r.strip();
        else
          r._strip();
        return r;
      }, MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      }, MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      inherits2(K256, MPrime), K256.prototype.split = function split(input, output) {
        var mask = 4194303, outLen = Math.min(input.length, 9);
        for (var i2 = 0;i2 < outLen; i2++)
          output.words[i2] = input.words[i2];
        if (output.length = outLen, input.length <= 9) {
          input.words[0] = 0, input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i2 = 10;i2 < input.length; i2++) {
          var next = input.words[i2] | 0;
          input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22, prev = next;
        }
        if (prev >>>= 22, input.words[i2 - 10] = prev, prev === 0 && input.length > 10)
          input.length -= 10;
        else
          input.length -= 9;
      }, K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0, num.words[num.length + 1] = 0, num.length += 2;
        var lo = 0;
        for (var i2 = 0;i2 < num.length; i2++) {
          var w = num.words[i2] | 0;
          lo += w * 977, num.words[i2] = lo & 67108863, lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          if (num.length--, num.words[num.length - 1] === 0)
            num.length--;
        }
        return num;
      };
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      inherits2(P25519, MPrime), P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0;i2 < num.length; i2++) {
          var hi2 = (num.words[i2] | 0) * 19 + carry, lo = hi2 & 67108863;
          hi2 >>>= 26, num.words[i2] = lo, carry = hi2;
        }
        if (carry !== 0)
          num.words[num.length++] = carry;
        return num;
      }, BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime;
        if (name === "k256")
          prime = new K256;
        else if (name === "p224")
          prime = new P224;
        else if (name === "p192")
          prime = new P192;
        else if (name === "p25519")
          prime = new P25519;
        else
          throw new Error("Unknown prime " + name);
        return primes[name] = prime, prime;
      };
      function Red(m2) {
        if (typeof m2 === "string") {
          var prime = BN._prime(m2);
          this.m = prime.p, this.prime = prime;
        } else
          assert(m2.gtn(1), "modulus must be greater than 1"), this.m = m2, this.prime = null;
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives"), assert(a.red, "red works only with red numbers");
      }, Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives"), assert(a.red && a.red === b.red, "red works only with red numbers");
      }, Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      }, Red.prototype.neg = function neg(a) {
        if (a.isZero())
          return a.clone();
        return this.m.sub(a)._forceRed(this);
      }, Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0)
          res.isub(this.m);
        return res._forceRed(this);
      }, Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0)
          res.isub(this.m);
        return res;
      }, Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0)
          res.iadd(this.m);
        return res._forceRed(this);
      }, Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0)
          res.iadd(this.m);
        return res;
      }, Red.prototype.shl = function shl(a, num) {
        return this._verify1(a), this.imod(a.ushln(num));
      }, Red.prototype.imul = function imul(a, b) {
        return this._verify2(a, b), this.imod(a.imul(b));
      }, Red.prototype.mul = function mul(a, b) {
        return this._verify2(a, b), this.imod(a.mul(b));
      }, Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      }, Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      }, Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        if (assert(mod3 % 2 === 1), mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q3 = this.m.subn(1), s3 = 0;
        while (!q3.isZero() && q3.andln(1) === 0)
          s3++, q3.iushrn(1);
        assert(!q3.isZero());
        var one = new BN(1).toRed(this), nOne = one.redNeg(), lpow = this.m.subn(1).iushrn(1), z2 = this.m.bitLength();
        z2 = new BN(2 * z2 * z2).toRed(this);
        while (this.pow(z2, lpow).cmp(nOne) !== 0)
          z2.redIAdd(nOne);
        var c = this.pow(z2, q3), r = this.pow(a, q3.addn(1).iushrn(1)), t2 = this.pow(a, q3), m2 = s3;
        while (t2.cmp(one) !== 0) {
          var tmp = t2;
          for (var i2 = 0;tmp.cmp(one) !== 0; i2++)
            tmp = tmp.redSqr();
          assert(i2 < m2);
          var b = this.pow(c, new BN(1).iushln(m2 - i2 - 1));
          r = r.redMul(b), c = b.redSqr(), t2 = t2.redMul(c), m2 = i2;
        }
        return r;
      }, Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0)
          return inv.negative = 0, this.imod(inv).redNeg();
        else
          return this.imod(inv);
      }, Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4, wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this), wnd[1] = a;
        for (var i2 = 2;i2 < wnd.length; i2++)
          wnd[i2] = this.mul(wnd[i2 - 1], a);
        var res = wnd[0], current = 0, currentLen = 0, start = num.bitLength() % 26;
        if (start === 0)
          start = 26;
        for (i2 = num.length - 1;i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j3 = start - 1;j3 >= 0; j3--) {
            var bit = word >> j3 & 1;
            if (res !== wnd[0])
              res = this.sqr(res);
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            if (current <<= 1, current |= bit, currentLen++, currentLen !== windowSize && (i2 !== 0 || j3 !== 0))
              continue;
            res = this.mul(res, wnd[current]), currentLen = 0, current = 0;
          }
          start = 26;
        }
        return res;
      }, Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      }, Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        return res.red = null, res;
      }, BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m2) {
        if (Red.call(this, m2), this.shift = this.m.bitLength(), this.shift % 26 !== 0)
          this.shift += 26 - this.shift % 26;
        this.r = new BN(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red), Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      }, Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        return r.red = null, r;
      }, Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero())
          return a.words[0] = 0, a.length = 1, a;
        var t2 = a.imul(b), c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t2.isub(c).iushrn(this.shift), res = u;
        if (u.cmp(this.m) >= 0)
          res = u.isub(this.m);
        else if (u.cmpn(0) < 0)
          res = u.iadd(this.m);
        return res._forceRed(this);
      }, Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t2 = a.mul(b), c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t2.isub(c).iushrn(this.shift), res = u;
        if (u.cmp(this.m) >= 0)
          res = u.isub(this.m);
        else if (u.cmpn(0) < 0)
          res = u.iadd(this.m);
        return res._forceRed(this);
      }, Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  });
  require_browser = __commonJS2((exports, module) => {
    var elliptic = require_elliptic(), BN = require_bn2();
    module.exports = function createECDH(curve) {
      return new ECDH(curve);
    };
    var aliases = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
    aliases.p224 = aliases.secp224r1;
    aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
    aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
    aliases.p384 = aliases.secp384r1;
    aliases.p521 = aliases.secp521r1;
    function ECDH(curve) {
      if (this.curveType = aliases[curve], !this.curveType)
        this.curveType = { name: curve };
      this.curve = new elliptic.ec(this.curveType.name), this.keys = undefined;
    }
    ECDH.prototype.generateKeys = function(enc, format3) {
      return this.keys = this.curve.genKeyPair(), this.getPublicKey(enc, format3);
    };
    ECDH.prototype.computeSecret = function(other, inenc, enc) {
      if (inenc = inenc || "utf8", !Buffer.isBuffer(other))
        other = new Buffer(other, inenc);
      var otherPub = this.curve.keyFromPublic(other).getPublic(), out = otherPub.mul(this.keys.getPrivate()).getX();
      return formatReturnValue(out, enc, this.curveType.byteLength);
    };
    ECDH.prototype.getPublicKey = function(enc, format3) {
      var key = this.keys.getPublic(format3 === "compressed", true);
      if (format3 === "hybrid")
        if (key[key.length - 1] % 2)
          key[0] = 7;
        else
          key[0] = 6;
      return formatReturnValue(key, enc);
    };
    ECDH.prototype.getPrivateKey = function(enc) {
      return formatReturnValue(this.keys.getPrivate(), enc);
    };
    ECDH.prototype.setPublicKey = function(pub, enc) {
      if (enc = enc || "utf8", !Buffer.isBuffer(pub))
        pub = new Buffer(pub, enc);
      return this.keys._importPublic(pub), this;
    };
    ECDH.prototype.setPrivateKey = function(priv, enc) {
      if (enc = enc || "utf8", !Buffer.isBuffer(priv))
        priv = new Buffer(priv, enc);
      var _priv = new BN(priv);
      return _priv = _priv.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(_priv), this;
    };
    function formatReturnValue(bn2, enc, len2) {
      if (!Array.isArray(bn2))
        bn2 = bn2.toArray();
      var buf = new Buffer(bn2);
      if (len2 && buf.length < len2) {
        var zeros = new Buffer(len2 - buf.length);
        zeros.fill(0), buf = Buffer.concat([zeros, buf]);
      }
      if (!enc)
        return buf;
      else
        return buf.toString(enc);
    }
  });
  require_create_ecdh = __commonJS2((exports, module) => {
    var createECDH = (init_crypto(), __toCommonJS(exports_crypto)).createECDH;
    module.exports = createECDH || require_browser();
  });
  require_bn3 = __commonJS2((exports, module) => {
    (function(module2, exports2) {
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number))
          return number;
        if (this.negative = 0, this.words = null, this.length = 0, this.red = null, number !== null) {
          if (base === "le" || base === "be")
            endian = base, base = 10;
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object")
        module2.exports = BN;
      else
        exports2.BN = BN;
      BN.BN = BN, BN.wordSize = 26;
      var Buffer22;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined")
          Buffer22 = window.Buffer;
        else
          Buffer22 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer;
      } catch (e2) {}
      BN.isBN = function isBN(num) {
        if (num instanceof BN)
          return true;
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      }, BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      }, BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      }, BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number")
          return this._initNumber(number, base, endian);
        if (typeof number === "object")
          return this._initArray(number, base, endian);
        if (base === "hex")
          base = 16;
        assert(base === (base | 0) && base >= 2 && base <= 36), number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-")
          start++, this.negative = 1;
        if (start < number.length) {
          if (base === 16)
            this._parseHex(number, start, endian);
          else if (this._parseBase(number, base, start), endian === "le")
            this._initArray(this.toArray(), base, endian);
        }
      }, BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0)
          this.negative = 1, number = -number;
        if (number < 67108864)
          this.words = [number & 67108863], this.length = 1;
        else if (number < 4503599627370496)
          this.words = [number & 67108863, number / 67108864 & 67108863], this.length = 2;
        else
          assert(number < 9007199254740992), this.words = [number & 67108863, number / 67108864 & 67108863, 1], this.length = 3;
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      }, BN.prototype._initArray = function _initArray(number, base, endian) {
        if (assert(typeof number.length === "number"), number.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(number.length / 3), this.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          this.words[i2] = 0;
        var j3, w, off = 0;
        if (endian === "be") {
          for (i2 = number.length - 1, j3 = 0;i2 >= 0; i2 -= 3)
            if (w = number[i2] | number[i2 - 1] << 8 | number[i2 - 2] << 16, this.words[j3] |= w << off & 67108863, this.words[j3 + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
              off -= 26, j3++;
        } else if (endian === "le") {
          for (i2 = 0, j3 = 0;i2 < number.length; i2 += 3)
            if (w = number[i2] | number[i2 + 1] << 8 | number[i2 + 2] << 16, this.words[j3] |= w << off & 67108863, this.words[j3 + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
              off -= 26, j3++;
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 65 && c <= 70)
          return c - 55;
        else if (c >= 97 && c <= 102)
          return c - 87;
        else
          return c - 48 & 15;
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound)
          r |= parseHex4Bits(string, index - 1) << 4;
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6), this.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          this.words[i2] = 0;
        var off = 0, j3 = 0, w;
        if (endian === "be")
          for (i2 = number.length - 1;i2 >= start; i2 -= 2)
            if (w = parseHexByte(number, start, i2) << off, this.words[j3] |= w & 67108863, off >= 18)
              off -= 18, j3 += 1, this.words[j3] |= w >>> 26;
            else
              off += 8;
        else {
          var parseLength = number.length - start;
          for (i2 = parseLength % 2 === 0 ? start + 1 : start;i2 < number.length; i2 += 2)
            if (w = parseHexByte(number, start, i2) << off, this.words[j3] |= w & 67108863, off >= 18)
              off -= 18, j3 += 1, this.words[j3] |= w >>> 26;
            else
              off += 8;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0, len2 = Math.min(str.length, end);
        for (var i2 = start;i2 < len2; i2++) {
          var c = str.charCodeAt(i2) - 48;
          if (r *= mul, c >= 49)
            r += c - 49 + 10;
          else if (c >= 17)
            r += c - 17 + 10;
          else
            r += c;
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0], this.length = 1;
        for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base)
          limbLen++;
        limbLen--, limbPow = limbPow / base | 0;
        var total = number.length - start, mod = total % limbLen, end = Math.min(total, total - mod) + start, word = 0;
        for (var i2 = start;i2 < end; i2 += limbLen)
          if (word = parseBase(number, i2, i2 + limbLen, base), this.imuln(limbPow), this.words[0] + word < 67108864)
            this.words[0] += word;
          else
            this._iaddn(word);
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i2, number.length, base);
          for (i2 = 0;i2 < mod; i2++)
            pow *= base;
          if (this.imuln(pow), this.words[0] + word < 67108864)
            this.words[0] += word;
          else
            this._iaddn(word);
        }
        this.strip();
      }, BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          dest.words[i2] = this.words[i2];
        dest.length = this.length, dest.negative = this.negative, dest.red = this.red;
      }, BN.prototype.clone = function clone() {
        var r = new BN(null);
        return this.copy(r), r;
      }, BN.prototype._expand = function _expand(size) {
        while (this.length < size)
          this.words[this.length++] = 0;
        return this;
      }, BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0)
          this.length--;
        return this._normSign();
      }, BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0)
          this.negative = 0;
        return this;
      }, BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      if (BN.prototype.toString = function toString(base, padding) {
        base = base || 10, padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0, carry = 0;
          for (var i2 = 0;i2 < this.length; i2++) {
            var w = this.words[i2], word = ((w << off | carry) & 16777215).toString(16);
            if (carry = w >>> 24 - off & 16777215, off += 2, off >= 26)
              off -= 26, i2--;
            if (carry !== 0 || i2 !== this.length - 1)
              out = zeros[6 - word.length] + word + out;
            else
              out = word + out;
          }
          if (carry !== 0)
            out = carry.toString(16) + out;
          while (out.length % padding !== 0)
            out = "0" + out;
          if (this.negative !== 0)
            out = "-" + out;
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base], groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            if (c = c.idivn(groupBase), !c.isZero())
              out = zeros[groupSize - r.length] + r + out;
            else
              out = r + out;
          }
          if (this.isZero())
            out = "0" + out;
          while (out.length % padding !== 0)
            out = "0" + out;
          if (this.negative !== 0)
            out = "-" + out;
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      }, BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2)
          ret += this.words[1] * 67108864;
        else if (this.length === 3 && this.words[2] === 1)
          ret += 4503599627370496 + this.words[1] * 67108864;
        else if (this.length > 2)
          assert(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -ret : ret;
      }, BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      }, BN.prototype.toBuffer = function toBuffer(endian, length) {
        return assert(typeof Buffer22 !== "undefined"), this.toArrayLike(Buffer22, endian, length);
      }, BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      }, BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength2 = this.byteLength(), reqLength = length || Math.max(1, byteLength2);
        assert(byteLength2 <= reqLength, "byte array longer than desired length"), assert(reqLength > 0, "Requested array length <= 0"), this.strip();
        var littleEndian = endian === "le", res = new ArrayType(reqLength), b, i2, q3 = this.clone();
        if (!littleEndian) {
          for (i2 = 0;i2 < reqLength - byteLength2; i2++)
            res[i2] = 0;
          for (i2 = 0;!q3.isZero(); i2++)
            b = q3.andln(255), q3.iushrn(8), res[reqLength - i2 - 1] = b;
        } else {
          for (i2 = 0;!q3.isZero(); i2++)
            b = q3.andln(255), q3.iushrn(8), res[i2] = b;
          for (;i2 < reqLength; i2++)
            res[i2] = 0;
        }
        return res;
      }, Math.clz32)
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      else
        BN.prototype._countBits = function _countBits(w) {
          var t2 = w, r = 0;
          if (t2 >= 4096)
            r += 13, t2 >>>= 13;
          if (t2 >= 64)
            r += 7, t2 >>>= 7;
          if (t2 >= 8)
            r += 4, t2 >>>= 4;
          if (t2 >= 2)
            r += 2, t2 >>>= 2;
          return r + t2;
        };
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t2 = w, r = 0;
        if ((t2 & 8191) === 0)
          r += 13, t2 >>>= 13;
        if ((t2 & 127) === 0)
          r += 7, t2 >>>= 7;
        if ((t2 & 15) === 0)
          r += 4, t2 >>>= 4;
        if ((t2 & 3) === 0)
          r += 2, t2 >>>= 2;
        if ((t2 & 1) === 0)
          r++;
        return r;
      }, BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1], hi2 = this._countBits(w);
        return (this.length - 1) * 26 + hi2;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0;bit < w.length; bit++) {
          var off = bit / 26 | 0, wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i2 = 0;i2 < this.length; i2++) {
          var b = this._zeroBits(this.words[i2]);
          if (r += b, b !== 26)
            break;
        }
        return r;
      }, BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      }, BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0)
          return this.abs().inotn(width).iaddn(1);
        return this.clone();
      }, BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1))
          return this.notn(width).iaddn(1).ineg();
        return this.clone();
      }, BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      }, BN.prototype.neg = function neg() {
        return this.clone().ineg();
      }, BN.prototype.ineg = function ineg() {
        if (!this.isZero())
          this.negative ^= 1;
        return this;
      }, BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length)
          this.words[this.length++] = 0;
        for (var i2 = 0;i2 < num.length; i2++)
          this.words[i2] = this.words[i2] | num.words[i2];
        return this.strip();
      }, BN.prototype.ior = function ior(num) {
        return assert((this.negative | num.negative) === 0), this.iuor(num);
      }, BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      }, BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      }, BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length)
          b = num;
        else
          b = this;
        for (var i2 = 0;i2 < b.length; i2++)
          this.words[i2] = this.words[i2] & num.words[i2];
        return this.length = b.length, this.strip();
      }, BN.prototype.iand = function iand(num) {
        return assert((this.negative | num.negative) === 0), this.iuand(num);
      }, BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      }, BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      }, BN.prototype.iuxor = function iuxor(num) {
        var a, b;
        if (this.length > num.length)
          a = this, b = num;
        else
          a = num, b = this;
        for (var i2 = 0;i2 < b.length; i2++)
          this.words[i2] = a.words[i2] ^ b.words[i2];
        if (this !== a)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        return this.length = a.length, this.strip();
      }, BN.prototype.ixor = function ixor(num) {
        return assert((this.negative | num.negative) === 0), this.iuxor(num);
      }, BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      }, BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      }, BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0, bitsLeft = width % 26;
        if (this._expand(bytesNeeded), bitsLeft > 0)
          bytesNeeded--;
        for (var i2 = 0;i2 < bytesNeeded; i2++)
          this.words[i2] = ~this.words[i2] & 67108863;
        if (bitsLeft > 0)
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        return this.strip();
      }, BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      }, BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0, wbit = bit % 26;
        if (this._expand(off + 1), val)
          this.words[off] = this.words[off] | 1 << wbit;
        else
          this.words[off] = this.words[off] & ~(1 << wbit);
        return this.strip();
      }, BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0)
          return this.negative = 0, r = this.isub(num), this.negative ^= 1, this._normSign();
        else if (this.negative === 0 && num.negative !== 0)
          return num.negative = 0, r = this.isub(num), num.negative = 1, r._normSign();
        var a, b;
        if (this.length > num.length)
          a = this, b = num;
        else
          a = num, b = this;
        var carry = 0;
        for (var i2 = 0;i2 < b.length; i2++)
          r = (a.words[i2] | 0) + (b.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
        for (;carry !== 0 && i2 < a.length; i2++)
          r = (a.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
        if (this.length = a.length, carry !== 0)
          this.words[this.length] = carry, this.length++;
        else if (a !== this)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        return this;
      }, BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0)
          return num.negative = 0, res = this.sub(num), num.negative ^= 1, res;
        else if (num.negative === 0 && this.negative !== 0)
          return this.negative = 0, res = num.sub(this), this.negative = 1, res;
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      }, BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          return num.negative = 1, r._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(num), this.negative = 1, this._normSign();
        var cmp = this.cmp(num);
        if (cmp === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var a, b;
        if (cmp > 0)
          a = this, b = num;
        else
          a = num, b = this;
        var carry = 0;
        for (var i2 = 0;i2 < b.length; i2++)
          r = (a.words[i2] | 0) - (b.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
        for (;carry !== 0 && i2 < a.length; i2++)
          r = (a.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
        if (carry === 0 && i2 < a.length && a !== this)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        if (this.length = Math.max(this.length, i2), a !== this)
          this.negative = 1;
        return this.strip();
      }, BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len2 = self2.length + num.length | 0;
        out.length = len2, len2 = len2 - 1 | 0;
        var a = self2.words[0] | 0, b = num.words[0] | 0, r = a * b, lo = r & 67108863, carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k4 = 1;k4 < len2; k4++) {
          var ncarry = carry >>> 26, rword = carry & 67108863, maxJ = Math.min(k4, num.length - 1);
          for (var j3 = Math.max(0, k4 - self2.length + 1);j3 <= maxJ; j3++) {
            var i2 = k4 - j3 | 0;
            a = self2.words[i2] | 0, b = num.words[j3] | 0, r = a * b + rword, ncarry += r / 67108864 | 0, rword = r & 67108863;
          }
          out.words[k4] = rword | 0, carry = ncarry | 0;
        }
        if (carry !== 0)
          out.words[k4] = carry | 0;
        else
          out.length--;
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo(self2, num, out) {
        var a = self2.words, b = num.words, o = out.words, c = 0, lo, mid, hi2, a0 = a[0] | 0, al0 = a0 & 8191, ah0 = a0 >>> 13, a1 = a[1] | 0, al1 = a1 & 8191, ah1 = a1 >>> 13, a2 = a[2] | 0, al2 = a2 & 8191, ah2 = a2 >>> 13, a3 = a[3] | 0, al3 = a3 & 8191, ah3 = a3 >>> 13, a4 = a[4] | 0, al4 = a4 & 8191, ah4 = a4 >>> 13, a5 = a[5] | 0, al5 = a5 & 8191, ah5 = a5 >>> 13, a6 = a[6] | 0, al6 = a6 & 8191, ah6 = a6 >>> 13, a7 = a[7] | 0, al7 = a7 & 8191, ah7 = a7 >>> 13, a8 = a[8] | 0, al8 = a8 & 8191, ah8 = a8 >>> 13, a9 = a[9] | 0, al9 = a9 & 8191, ah9 = a9 >>> 13, b0 = b[0] | 0, bl0 = b0 & 8191, bh0 = b0 >>> 13, b1 = b[1] | 0, bl1 = b1 & 8191, bh1 = b1 >>> 13, b2 = b[2] | 0, bl2 = b2 & 8191, bh2 = b2 >>> 13, b3 = b[3] | 0, bl3 = b3 & 8191, bh3 = b3 >>> 13, b4 = b[4] | 0, bl4 = b4 & 8191, bh4 = b4 >>> 13, b5 = b[5] | 0, bl5 = b5 & 8191, bh5 = b5 >>> 13, b6 = b[6] | 0, bl6 = b6 & 8191, bh6 = b6 >>> 13, b7 = b[7] | 0, bl7 = b7 & 8191, bh7 = b7 >>> 13, b8 = b[8] | 0, bl8 = b8 & 8191, bh8 = b8 >>> 13, b9 = b[9] | 0, bl9 = b9 & 8191, bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative, out.length = 19, lo = Math.imul(al0, bl0), mid = Math.imul(al0, bh0), mid = mid + Math.imul(ah0, bl0) | 0, hi2 = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w0 >>> 26) | 0, w0 &= 67108863, lo = Math.imul(al1, bl0), mid = Math.imul(al1, bh0), mid = mid + Math.imul(ah1, bl0) | 0, hi2 = Math.imul(ah1, bh0), lo = lo + Math.imul(al0, bl1) | 0, mid = mid + Math.imul(al0, bh1) | 0, mid = mid + Math.imul(ah0, bl1) | 0, hi2 = hi2 + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w1 >>> 26) | 0, w1 &= 67108863, lo = Math.imul(al2, bl0), mid = Math.imul(al2, bh0), mid = mid + Math.imul(ah2, bl0) | 0, hi2 = Math.imul(ah2, bh0), lo = lo + Math.imul(al1, bl1) | 0, mid = mid + Math.imul(al1, bh1) | 0, mid = mid + Math.imul(ah1, bl1) | 0, hi2 = hi2 + Math.imul(ah1, bh1) | 0, lo = lo + Math.imul(al0, bl2) | 0, mid = mid + Math.imul(al0, bh2) | 0, mid = mid + Math.imul(ah0, bl2) | 0, hi2 = hi2 + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w2 >>> 26) | 0, w2 &= 67108863, lo = Math.imul(al3, bl0), mid = Math.imul(al3, bh0), mid = mid + Math.imul(ah3, bl0) | 0, hi2 = Math.imul(ah3, bh0), lo = lo + Math.imul(al2, bl1) | 0, mid = mid + Math.imul(al2, bh1) | 0, mid = mid + Math.imul(ah2, bl1) | 0, hi2 = hi2 + Math.imul(ah2, bh1) | 0, lo = lo + Math.imul(al1, bl2) | 0, mid = mid + Math.imul(al1, bh2) | 0, mid = mid + Math.imul(ah1, bl2) | 0, hi2 = hi2 + Math.imul(ah1, bh2) | 0, lo = lo + Math.imul(al0, bl3) | 0, mid = mid + Math.imul(al0, bh3) | 0, mid = mid + Math.imul(ah0, bl3) | 0, hi2 = hi2 + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w3 >>> 26) | 0, w3 &= 67108863, lo = Math.imul(al4, bl0), mid = Math.imul(al4, bh0), mid = mid + Math.imul(ah4, bl0) | 0, hi2 = Math.imul(ah4, bh0), lo = lo + Math.imul(al3, bl1) | 0, mid = mid + Math.imul(al3, bh1) | 0, mid = mid + Math.imul(ah3, bl1) | 0, hi2 = hi2 + Math.imul(ah3, bh1) | 0, lo = lo + Math.imul(al2, bl2) | 0, mid = mid + Math.imul(al2, bh2) | 0, mid = mid + Math.imul(ah2, bl2) | 0, hi2 = hi2 + Math.imul(ah2, bh2) | 0, lo = lo + Math.imul(al1, bl3) | 0, mid = mid + Math.imul(al1, bh3) | 0, mid = mid + Math.imul(ah1, bl3) | 0, hi2 = hi2 + Math.imul(ah1, bh3) | 0, lo = lo + Math.imul(al0, bl4) | 0, mid = mid + Math.imul(al0, bh4) | 0, mid = mid + Math.imul(ah0, bl4) | 0, hi2 = hi2 + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w4 >>> 26) | 0, w4 &= 67108863, lo = Math.imul(al5, bl0), mid = Math.imul(al5, bh0), mid = mid + Math.imul(ah5, bl0) | 0, hi2 = Math.imul(ah5, bh0), lo = lo + Math.imul(al4, bl1) | 0, mid = mid + Math.imul(al4, bh1) | 0, mid = mid + Math.imul(ah4, bl1) | 0, hi2 = hi2 + Math.imul(ah4, bh1) | 0, lo = lo + Math.imul(al3, bl2) | 0, mid = mid + Math.imul(al3, bh2) | 0, mid = mid + Math.imul(ah3, bl2) | 0, hi2 = hi2 + Math.imul(ah3, bh2) | 0, lo = lo + Math.imul(al2, bl3) | 0, mid = mid + Math.imul(al2, bh3) | 0, mid = mid + Math.imul(ah2, bl3) | 0, hi2 = hi2 + Math.imul(ah2, bh3) | 0, lo = lo + Math.imul(al1, bl4) | 0, mid = mid + Math.imul(al1, bh4) | 0, mid = mid + Math.imul(ah1, bl4) | 0, hi2 = hi2 + Math.imul(ah1, bh4) | 0, lo = lo + Math.imul(al0, bl5) | 0, mid = mid + Math.imul(al0, bh5) | 0, mid = mid + Math.imul(ah0, bl5) | 0, hi2 = hi2 + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w5 >>> 26) | 0, w5 &= 67108863, lo = Math.imul(al6, bl0), mid = Math.imul(al6, bh0), mid = mid + Math.imul(ah6, bl0) | 0, hi2 = Math.imul(ah6, bh0), lo = lo + Math.imul(al5, bl1) | 0, mid = mid + Math.imul(al5, bh1) | 0, mid = mid + Math.imul(ah5, bl1) | 0, hi2 = hi2 + Math.imul(ah5, bh1) | 0, lo = lo + Math.imul(al4, bl2) | 0, mid = mid + Math.imul(al4, bh2) | 0, mid = mid + Math.imul(ah4, bl2) | 0, hi2 = hi2 + Math.imul(ah4, bh2) | 0, lo = lo + Math.imul(al3, bl3) | 0, mid = mid + Math.imul(al3, bh3) | 0, mid = mid + Math.imul(ah3, bl3) | 0, hi2 = hi2 + Math.imul(ah3, bh3) | 0, lo = lo + Math.imul(al2, bl4) | 0, mid = mid + Math.imul(al2, bh4) | 0, mid = mid + Math.imul(ah2, bl4) | 0, hi2 = hi2 + Math.imul(ah2, bh4) | 0, lo = lo + Math.imul(al1, bl5) | 0, mid = mid + Math.imul(al1, bh5) | 0, mid = mid + Math.imul(ah1, bl5) | 0, hi2 = hi2 + Math.imul(ah1, bh5) | 0, lo = lo + Math.imul(al0, bl6) | 0, mid = mid + Math.imul(al0, bh6) | 0, mid = mid + Math.imul(ah0, bl6) | 0, hi2 = hi2 + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w6 >>> 26) | 0, w6 &= 67108863, lo = Math.imul(al7, bl0), mid = Math.imul(al7, bh0), mid = mid + Math.imul(ah7, bl0) | 0, hi2 = Math.imul(ah7, bh0), lo = lo + Math.imul(al6, bl1) | 0, mid = mid + Math.imul(al6, bh1) | 0, mid = mid + Math.imul(ah6, bl1) | 0, hi2 = hi2 + Math.imul(ah6, bh1) | 0, lo = lo + Math.imul(al5, bl2) | 0, mid = mid + Math.imul(al5, bh2) | 0, mid = mid + Math.imul(ah5, bl2) | 0, hi2 = hi2 + Math.imul(ah5, bh2) | 0, lo = lo + Math.imul(al4, bl3) | 0, mid = mid + Math.imul(al4, bh3) | 0, mid = mid + Math.imul(ah4, bl3) | 0, hi2 = hi2 + Math.imul(ah4, bh3) | 0, lo = lo + Math.imul(al3, bl4) | 0, mid = mid + Math.imul(al3, bh4) | 0, mid = mid + Math.imul(ah3, bl4) | 0, hi2 = hi2 + Math.imul(ah3, bh4) | 0, lo = lo + Math.imul(al2, bl5) | 0, mid = mid + Math.imul(al2, bh5) | 0, mid = mid + Math.imul(ah2, bl5) | 0, hi2 = hi2 + Math.imul(ah2, bh5) | 0, lo = lo + Math.imul(al1, bl6) | 0, mid = mid + Math.imul(al1, bh6) | 0, mid = mid + Math.imul(ah1, bl6) | 0, hi2 = hi2 + Math.imul(ah1, bh6) | 0, lo = lo + Math.imul(al0, bl7) | 0, mid = mid + Math.imul(al0, bh7) | 0, mid = mid + Math.imul(ah0, bl7) | 0, hi2 = hi2 + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w7 >>> 26) | 0, w7 &= 67108863, lo = Math.imul(al8, bl0), mid = Math.imul(al8, bh0), mid = mid + Math.imul(ah8, bl0) | 0, hi2 = Math.imul(ah8, bh0), lo = lo + Math.imul(al7, bl1) | 0, mid = mid + Math.imul(al7, bh1) | 0, mid = mid + Math.imul(ah7, bl1) | 0, hi2 = hi2 + Math.imul(ah7, bh1) | 0, lo = lo + Math.imul(al6, bl2) | 0, mid = mid + Math.imul(al6, bh2) | 0, mid = mid + Math.imul(ah6, bl2) | 0, hi2 = hi2 + Math.imul(ah6, bh2) | 0, lo = lo + Math.imul(al5, bl3) | 0, mid = mid + Math.imul(al5, bh3) | 0, mid = mid + Math.imul(ah5, bl3) | 0, hi2 = hi2 + Math.imul(ah5, bh3) | 0, lo = lo + Math.imul(al4, bl4) | 0, mid = mid + Math.imul(al4, bh4) | 0, mid = mid + Math.imul(ah4, bl4) | 0, hi2 = hi2 + Math.imul(ah4, bh4) | 0, lo = lo + Math.imul(al3, bl5) | 0, mid = mid + Math.imul(al3, bh5) | 0, mid = mid + Math.imul(ah3, bl5) | 0, hi2 = hi2 + Math.imul(ah3, bh5) | 0, lo = lo + Math.imul(al2, bl6) | 0, mid = mid + Math.imul(al2, bh6) | 0, mid = mid + Math.imul(ah2, bl6) | 0, hi2 = hi2 + Math.imul(ah2, bh6) | 0, lo = lo + Math.imul(al1, bl7) | 0, mid = mid + Math.imul(al1, bh7) | 0, mid = mid + Math.imul(ah1, bl7) | 0, hi2 = hi2 + Math.imul(ah1, bh7) | 0, lo = lo + Math.imul(al0, bl8) | 0, mid = mid + Math.imul(al0, bh8) | 0, mid = mid + Math.imul(ah0, bl8) | 0, hi2 = hi2 + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0, w8 &= 67108863, lo = Math.imul(al9, bl0), mid = Math.imul(al9, bh0), mid = mid + Math.imul(ah9, bl0) | 0, hi2 = Math.imul(ah9, bh0), lo = lo + Math.imul(al8, bl1) | 0, mid = mid + Math.imul(al8, bh1) | 0, mid = mid + Math.imul(ah8, bl1) | 0, hi2 = hi2 + Math.imul(ah8, bh1) | 0, lo = lo + Math.imul(al7, bl2) | 0, mid = mid + Math.imul(al7, bh2) | 0, mid = mid + Math.imul(ah7, bl2) | 0, hi2 = hi2 + Math.imul(ah7, bh2) | 0, lo = lo + Math.imul(al6, bl3) | 0, mid = mid + Math.imul(al6, bh3) | 0, mid = mid + Math.imul(ah6, bl3) | 0, hi2 = hi2 + Math.imul(ah6, bh3) | 0, lo = lo + Math.imul(al5, bl4) | 0, mid = mid + Math.imul(al5, bh4) | 0, mid = mid + Math.imul(ah5, bl4) | 0, hi2 = hi2 + Math.imul(ah5, bh4) | 0, lo = lo + Math.imul(al4, bl5) | 0, mid = mid + Math.imul(al4, bh5) | 0, mid = mid + Math.imul(ah4, bl5) | 0, hi2 = hi2 + Math.imul(ah4, bh5) | 0, lo = lo + Math.imul(al3, bl6) | 0, mid = mid + Math.imul(al3, bh6) | 0, mid = mid + Math.imul(ah3, bl6) | 0, hi2 = hi2 + Math.imul(ah3, bh6) | 0, lo = lo + Math.imul(al2, bl7) | 0, mid = mid + Math.imul(al2, bh7) | 0, mid = mid + Math.imul(ah2, bl7) | 0, hi2 = hi2 + Math.imul(ah2, bh7) | 0, lo = lo + Math.imul(al1, bl8) | 0, mid = mid + Math.imul(al1, bh8) | 0, mid = mid + Math.imul(ah1, bl8) | 0, hi2 = hi2 + Math.imul(ah1, bh8) | 0, lo = lo + Math.imul(al0, bl9) | 0, mid = mid + Math.imul(al0, bh9) | 0, mid = mid + Math.imul(ah0, bl9) | 0, hi2 = hi2 + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0, w9 &= 67108863, lo = Math.imul(al9, bl1), mid = Math.imul(al9, bh1), mid = mid + Math.imul(ah9, bl1) | 0, hi2 = Math.imul(ah9, bh1), lo = lo + Math.imul(al8, bl2) | 0, mid = mid + Math.imul(al8, bh2) | 0, mid = mid + Math.imul(ah8, bl2) | 0, hi2 = hi2 + Math.imul(ah8, bh2) | 0, lo = lo + Math.imul(al7, bl3) | 0, mid = mid + Math.imul(al7, bh3) | 0, mid = mid + Math.imul(ah7, bl3) | 0, hi2 = hi2 + Math.imul(ah7, bh3) | 0, lo = lo + Math.imul(al6, bl4) | 0, mid = mid + Math.imul(al6, bh4) | 0, mid = mid + Math.imul(ah6, bl4) | 0, hi2 = hi2 + Math.imul(ah6, bh4) | 0, lo = lo + Math.imul(al5, bl5) | 0, mid = mid + Math.imul(al5, bh5) | 0, mid = mid + Math.imul(ah5, bl5) | 0, hi2 = hi2 + Math.imul(ah5, bh5) | 0, lo = lo + Math.imul(al4, bl6) | 0, mid = mid + Math.imul(al4, bh6) | 0, mid = mid + Math.imul(ah4, bl6) | 0, hi2 = hi2 + Math.imul(ah4, bh6) | 0, lo = lo + Math.imul(al3, bl7) | 0, mid = mid + Math.imul(al3, bh7) | 0, mid = mid + Math.imul(ah3, bl7) | 0, hi2 = hi2 + Math.imul(ah3, bh7) | 0, lo = lo + Math.imul(al2, bl8) | 0, mid = mid + Math.imul(al2, bh8) | 0, mid = mid + Math.imul(ah2, bl8) | 0, hi2 = hi2 + Math.imul(ah2, bh8) | 0, lo = lo + Math.imul(al1, bl9) | 0, mid = mid + Math.imul(al1, bh9) | 0, mid = mid + Math.imul(ah1, bl9) | 0, hi2 = hi2 + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0, w10 &= 67108863, lo = Math.imul(al9, bl2), mid = Math.imul(al9, bh2), mid = mid + Math.imul(ah9, bl2) | 0, hi2 = Math.imul(ah9, bh2), lo = lo + Math.imul(al8, bl3) | 0, mid = mid + Math.imul(al8, bh3) | 0, mid = mid + Math.imul(ah8, bl3) | 0, hi2 = hi2 + Math.imul(ah8, bh3) | 0, lo = lo + Math.imul(al7, bl4) | 0, mid = mid + Math.imul(al7, bh4) | 0, mid = mid + Math.imul(ah7, bl4) | 0, hi2 = hi2 + Math.imul(ah7, bh4) | 0, lo = lo + Math.imul(al6, bl5) | 0, mid = mid + Math.imul(al6, bh5) | 0, mid = mid + Math.imul(ah6, bl5) | 0, hi2 = hi2 + Math.imul(ah6, bh5) | 0, lo = lo + Math.imul(al5, bl6) | 0, mid = mid + Math.imul(al5, bh6) | 0, mid = mid + Math.imul(ah5, bl6) | 0, hi2 = hi2 + Math.imul(ah5, bh6) | 0, lo = lo + Math.imul(al4, bl7) | 0, mid = mid + Math.imul(al4, bh7) | 0, mid = mid + Math.imul(ah4, bl7) | 0, hi2 = hi2 + Math.imul(ah4, bh7) | 0, lo = lo + Math.imul(al3, bl8) | 0, mid = mid + Math.imul(al3, bh8) | 0, mid = mid + Math.imul(ah3, bl8) | 0, hi2 = hi2 + Math.imul(ah3, bh8) | 0, lo = lo + Math.imul(al2, bl9) | 0, mid = mid + Math.imul(al2, bh9) | 0, mid = mid + Math.imul(ah2, bl9) | 0, hi2 = hi2 + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0, w11 &= 67108863, lo = Math.imul(al9, bl3), mid = Math.imul(al9, bh3), mid = mid + Math.imul(ah9, bl3) | 0, hi2 = Math.imul(ah9, bh3), lo = lo + Math.imul(al8, bl4) | 0, mid = mid + Math.imul(al8, bh4) | 0, mid = mid + Math.imul(ah8, bl4) | 0, hi2 = hi2 + Math.imul(ah8, bh4) | 0, lo = lo + Math.imul(al7, bl5) | 0, mid = mid + Math.imul(al7, bh5) | 0, mid = mid + Math.imul(ah7, bl5) | 0, hi2 = hi2 + Math.imul(ah7, bh5) | 0, lo = lo + Math.imul(al6, bl6) | 0, mid = mid + Math.imul(al6, bh6) | 0, mid = mid + Math.imul(ah6, bl6) | 0, hi2 = hi2 + Math.imul(ah6, bh6) | 0, lo = lo + Math.imul(al5, bl7) | 0, mid = mid + Math.imul(al5, bh7) | 0, mid = mid + Math.imul(ah5, bl7) | 0, hi2 = hi2 + Math.imul(ah5, bh7) | 0, lo = lo + Math.imul(al4, bl8) | 0, mid = mid + Math.imul(al4, bh8) | 0, mid = mid + Math.imul(ah4, bl8) | 0, hi2 = hi2 + Math.imul(ah4, bh8) | 0, lo = lo + Math.imul(al3, bl9) | 0, mid = mid + Math.imul(al3, bh9) | 0, mid = mid + Math.imul(ah3, bl9) | 0, hi2 = hi2 + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0, w12 &= 67108863, lo = Math.imul(al9, bl4), mid = Math.imul(al9, bh4), mid = mid + Math.imul(ah9, bl4) | 0, hi2 = Math.imul(ah9, bh4), lo = lo + Math.imul(al8, bl5) | 0, mid = mid + Math.imul(al8, bh5) | 0, mid = mid + Math.imul(ah8, bl5) | 0, hi2 = hi2 + Math.imul(ah8, bh5) | 0, lo = lo + Math.imul(al7, bl6) | 0, mid = mid + Math.imul(al7, bh6) | 0, mid = mid + Math.imul(ah7, bl6) | 0, hi2 = hi2 + Math.imul(ah7, bh6) | 0, lo = lo + Math.imul(al6, bl7) | 0, mid = mid + Math.imul(al6, bh7) | 0, mid = mid + Math.imul(ah6, bl7) | 0, hi2 = hi2 + Math.imul(ah6, bh7) | 0, lo = lo + Math.imul(al5, bl8) | 0, mid = mid + Math.imul(al5, bh8) | 0, mid = mid + Math.imul(ah5, bl8) | 0, hi2 = hi2 + Math.imul(ah5, bh8) | 0, lo = lo + Math.imul(al4, bl9) | 0, mid = mid + Math.imul(al4, bh9) | 0, mid = mid + Math.imul(ah4, bl9) | 0, hi2 = hi2 + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0, w13 &= 67108863, lo = Math.imul(al9, bl5), mid = Math.imul(al9, bh5), mid = mid + Math.imul(ah9, bl5) | 0, hi2 = Math.imul(ah9, bh5), lo = lo + Math.imul(al8, bl6) | 0, mid = mid + Math.imul(al8, bh6) | 0, mid = mid + Math.imul(ah8, bl6) | 0, hi2 = hi2 + Math.imul(ah8, bh6) | 0, lo = lo + Math.imul(al7, bl7) | 0, mid = mid + Math.imul(al7, bh7) | 0, mid = mid + Math.imul(ah7, bl7) | 0, hi2 = hi2 + Math.imul(ah7, bh7) | 0, lo = lo + Math.imul(al6, bl8) | 0, mid = mid + Math.imul(al6, bh8) | 0, mid = mid + Math.imul(ah6, bl8) | 0, hi2 = hi2 + Math.imul(ah6, bh8) | 0, lo = lo + Math.imul(al5, bl9) | 0, mid = mid + Math.imul(al5, bh9) | 0, mid = mid + Math.imul(ah5, bl9) | 0, hi2 = hi2 + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0, w14 &= 67108863, lo = Math.imul(al9, bl6), mid = Math.imul(al9, bh6), mid = mid + Math.imul(ah9, bl6) | 0, hi2 = Math.imul(ah9, bh6), lo = lo + Math.imul(al8, bl7) | 0, mid = mid + Math.imul(al8, bh7) | 0, mid = mid + Math.imul(ah8, bl7) | 0, hi2 = hi2 + Math.imul(ah8, bh7) | 0, lo = lo + Math.imul(al7, bl8) | 0, mid = mid + Math.imul(al7, bh8) | 0, mid = mid + Math.imul(ah7, bl8) | 0, hi2 = hi2 + Math.imul(ah7, bh8) | 0, lo = lo + Math.imul(al6, bl9) | 0, mid = mid + Math.imul(al6, bh9) | 0, mid = mid + Math.imul(ah6, bl9) | 0, hi2 = hi2 + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0, w15 &= 67108863, lo = Math.imul(al9, bl7), mid = Math.imul(al9, bh7), mid = mid + Math.imul(ah9, bl7) | 0, hi2 = Math.imul(ah9, bh7), lo = lo + Math.imul(al8, bl8) | 0, mid = mid + Math.imul(al8, bh8) | 0, mid = mid + Math.imul(ah8, bl8) | 0, hi2 = hi2 + Math.imul(ah8, bh8) | 0, lo = lo + Math.imul(al7, bl9) | 0, mid = mid + Math.imul(al7, bh9) | 0, mid = mid + Math.imul(ah7, bl9) | 0, hi2 = hi2 + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0, w16 &= 67108863, lo = Math.imul(al9, bl8), mid = Math.imul(al9, bh8), mid = mid + Math.imul(ah9, bl8) | 0, hi2 = Math.imul(ah9, bh8), lo = lo + Math.imul(al8, bl9) | 0, mid = mid + Math.imul(al8, bh9) | 0, mid = mid + Math.imul(ah8, bl9) | 0, hi2 = hi2 + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0, w17 &= 67108863, lo = Math.imul(al9, bl9), mid = Math.imul(al9, bh9), mid = mid + Math.imul(ah9, bl9) | 0, hi2 = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        if (c = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0, w18 &= 67108863, o[0] = w0, o[1] = w1, o[2] = w2, o[3] = w3, o[4] = w4, o[5] = w5, o[6] = w6, o[7] = w7, o[8] = w8, o[9] = w9, o[10] = w10, o[11] = w11, o[12] = w12, o[13] = w13, o[14] = w14, o[15] = w15, o[16] = w16, o[17] = w17, o[18] = w18, c !== 0)
          o[19] = c, out.length++;
        return out;
      };
      if (!Math.imul)
        comb10MulTo = smallMulTo;
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative, out.length = self2.length + num.length;
        var carry = 0, hncarry = 0;
        for (var k4 = 0;k4 < out.length - 1; k4++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863, maxJ = Math.min(k4, num.length - 1);
          for (var j3 = Math.max(0, k4 - self2.length + 1);j3 <= maxJ; j3++) {
            var i2 = k4 - j3, a = self2.words[i2] | 0, b = num.words[j3] | 0, r = a * b, lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0, lo = lo + rword | 0, rword = lo & 67108863, ncarry = ncarry + (lo >>> 26) | 0, hncarry += ncarry >>> 26, ncarry &= 67108863;
          }
          out.words[k4] = rword, carry = ncarry, ncarry = hncarry;
        }
        if (carry !== 0)
          out.words[k4] = carry;
        else
          out.length--;
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM;
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res, len2 = this.length + num.length;
        if (this.length === 10 && num.length === 10)
          res = comb10MulTo(this, num, out);
        else if (len2 < 63)
          res = smallMulTo(this, num, out);
        else if (len2 < 1024)
          res = bigMulTo(this, num, out);
        else
          res = jumboMulTo(this, num, out);
        return res;
      };
      function FFTM(x4, y) {
        this.x = x4, this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N3) {
        var t2 = new Array(N3), l3 = BN.prototype._countBits(N3) - 1;
        for (var i2 = 0;i2 < N3; i2++)
          t2[i2] = this.revBin(i2, l3, N3);
        return t2;
      }, FFTM.prototype.revBin = function revBin(x4, l3, N3) {
        if (x4 === 0 || x4 === N3 - 1)
          return x4;
        var rb = 0;
        for (var i2 = 0;i2 < l3; i2++)
          rb |= (x4 & 1) << l3 - i2 - 1, x4 >>= 1;
        return rb;
      }, FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N3) {
        for (var i2 = 0;i2 < N3; i2++)
          rtws[i2] = rws[rbt[i2]], itws[i2] = iws[rbt[i2]];
      }, FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N3, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N3);
        for (var s3 = 1;s3 < N3; s3 <<= 1) {
          var l3 = s3 << 1, rtwdf = Math.cos(2 * Math.PI / l3), itwdf = Math.sin(2 * Math.PI / l3);
          for (var p2 = 0;p2 < N3; p2 += l3) {
            var rtwdf_ = rtwdf, itwdf_ = itwdf;
            for (var j3 = 0;j3 < s3; j3++) {
              var re2 = rtws[p2 + j3], ie4 = itws[p2 + j3], ro = rtws[p2 + j3 + s3], io = itws[p2 + j3 + s3], rx = rtwdf_ * ro - itwdf_ * io;
              if (io = rtwdf_ * io + itwdf_ * ro, ro = rx, rtws[p2 + j3] = re2 + ro, itws[p2 + j3] = ie4 + io, rtws[p2 + j3 + s3] = re2 - ro, itws[p2 + j3 + s3] = ie4 - io, j3 !== l3)
                rx = rtwdf * rtwdf_ - itwdf * itwdf_, itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_, rtwdf_ = rx;
            }
          }
        }
      }, FFTM.prototype.guessLen13b = function guessLen13b(n, m2) {
        var N3 = Math.max(m2, n) | 1, odd = N3 & 1, i2 = 0;
        for (N3 = N3 / 2 | 0;N3; N3 = N3 >>> 1)
          i2++;
        return 1 << i2 + 1 + odd;
      }, FFTM.prototype.conjugate = function conjugate(rws, iws, N3) {
        if (N3 <= 1)
          return;
        for (var i2 = 0;i2 < N3 / 2; i2++) {
          var t2 = rws[i2];
          rws[i2] = rws[N3 - i2 - 1], rws[N3 - i2 - 1] = t2, t2 = iws[i2], iws[i2] = -iws[N3 - i2 - 1], iws[N3 - i2 - 1] = -t2;
        }
      }, FFTM.prototype.normalize13b = function normalize13b(ws, N3) {
        var carry = 0;
        for (var i2 = 0;i2 < N3 / 2; i2++) {
          var w = Math.round(ws[2 * i2 + 1] / N3) * 8192 + Math.round(ws[2 * i2] / N3) + carry;
          if (ws[i2] = w & 67108863, w < 67108864)
            carry = 0;
          else
            carry = w / 67108864 | 0;
        }
        return ws;
      }, FFTM.prototype.convert13b = function convert13b(ws, len2, rws, N3) {
        var carry = 0;
        for (var i2 = 0;i2 < len2; i2++)
          carry = carry + (ws[i2] | 0), rws[2 * i2] = carry & 8191, carry = carry >>> 13, rws[2 * i2 + 1] = carry & 8191, carry = carry >>> 13;
        for (i2 = 2 * len2;i2 < N3; ++i2)
          rws[i2] = 0;
        assert(carry === 0), assert((carry & -8192) === 0);
      }, FFTM.prototype.stub = function stub(N3) {
        var ph = new Array(N3);
        for (var i2 = 0;i2 < N3; i2++)
          ph[i2] = 0;
        return ph;
      }, FFTM.prototype.mulp = function mulp(x4, y, out) {
        var N3 = 2 * this.guessLen13b(x4.length, y.length), rbt = this.makeRBT(N3), _3 = this.stub(N3), rws = new Array(N3), rwst = new Array(N3), iwst = new Array(N3), nrws = new Array(N3), nrwst = new Array(N3), niwst = new Array(N3), rmws = out.words;
        rmws.length = N3, this.convert13b(x4.words, x4.length, rws, N3), this.convert13b(y.words, y.length, nrws, N3), this.transform(rws, _3, rwst, iwst, N3, rbt), this.transform(nrws, _3, nrwst, niwst, N3, rbt);
        for (var i2 = 0;i2 < N3; i2++) {
          var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
          iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2], rwst[i2] = rx;
        }
        return this.conjugate(rwst, iwst, N3), this.transform(rwst, iwst, rmws, _3, N3, rbt), this.conjugate(rmws, _3, N3), this.normalize13b(rmws, N3), out.negative = x4.negative ^ y.negative, out.length = x4.length + y.length, out.strip();
      }, BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        return out.words = new Array(this.length + num.length), this.mulTo(num, out);
      }, BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        return out.words = new Array(this.length + num.length), jumboMulTo(this, num, out);
      }, BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      }, BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number"), assert(num < 67108864);
        var carry = 0;
        for (var i2 = 0;i2 < this.length; i2++) {
          var w = (this.words[i2] | 0) * num, lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26, carry += w / 67108864 | 0, carry += lo >>> 26, this.words[i2] = lo & 67108863;
        }
        if (carry !== 0)
          this.words[i2] = carry, this.length++;
        return this.length = num === 0 ? 1 : this.length, this;
      }, BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      }, BN.prototype.sqr = function sqr() {
        return this.mul(this);
      }, BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      }, BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i2 = 0;i2 < w.length; i2++, res = res.sqr())
          if (w[i2] !== 0)
            break;
        if (++i2 < w.length)
          for (var q3 = res.sqr();i2 < w.length; i2++, q3 = q3.sqr()) {
            if (w[i2] === 0)
              continue;
            res = res.mul(q3);
          }
        return res;
      }, BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26, s3 = (bits - r) / 26, carryMask = 67108863 >>> 26 - r << 26 - r, i2;
        if (r !== 0) {
          var carry = 0;
          for (i2 = 0;i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask, c = (this.words[i2] | 0) - newCarry << r;
            this.words[i2] = c | carry, carry = newCarry >>> 26 - r;
          }
          if (carry)
            this.words[i2] = carry, this.length++;
        }
        if (s3 !== 0) {
          for (i2 = this.length - 1;i2 >= 0; i2--)
            this.words[i2 + s3] = this.words[i2];
          for (i2 = 0;i2 < s3; i2++)
            this.words[i2] = 0;
          this.length += s3;
        }
        return this.strip();
      }, BN.prototype.ishln = function ishln(bits) {
        return assert(this.negative === 0), this.iushln(bits);
      }, BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint)
          h = (hint - hint % 26) / 26;
        else
          h = 0;
        var r = bits % 26, s3 = Math.min((bits - r) / 26, this.length), mask = 67108863 ^ 67108863 >>> r << r, maskedWords = extended;
        if (h -= s3, h = Math.max(0, h), maskedWords) {
          for (var i2 = 0;i2 < s3; i2++)
            maskedWords.words[i2] = this.words[i2];
          maskedWords.length = s3;
        }
        if (s3 === 0)
          ;
        else if (this.length > s3) {
          this.length -= s3;
          for (i2 = 0;i2 < this.length; i2++)
            this.words[i2] = this.words[i2 + s3];
        } else
          this.words[0] = 0, this.length = 1;
        var carry = 0;
        for (i2 = this.length - 1;i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r | word >>> r, carry = word & mask;
        }
        if (maskedWords && carry !== 0)
          maskedWords.words[maskedWords.length++] = carry;
        if (this.length === 0)
          this.words[0] = 0, this.length = 1;
        return this.strip();
      }, BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        return assert(this.negative === 0), this.iushrn(bits, hint, extended);
      }, BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      }, BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      }, BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      }, BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      }, BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26, s3 = (bit - r) / 26, q3 = 1 << r;
        if (this.length <= s3)
          return false;
        var w = this.words[s3];
        return !!(w & q3);
      }, BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26, s3 = (bits - r) / 26;
        if (assert(this.negative === 0, "imaskn works only with positive numbers"), this.length <= s3)
          return this;
        if (r !== 0)
          s3++;
        if (this.length = Math.min(s3, this.length), r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      }, BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      }, BN.prototype.iaddn = function iaddn(num) {
        if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num)
            return this.words[0] = num - (this.words[0] | 0), this.negative = 0, this;
          return this.negative = 0, this.isubn(num), this.negative = 1, this;
        }
        return this._iaddn(num);
      }, BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0;i2 < this.length && this.words[i2] >= 67108864; i2++)
          if (this.words[i2] -= 67108864, i2 === this.length - 1)
            this.words[i2 + 1] = 1;
          else
            this.words[i2 + 1]++;
        return this.length = Math.max(this.length, i2 + 1), this;
      }, BN.prototype.isubn = function isubn(num) {
        if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(num), this.negative = 1, this;
        if (this.words[0] -= num, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var i2 = 0;i2 < this.length && this.words[i2] < 0; i2++)
            this.words[i2] += 67108864, this.words[i2 + 1] -= 1;
        return this.strip();
      }, BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      }, BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      }, BN.prototype.iabs = function iabs() {
        return this.negative = 0, this;
      }, BN.prototype.abs = function abs() {
        return this.clone().iabs();
      }, BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len2 = num.length + shift, i2;
        this._expand(len2);
        var w, carry = 0;
        for (i2 = 0;i2 < num.length; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul;
          w -= right & 67108863, carry = (w >> 26) - (right / 67108864 | 0), this.words[i2 + shift] = w & 67108863;
        }
        for (;i2 < this.length - shift; i2++)
          w = (this.words[i2 + shift] | 0) + carry, carry = w >> 26, this.words[i2 + shift] = w & 67108863;
        if (carry === 0)
          return this.strip();
        assert(carry === -1), carry = 0;
        for (i2 = 0;i2 < this.length; i2++)
          w = -(this.words[i2] | 0) + carry, carry = w >> 26, this.words[i2] = w & 67108863;
        return this.negative = 1, this.strip();
      }, BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length, a = this.clone(), b = num, bhi = b.words[b.length - 1] | 0, bhiBits = this._countBits(bhi);
        if (shift = 26 - bhiBits, shift !== 0)
          b = b.ushln(shift), a.iushln(shift), bhi = b.words[b.length - 1] | 0;
        var m2 = a.length - b.length, q3;
        if (mode !== "mod") {
          q3 = new BN(null), q3.length = m2 + 1, q3.words = new Array(q3.length);
          for (var i2 = 0;i2 < q3.length; i2++)
            q3.words[i2] = 0;
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m2);
        if (diff.negative === 0) {
          if (a = diff, q3)
            q3.words[m2] = 1;
        }
        for (var j3 = m2 - 1;j3 >= 0; j3--) {
          var qj = (a.words[b.length + j3] | 0) * 67108864 + (a.words[b.length + j3 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863), a._ishlnsubmul(b, qj, j3);
          while (a.negative !== 0)
            if (qj--, a.negative = 0, a._ishlnsubmul(b, 1, j3), !a.isZero())
              a.negative ^= 1;
          if (q3)
            q3.words[j3] = qj;
        }
        if (q3)
          q3.strip();
        if (a.strip(), mode !== "div" && shift !== 0)
          a.iushrn(shift);
        return { div: q3 || null, mod: a };
      }, BN.prototype.divmod = function divmod(num, mode, positive) {
        if (assert(!num.isZero()), this.isZero())
          return { div: new BN(0), mod: new BN(0) };
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          if (res = this.neg().divmod(num, mode), mode !== "mod")
            div = res.div.neg();
          if (mode !== "div") {
            if (mod = res.mod.neg(), positive && mod.negative !== 0)
              mod.iadd(num);
          }
          return { div, mod };
        }
        if (this.negative === 0 && num.negative !== 0) {
          if (res = this.divmod(num.neg(), mode), mode !== "mod")
            div = res.div.neg();
          return { div, mod: res.mod };
        }
        if ((this.negative & num.negative) !== 0) {
          if (res = this.neg().divmod(num.neg(), mode), mode !== "div") {
            if (mod = res.mod.neg(), positive && mod.negative !== 0)
              mod.isub(num);
          }
          return { div: res.div, mod };
        }
        if (num.length > this.length || this.cmp(num) < 0)
          return { div: new BN(0), mod: this };
        if (num.length === 1) {
          if (mode === "div")
            return { div: this.divn(num.words[0]), mod: null };
          if (mode === "mod")
            return { div: null, mod: new BN(this.modn(num.words[0])) };
          return { div: this.divn(num.words[0]), mod: new BN(this.modn(num.words[0])) };
        }
        return this._wordDiv(num, mode);
      }, BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      }, BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      }, BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      }, BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod, half = num.ushrn(1), r2 = num.andln(1), cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      }, BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p2 = 67108864 % num, acc = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--)
          acc = (p2 * acc + (this.words[i2] | 0)) % num;
        return acc;
      }, BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--) {
          var w = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w / num | 0, carry = w % num;
        }
        return this.strip();
      }, BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      }, BN.prototype.egcd = function egcd(p2) {
        assert(p2.negative === 0), assert(!p2.isZero());
        var x4 = this, y = p2.clone();
        if (x4.negative !== 0)
          x4 = x4.umod(p2);
        else
          x4 = x4.clone();
        var A3 = new BN(1), B3 = new BN(0), C2 = new BN(0), D2 = new BN(1), g2 = 0;
        while (x4.isEven() && y.isEven())
          x4.iushrn(1), y.iushrn(1), ++g2;
        var yp = y.clone(), xp = x4.clone();
        while (!x4.isZero()) {
          for (var i2 = 0, im = 1;(x4.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            x4.iushrn(i2);
            while (i2-- > 0) {
              if (A3.isOdd() || B3.isOdd())
                A3.iadd(yp), B3.isub(xp);
              A3.iushrn(1), B3.iushrn(1);
            }
          }
          for (var j3 = 0, jm = 1;(y.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
            ;
          if (j3 > 0) {
            y.iushrn(j3);
            while (j3-- > 0) {
              if (C2.isOdd() || D2.isOdd())
                C2.iadd(yp), D2.isub(xp);
              C2.iushrn(1), D2.iushrn(1);
            }
          }
          if (x4.cmp(y) >= 0)
            x4.isub(y), A3.isub(C2), B3.isub(D2);
          else
            y.isub(x4), C2.isub(A3), D2.isub(B3);
        }
        return { a: C2, b: D2, gcd: y.iushln(g2) };
      }, BN.prototype._invmp = function _invmp(p2) {
        assert(p2.negative === 0), assert(!p2.isZero());
        var a = this, b = p2.clone();
        if (a.negative !== 0)
          a = a.umod(p2);
        else
          a = a.clone();
        var x1 = new BN(1), x22 = new BN(0), delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i2 = 0, im = 1;(a.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            a.iushrn(i2);
            while (i2-- > 0) {
              if (x1.isOdd())
                x1.iadd(delta);
              x1.iushrn(1);
            }
          }
          for (var j3 = 0, jm = 1;(b.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
            ;
          if (j3 > 0) {
            b.iushrn(j3);
            while (j3-- > 0) {
              if (x22.isOdd())
                x22.iadd(delta);
              x22.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0)
            a.isub(b), x1.isub(x22);
          else
            b.isub(a), x22.isub(x1);
        }
        var res;
        if (a.cmpn(1) === 0)
          res = x1;
        else
          res = x22;
        if (res.cmpn(0) < 0)
          res.iadd(p2);
        return res;
      }, BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone(), b = num.clone();
        a.negative = 0, b.negative = 0;
        for (var shift = 0;a.isEven() && b.isEven(); shift++)
          a.iushrn(1), b.iushrn(1);
        do {
          while (a.isEven())
            a.iushrn(1);
          while (b.isEven())
            b.iushrn(1);
          var r = a.cmp(b);
          if (r < 0) {
            var t2 = a;
            a = b, b = t2;
          } else if (r === 0 || b.cmpn(1) === 0)
            break;
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      }, BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      }, BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      }, BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      }, BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      }, BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26, s3 = (bit - r) / 26, q3 = 1 << r;
        if (this.length <= s3)
          return this._expand(s3 + 1), this.words[s3] |= q3, this;
        var carry = q3;
        for (var i2 = s3;carry !== 0 && i2 < this.length; i2++) {
          var w = this.words[i2] | 0;
          w += carry, carry = w >>> 26, w &= 67108863, this.words[i2] = w;
        }
        if (carry !== 0)
          this.words[i2] = carry, this.length++;
        return this;
      }, BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      }, BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1)
          res = 1;
        else {
          if (negative)
            num = -num;
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--) {
          var a = this.words[i2] | 0, b = num.words[i2] | 0;
          if (a === b)
            continue;
          if (a < b)
            res = -1;
          else if (a > b)
            res = 1;
          break;
        }
        return res;
      }, BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      }, BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      }, BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      }, BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      }, BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      }, BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      }, BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      }, BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      }, BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      }, BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      }, BN.red = function red(num) {
        return new Red(num);
      }, BN.prototype.toRed = function toRed(ctx) {
        return assert(!this.red, "Already a number in reduction context"), assert(this.negative === 0, "red works only with positives"), ctx.convertTo(this)._forceRed(ctx);
      }, BN.prototype.fromRed = function fromRed() {
        return assert(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, BN.prototype._forceRed = function _forceRed(ctx) {
        return this.red = ctx, this;
      }, BN.prototype.forceRed = function forceRed(ctx) {
        return assert(!this.red, "Already a number in reduction context"), this._forceRed(ctx);
      }, BN.prototype.redAdd = function redAdd(num) {
        return assert(this.red, "redAdd works only with red numbers"), this.red.add(this, num);
      }, BN.prototype.redIAdd = function redIAdd(num) {
        return assert(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, num);
      }, BN.prototype.redSub = function redSub(num) {
        return assert(this.red, "redSub works only with red numbers"), this.red.sub(this, num);
      }, BN.prototype.redISub = function redISub(num) {
        return assert(this.red, "redISub works only with red numbers"), this.red.isub(this, num);
      }, BN.prototype.redShl = function redShl(num) {
        return assert(this.red, "redShl works only with red numbers"), this.red.shl(this, num);
      }, BN.prototype.redMul = function redMul(num) {
        return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.mul(this, num);
      }, BN.prototype.redIMul = function redIMul(num) {
        return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.imul(this, num);
      }, BN.prototype.redSqr = function redSqr() {
        return assert(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, BN.prototype.redISqr = function redISqr() {
        return assert(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, BN.prototype.redSqrt = function redSqrt() {
        return assert(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, BN.prototype.redInvm = function redInvm() {
        return assert(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, BN.prototype.redNeg = function redNeg() {
        return assert(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, BN.prototype.redPow = function redPow(num) {
        return assert(this.red && !num.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, num);
      };
      var primes = { k256: null, p224: null, p192: null, p25519: null };
      function MPrime(name, p2) {
        this.name = name, this.p = new BN(p2, 16), this.n = this.p.bitLength(), this.k = new BN(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        return tmp.words = new Array(Math.ceil(this.n / 13)), tmp;
      }, MPrime.prototype.ireduce = function ireduce(num) {
        var r = num, rlen;
        do
          this.split(r, this.tmp), r = this.imulK(r), r = r.iadd(this.tmp), rlen = r.bitLength();
        while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0)
          r.words[0] = 0, r.length = 1;
        else if (cmp > 0)
          r.isub(this.p);
        else if (r.strip !== undefined)
          r.strip();
        else
          r._strip();
        return r;
      }, MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      }, MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      inherits2(K256, MPrime), K256.prototype.split = function split(input, output) {
        var mask = 4194303, outLen = Math.min(input.length, 9);
        for (var i2 = 0;i2 < outLen; i2++)
          output.words[i2] = input.words[i2];
        if (output.length = outLen, input.length <= 9) {
          input.words[0] = 0, input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i2 = 10;i2 < input.length; i2++) {
          var next = input.words[i2] | 0;
          input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22, prev = next;
        }
        if (prev >>>= 22, input.words[i2 - 10] = prev, prev === 0 && input.length > 10)
          input.length -= 10;
        else
          input.length -= 9;
      }, K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0, num.words[num.length + 1] = 0, num.length += 2;
        var lo = 0;
        for (var i2 = 0;i2 < num.length; i2++) {
          var w = num.words[i2] | 0;
          lo += w * 977, num.words[i2] = lo & 67108863, lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          if (num.length--, num.words[num.length - 1] === 0)
            num.length--;
        }
        return num;
      };
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      inherits2(P25519, MPrime), P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0;i2 < num.length; i2++) {
          var hi2 = (num.words[i2] | 0) * 19 + carry, lo = hi2 & 67108863;
          hi2 >>>= 26, num.words[i2] = lo, carry = hi2;
        }
        if (carry !== 0)
          num.words[num.length++] = carry;
        return num;
      }, BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime;
        if (name === "k256")
          prime = new K256;
        else if (name === "p224")
          prime = new P224;
        else if (name === "p192")
          prime = new P192;
        else if (name === "p25519")
          prime = new P25519;
        else
          throw new Error("Unknown prime " + name);
        return primes[name] = prime, prime;
      };
      function Red(m2) {
        if (typeof m2 === "string") {
          var prime = BN._prime(m2);
          this.m = prime.p, this.prime = prime;
        } else
          assert(m2.gtn(1), "modulus must be greater than 1"), this.m = m2, this.prime = null;
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives"), assert(a.red, "red works only with red numbers");
      }, Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives"), assert(a.red && a.red === b.red, "red works only with red numbers");
      }, Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      }, Red.prototype.neg = function neg(a) {
        if (a.isZero())
          return a.clone();
        return this.m.sub(a)._forceRed(this);
      }, Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0)
          res.isub(this.m);
        return res._forceRed(this);
      }, Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0)
          res.isub(this.m);
        return res;
      }, Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0)
          res.iadd(this.m);
        return res._forceRed(this);
      }, Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0)
          res.iadd(this.m);
        return res;
      }, Red.prototype.shl = function shl(a, num) {
        return this._verify1(a), this.imod(a.ushln(num));
      }, Red.prototype.imul = function imul(a, b) {
        return this._verify2(a, b), this.imod(a.imul(b));
      }, Red.prototype.mul = function mul(a, b) {
        return this._verify2(a, b), this.imod(a.mul(b));
      }, Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      }, Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      }, Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        if (assert(mod3 % 2 === 1), mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q3 = this.m.subn(1), s3 = 0;
        while (!q3.isZero() && q3.andln(1) === 0)
          s3++, q3.iushrn(1);
        assert(!q3.isZero());
        var one = new BN(1).toRed(this), nOne = one.redNeg(), lpow = this.m.subn(1).iushrn(1), z2 = this.m.bitLength();
        z2 = new BN(2 * z2 * z2).toRed(this);
        while (this.pow(z2, lpow).cmp(nOne) !== 0)
          z2.redIAdd(nOne);
        var c = this.pow(z2, q3), r = this.pow(a, q3.addn(1).iushrn(1)), t2 = this.pow(a, q3), m2 = s3;
        while (t2.cmp(one) !== 0) {
          var tmp = t2;
          for (var i2 = 0;tmp.cmp(one) !== 0; i2++)
            tmp = tmp.redSqr();
          assert(i2 < m2);
          var b = this.pow(c, new BN(1).iushln(m2 - i2 - 1));
          r = r.redMul(b), c = b.redSqr(), t2 = t2.redMul(c), m2 = i2;
        }
        return r;
      }, Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0)
          return inv.negative = 0, this.imod(inv).redNeg();
        else
          return this.imod(inv);
      }, Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4, wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this), wnd[1] = a;
        for (var i2 = 2;i2 < wnd.length; i2++)
          wnd[i2] = this.mul(wnd[i2 - 1], a);
        var res = wnd[0], current = 0, currentLen = 0, start = num.bitLength() % 26;
        if (start === 0)
          start = 26;
        for (i2 = num.length - 1;i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j3 = start - 1;j3 >= 0; j3--) {
            var bit = word >> j3 & 1;
            if (res !== wnd[0])
              res = this.sqr(res);
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            if (current <<= 1, current |= bit, currentLen++, currentLen !== windowSize && (i2 !== 0 || j3 !== 0))
              continue;
            res = this.mul(res, wnd[current]), currentLen = 0, current = 0;
          }
          start = 26;
        }
        return res;
      }, Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      }, Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        return res.red = null, res;
      }, BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m2) {
        if (Red.call(this, m2), this.shift = this.m.bitLength(), this.shift % 26 !== 0)
          this.shift += 26 - this.shift % 26;
        this.r = new BN(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red), Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      }, Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        return r.red = null, r;
      }, Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero())
          return a.words[0] = 0, a.length = 1, a;
        var t2 = a.imul(b), c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t2.isub(c).iushrn(this.shift), res = u;
        if (u.cmp(this.m) >= 0)
          res = u.isub(this.m);
        else if (u.cmpn(0) < 0)
          res = u.iadd(this.m);
        return res._forceRed(this);
      }, Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t2 = a.mul(b), c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t2.isub(c).iushrn(this.shift), res = u;
        if (u.cmp(this.m) >= 0)
          res = u.isub(this.m);
        else if (u.cmpn(0) < 0)
          res = u.iadd(this.m);
        return res._forceRed(this);
      }, Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  });
  require_api = __commonJS2((exports) => {
    var asn1 = require_asn1(), inherits2 = require_inherits(), api = exports;
    api.define = function define(name, body) {
      return new Entity(name, body);
    };
    function Entity(name, body) {
      this.name = name, this.body = body, this.decoders = {}, this.encoders = {};
    }
    Entity.prototype._createNamed = function createNamed(base) {
      var named;
      try {
        named = (()=>{throw new Error("Cannot require module "+"vm");})().runInThisContext("(function " + this.name + `(entity) {
  this._initNamed(entity);
})`);
      } catch (e2) {
        named = function(entity) {
          this._initNamed(entity);
        };
      }
      return inherits2(named, base), named.prototype._initNamed = function initnamed(entity) {
        base.call(this, entity);
      }, new named(this);
    };
    Entity.prototype._getDecoder = function _getDecoder(enc) {
      if (enc = enc || "der", !this.decoders.hasOwnProperty(enc))
        this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
      return this.decoders[enc];
    };
    Entity.prototype.decode = function decode(data, enc, options) {
      return this._getDecoder(enc).decode(data, options);
    };
    Entity.prototype._getEncoder = function _getEncoder(enc) {
      if (enc = enc || "der", !this.encoders.hasOwnProperty(enc))
        this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
      return this.encoders[enc];
    };
    Entity.prototype.encode = function encode(data, enc, reporter) {
      return this._getEncoder(enc).encode(data, reporter);
    };
  });
  require_reporter = __commonJS2((exports) => {
    var inherits2 = require_inherits();
    function Reporter(options) {
      this._reporterState = { obj: null, path: [], options: options || {}, errors: [] };
    }
    exports.Reporter = Reporter;
    Reporter.prototype.isError = function isError(obj) {
      return obj instanceof ReporterError;
    };
    Reporter.prototype.save = function save() {
      var state = this._reporterState;
      return { obj: state.obj, pathLen: state.path.length };
    };
    Reporter.prototype.restore = function restore(data) {
      var state = this._reporterState;
      state.obj = data.obj, state.path = state.path.slice(0, data.pathLen);
    };
    Reporter.prototype.enterKey = function enterKey(key) {
      return this._reporterState.path.push(key);
    };
    Reporter.prototype.exitKey = function exitKey(index) {
      var state = this._reporterState;
      state.path = state.path.slice(0, index - 1);
    };
    Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
      var state = this._reporterState;
      if (this.exitKey(index), state.obj !== null)
        state.obj[key] = value;
    };
    Reporter.prototype.path = function path() {
      return this._reporterState.path.join("/");
    };
    Reporter.prototype.enterObject = function enterObject() {
      var state = this._reporterState, prev = state.obj;
      return state.obj = {}, prev;
    };
    Reporter.prototype.leaveObject = function leaveObject(prev) {
      var state = this._reporterState, now = state.obj;
      return state.obj = prev, now;
    };
    Reporter.prototype.error = function error(msg) {
      var err, state = this._reporterState, inherited = msg instanceof ReporterError;
      if (inherited)
        err = msg;
      else
        err = new ReporterError(state.path.map(function(elem) {
          return "[" + JSON.stringify(elem) + "]";
        }).join(""), msg.message || msg, msg.stack);
      if (!state.options.partial)
        throw err;
      if (!inherited)
        state.errors.push(err);
      return err;
    };
    Reporter.prototype.wrapResult = function wrapResult(result) {
      var state = this._reporterState;
      if (!state.options.partial)
        return result;
      return { result: this.isError(result) ? null : result, errors: state.errors };
    };
    function ReporterError(path, msg) {
      this.path = path, this.rethrow(msg);
    }
    inherits2(ReporterError, Error);
    ReporterError.prototype.rethrow = function rethrow(msg) {
      if (this.message = msg + " at: " + (this.path || "(shallow)"), Error.captureStackTrace)
        Error.captureStackTrace(this, ReporterError);
      if (!this.stack)
        try {
          throw new Error(this.message);
        } catch (e2) {
          this.stack = e2.stack;
        }
      return this;
    };
  });
  require_buffer = __commonJS2((exports) => {
    var inherits2 = require_inherits(), Reporter = require_base2().Reporter, Buffer22 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer;
    function DecoderBuffer(base, options) {
      if (Reporter.call(this, options), !Buffer22.isBuffer(base)) {
        this.error("Input not Buffer");
        return;
      }
      this.base = base, this.offset = 0, this.length = base.length;
    }
    inherits2(DecoderBuffer, Reporter);
    exports.DecoderBuffer = DecoderBuffer;
    DecoderBuffer.prototype.save = function save() {
      return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
    };
    DecoderBuffer.prototype.restore = function restore(save) {
      var res = new DecoderBuffer(this.base);
      return res.offset = save.offset, res.length = this.offset, this.offset = save.offset, Reporter.prototype.restore.call(this, save.reporter), res;
    };
    DecoderBuffer.prototype.isEmpty = function isEmpty() {
      return this.offset === this.length;
    };
    DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
      if (this.offset + 1 <= this.length)
        return this.base.readUInt8(this.offset++, true);
      else
        return this.error(fail || "DecoderBuffer overrun");
    };
    DecoderBuffer.prototype.skip = function skip(bytes, fail) {
      if (!(this.offset + bytes <= this.length))
        return this.error(fail || "DecoderBuffer overrun");
      var res = new DecoderBuffer(this.base);
      return res._reporterState = this._reporterState, res.offset = this.offset, res.length = this.offset + bytes, this.offset += bytes, res;
    };
    DecoderBuffer.prototype.raw = function raw(save) {
      return this.base.slice(save ? save.offset : this.offset, this.length);
    };
    function EncoderBuffer(value, reporter) {
      if (Array.isArray(value))
        this.length = 0, this.value = value.map(function(item) {
          if (!(item instanceof EncoderBuffer))
            item = new EncoderBuffer(item, reporter);
          return this.length += item.length, item;
        }, this);
      else if (typeof value === "number") {
        if (!(0 <= value && value <= 255))
          return reporter.error("non-byte EncoderBuffer value");
        this.value = value, this.length = 1;
      } else if (typeof value === "string")
        this.value = value, this.length = Buffer22.byteLength(value);
      else if (Buffer22.isBuffer(value))
        this.value = value, this.length = value.length;
      else
        return reporter.error("Unsupported type: " + typeof value);
    }
    exports.EncoderBuffer = EncoderBuffer;
    EncoderBuffer.prototype.join = function join(out, offset) {
      if (!out)
        out = new Buffer22(this.length);
      if (!offset)
        offset = 0;
      if (this.length === 0)
        return out;
      if (Array.isArray(this.value))
        this.value.forEach(function(item) {
          item.join(out, offset), offset += item.length;
        });
      else {
        if (typeof this.value === "number")
          out[offset] = this.value;
        else if (typeof this.value === "string")
          out.write(this.value, offset);
        else if (Buffer22.isBuffer(this.value))
          this.value.copy(out, offset);
        offset += this.length;
      }
      return out;
    };
  });
  require_node = __commonJS2((exports, module) => {
    var Reporter = require_base2().Reporter, EncoderBuffer = require_base2().EncoderBuffer, DecoderBuffer = require_base2().DecoderBuffer, assert = require_minimalistic_assert(), tags = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], methods = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(tags), overrided = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
    function Node(enc, parent) {
      var state = {};
      if (this._baseState = state, state.enc = enc, state.parent = parent || null, state.children = null, state.tag = null, state.args = null, state.reverseArgs = null, state.choice = null, state.optional = false, state.any = false, state.obj = false, state.use = null, state.useDecoder = null, state.key = null, state.default = null, state.explicit = null, state.implicit = null, state.contains = null, !state.parent)
        state.children = [], this._wrap();
    }
    module.exports = Node;
    var stateProps = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
    Node.prototype.clone = function clone() {
      var state = this._baseState, cstate = {};
      stateProps.forEach(function(prop) {
        cstate[prop] = state[prop];
      });
      var res = new this.constructor(cstate.parent);
      return res._baseState = cstate, res;
    };
    Node.prototype._wrap = function wrap() {
      var state = this._baseState;
      methods.forEach(function(method) {
        this[method] = function _wrappedMethod() {
          var clone = new this.constructor(this);
          return state.children.push(clone), clone[method].apply(clone, arguments);
        };
      }, this);
    };
    Node.prototype._init = function init(body) {
      var state = this._baseState;
      assert(state.parent === null), body.call(this), state.children = state.children.filter(function(child) {
        return child._baseState.parent === this;
      }, this), assert.equal(state.children.length, 1, "Root node can have only one child");
    };
    Node.prototype._useArgs = function useArgs(args) {
      var state = this._baseState, children = args.filter(function(arg) {
        return arg instanceof this.constructor;
      }, this);
      if (args = args.filter(function(arg) {
        return !(arg instanceof this.constructor);
      }, this), children.length !== 0)
        assert(state.children === null), state.children = children, children.forEach(function(child) {
          child._baseState.parent = this;
        }, this);
      if (args.length !== 0)
        assert(state.args === null), state.args = args, state.reverseArgs = args.map(function(arg) {
          if (typeof arg !== "object" || arg.constructor !== Object)
            return arg;
          var res = {};
          return Object.keys(arg).forEach(function(key) {
            if (key == (key | 0))
              key |= 0;
            var value = arg[key];
            res[value] = key;
          }), res;
        });
    };
    overrided.forEach(function(method) {
      Node.prototype[method] = function _overrided() {
        var state = this._baseState;
        throw new Error(method + " not implemented for encoding: " + state.enc);
      };
    });
    tags.forEach(function(tag) {
      Node.prototype[tag] = function _tagMethod() {
        var state = this._baseState, args = Array.prototype.slice.call(arguments);
        return assert(state.tag === null), state.tag = tag, this._useArgs(args), this;
      };
    });
    Node.prototype.use = function use(item) {
      assert(item);
      var state = this._baseState;
      return assert(state.use === null), state.use = item, this;
    };
    Node.prototype.optional = function optional() {
      var state = this._baseState;
      return state.optional = true, this;
    };
    Node.prototype.def = function def(val) {
      var state = this._baseState;
      return assert(state.default === null), state.default = val, state.optional = true, this;
    };
    Node.prototype.explicit = function explicit(num) {
      var state = this._baseState;
      return assert(state.explicit === null && state.implicit === null), state.explicit = num, this;
    };
    Node.prototype.implicit = function implicit(num) {
      var state = this._baseState;
      return assert(state.explicit === null && state.implicit === null), state.implicit = num, this;
    };
    Node.prototype.obj = function obj() {
      var state = this._baseState, args = Array.prototype.slice.call(arguments);
      if (state.obj = true, args.length !== 0)
        this._useArgs(args);
      return this;
    };
    Node.prototype.key = function key(newKey) {
      var state = this._baseState;
      return assert(state.key === null), state.key = newKey, this;
    };
    Node.prototype.any = function any() {
      var state = this._baseState;
      return state.any = true, this;
    };
    Node.prototype.choice = function choice(obj) {
      var state = this._baseState;
      return assert(state.choice === null), state.choice = obj, this._useArgs(Object.keys(obj).map(function(key) {
        return obj[key];
      })), this;
    };
    Node.prototype.contains = function contains(item) {
      var state = this._baseState;
      return assert(state.use === null), state.contains = item, this;
    };
    Node.prototype._decode = function decode(input, options) {
      var state = this._baseState;
      if (state.parent === null)
        return input.wrapResult(state.children[0]._decode(input, options));
      var result = state.default, present = true, prevKey = null;
      if (state.key !== null)
        prevKey = input.enterKey(state.key);
      if (state.optional) {
        var tag = null;
        if (state.explicit !== null)
          tag = state.explicit;
        else if (state.implicit !== null)
          tag = state.implicit;
        else if (state.tag !== null)
          tag = state.tag;
        if (tag === null && !state.any) {
          var save = input.save();
          try {
            if (state.choice === null)
              this._decodeGeneric(state.tag, input, options);
            else
              this._decodeChoice(input, options);
            present = true;
          } catch (e2) {
            present = false;
          }
          input.restore(save);
        } else if (present = this._peekTag(input, tag, state.any), input.isError(present))
          return present;
      }
      var prevObj;
      if (state.obj && present)
        prevObj = input.enterObject();
      if (present) {
        if (state.explicit !== null) {
          var explicit = this._decodeTag(input, state.explicit);
          if (input.isError(explicit))
            return explicit;
          input = explicit;
        }
        var start = input.offset;
        if (state.use === null && state.choice === null) {
          if (state.any)
            var save = input.save();
          var body = this._decodeTag(input, state.implicit !== null ? state.implicit : state.tag, state.any);
          if (input.isError(body))
            return body;
          if (state.any)
            result = input.raw(save);
          else
            input = body;
        }
        if (options && options.track && state.tag !== null)
          options.track(input.path(), start, input.length, "tagged");
        if (options && options.track && state.tag !== null)
          options.track(input.path(), input.offset, input.length, "content");
        if (state.any)
          result = result;
        else if (state.choice === null)
          result = this._decodeGeneric(state.tag, input, options);
        else
          result = this._decodeChoice(input, options);
        if (input.isError(result))
          return result;
        if (!state.any && state.choice === null && state.children !== null)
          state.children.forEach(function decodeChildren(child) {
            child._decode(input, options);
          });
        if (state.contains && (state.tag === "octstr" || state.tag === "bitstr")) {
          var data = new DecoderBuffer(result);
          result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
        }
      }
      if (state.obj && present)
        result = input.leaveObject(prevObj);
      if (state.key !== null && (result !== null || present === true))
        input.leaveKey(prevKey, state.key, result);
      else if (prevKey !== null)
        input.exitKey(prevKey);
      return result;
    };
    Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
      var state = this._baseState;
      if (tag === "seq" || tag === "set")
        return null;
      if (tag === "seqof" || tag === "setof")
        return this._decodeList(input, tag, state.args[0], options);
      else if (/str$/.test(tag))
        return this._decodeStr(input, tag, options);
      else if (tag === "objid" && state.args)
        return this._decodeObjid(input, state.args[0], state.args[1], options);
      else if (tag === "objid")
        return this._decodeObjid(input, null, null, options);
      else if (tag === "gentime" || tag === "utctime")
        return this._decodeTime(input, tag, options);
      else if (tag === "null_")
        return this._decodeNull(input, options);
      else if (tag === "bool")
        return this._decodeBool(input, options);
      else if (tag === "objDesc")
        return this._decodeStr(input, tag, options);
      else if (tag === "int" || tag === "enum")
        return this._decodeInt(input, state.args && state.args[0], options);
      if (state.use !== null)
        return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
      else
        return input.error("unknown tag: " + tag);
    };
    Node.prototype._getUse = function _getUse(entity, obj) {
      var state = this._baseState;
      if (state.useDecoder = this._use(entity, obj), assert(state.useDecoder._baseState.parent === null), state.useDecoder = state.useDecoder._baseState.children[0], state.implicit !== state.useDecoder._baseState.implicit)
        state.useDecoder = state.useDecoder.clone(), state.useDecoder._baseState.implicit = state.implicit;
      return state.useDecoder;
    };
    Node.prototype._decodeChoice = function decodeChoice(input, options) {
      var state = this._baseState, result = null, match = false;
      if (Object.keys(state.choice).some(function(key) {
        var save = input.save(), node = state.choice[key];
        try {
          var value = node._decode(input, options);
          if (input.isError(value))
            return false;
          result = { type: key, value }, match = true;
        } catch (e2) {
          return input.restore(save), false;
        }
        return true;
      }, this), !match)
        return input.error("Choice not matched");
      return result;
    };
    Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
      return new EncoderBuffer(data, this.reporter);
    };
    Node.prototype._encode = function encode(data, reporter, parent) {
      var state = this._baseState;
      if (state.default !== null && state.default === data)
        return;
      var result = this._encodeValue(data, reporter, parent);
      if (result === undefined)
        return;
      if (this._skipDefault(result, reporter, parent))
        return;
      return result;
    };
    Node.prototype._encodeValue = function encode(data, reporter, parent) {
      var state = this._baseState;
      if (state.parent === null)
        return state.children[0]._encode(data, reporter || new Reporter);
      var result = null;
      if (this.reporter = reporter, state.optional && data === undefined)
        if (state.default !== null)
          data = state.default;
        else
          return;
      var content = null, primitive = false;
      if (state.any)
        result = this._createEncoderBuffer(data);
      else if (state.choice)
        result = this._encodeChoice(data, reporter);
      else if (state.contains)
        content = this._getUse(state.contains, parent)._encode(data, reporter), primitive = true;
      else if (state.children)
        content = state.children.map(function(child2) {
          if (child2._baseState.tag === "null_")
            return child2._encode(null, reporter, data);
          if (child2._baseState.key === null)
            return reporter.error("Child should have a key");
          var prevKey = reporter.enterKey(child2._baseState.key);
          if (typeof data !== "object")
            return reporter.error("Child expected, but input is not object");
          var res = child2._encode(data[child2._baseState.key], reporter, data);
          return reporter.leaveKey(prevKey), res;
        }, this).filter(function(child2) {
          return child2;
        }), content = this._createEncoderBuffer(content);
      else if (state.tag === "seqof" || state.tag === "setof") {
        if (!(state.args && state.args.length === 1))
          return reporter.error("Too many args for : " + state.tag);
        if (!Array.isArray(data))
          return reporter.error("seqof/setof, but data is not Array");
        var child = this.clone();
        child._baseState.implicit = null, content = this._createEncoderBuffer(data.map(function(item) {
          var state2 = this._baseState;
          return this._getUse(state2.args[0], data)._encode(item, reporter);
        }, child));
      } else if (state.use !== null)
        result = this._getUse(state.use, parent)._encode(data, reporter);
      else
        content = this._encodePrimitive(state.tag, data), primitive = true;
      var result;
      if (!state.any && state.choice === null) {
        var tag = state.implicit !== null ? state.implicit : state.tag, cls = state.implicit === null ? "universal" : "context";
        if (tag === null) {
          if (state.use === null)
            reporter.error("Tag could be omitted only for .use()");
        } else if (state.use === null)
          result = this._encodeComposite(tag, primitive, cls, content);
      }
      if (state.explicit !== null)
        result = this._encodeComposite(state.explicit, false, "context", result);
      return result;
    };
    Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
      var state = this._baseState, node = state.choice[data.type];
      if (!node)
        assert(false, data.type + " not found in " + JSON.stringify(Object.keys(state.choice)));
      return node._encode(data.value, reporter);
    };
    Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
      var state = this._baseState;
      if (/str$/.test(tag))
        return this._encodeStr(data, tag);
      else if (tag === "objid" && state.args)
        return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
      else if (tag === "objid")
        return this._encodeObjid(data, null, null);
      else if (tag === "gentime" || tag === "utctime")
        return this._encodeTime(data, tag);
      else if (tag === "null_")
        return this._encodeNull();
      else if (tag === "int" || tag === "enum")
        return this._encodeInt(data, state.args && state.reverseArgs[0]);
      else if (tag === "bool")
        return this._encodeBool(data);
      else if (tag === "objDesc")
        return this._encodeStr(data, tag);
      else
        throw new Error("Unsupported tag: " + tag);
    };
    Node.prototype._isNumstr = function isNumstr(str) {
      return /^[0-9 ]*$/.test(str);
    };
    Node.prototype._isPrintstr = function isPrintstr(str) {
      return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
    };
  });
  require_base2 = __commonJS2((exports) => {
    var base = exports;
    base.Reporter = require_reporter().Reporter;
    base.DecoderBuffer = require_buffer().DecoderBuffer;
    base.EncoderBuffer = require_buffer().EncoderBuffer;
    base.Node = require_node();
  });
  require_der = __commonJS2((exports) => {
    var constants2 = require_constants();
    exports.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" };
    exports.tagClassByName = constants2._reverse(exports.tagClass);
    exports.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" };
    exports.tagByName = constants2._reverse(exports.tag);
  });
  require_constants = __commonJS2((exports) => {
    var constants2 = exports;
    constants2._reverse = function reverse(map) {
      var res = {};
      return Object.keys(map).forEach(function(key) {
        if ((key | 0) == key)
          key = key | 0;
        var value = map[key];
        res[value] = key;
      }), res;
    };
    constants2.der = require_der();
  });
  require_der2 = __commonJS2((exports, module) => {
    var inherits2 = require_inherits(), asn1 = require_asn1(), base = asn1.base, bignum = asn1.bignum, der = asn1.constants.der;
    function DERDecoder(entity) {
      this.enc = "der", this.name = entity.name, this.entity = entity, this.tree = new DERNode, this.tree._init(entity.body);
    }
    module.exports = DERDecoder;
    DERDecoder.prototype.decode = function decode(data, options) {
      if (!(data instanceof base.DecoderBuffer))
        data = new base.DecoderBuffer(data, options);
      return this.tree._decode(data, options);
    };
    function DERNode(parent) {
      base.Node.call(this, "der", parent);
    }
    inherits2(DERNode, base.Node);
    DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
      if (buffer.isEmpty())
        return false;
      var state = buffer.save(), decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
      if (buffer.isError(decodedTag))
        return decodedTag;
      return buffer.restore(state), decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + "of" === tag || any;
    };
    DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
      var decodedTag = derDecodeTag(buffer, 'Failed to decode tag of "' + tag + '"');
      if (buffer.isError(decodedTag))
        return decodedTag;
      var len2 = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of "' + tag + '"');
      if (buffer.isError(len2))
        return len2;
      if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag)
        return buffer.error('Failed to match tag: "' + tag + '"');
      if (decodedTag.primitive || len2 !== null)
        return buffer.skip(len2, 'Failed to match body of: "' + tag + '"');
      var state = buffer.save(), res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: "' + this.tag + '"');
      if (buffer.isError(res))
        return res;
      return len2 = buffer.offset - state.offset, buffer.restore(state), buffer.skip(len2, 'Failed to match body of: "' + tag + '"');
    };
    DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
      while (true) {
        var tag = derDecodeTag(buffer, fail);
        if (buffer.isError(tag))
          return tag;
        var len2 = derDecodeLen(buffer, tag.primitive, fail);
        if (buffer.isError(len2))
          return len2;
        var res;
        if (tag.primitive || len2 !== null)
          res = buffer.skip(len2);
        else
          res = this._skipUntilEnd(buffer, fail);
        if (buffer.isError(res))
          return res;
        if (tag.tagStr === "end")
          break;
      }
    };
    DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder, options) {
      var result = [];
      while (!buffer.isEmpty()) {
        var possibleEnd = this._peekTag(buffer, "end");
        if (buffer.isError(possibleEnd))
          return possibleEnd;
        var res = decoder.decode(buffer, "der", options);
        if (buffer.isError(res) && possibleEnd)
          break;
        result.push(res);
      }
      return result;
    };
    DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
      if (tag === "bitstr") {
        var unused = buffer.readUInt8();
        if (buffer.isError(unused))
          return unused;
        return { unused, data: buffer.raw() };
      } else if (tag === "bmpstr") {
        var raw = buffer.raw();
        if (raw.length % 2 === 1)
          return buffer.error("Decoding of string type: bmpstr length mismatch");
        var str = "";
        for (var i2 = 0;i2 < raw.length / 2; i2++)
          str += String.fromCharCode(raw.readUInt16BE(i2 * 2));
        return str;
      } else if (tag === "numstr") {
        var numstr = buffer.raw().toString("ascii");
        if (!this._isNumstr(numstr))
          return buffer.error("Decoding of string type: numstr unsupported characters");
        return numstr;
      } else if (tag === "octstr")
        return buffer.raw();
      else if (tag === "objDesc")
        return buffer.raw();
      else if (tag === "printstr") {
        var printstr = buffer.raw().toString("ascii");
        if (!this._isPrintstr(printstr))
          return buffer.error("Decoding of string type: printstr unsupported characters");
        return printstr;
      } else if (/str$/.test(tag))
        return buffer.raw().toString();
      else
        return buffer.error("Decoding of string type: " + tag + " unsupported");
    };
    DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative2) {
      var result, identifiers = [], ident = 0;
      while (!buffer.isEmpty()) {
        var subident = buffer.readUInt8();
        if (ident <<= 7, ident |= subident & 127, (subident & 128) === 0)
          identifiers.push(ident), ident = 0;
      }
      if (subident & 128)
        identifiers.push(ident);
      var first = identifiers[0] / 40 | 0, second = identifiers[0] % 40;
      if (relative2)
        result = identifiers;
      else
        result = [first, second].concat(identifiers.slice(1));
      if (values) {
        var tmp = values[result.join(" ")];
        if (tmp === undefined)
          tmp = values[result.join(".")];
        if (tmp !== undefined)
          result = tmp;
      }
      return result;
    };
    DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
      var str = buffer.raw().toString();
      if (tag === "gentime")
        var year = str.slice(0, 4) | 0, mon = str.slice(4, 6) | 0, day = str.slice(6, 8) | 0, hour = str.slice(8, 10) | 0, min = str.slice(10, 12) | 0, sec = str.slice(12, 14) | 0;
      else if (tag === "utctime") {
        var year = str.slice(0, 2) | 0, mon = str.slice(2, 4) | 0, day = str.slice(4, 6) | 0, hour = str.slice(6, 8) | 0, min = str.slice(8, 10) | 0, sec = str.slice(10, 12) | 0;
        if (year < 70)
          year = 2000 + year;
        else
          year = 1900 + year;
      } else
        return buffer.error("Decoding " + tag + " time is not supported yet");
      return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
    };
    DERNode.prototype._decodeNull = function decodeNull(buffer) {
      return null;
    };
    DERNode.prototype._decodeBool = function decodeBool(buffer) {
      var res = buffer.readUInt8();
      if (buffer.isError(res))
        return res;
      else
        return res !== 0;
    };
    DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
      var raw = buffer.raw(), res = new bignum(raw);
      if (values)
        res = values[res.toString(10)] || res;
      return res;
    };
    DERNode.prototype._use = function use(entity, obj) {
      if (typeof entity === "function")
        entity = entity(obj);
      return entity._getDecoder("der").tree;
    };
    function derDecodeTag(buf, fail) {
      var tag = buf.readUInt8(fail);
      if (buf.isError(tag))
        return tag;
      var cls = der.tagClass[tag >> 6], primitive = (tag & 32) === 0;
      if ((tag & 31) === 31) {
        var oct = tag;
        tag = 0;
        while ((oct & 128) === 128) {
          if (oct = buf.readUInt8(fail), buf.isError(oct))
            return oct;
          tag <<= 7, tag |= oct & 127;
        }
      } else
        tag &= 31;
      var tagStr = der.tag[tag];
      return { cls, primitive, tag, tagStr };
    }
    function derDecodeLen(buf, primitive, fail) {
      var len2 = buf.readUInt8(fail);
      if (buf.isError(len2))
        return len2;
      if (!primitive && len2 === 128)
        return null;
      if ((len2 & 128) === 0)
        return len2;
      var num = len2 & 127;
      if (num > 4)
        return buf.error("length octect is too long");
      len2 = 0;
      for (var i2 = 0;i2 < num; i2++) {
        len2 <<= 8;
        var j3 = buf.readUInt8(fail);
        if (buf.isError(j3))
          return j3;
        len2 |= j3;
      }
      return len2;
    }
  });
  require_pem = __commonJS2((exports, module) => {
    var inherits2 = require_inherits(), Buffer22 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer, DERDecoder = require_der2();
    function PEMDecoder(entity) {
      DERDecoder.call(this, entity), this.enc = "pem";
    }
    inherits2(PEMDecoder, DERDecoder);
    module.exports = PEMDecoder;
    PEMDecoder.prototype.decode = function decode(data, options) {
      var lines = data.toString().split(/[\r\n]+/g), label = options.label.toUpperCase(), re2 = /^-----(BEGIN|END) ([^-]+)-----$/, start = -1, end = -1;
      for (var i2 = 0;i2 < lines.length; i2++) {
        var match = lines[i2].match(re2);
        if (match === null)
          continue;
        if (match[2] !== label)
          continue;
        if (start === -1) {
          if (match[1] !== "BEGIN")
            break;
          start = i2;
        } else {
          if (match[1] !== "END")
            break;
          end = i2;
          break;
        }
      }
      if (start === -1 || end === -1)
        throw new Error("PEM section not found for: " + label);
      var base64 = lines.slice(start + 1, end).join("");
      base64.replace(/[^a-z0-9\+\/=]+/gi, "");
      var input = new Buffer22(base64, "base64");
      return DERDecoder.prototype.decode.call(this, input, options);
    };
  });
  require_decoders = __commonJS2((exports) => {
    var decoders = exports;
    decoders.der = require_der2();
    decoders.pem = require_pem();
  });
  require_der3 = __commonJS2((exports, module) => {
    var inherits2 = require_inherits(), Buffer22 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer, asn1 = require_asn1(), base = asn1.base, der = asn1.constants.der;
    function DEREncoder(entity) {
      this.enc = "der", this.name = entity.name, this.entity = entity, this.tree = new DERNode, this.tree._init(entity.body);
    }
    module.exports = DEREncoder;
    DEREncoder.prototype.encode = function encode(data, reporter) {
      return this.tree._encode(data, reporter).join();
    };
    function DERNode(parent) {
      base.Node.call(this, "der", parent);
    }
    inherits2(DERNode, base.Node);
    DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
      var encodedTag = encodeTag(tag, primitive, cls, this.reporter);
      if (content.length < 128) {
        var header = new Buffer22(2);
        return header[0] = encodedTag, header[1] = content.length, this._createEncoderBuffer([header, content]);
      }
      var lenOctets = 1;
      for (var i2 = content.length;i2 >= 256; i2 >>= 8)
        lenOctets++;
      var header = new Buffer22(2 + lenOctets);
      header[0] = encodedTag, header[1] = 128 | lenOctets;
      for (var i2 = 1 + lenOctets, j3 = content.length;j3 > 0; i2--, j3 >>= 8)
        header[i2] = j3 & 255;
      return this._createEncoderBuffer([header, content]);
    };
    DERNode.prototype._encodeStr = function encodeStr(str, tag) {
      if (tag === "bitstr")
        return this._createEncoderBuffer([str.unused | 0, str.data]);
      else if (tag === "bmpstr") {
        var buf = new Buffer22(str.length * 2);
        for (var i2 = 0;i2 < str.length; i2++)
          buf.writeUInt16BE(str.charCodeAt(i2), i2 * 2);
        return this._createEncoderBuffer(buf);
      } else if (tag === "numstr") {
        if (!this._isNumstr(str))
          return this.reporter.error("Encoding of string type: numstr supports only digits and space");
        return this._createEncoderBuffer(str);
      } else if (tag === "printstr") {
        if (!this._isPrintstr(str))
          return this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark");
        return this._createEncoderBuffer(str);
      } else if (/str$/.test(tag))
        return this._createEncoderBuffer(str);
      else if (tag === "objDesc")
        return this._createEncoderBuffer(str);
      else
        return this.reporter.error("Encoding of string type: " + tag + " unsupported");
    };
    DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative2) {
      if (typeof id === "string") {
        if (!values)
          return this.reporter.error("string objid given, but no values map found");
        if (!values.hasOwnProperty(id))
          return this.reporter.error("objid not found in values map");
        id = values[id].split(/[\s\.]+/g);
        for (var i2 = 0;i2 < id.length; i2++)
          id[i2] |= 0;
      } else if (Array.isArray(id)) {
        id = id.slice();
        for (var i2 = 0;i2 < id.length; i2++)
          id[i2] |= 0;
      }
      if (!Array.isArray(id))
        return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(id));
      if (!relative2) {
        if (id[1] >= 40)
          return this.reporter.error("Second objid identifier OOB");
        id.splice(0, 2, id[0] * 40 + id[1]);
      }
      var size = 0;
      for (var i2 = 0;i2 < id.length; i2++) {
        var ident = id[i2];
        for (size++;ident >= 128; ident >>= 7)
          size++;
      }
      var objid = new Buffer22(size), offset = objid.length - 1;
      for (var i2 = id.length - 1;i2 >= 0; i2--) {
        var ident = id[i2];
        objid[offset--] = ident & 127;
        while ((ident >>= 7) > 0)
          objid[offset--] = 128 | ident & 127;
      }
      return this._createEncoderBuffer(objid);
    };
    function two(num) {
      if (num < 10)
        return "0" + num;
      else
        return num;
    }
    DERNode.prototype._encodeTime = function encodeTime(time, tag) {
      var str, date = new Date(time);
      if (tag === "gentime")
        str = [two(date.getFullYear()), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), "Z"].join("");
      else if (tag === "utctime")
        str = [two(date.getFullYear() % 100), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), "Z"].join("");
      else
        this.reporter.error("Encoding " + tag + " time is not supported yet");
      return this._encodeStr(str, "octstr");
    };
    DERNode.prototype._encodeNull = function encodeNull() {
      return this._createEncoderBuffer("");
    };
    DERNode.prototype._encodeInt = function encodeInt(num, values) {
      if (typeof num === "string") {
        if (!values)
          return this.reporter.error("String int or enum given, but no values map");
        if (!values.hasOwnProperty(num))
          return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
        num = values[num];
      }
      if (typeof num !== "number" && !Buffer22.isBuffer(num)) {
        var numArray = num.toArray();
        if (!num.sign && numArray[0] & 128)
          numArray.unshift(0);
        num = new Buffer22(numArray);
      }
      if (Buffer22.isBuffer(num)) {
        var size = num.length;
        if (num.length === 0)
          size++;
        var out = new Buffer22(size);
        if (num.copy(out), num.length === 0)
          out[0] = 0;
        return this._createEncoderBuffer(out);
      }
      if (num < 128)
        return this._createEncoderBuffer(num);
      if (num < 256)
        return this._createEncoderBuffer([0, num]);
      var size = 1;
      for (var i2 = num;i2 >= 256; i2 >>= 8)
        size++;
      var out = new Array(size);
      for (var i2 = out.length - 1;i2 >= 0; i2--)
        out[i2] = num & 255, num >>= 8;
      if (out[0] & 128)
        out.unshift(0);
      return this._createEncoderBuffer(new Buffer22(out));
    };
    DERNode.prototype._encodeBool = function encodeBool(value) {
      return this._createEncoderBuffer(value ? 255 : 0);
    };
    DERNode.prototype._use = function use(entity, obj) {
      if (typeof entity === "function")
        entity = entity(obj);
      return entity._getEncoder("der").tree;
    };
    DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
      var state = this._baseState, i2;
      if (state.default === null)
        return false;
      var data = dataBuffer.join();
      if (state.defaultBuffer === undefined)
        state.defaultBuffer = this._encodeValue(state.default, reporter, parent).join();
      if (data.length !== state.defaultBuffer.length)
        return false;
      for (i2 = 0;i2 < data.length; i2++)
        if (data[i2] !== state.defaultBuffer[i2])
          return false;
      return true;
    };
    function encodeTag(tag, primitive, cls, reporter) {
      var res;
      if (tag === "seqof")
        tag = "seq";
      else if (tag === "setof")
        tag = "set";
      if (der.tagByName.hasOwnProperty(tag))
        res = der.tagByName[tag];
      else if (typeof tag === "number" && (tag | 0) === tag)
        res = tag;
      else
        return reporter.error("Unknown tag: " + tag);
      if (res >= 31)
        return reporter.error("Multi-octet tag encoding unsupported");
      if (!primitive)
        res |= 32;
      return res |= der.tagClassByName[cls || "universal"] << 6, res;
    }
  });
  require_pem2 = __commonJS2((exports, module) => {
    var inherits2 = require_inherits(), DEREncoder = require_der3();
    function PEMEncoder(entity) {
      DEREncoder.call(this, entity), this.enc = "pem";
    }
    inherits2(PEMEncoder, DEREncoder);
    module.exports = PEMEncoder;
    PEMEncoder.prototype.encode = function encode(data, options) {
      var buf = DEREncoder.prototype.encode.call(this, data), p2 = buf.toString("base64"), out = ["-----BEGIN " + options.label + "-----"];
      for (var i2 = 0;i2 < p2.length; i2 += 64)
        out.push(p2.slice(i2, i2 + 64));
      return out.push("-----END " + options.label + "-----"), out.join(`
`);
    };
  });
  require_encoders = __commonJS2((exports) => {
    var encoders = exports;
    encoders.der = require_der3();
    encoders.pem = require_pem2();
  });
  require_asn1 = __commonJS2((exports) => {
    var asn1 = exports;
    asn1.bignum = require_bn3();
    asn1.define = require_api().define;
    asn1.base = require_base2();
    asn1.constants = require_constants();
    asn1.decoders = require_decoders();
    asn1.encoders = require_encoders();
  });
  require_certificate = __commonJS2((exports, module) => {
    var asn = require_asn1(), Time = asn.define("Time", function() {
      this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
    }), AttributeTypeValue = asn.define("AttributeTypeValue", function() {
      this.seq().obj(this.key("type").objid(), this.key("value").any());
    }), AlgorithmIdentifier = asn.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
    }), SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
    }), RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
      this.setof(AttributeTypeValue);
    }), RDNSequence = asn.define("RDNSequence", function() {
      this.seqof(RelativeDistinguishedName);
    }), Name = asn.define("Name", function() {
      this.choice({ rdnSequence: this.use(RDNSequence) });
    }), Validity = asn.define("Validity", function() {
      this.seq().obj(this.key("notBefore").use(Time), this.key("notAfter").use(Time));
    }), Extension = asn.define("Extension", function() {
      this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
    }), TBSCertificate = asn.define("TBSCertificate", function() {
      this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(AlgorithmIdentifier), this.key("issuer").use(Name), this.key("validity").use(Validity), this.key("subject").use(Name), this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(Extension).optional());
    }), X509Certificate = asn.define("X509Certificate", function() {
      this.seq().obj(this.key("tbsCertificate").use(TBSCertificate), this.key("signatureAlgorithm").use(AlgorithmIdentifier), this.key("signatureValue").bitstr());
    });
    module.exports = X509Certificate;
  });
  require_asn12 = __commonJS2((exports) => {
    var asn1 = require_asn1();
    exports.certificate = require_certificate();
    var RSAPrivateKey = asn1.define("RSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
    });
    exports.RSAPrivateKey = RSAPrivateKey;
    var RSAPublicKey = asn1.define("RSAPublicKey", function() {
      this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
    });
    exports.RSAPublicKey = RSAPublicKey;
    var AlgorithmIdentifier = asn1.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
    }), PublicKey = asn1.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
    });
    exports.PublicKey = PublicKey;
    var PrivateKeyInfo = asn1.define("PrivateKeyInfo", function() {
      this.seq().obj(this.key("version").int(), this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPrivateKey").octstr());
    });
    exports.PrivateKey = PrivateKeyInfo;
    var EncryptedPrivateKeyInfo = asn1.define("EncryptedPrivateKeyInfo", function() {
      this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
    });
    exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
    var DSAPrivateKey = asn1.define("DSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
    });
    exports.DSAPrivateKey = DSAPrivateKey;
    exports.DSAparam = asn1.define("DSAparam", function() {
      this.int();
    });
    var ECParameters = asn1.define("ECParameters", function() {
      this.choice({ namedCurve: this.objid() });
    }), ECPrivateKey = asn1.define("ECPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(ECParameters), this.key("publicKey").optional().explicit(1).bitstr());
    });
    exports.ECPrivateKey = ECPrivateKey;
    exports.signature = asn1.define("signature", function() {
      this.seq().obj(this.key("r").int(), this.key("s").int());
    });
  });
  require_aesid = __commonJS2((exports, module) => {
    module.exports = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
  });
  require_hash_base = __commonJS2((exports, module) => {
    var Buffer22 = require_safe_buffer().Buffer, Transform = require_stream().Transform, inherits2 = require_inherits();
    function HashBase(blockSize) {
      Transform.call(this), this._block = Buffer22.allocUnsafe(blockSize), this._blockSize = blockSize, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = false;
    }
    inherits2(HashBase, Transform);
    HashBase.prototype._transform = function(chunk, encoding, callback) {
      var error = null;
      try {
        this.update(chunk, encoding);
      } catch (err) {
        error = err;
      }
      callback(error);
    };
    HashBase.prototype._flush = function(callback) {
      var error = null;
      try {
        this.push(this.digest());
      } catch (err) {
        error = err;
      }
      callback(error);
    };
    var useUint8Array = typeof Uint8Array !== "undefined", useArrayBuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && ArrayBuffer.isView && (Buffer22.prototype instanceof Uint8Array || Buffer22.TYPED_ARRAY_SUPPORT);
    function toBuffer(data, encoding) {
      if (data instanceof Buffer22)
        return data;
      if (typeof data === "string")
        return Buffer22.from(data, encoding);
      if (useArrayBuffer && ArrayBuffer.isView(data)) {
        if (data.byteLength === 0)
          return Buffer22.alloc(0);
        var res = Buffer22.from(data.buffer, data.byteOffset, data.byteLength);
        if (res.byteLength === data.byteLength)
          return res;
      }
      if (useUint8Array && data instanceof Uint8Array)
        return Buffer22.from(data);
      if (Buffer22.isBuffer(data) && data.constructor && typeof data.constructor.isBuffer === "function" && data.constructor.isBuffer(data))
        return Buffer22.from(data);
      throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
    }
    HashBase.prototype.update = function(data, encoding) {
      if (this._finalized)
        throw new Error("Digest already called");
      data = toBuffer(data, encoding);
      var block = this._block, offset = 0;
      while (this._blockOffset + data.length - offset >= this._blockSize) {
        for (var i2 = this._blockOffset;i2 < this._blockSize; )
          block[i2++] = data[offset++];
        this._update(), this._blockOffset = 0;
      }
      while (offset < data.length)
        block[this._blockOffset++] = data[offset++];
      for (var j3 = 0, carry = data.length * 8;carry > 0; ++j3)
        if (this._length[j3] += carry, carry = this._length[j3] / 4294967296 | 0, carry > 0)
          this._length[j3] -= 4294967296 * carry;
      return this;
    };
    HashBase.prototype._update = function() {
      throw new Error("_update is not implemented");
    };
    HashBase.prototype.digest = function(encoding) {
      if (this._finalized)
        throw new Error("Digest already called");
      this._finalized = true;
      var digest = this._digest();
      if (encoding !== undefined)
        digest = digest.toString(encoding);
      this._block.fill(0), this._blockOffset = 0;
      for (var i2 = 0;i2 < 4; ++i2)
        this._length[i2] = 0;
      return digest;
    };
    HashBase.prototype._digest = function() {
      throw new Error("_digest is not implemented");
    };
    module.exports = HashBase;
  });
  require_md5 = __commonJS2((exports, module) => {
    var inherits2 = require_inherits(), HashBase = require_hash_base(), Buffer22 = require_safe_buffer().Buffer, ARRAY16 = new Array(16);
    function MD5() {
      HashBase.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
    }
    inherits2(MD5, HashBase);
    MD5.prototype._update = function() {
      var M2 = ARRAY16;
      for (var i2 = 0;i2 < 16; ++i2)
        M2[i2] = this._block.readInt32LE(i2 * 4);
      var a = this._a, b = this._b, c = this._c, d3 = this._d;
      a = fnF(a, b, c, d3, M2[0], 3614090360, 7), d3 = fnF(d3, a, b, c, M2[1], 3905402710, 12), c = fnF(c, d3, a, b, M2[2], 606105819, 17), b = fnF(b, c, d3, a, M2[3], 3250441966, 22), a = fnF(a, b, c, d3, M2[4], 4118548399, 7), d3 = fnF(d3, a, b, c, M2[5], 1200080426, 12), c = fnF(c, d3, a, b, M2[6], 2821735955, 17), b = fnF(b, c, d3, a, M2[7], 4249261313, 22), a = fnF(a, b, c, d3, M2[8], 1770035416, 7), d3 = fnF(d3, a, b, c, M2[9], 2336552879, 12), c = fnF(c, d3, a, b, M2[10], 4294925233, 17), b = fnF(b, c, d3, a, M2[11], 2304563134, 22), a = fnF(a, b, c, d3, M2[12], 1804603682, 7), d3 = fnF(d3, a, b, c, M2[13], 4254626195, 12), c = fnF(c, d3, a, b, M2[14], 2792965006, 17), b = fnF(b, c, d3, a, M2[15], 1236535329, 22), a = fnG(a, b, c, d3, M2[1], 4129170786, 5), d3 = fnG(d3, a, b, c, M2[6], 3225465664, 9), c = fnG(c, d3, a, b, M2[11], 643717713, 14), b = fnG(b, c, d3, a, M2[0], 3921069994, 20), a = fnG(a, b, c, d3, M2[5], 3593408605, 5), d3 = fnG(d3, a, b, c, M2[10], 38016083, 9), c = fnG(c, d3, a, b, M2[15], 3634488961, 14), b = fnG(b, c, d3, a, M2[4], 3889429448, 20), a = fnG(a, b, c, d3, M2[9], 568446438, 5), d3 = fnG(d3, a, b, c, M2[14], 3275163606, 9), c = fnG(c, d3, a, b, M2[3], 4107603335, 14), b = fnG(b, c, d3, a, M2[8], 1163531501, 20), a = fnG(a, b, c, d3, M2[13], 2850285829, 5), d3 = fnG(d3, a, b, c, M2[2], 4243563512, 9), c = fnG(c, d3, a, b, M2[7], 1735328473, 14), b = fnG(b, c, d3, a, M2[12], 2368359562, 20), a = fnH(a, b, c, d3, M2[5], 4294588738, 4), d3 = fnH(d3, a, b, c, M2[8], 2272392833, 11), c = fnH(c, d3, a, b, M2[11], 1839030562, 16), b = fnH(b, c, d3, a, M2[14], 4259657740, 23), a = fnH(a, b, c, d3, M2[1], 2763975236, 4), d3 = fnH(d3, a, b, c, M2[4], 1272893353, 11), c = fnH(c, d3, a, b, M2[7], 4139469664, 16), b = fnH(b, c, d3, a, M2[10], 3200236656, 23), a = fnH(a, b, c, d3, M2[13], 681279174, 4), d3 = fnH(d3, a, b, c, M2[0], 3936430074, 11), c = fnH(c, d3, a, b, M2[3], 3572445317, 16), b = fnH(b, c, d3, a, M2[6], 76029189, 23), a = fnH(a, b, c, d3, M2[9], 3654602809, 4), d3 = fnH(d3, a, b, c, M2[12], 3873151461, 11), c = fnH(c, d3, a, b, M2[15], 530742520, 16), b = fnH(b, c, d3, a, M2[2], 3299628645, 23), a = fnI(a, b, c, d3, M2[0], 4096336452, 6), d3 = fnI(d3, a, b, c, M2[7], 1126891415, 10), c = fnI(c, d3, a, b, M2[14], 2878612391, 15), b = fnI(b, c, d3, a, M2[5], 4237533241, 21), a = fnI(a, b, c, d3, M2[12], 1700485571, 6), d3 = fnI(d3, a, b, c, M2[3], 2399980690, 10), c = fnI(c, d3, a, b, M2[10], 4293915773, 15), b = fnI(b, c, d3, a, M2[1], 2240044497, 21), a = fnI(a, b, c, d3, M2[8], 1873313359, 6), d3 = fnI(d3, a, b, c, M2[15], 4264355552, 10), c = fnI(c, d3, a, b, M2[6], 2734768916, 15), b = fnI(b, c, d3, a, M2[13], 1309151649, 21), a = fnI(a, b, c, d3, M2[4], 4149444226, 6), d3 = fnI(d3, a, b, c, M2[11], 3174756917, 10), c = fnI(c, d3, a, b, M2[2], 718787259, 15), b = fnI(b, c, d3, a, M2[9], 3951481745, 21), this._a = this._a + a | 0, this._b = this._b + b | 0, this._c = this._c + c | 0, this._d = this._d + d3 | 0;
    };
    MD5.prototype._digest = function() {
      if (this._block[this._blockOffset++] = 128, this._blockOffset > 56)
        this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0;
      this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
      var buffer = Buffer22.allocUnsafe(16);
      return buffer.writeInt32LE(this._a, 0), buffer.writeInt32LE(this._b, 4), buffer.writeInt32LE(this._c, 8), buffer.writeInt32LE(this._d, 12), buffer;
    };
    function rotl(x4, n) {
      return x4 << n | x4 >>> 32 - n;
    }
    function fnF(a, b, c, d3, m2, k4, s3) {
      return rotl(a + (b & c | ~b & d3) + m2 + k4 | 0, s3) + b | 0;
    }
    function fnG(a, b, c, d3, m2, k4, s3) {
      return rotl(a + (b & d3 | c & ~d3) + m2 + k4 | 0, s3) + b | 0;
    }
    function fnH(a, b, c, d3, m2, k4, s3) {
      return rotl(a + (b ^ c ^ d3) + m2 + k4 | 0, s3) + b | 0;
    }
    function fnI(a, b, c, d3, m2, k4, s3) {
      return rotl(a + (c ^ (b | ~d3)) + m2 + k4 | 0, s3) + b | 0;
    }
    module.exports = MD5;
  });
  require_evp_bytestokey = __commonJS2((exports, module) => {
    var Buffer22 = require_safe_buffer().Buffer, MD5 = require_md5();
    function EVP_BytesToKey(password, salt, keyBits, ivLen) {
      if (!Buffer22.isBuffer(password))
        password = Buffer22.from(password, "binary");
      if (salt) {
        if (!Buffer22.isBuffer(salt))
          salt = Buffer22.from(salt, "binary");
        if (salt.length !== 8)
          throw new RangeError("salt should be Buffer with 8 byte length");
      }
      var keyLen = keyBits / 8, key = Buffer22.alloc(keyLen), iv = Buffer22.alloc(ivLen || 0), tmp = Buffer22.alloc(0);
      while (keyLen > 0 || ivLen > 0) {
        var hash = new MD5;
        if (hash.update(tmp), hash.update(password), salt)
          hash.update(salt);
        tmp = hash.digest();
        var used = 0;
        if (keyLen > 0) {
          var keyStart = key.length - keyLen;
          used = Math.min(keyLen, tmp.length), tmp.copy(key, keyStart, 0, used), keyLen -= used;
        }
        if (used < tmp.length && ivLen > 0) {
          var ivStart = iv.length - ivLen, length = Math.min(ivLen, tmp.length - used);
          tmp.copy(iv, ivStart, used, used + length), ivLen -= length;
        }
      }
      return tmp.fill(0), { key, iv };
    }
    module.exports = EVP_BytesToKey;
  });
  require_browserify_aes = __commonJS2((exports) => {
    var crypto2 = (init_crypto(), __toCommonJS(exports_crypto));
    exports.createCipher = exports.Cipher = crypto2.createCipher;
    exports.createCipheriv = exports.Cipheriv = crypto2.createCipheriv;
    exports.createDecipher = exports.Decipher = crypto2.createDecipher;
    exports.createDecipheriv = exports.Decipheriv = crypto2.createDecipheriv;
    exports.listCiphers = exports.getCiphers = crypto2.getCiphers;
  });
  require_fixProc = __commonJS2((exports, module) => {
    var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, evp = require_evp_bytestokey(), ciphers = require_browserify_aes(), Buffer22 = require_safe_buffer().Buffer;
    module.exports = function(okey, password) {
      var key = okey.toString(), match = key.match(findProc), decrypted;
      if (!match) {
        var match2 = key.match(fullRegex);
        decrypted = Buffer22.from(match2[2].replace(/[\r\n]/g, ""), "base64");
      } else {
        var suite = "aes" + match[1], iv = Buffer22.from(match[2], "hex"), cipherText = Buffer22.from(match[3].replace(/[\r\n]/g, ""), "base64"), cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key, out = [], cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
        out.push(cipher.update(cipherText)), out.push(cipher.final()), decrypted = Buffer22.concat(out);
      }
      var tag = key.match(startRegex)[1];
      return { tag, data: decrypted };
    };
  });
  require_parse_asn1 = __commonJS2((exports, module) => {
    var asn1 = require_asn12(), aesid = require_aesid(), fixProc = require_fixProc(), ciphers = require_browserify_aes(), compat = require_pbkdf2(), Buffer22 = require_safe_buffer().Buffer;
    function decrypt(data, password) {
      var salt = data.algorithm.decrypt.kde.kdeparams.salt, iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), algo = aesid[data.algorithm.decrypt.cipher.algo.join(".")], iv = data.algorithm.decrypt.cipher.iv, cipherText = data.subjectPrivateKey, keylen = parseInt(algo.split("-")[1], 10) / 8, key = compat.pbkdf2Sync(password, salt, iters, keylen, "sha1"), cipher = ciphers.createDecipheriv(algo, key, iv), out = [];
      return out.push(cipher.update(cipherText)), out.push(cipher.final()), Buffer22.concat(out);
    }
    function parseKeys(buffer) {
      var password;
      if (typeof buffer === "object" && !Buffer22.isBuffer(buffer))
        password = buffer.passphrase, buffer = buffer.key;
      if (typeof buffer === "string")
        buffer = Buffer22.from(buffer);
      var stripped = fixProc(buffer, password), type = stripped.tag, data = stripped.data, subtype, ndata;
      switch (type) {
        case "CERTIFICATE":
          ndata = asn1.certificate.decode(data, "der").tbsCertificate.subjectPublicKeyInfo;
        case "PUBLIC KEY":
          if (!ndata)
            ndata = asn1.PublicKey.decode(data, "der");
          switch (subtype = ndata.algorithm.algorithm.join("."), subtype) {
            case "1.2.840.113549.1.1.1":
              return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
            case "1.2.840.10045.2.1":
              return ndata.subjectPrivateKey = ndata.subjectPublicKey, { type: "ec", data: ndata };
            case "1.2.840.10040.4.1":
              return ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, "der"), { type: "dsa", data: ndata.algorithm.params };
            default:
              throw new Error("unknown key id " + subtype);
          }
        case "ENCRYPTED PRIVATE KEY":
          data = asn1.EncryptedPrivateKey.decode(data, "der"), data = decrypt(data, password);
        case "PRIVATE KEY":
          switch (ndata = asn1.PrivateKey.decode(data, "der"), subtype = ndata.algorithm.algorithm.join("."), subtype) {
            case "1.2.840.113549.1.1.1":
              return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
            case "1.2.840.10045.2.1":
              return { curve: ndata.algorithm.curve, privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey };
            case "1.2.840.10040.4.1":
              return ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, "der"), { type: "dsa", params: ndata.algorithm.params };
            default:
              throw new Error("unknown key id " + subtype);
          }
        case "RSA PUBLIC KEY":
          return asn1.RSAPublicKey.decode(data, "der");
        case "RSA PRIVATE KEY":
          return asn1.RSAPrivateKey.decode(data, "der");
        case "DSA PRIVATE KEY":
          return { type: "dsa", params: asn1.DSAPrivateKey.decode(data, "der") };
        case "EC PRIVATE KEY":
          return data = asn1.ECPrivateKey.decode(data, "der"), { curve: data.parameters.value, privateKey: data.privateKey };
        default:
          throw new Error("unknown key type " + type);
      }
    }
    parseKeys.signature = asn1.signature;
    module.exports = parseKeys;
  });
  require_mgf = __commonJS2((exports, module) => {
    var createHash = require_create_hash(), Buffer22 = require_safe_buffer().Buffer;
    module.exports = function(seed, len2) {
      var t2 = Buffer22.alloc(0), i2 = 0, c;
      while (t2.length < len2)
        c = i2ops(i2++), t2 = Buffer22.concat([t2, createHash("sha1").update(seed).update(c).digest()]);
      return t2.slice(0, len2);
    };
    function i2ops(c) {
      var out = Buffer22.allocUnsafe(4);
      return out.writeUInt32BE(c, 0), out;
    }
  });
  require_xor = __commonJS2((exports, module) => {
    module.exports = function xor(a, b) {
      var len2 = a.length, i2 = -1;
      while (++i2 < len2)
        a[i2] ^= b[i2];
      return a;
    };
  });
  require_bn4 = __commonJS2((exports, module) => {
    (function(module2, exports2) {
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number))
          return number;
        if (this.negative = 0, this.words = null, this.length = 0, this.red = null, number !== null) {
          if (base === "le" || base === "be")
            endian = base, base = 10;
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object")
        module2.exports = BN;
      else
        exports2.BN = BN;
      BN.BN = BN, BN.wordSize = 26;
      var Buffer22;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined")
          Buffer22 = window.Buffer;
        else
          Buffer22 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer;
      } catch (e2) {}
      BN.isBN = function isBN(num) {
        if (num instanceof BN)
          return true;
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      }, BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      }, BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      }, BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number")
          return this._initNumber(number, base, endian);
        if (typeof number === "object")
          return this._initArray(number, base, endian);
        if (base === "hex")
          base = 16;
        assert(base === (base | 0) && base >= 2 && base <= 36), number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-")
          start++, this.negative = 1;
        if (start < number.length) {
          if (base === 16)
            this._parseHex(number, start, endian);
          else if (this._parseBase(number, base, start), endian === "le")
            this._initArray(this.toArray(), base, endian);
        }
      }, BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0)
          this.negative = 1, number = -number;
        if (number < 67108864)
          this.words = [number & 67108863], this.length = 1;
        else if (number < 4503599627370496)
          this.words = [number & 67108863, number / 67108864 & 67108863], this.length = 2;
        else
          assert(number < 9007199254740992), this.words = [number & 67108863, number / 67108864 & 67108863, 1], this.length = 3;
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      }, BN.prototype._initArray = function _initArray(number, base, endian) {
        if (assert(typeof number.length === "number"), number.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(number.length / 3), this.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          this.words[i2] = 0;
        var j3, w, off = 0;
        if (endian === "be") {
          for (i2 = number.length - 1, j3 = 0;i2 >= 0; i2 -= 3)
            if (w = number[i2] | number[i2 - 1] << 8 | number[i2 - 2] << 16, this.words[j3] |= w << off & 67108863, this.words[j3 + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
              off -= 26, j3++;
        } else if (endian === "le") {
          for (i2 = 0, j3 = 0;i2 < number.length; i2 += 3)
            if (w = number[i2] | number[i2 + 1] << 8 | number[i2 + 2] << 16, this.words[j3] |= w << off & 67108863, this.words[j3 + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
              off -= 26, j3++;
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 65 && c <= 70)
          return c - 55;
        else if (c >= 97 && c <= 102)
          return c - 87;
        else
          return c - 48 & 15;
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound)
          r |= parseHex4Bits(string, index - 1) << 4;
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6), this.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          this.words[i2] = 0;
        var off = 0, j3 = 0, w;
        if (endian === "be")
          for (i2 = number.length - 1;i2 >= start; i2 -= 2)
            if (w = parseHexByte(number, start, i2) << off, this.words[j3] |= w & 67108863, off >= 18)
              off -= 18, j3 += 1, this.words[j3] |= w >>> 26;
            else
              off += 8;
        else {
          var parseLength = number.length - start;
          for (i2 = parseLength % 2 === 0 ? start + 1 : start;i2 < number.length; i2 += 2)
            if (w = parseHexByte(number, start, i2) << off, this.words[j3] |= w & 67108863, off >= 18)
              off -= 18, j3 += 1, this.words[j3] |= w >>> 26;
            else
              off += 8;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0, len2 = Math.min(str.length, end);
        for (var i2 = start;i2 < len2; i2++) {
          var c = str.charCodeAt(i2) - 48;
          if (r *= mul, c >= 49)
            r += c - 49 + 10;
          else if (c >= 17)
            r += c - 17 + 10;
          else
            r += c;
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0], this.length = 1;
        for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base)
          limbLen++;
        limbLen--, limbPow = limbPow / base | 0;
        var total = number.length - start, mod = total % limbLen, end = Math.min(total, total - mod) + start, word = 0;
        for (var i2 = start;i2 < end; i2 += limbLen)
          if (word = parseBase(number, i2, i2 + limbLen, base), this.imuln(limbPow), this.words[0] + word < 67108864)
            this.words[0] += word;
          else
            this._iaddn(word);
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i2, number.length, base);
          for (i2 = 0;i2 < mod; i2++)
            pow *= base;
          if (this.imuln(pow), this.words[0] + word < 67108864)
            this.words[0] += word;
          else
            this._iaddn(word);
        }
        this.strip();
      }, BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          dest.words[i2] = this.words[i2];
        dest.length = this.length, dest.negative = this.negative, dest.red = this.red;
      }, BN.prototype.clone = function clone() {
        var r = new BN(null);
        return this.copy(r), r;
      }, BN.prototype._expand = function _expand(size) {
        while (this.length < size)
          this.words[this.length++] = 0;
        return this;
      }, BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0)
          this.length--;
        return this._normSign();
      }, BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0)
          this.negative = 0;
        return this;
      }, BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      if (BN.prototype.toString = function toString(base, padding) {
        base = base || 10, padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0, carry = 0;
          for (var i2 = 0;i2 < this.length; i2++) {
            var w = this.words[i2], word = ((w << off | carry) & 16777215).toString(16);
            if (carry = w >>> 24 - off & 16777215, off += 2, off >= 26)
              off -= 26, i2--;
            if (carry !== 0 || i2 !== this.length - 1)
              out = zeros[6 - word.length] + word + out;
            else
              out = word + out;
          }
          if (carry !== 0)
            out = carry.toString(16) + out;
          while (out.length % padding !== 0)
            out = "0" + out;
          if (this.negative !== 0)
            out = "-" + out;
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base], groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            if (c = c.idivn(groupBase), !c.isZero())
              out = zeros[groupSize - r.length] + r + out;
            else
              out = r + out;
          }
          if (this.isZero())
            out = "0" + out;
          while (out.length % padding !== 0)
            out = "0" + out;
          if (this.negative !== 0)
            out = "-" + out;
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      }, BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2)
          ret += this.words[1] * 67108864;
        else if (this.length === 3 && this.words[2] === 1)
          ret += 4503599627370496 + this.words[1] * 67108864;
        else if (this.length > 2)
          assert(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -ret : ret;
      }, BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      }, BN.prototype.toBuffer = function toBuffer(endian, length) {
        return assert(typeof Buffer22 !== "undefined"), this.toArrayLike(Buffer22, endian, length);
      }, BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      }, BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength2 = this.byteLength(), reqLength = length || Math.max(1, byteLength2);
        assert(byteLength2 <= reqLength, "byte array longer than desired length"), assert(reqLength > 0, "Requested array length <= 0"), this.strip();
        var littleEndian = endian === "le", res = new ArrayType(reqLength), b, i2, q3 = this.clone();
        if (!littleEndian) {
          for (i2 = 0;i2 < reqLength - byteLength2; i2++)
            res[i2] = 0;
          for (i2 = 0;!q3.isZero(); i2++)
            b = q3.andln(255), q3.iushrn(8), res[reqLength - i2 - 1] = b;
        } else {
          for (i2 = 0;!q3.isZero(); i2++)
            b = q3.andln(255), q3.iushrn(8), res[i2] = b;
          for (;i2 < reqLength; i2++)
            res[i2] = 0;
        }
        return res;
      }, Math.clz32)
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      else
        BN.prototype._countBits = function _countBits(w) {
          var t2 = w, r = 0;
          if (t2 >= 4096)
            r += 13, t2 >>>= 13;
          if (t2 >= 64)
            r += 7, t2 >>>= 7;
          if (t2 >= 8)
            r += 4, t2 >>>= 4;
          if (t2 >= 2)
            r += 2, t2 >>>= 2;
          return r + t2;
        };
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t2 = w, r = 0;
        if ((t2 & 8191) === 0)
          r += 13, t2 >>>= 13;
        if ((t2 & 127) === 0)
          r += 7, t2 >>>= 7;
        if ((t2 & 15) === 0)
          r += 4, t2 >>>= 4;
        if ((t2 & 3) === 0)
          r += 2, t2 >>>= 2;
        if ((t2 & 1) === 0)
          r++;
        return r;
      }, BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1], hi2 = this._countBits(w);
        return (this.length - 1) * 26 + hi2;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0;bit < w.length; bit++) {
          var off = bit / 26 | 0, wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i2 = 0;i2 < this.length; i2++) {
          var b = this._zeroBits(this.words[i2]);
          if (r += b, b !== 26)
            break;
        }
        return r;
      }, BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      }, BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0)
          return this.abs().inotn(width).iaddn(1);
        return this.clone();
      }, BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1))
          return this.notn(width).iaddn(1).ineg();
        return this.clone();
      }, BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      }, BN.prototype.neg = function neg() {
        return this.clone().ineg();
      }, BN.prototype.ineg = function ineg() {
        if (!this.isZero())
          this.negative ^= 1;
        return this;
      }, BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length)
          this.words[this.length++] = 0;
        for (var i2 = 0;i2 < num.length; i2++)
          this.words[i2] = this.words[i2] | num.words[i2];
        return this.strip();
      }, BN.prototype.ior = function ior(num) {
        return assert((this.negative | num.negative) === 0), this.iuor(num);
      }, BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      }, BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      }, BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length)
          b = num;
        else
          b = this;
        for (var i2 = 0;i2 < b.length; i2++)
          this.words[i2] = this.words[i2] & num.words[i2];
        return this.length = b.length, this.strip();
      }, BN.prototype.iand = function iand(num) {
        return assert((this.negative | num.negative) === 0), this.iuand(num);
      }, BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      }, BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      }, BN.prototype.iuxor = function iuxor(num) {
        var a, b;
        if (this.length > num.length)
          a = this, b = num;
        else
          a = num, b = this;
        for (var i2 = 0;i2 < b.length; i2++)
          this.words[i2] = a.words[i2] ^ b.words[i2];
        if (this !== a)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        return this.length = a.length, this.strip();
      }, BN.prototype.ixor = function ixor(num) {
        return assert((this.negative | num.negative) === 0), this.iuxor(num);
      }, BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      }, BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      }, BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0, bitsLeft = width % 26;
        if (this._expand(bytesNeeded), bitsLeft > 0)
          bytesNeeded--;
        for (var i2 = 0;i2 < bytesNeeded; i2++)
          this.words[i2] = ~this.words[i2] & 67108863;
        if (bitsLeft > 0)
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        return this.strip();
      }, BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      }, BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0, wbit = bit % 26;
        if (this._expand(off + 1), val)
          this.words[off] = this.words[off] | 1 << wbit;
        else
          this.words[off] = this.words[off] & ~(1 << wbit);
        return this.strip();
      }, BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0)
          return this.negative = 0, r = this.isub(num), this.negative ^= 1, this._normSign();
        else if (this.negative === 0 && num.negative !== 0)
          return num.negative = 0, r = this.isub(num), num.negative = 1, r._normSign();
        var a, b;
        if (this.length > num.length)
          a = this, b = num;
        else
          a = num, b = this;
        var carry = 0;
        for (var i2 = 0;i2 < b.length; i2++)
          r = (a.words[i2] | 0) + (b.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
        for (;carry !== 0 && i2 < a.length; i2++)
          r = (a.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
        if (this.length = a.length, carry !== 0)
          this.words[this.length] = carry, this.length++;
        else if (a !== this)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        return this;
      }, BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0)
          return num.negative = 0, res = this.sub(num), num.negative ^= 1, res;
        else if (num.negative === 0 && this.negative !== 0)
          return this.negative = 0, res = num.sub(this), this.negative = 1, res;
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      }, BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          return num.negative = 1, r._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(num), this.negative = 1, this._normSign();
        var cmp = this.cmp(num);
        if (cmp === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var a, b;
        if (cmp > 0)
          a = this, b = num;
        else
          a = num, b = this;
        var carry = 0;
        for (var i2 = 0;i2 < b.length; i2++)
          r = (a.words[i2] | 0) - (b.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
        for (;carry !== 0 && i2 < a.length; i2++)
          r = (a.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
        if (carry === 0 && i2 < a.length && a !== this)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        if (this.length = Math.max(this.length, i2), a !== this)
          this.negative = 1;
        return this.strip();
      }, BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len2 = self2.length + num.length | 0;
        out.length = len2, len2 = len2 - 1 | 0;
        var a = self2.words[0] | 0, b = num.words[0] | 0, r = a * b, lo = r & 67108863, carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k4 = 1;k4 < len2; k4++) {
          var ncarry = carry >>> 26, rword = carry & 67108863, maxJ = Math.min(k4, num.length - 1);
          for (var j3 = Math.max(0, k4 - self2.length + 1);j3 <= maxJ; j3++) {
            var i2 = k4 - j3 | 0;
            a = self2.words[i2] | 0, b = num.words[j3] | 0, r = a * b + rword, ncarry += r / 67108864 | 0, rword = r & 67108863;
          }
          out.words[k4] = rword | 0, carry = ncarry | 0;
        }
        if (carry !== 0)
          out.words[k4] = carry | 0;
        else
          out.length--;
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo(self2, num, out) {
        var a = self2.words, b = num.words, o = out.words, c = 0, lo, mid, hi2, a0 = a[0] | 0, al0 = a0 & 8191, ah0 = a0 >>> 13, a1 = a[1] | 0, al1 = a1 & 8191, ah1 = a1 >>> 13, a2 = a[2] | 0, al2 = a2 & 8191, ah2 = a2 >>> 13, a3 = a[3] | 0, al3 = a3 & 8191, ah3 = a3 >>> 13, a4 = a[4] | 0, al4 = a4 & 8191, ah4 = a4 >>> 13, a5 = a[5] | 0, al5 = a5 & 8191, ah5 = a5 >>> 13, a6 = a[6] | 0, al6 = a6 & 8191, ah6 = a6 >>> 13, a7 = a[7] | 0, al7 = a7 & 8191, ah7 = a7 >>> 13, a8 = a[8] | 0, al8 = a8 & 8191, ah8 = a8 >>> 13, a9 = a[9] | 0, al9 = a9 & 8191, ah9 = a9 >>> 13, b0 = b[0] | 0, bl0 = b0 & 8191, bh0 = b0 >>> 13, b1 = b[1] | 0, bl1 = b1 & 8191, bh1 = b1 >>> 13, b2 = b[2] | 0, bl2 = b2 & 8191, bh2 = b2 >>> 13, b3 = b[3] | 0, bl3 = b3 & 8191, bh3 = b3 >>> 13, b4 = b[4] | 0, bl4 = b4 & 8191, bh4 = b4 >>> 13, b5 = b[5] | 0, bl5 = b5 & 8191, bh5 = b5 >>> 13, b6 = b[6] | 0, bl6 = b6 & 8191, bh6 = b6 >>> 13, b7 = b[7] | 0, bl7 = b7 & 8191, bh7 = b7 >>> 13, b8 = b[8] | 0, bl8 = b8 & 8191, bh8 = b8 >>> 13, b9 = b[9] | 0, bl9 = b9 & 8191, bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative, out.length = 19, lo = Math.imul(al0, bl0), mid = Math.imul(al0, bh0), mid = mid + Math.imul(ah0, bl0) | 0, hi2 = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w0 >>> 26) | 0, w0 &= 67108863, lo = Math.imul(al1, bl0), mid = Math.imul(al1, bh0), mid = mid + Math.imul(ah1, bl0) | 0, hi2 = Math.imul(ah1, bh0), lo = lo + Math.imul(al0, bl1) | 0, mid = mid + Math.imul(al0, bh1) | 0, mid = mid + Math.imul(ah0, bl1) | 0, hi2 = hi2 + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w1 >>> 26) | 0, w1 &= 67108863, lo = Math.imul(al2, bl0), mid = Math.imul(al2, bh0), mid = mid + Math.imul(ah2, bl0) | 0, hi2 = Math.imul(ah2, bh0), lo = lo + Math.imul(al1, bl1) | 0, mid = mid + Math.imul(al1, bh1) | 0, mid = mid + Math.imul(ah1, bl1) | 0, hi2 = hi2 + Math.imul(ah1, bh1) | 0, lo = lo + Math.imul(al0, bl2) | 0, mid = mid + Math.imul(al0, bh2) | 0, mid = mid + Math.imul(ah0, bl2) | 0, hi2 = hi2 + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w2 >>> 26) | 0, w2 &= 67108863, lo = Math.imul(al3, bl0), mid = Math.imul(al3, bh0), mid = mid + Math.imul(ah3, bl0) | 0, hi2 = Math.imul(ah3, bh0), lo = lo + Math.imul(al2, bl1) | 0, mid = mid + Math.imul(al2, bh1) | 0, mid = mid + Math.imul(ah2, bl1) | 0, hi2 = hi2 + Math.imul(ah2, bh1) | 0, lo = lo + Math.imul(al1, bl2) | 0, mid = mid + Math.imul(al1, bh2) | 0, mid = mid + Math.imul(ah1, bl2) | 0, hi2 = hi2 + Math.imul(ah1, bh2) | 0, lo = lo + Math.imul(al0, bl3) | 0, mid = mid + Math.imul(al0, bh3) | 0, mid = mid + Math.imul(ah0, bl3) | 0, hi2 = hi2 + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w3 >>> 26) | 0, w3 &= 67108863, lo = Math.imul(al4, bl0), mid = Math.imul(al4, bh0), mid = mid + Math.imul(ah4, bl0) | 0, hi2 = Math.imul(ah4, bh0), lo = lo + Math.imul(al3, bl1) | 0, mid = mid + Math.imul(al3, bh1) | 0, mid = mid + Math.imul(ah3, bl1) | 0, hi2 = hi2 + Math.imul(ah3, bh1) | 0, lo = lo + Math.imul(al2, bl2) | 0, mid = mid + Math.imul(al2, bh2) | 0, mid = mid + Math.imul(ah2, bl2) | 0, hi2 = hi2 + Math.imul(ah2, bh2) | 0, lo = lo + Math.imul(al1, bl3) | 0, mid = mid + Math.imul(al1, bh3) | 0, mid = mid + Math.imul(ah1, bl3) | 0, hi2 = hi2 + Math.imul(ah1, bh3) | 0, lo = lo + Math.imul(al0, bl4) | 0, mid = mid + Math.imul(al0, bh4) | 0, mid = mid + Math.imul(ah0, bl4) | 0, hi2 = hi2 + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w4 >>> 26) | 0, w4 &= 67108863, lo = Math.imul(al5, bl0), mid = Math.imul(al5, bh0), mid = mid + Math.imul(ah5, bl0) | 0, hi2 = Math.imul(ah5, bh0), lo = lo + Math.imul(al4, bl1) | 0, mid = mid + Math.imul(al4, bh1) | 0, mid = mid + Math.imul(ah4, bl1) | 0, hi2 = hi2 + Math.imul(ah4, bh1) | 0, lo = lo + Math.imul(al3, bl2) | 0, mid = mid + Math.imul(al3, bh2) | 0, mid = mid + Math.imul(ah3, bl2) | 0, hi2 = hi2 + Math.imul(ah3, bh2) | 0, lo = lo + Math.imul(al2, bl3) | 0, mid = mid + Math.imul(al2, bh3) | 0, mid = mid + Math.imul(ah2, bl3) | 0, hi2 = hi2 + Math.imul(ah2, bh3) | 0, lo = lo + Math.imul(al1, bl4) | 0, mid = mid + Math.imul(al1, bh4) | 0, mid = mid + Math.imul(ah1, bl4) | 0, hi2 = hi2 + Math.imul(ah1, bh4) | 0, lo = lo + Math.imul(al0, bl5) | 0, mid = mid + Math.imul(al0, bh5) | 0, mid = mid + Math.imul(ah0, bl5) | 0, hi2 = hi2 + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w5 >>> 26) | 0, w5 &= 67108863, lo = Math.imul(al6, bl0), mid = Math.imul(al6, bh0), mid = mid + Math.imul(ah6, bl0) | 0, hi2 = Math.imul(ah6, bh0), lo = lo + Math.imul(al5, bl1) | 0, mid = mid + Math.imul(al5, bh1) | 0, mid = mid + Math.imul(ah5, bl1) | 0, hi2 = hi2 + Math.imul(ah5, bh1) | 0, lo = lo + Math.imul(al4, bl2) | 0, mid = mid + Math.imul(al4, bh2) | 0, mid = mid + Math.imul(ah4, bl2) | 0, hi2 = hi2 + Math.imul(ah4, bh2) | 0, lo = lo + Math.imul(al3, bl3) | 0, mid = mid + Math.imul(al3, bh3) | 0, mid = mid + Math.imul(ah3, bl3) | 0, hi2 = hi2 + Math.imul(ah3, bh3) | 0, lo = lo + Math.imul(al2, bl4) | 0, mid = mid + Math.imul(al2, bh4) | 0, mid = mid + Math.imul(ah2, bl4) | 0, hi2 = hi2 + Math.imul(ah2, bh4) | 0, lo = lo + Math.imul(al1, bl5) | 0, mid = mid + Math.imul(al1, bh5) | 0, mid = mid + Math.imul(ah1, bl5) | 0, hi2 = hi2 + Math.imul(ah1, bh5) | 0, lo = lo + Math.imul(al0, bl6) | 0, mid = mid + Math.imul(al0, bh6) | 0, mid = mid + Math.imul(ah0, bl6) | 0, hi2 = hi2 + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w6 >>> 26) | 0, w6 &= 67108863, lo = Math.imul(al7, bl0), mid = Math.imul(al7, bh0), mid = mid + Math.imul(ah7, bl0) | 0, hi2 = Math.imul(ah7, bh0), lo = lo + Math.imul(al6, bl1) | 0, mid = mid + Math.imul(al6, bh1) | 0, mid = mid + Math.imul(ah6, bl1) | 0, hi2 = hi2 + Math.imul(ah6, bh1) | 0, lo = lo + Math.imul(al5, bl2) | 0, mid = mid + Math.imul(al5, bh2) | 0, mid = mid + Math.imul(ah5, bl2) | 0, hi2 = hi2 + Math.imul(ah5, bh2) | 0, lo = lo + Math.imul(al4, bl3) | 0, mid = mid + Math.imul(al4, bh3) | 0, mid = mid + Math.imul(ah4, bl3) | 0, hi2 = hi2 + Math.imul(ah4, bh3) | 0, lo = lo + Math.imul(al3, bl4) | 0, mid = mid + Math.imul(al3, bh4) | 0, mid = mid + Math.imul(ah3, bl4) | 0, hi2 = hi2 + Math.imul(ah3, bh4) | 0, lo = lo + Math.imul(al2, bl5) | 0, mid = mid + Math.imul(al2, bh5) | 0, mid = mid + Math.imul(ah2, bl5) | 0, hi2 = hi2 + Math.imul(ah2, bh5) | 0, lo = lo + Math.imul(al1, bl6) | 0, mid = mid + Math.imul(al1, bh6) | 0, mid = mid + Math.imul(ah1, bl6) | 0, hi2 = hi2 + Math.imul(ah1, bh6) | 0, lo = lo + Math.imul(al0, bl7) | 0, mid = mid + Math.imul(al0, bh7) | 0, mid = mid + Math.imul(ah0, bl7) | 0, hi2 = hi2 + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w7 >>> 26) | 0, w7 &= 67108863, lo = Math.imul(al8, bl0), mid = Math.imul(al8, bh0), mid = mid + Math.imul(ah8, bl0) | 0, hi2 = Math.imul(ah8, bh0), lo = lo + Math.imul(al7, bl1) | 0, mid = mid + Math.imul(al7, bh1) | 0, mid = mid + Math.imul(ah7, bl1) | 0, hi2 = hi2 + Math.imul(ah7, bh1) | 0, lo = lo + Math.imul(al6, bl2) | 0, mid = mid + Math.imul(al6, bh2) | 0, mid = mid + Math.imul(ah6, bl2) | 0, hi2 = hi2 + Math.imul(ah6, bh2) | 0, lo = lo + Math.imul(al5, bl3) | 0, mid = mid + Math.imul(al5, bh3) | 0, mid = mid + Math.imul(ah5, bl3) | 0, hi2 = hi2 + Math.imul(ah5, bh3) | 0, lo = lo + Math.imul(al4, bl4) | 0, mid = mid + Math.imul(al4, bh4) | 0, mid = mid + Math.imul(ah4, bl4) | 0, hi2 = hi2 + Math.imul(ah4, bh4) | 0, lo = lo + Math.imul(al3, bl5) | 0, mid = mid + Math.imul(al3, bh5) | 0, mid = mid + Math.imul(ah3, bl5) | 0, hi2 = hi2 + Math.imul(ah3, bh5) | 0, lo = lo + Math.imul(al2, bl6) | 0, mid = mid + Math.imul(al2, bh6) | 0, mid = mid + Math.imul(ah2, bl6) | 0, hi2 = hi2 + Math.imul(ah2, bh6) | 0, lo = lo + Math.imul(al1, bl7) | 0, mid = mid + Math.imul(al1, bh7) | 0, mid = mid + Math.imul(ah1, bl7) | 0, hi2 = hi2 + Math.imul(ah1, bh7) | 0, lo = lo + Math.imul(al0, bl8) | 0, mid = mid + Math.imul(al0, bh8) | 0, mid = mid + Math.imul(ah0, bl8) | 0, hi2 = hi2 + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0, w8 &= 67108863, lo = Math.imul(al9, bl0), mid = Math.imul(al9, bh0), mid = mid + Math.imul(ah9, bl0) | 0, hi2 = Math.imul(ah9, bh0), lo = lo + Math.imul(al8, bl1) | 0, mid = mid + Math.imul(al8, bh1) | 0, mid = mid + Math.imul(ah8, bl1) | 0, hi2 = hi2 + Math.imul(ah8, bh1) | 0, lo = lo + Math.imul(al7, bl2) | 0, mid = mid + Math.imul(al7, bh2) | 0, mid = mid + Math.imul(ah7, bl2) | 0, hi2 = hi2 + Math.imul(ah7, bh2) | 0, lo = lo + Math.imul(al6, bl3) | 0, mid = mid + Math.imul(al6, bh3) | 0, mid = mid + Math.imul(ah6, bl3) | 0, hi2 = hi2 + Math.imul(ah6, bh3) | 0, lo = lo + Math.imul(al5, bl4) | 0, mid = mid + Math.imul(al5, bh4) | 0, mid = mid + Math.imul(ah5, bl4) | 0, hi2 = hi2 + Math.imul(ah5, bh4) | 0, lo = lo + Math.imul(al4, bl5) | 0, mid = mid + Math.imul(al4, bh5) | 0, mid = mid + Math.imul(ah4, bl5) | 0, hi2 = hi2 + Math.imul(ah4, bh5) | 0, lo = lo + Math.imul(al3, bl6) | 0, mid = mid + Math.imul(al3, bh6) | 0, mid = mid + Math.imul(ah3, bl6) | 0, hi2 = hi2 + Math.imul(ah3, bh6) | 0, lo = lo + Math.imul(al2, bl7) | 0, mid = mid + Math.imul(al2, bh7) | 0, mid = mid + Math.imul(ah2, bl7) | 0, hi2 = hi2 + Math.imul(ah2, bh7) | 0, lo = lo + Math.imul(al1, bl8) | 0, mid = mid + Math.imul(al1, bh8) | 0, mid = mid + Math.imul(ah1, bl8) | 0, hi2 = hi2 + Math.imul(ah1, bh8) | 0, lo = lo + Math.imul(al0, bl9) | 0, mid = mid + Math.imul(al0, bh9) | 0, mid = mid + Math.imul(ah0, bl9) | 0, hi2 = hi2 + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0, w9 &= 67108863, lo = Math.imul(al9, bl1), mid = Math.imul(al9, bh1), mid = mid + Math.imul(ah9, bl1) | 0, hi2 = Math.imul(ah9, bh1), lo = lo + Math.imul(al8, bl2) | 0, mid = mid + Math.imul(al8, bh2) | 0, mid = mid + Math.imul(ah8, bl2) | 0, hi2 = hi2 + Math.imul(ah8, bh2) | 0, lo = lo + Math.imul(al7, bl3) | 0, mid = mid + Math.imul(al7, bh3) | 0, mid = mid + Math.imul(ah7, bl3) | 0, hi2 = hi2 + Math.imul(ah7, bh3) | 0, lo = lo + Math.imul(al6, bl4) | 0, mid = mid + Math.imul(al6, bh4) | 0, mid = mid + Math.imul(ah6, bl4) | 0, hi2 = hi2 + Math.imul(ah6, bh4) | 0, lo = lo + Math.imul(al5, bl5) | 0, mid = mid + Math.imul(al5, bh5) | 0, mid = mid + Math.imul(ah5, bl5) | 0, hi2 = hi2 + Math.imul(ah5, bh5) | 0, lo = lo + Math.imul(al4, bl6) | 0, mid = mid + Math.imul(al4, bh6) | 0, mid = mid + Math.imul(ah4, bl6) | 0, hi2 = hi2 + Math.imul(ah4, bh6) | 0, lo = lo + Math.imul(al3, bl7) | 0, mid = mid + Math.imul(al3, bh7) | 0, mid = mid + Math.imul(ah3, bl7) | 0, hi2 = hi2 + Math.imul(ah3, bh7) | 0, lo = lo + Math.imul(al2, bl8) | 0, mid = mid + Math.imul(al2, bh8) | 0, mid = mid + Math.imul(ah2, bl8) | 0, hi2 = hi2 + Math.imul(ah2, bh8) | 0, lo = lo + Math.imul(al1, bl9) | 0, mid = mid + Math.imul(al1, bh9) | 0, mid = mid + Math.imul(ah1, bl9) | 0, hi2 = hi2 + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0, w10 &= 67108863, lo = Math.imul(al9, bl2), mid = Math.imul(al9, bh2), mid = mid + Math.imul(ah9, bl2) | 0, hi2 = Math.imul(ah9, bh2), lo = lo + Math.imul(al8, bl3) | 0, mid = mid + Math.imul(al8, bh3) | 0, mid = mid + Math.imul(ah8, bl3) | 0, hi2 = hi2 + Math.imul(ah8, bh3) | 0, lo = lo + Math.imul(al7, bl4) | 0, mid = mid + Math.imul(al7, bh4) | 0, mid = mid + Math.imul(ah7, bl4) | 0, hi2 = hi2 + Math.imul(ah7, bh4) | 0, lo = lo + Math.imul(al6, bl5) | 0, mid = mid + Math.imul(al6, bh5) | 0, mid = mid + Math.imul(ah6, bl5) | 0, hi2 = hi2 + Math.imul(ah6, bh5) | 0, lo = lo + Math.imul(al5, bl6) | 0, mid = mid + Math.imul(al5, bh6) | 0, mid = mid + Math.imul(ah5, bl6) | 0, hi2 = hi2 + Math.imul(ah5, bh6) | 0, lo = lo + Math.imul(al4, bl7) | 0, mid = mid + Math.imul(al4, bh7) | 0, mid = mid + Math.imul(ah4, bl7) | 0, hi2 = hi2 + Math.imul(ah4, bh7) | 0, lo = lo + Math.imul(al3, bl8) | 0, mid = mid + Math.imul(al3, bh8) | 0, mid = mid + Math.imul(ah3, bl8) | 0, hi2 = hi2 + Math.imul(ah3, bh8) | 0, lo = lo + Math.imul(al2, bl9) | 0, mid = mid + Math.imul(al2, bh9) | 0, mid = mid + Math.imul(ah2, bl9) | 0, hi2 = hi2 + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0, w11 &= 67108863, lo = Math.imul(al9, bl3), mid = Math.imul(al9, bh3), mid = mid + Math.imul(ah9, bl3) | 0, hi2 = Math.imul(ah9, bh3), lo = lo + Math.imul(al8, bl4) | 0, mid = mid + Math.imul(al8, bh4) | 0, mid = mid + Math.imul(ah8, bl4) | 0, hi2 = hi2 + Math.imul(ah8, bh4) | 0, lo = lo + Math.imul(al7, bl5) | 0, mid = mid + Math.imul(al7, bh5) | 0, mid = mid + Math.imul(ah7, bl5) | 0, hi2 = hi2 + Math.imul(ah7, bh5) | 0, lo = lo + Math.imul(al6, bl6) | 0, mid = mid + Math.imul(al6, bh6) | 0, mid = mid + Math.imul(ah6, bl6) | 0, hi2 = hi2 + Math.imul(ah6, bh6) | 0, lo = lo + Math.imul(al5, bl7) | 0, mid = mid + Math.imul(al5, bh7) | 0, mid = mid + Math.imul(ah5, bl7) | 0, hi2 = hi2 + Math.imul(ah5, bh7) | 0, lo = lo + Math.imul(al4, bl8) | 0, mid = mid + Math.imul(al4, bh8) | 0, mid = mid + Math.imul(ah4, bl8) | 0, hi2 = hi2 + Math.imul(ah4, bh8) | 0, lo = lo + Math.imul(al3, bl9) | 0, mid = mid + Math.imul(al3, bh9) | 0, mid = mid + Math.imul(ah3, bl9) | 0, hi2 = hi2 + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0, w12 &= 67108863, lo = Math.imul(al9, bl4), mid = Math.imul(al9, bh4), mid = mid + Math.imul(ah9, bl4) | 0, hi2 = Math.imul(ah9, bh4), lo = lo + Math.imul(al8, bl5) | 0, mid = mid + Math.imul(al8, bh5) | 0, mid = mid + Math.imul(ah8, bl5) | 0, hi2 = hi2 + Math.imul(ah8, bh5) | 0, lo = lo + Math.imul(al7, bl6) | 0, mid = mid + Math.imul(al7, bh6) | 0, mid = mid + Math.imul(ah7, bl6) | 0, hi2 = hi2 + Math.imul(ah7, bh6) | 0, lo = lo + Math.imul(al6, bl7) | 0, mid = mid + Math.imul(al6, bh7) | 0, mid = mid + Math.imul(ah6, bl7) | 0, hi2 = hi2 + Math.imul(ah6, bh7) | 0, lo = lo + Math.imul(al5, bl8) | 0, mid = mid + Math.imul(al5, bh8) | 0, mid = mid + Math.imul(ah5, bl8) | 0, hi2 = hi2 + Math.imul(ah5, bh8) | 0, lo = lo + Math.imul(al4, bl9) | 0, mid = mid + Math.imul(al4, bh9) | 0, mid = mid + Math.imul(ah4, bl9) | 0, hi2 = hi2 + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0, w13 &= 67108863, lo = Math.imul(al9, bl5), mid = Math.imul(al9, bh5), mid = mid + Math.imul(ah9, bl5) | 0, hi2 = Math.imul(ah9, bh5), lo = lo + Math.imul(al8, bl6) | 0, mid = mid + Math.imul(al8, bh6) | 0, mid = mid + Math.imul(ah8, bl6) | 0, hi2 = hi2 + Math.imul(ah8, bh6) | 0, lo = lo + Math.imul(al7, bl7) | 0, mid = mid + Math.imul(al7, bh7) | 0, mid = mid + Math.imul(ah7, bl7) | 0, hi2 = hi2 + Math.imul(ah7, bh7) | 0, lo = lo + Math.imul(al6, bl8) | 0, mid = mid + Math.imul(al6, bh8) | 0, mid = mid + Math.imul(ah6, bl8) | 0, hi2 = hi2 + Math.imul(ah6, bh8) | 0, lo = lo + Math.imul(al5, bl9) | 0, mid = mid + Math.imul(al5, bh9) | 0, mid = mid + Math.imul(ah5, bl9) | 0, hi2 = hi2 + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0, w14 &= 67108863, lo = Math.imul(al9, bl6), mid = Math.imul(al9, bh6), mid = mid + Math.imul(ah9, bl6) | 0, hi2 = Math.imul(ah9, bh6), lo = lo + Math.imul(al8, bl7) | 0, mid = mid + Math.imul(al8, bh7) | 0, mid = mid + Math.imul(ah8, bl7) | 0, hi2 = hi2 + Math.imul(ah8, bh7) | 0, lo = lo + Math.imul(al7, bl8) | 0, mid = mid + Math.imul(al7, bh8) | 0, mid = mid + Math.imul(ah7, bl8) | 0, hi2 = hi2 + Math.imul(ah7, bh8) | 0, lo = lo + Math.imul(al6, bl9) | 0, mid = mid + Math.imul(al6, bh9) | 0, mid = mid + Math.imul(ah6, bl9) | 0, hi2 = hi2 + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0, w15 &= 67108863, lo = Math.imul(al9, bl7), mid = Math.imul(al9, bh7), mid = mid + Math.imul(ah9, bl7) | 0, hi2 = Math.imul(ah9, bh7), lo = lo + Math.imul(al8, bl8) | 0, mid = mid + Math.imul(al8, bh8) | 0, mid = mid + Math.imul(ah8, bl8) | 0, hi2 = hi2 + Math.imul(ah8, bh8) | 0, lo = lo + Math.imul(al7, bl9) | 0, mid = mid + Math.imul(al7, bh9) | 0, mid = mid + Math.imul(ah7, bl9) | 0, hi2 = hi2 + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0, w16 &= 67108863, lo = Math.imul(al9, bl8), mid = Math.imul(al9, bh8), mid = mid + Math.imul(ah9, bl8) | 0, hi2 = Math.imul(ah9, bh8), lo = lo + Math.imul(al8, bl9) | 0, mid = mid + Math.imul(al8, bh9) | 0, mid = mid + Math.imul(ah8, bl9) | 0, hi2 = hi2 + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0, w17 &= 67108863, lo = Math.imul(al9, bl9), mid = Math.imul(al9, bh9), mid = mid + Math.imul(ah9, bl9) | 0, hi2 = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        if (c = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0, w18 &= 67108863, o[0] = w0, o[1] = w1, o[2] = w2, o[3] = w3, o[4] = w4, o[5] = w5, o[6] = w6, o[7] = w7, o[8] = w8, o[9] = w9, o[10] = w10, o[11] = w11, o[12] = w12, o[13] = w13, o[14] = w14, o[15] = w15, o[16] = w16, o[17] = w17, o[18] = w18, c !== 0)
          o[19] = c, out.length++;
        return out;
      };
      if (!Math.imul)
        comb10MulTo = smallMulTo;
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative, out.length = self2.length + num.length;
        var carry = 0, hncarry = 0;
        for (var k4 = 0;k4 < out.length - 1; k4++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863, maxJ = Math.min(k4, num.length - 1);
          for (var j3 = Math.max(0, k4 - self2.length + 1);j3 <= maxJ; j3++) {
            var i2 = k4 - j3, a = self2.words[i2] | 0, b = num.words[j3] | 0, r = a * b, lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0, lo = lo + rword | 0, rword = lo & 67108863, ncarry = ncarry + (lo >>> 26) | 0, hncarry += ncarry >>> 26, ncarry &= 67108863;
          }
          out.words[k4] = rword, carry = ncarry, ncarry = hncarry;
        }
        if (carry !== 0)
          out.words[k4] = carry;
        else
          out.length--;
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM;
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res, len2 = this.length + num.length;
        if (this.length === 10 && num.length === 10)
          res = comb10MulTo(this, num, out);
        else if (len2 < 63)
          res = smallMulTo(this, num, out);
        else if (len2 < 1024)
          res = bigMulTo(this, num, out);
        else
          res = jumboMulTo(this, num, out);
        return res;
      };
      function FFTM(x4, y) {
        this.x = x4, this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N3) {
        var t2 = new Array(N3), l3 = BN.prototype._countBits(N3) - 1;
        for (var i2 = 0;i2 < N3; i2++)
          t2[i2] = this.revBin(i2, l3, N3);
        return t2;
      }, FFTM.prototype.revBin = function revBin(x4, l3, N3) {
        if (x4 === 0 || x4 === N3 - 1)
          return x4;
        var rb = 0;
        for (var i2 = 0;i2 < l3; i2++)
          rb |= (x4 & 1) << l3 - i2 - 1, x4 >>= 1;
        return rb;
      }, FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N3) {
        for (var i2 = 0;i2 < N3; i2++)
          rtws[i2] = rws[rbt[i2]], itws[i2] = iws[rbt[i2]];
      }, FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N3, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N3);
        for (var s3 = 1;s3 < N3; s3 <<= 1) {
          var l3 = s3 << 1, rtwdf = Math.cos(2 * Math.PI / l3), itwdf = Math.sin(2 * Math.PI / l3);
          for (var p2 = 0;p2 < N3; p2 += l3) {
            var rtwdf_ = rtwdf, itwdf_ = itwdf;
            for (var j3 = 0;j3 < s3; j3++) {
              var re2 = rtws[p2 + j3], ie4 = itws[p2 + j3], ro = rtws[p2 + j3 + s3], io = itws[p2 + j3 + s3], rx = rtwdf_ * ro - itwdf_ * io;
              if (io = rtwdf_ * io + itwdf_ * ro, ro = rx, rtws[p2 + j3] = re2 + ro, itws[p2 + j3] = ie4 + io, rtws[p2 + j3 + s3] = re2 - ro, itws[p2 + j3 + s3] = ie4 - io, j3 !== l3)
                rx = rtwdf * rtwdf_ - itwdf * itwdf_, itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_, rtwdf_ = rx;
            }
          }
        }
      }, FFTM.prototype.guessLen13b = function guessLen13b(n, m2) {
        var N3 = Math.max(m2, n) | 1, odd = N3 & 1, i2 = 0;
        for (N3 = N3 / 2 | 0;N3; N3 = N3 >>> 1)
          i2++;
        return 1 << i2 + 1 + odd;
      }, FFTM.prototype.conjugate = function conjugate(rws, iws, N3) {
        if (N3 <= 1)
          return;
        for (var i2 = 0;i2 < N3 / 2; i2++) {
          var t2 = rws[i2];
          rws[i2] = rws[N3 - i2 - 1], rws[N3 - i2 - 1] = t2, t2 = iws[i2], iws[i2] = -iws[N3 - i2 - 1], iws[N3 - i2 - 1] = -t2;
        }
      }, FFTM.prototype.normalize13b = function normalize13b(ws, N3) {
        var carry = 0;
        for (var i2 = 0;i2 < N3 / 2; i2++) {
          var w = Math.round(ws[2 * i2 + 1] / N3) * 8192 + Math.round(ws[2 * i2] / N3) + carry;
          if (ws[i2] = w & 67108863, w < 67108864)
            carry = 0;
          else
            carry = w / 67108864 | 0;
        }
        return ws;
      }, FFTM.prototype.convert13b = function convert13b(ws, len2, rws, N3) {
        var carry = 0;
        for (var i2 = 0;i2 < len2; i2++)
          carry = carry + (ws[i2] | 0), rws[2 * i2] = carry & 8191, carry = carry >>> 13, rws[2 * i2 + 1] = carry & 8191, carry = carry >>> 13;
        for (i2 = 2 * len2;i2 < N3; ++i2)
          rws[i2] = 0;
        assert(carry === 0), assert((carry & -8192) === 0);
      }, FFTM.prototype.stub = function stub(N3) {
        var ph = new Array(N3);
        for (var i2 = 0;i2 < N3; i2++)
          ph[i2] = 0;
        return ph;
      }, FFTM.prototype.mulp = function mulp(x4, y, out) {
        var N3 = 2 * this.guessLen13b(x4.length, y.length), rbt = this.makeRBT(N3), _3 = this.stub(N3), rws = new Array(N3), rwst = new Array(N3), iwst = new Array(N3), nrws = new Array(N3), nrwst = new Array(N3), niwst = new Array(N3), rmws = out.words;
        rmws.length = N3, this.convert13b(x4.words, x4.length, rws, N3), this.convert13b(y.words, y.length, nrws, N3), this.transform(rws, _3, rwst, iwst, N3, rbt), this.transform(nrws, _3, nrwst, niwst, N3, rbt);
        for (var i2 = 0;i2 < N3; i2++) {
          var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
          iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2], rwst[i2] = rx;
        }
        return this.conjugate(rwst, iwst, N3), this.transform(rwst, iwst, rmws, _3, N3, rbt), this.conjugate(rmws, _3, N3), this.normalize13b(rmws, N3), out.negative = x4.negative ^ y.negative, out.length = x4.length + y.length, out.strip();
      }, BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        return out.words = new Array(this.length + num.length), this.mulTo(num, out);
      }, BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        return out.words = new Array(this.length + num.length), jumboMulTo(this, num, out);
      }, BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      }, BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number"), assert(num < 67108864);
        var carry = 0;
        for (var i2 = 0;i2 < this.length; i2++) {
          var w = (this.words[i2] | 0) * num, lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26, carry += w / 67108864 | 0, carry += lo >>> 26, this.words[i2] = lo & 67108863;
        }
        if (carry !== 0)
          this.words[i2] = carry, this.length++;
        return this.length = num === 0 ? 1 : this.length, this;
      }, BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      }, BN.prototype.sqr = function sqr() {
        return this.mul(this);
      }, BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      }, BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i2 = 0;i2 < w.length; i2++, res = res.sqr())
          if (w[i2] !== 0)
            break;
        if (++i2 < w.length)
          for (var q3 = res.sqr();i2 < w.length; i2++, q3 = q3.sqr()) {
            if (w[i2] === 0)
              continue;
            res = res.mul(q3);
          }
        return res;
      }, BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26, s3 = (bits - r) / 26, carryMask = 67108863 >>> 26 - r << 26 - r, i2;
        if (r !== 0) {
          var carry = 0;
          for (i2 = 0;i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask, c = (this.words[i2] | 0) - newCarry << r;
            this.words[i2] = c | carry, carry = newCarry >>> 26 - r;
          }
          if (carry)
            this.words[i2] = carry, this.length++;
        }
        if (s3 !== 0) {
          for (i2 = this.length - 1;i2 >= 0; i2--)
            this.words[i2 + s3] = this.words[i2];
          for (i2 = 0;i2 < s3; i2++)
            this.words[i2] = 0;
          this.length += s3;
        }
        return this.strip();
      }, BN.prototype.ishln = function ishln(bits) {
        return assert(this.negative === 0), this.iushln(bits);
      }, BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint)
          h = (hint - hint % 26) / 26;
        else
          h = 0;
        var r = bits % 26, s3 = Math.min((bits - r) / 26, this.length), mask = 67108863 ^ 67108863 >>> r << r, maskedWords = extended;
        if (h -= s3, h = Math.max(0, h), maskedWords) {
          for (var i2 = 0;i2 < s3; i2++)
            maskedWords.words[i2] = this.words[i2];
          maskedWords.length = s3;
        }
        if (s3 === 0)
          ;
        else if (this.length > s3) {
          this.length -= s3;
          for (i2 = 0;i2 < this.length; i2++)
            this.words[i2] = this.words[i2 + s3];
        } else
          this.words[0] = 0, this.length = 1;
        var carry = 0;
        for (i2 = this.length - 1;i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r | word >>> r, carry = word & mask;
        }
        if (maskedWords && carry !== 0)
          maskedWords.words[maskedWords.length++] = carry;
        if (this.length === 0)
          this.words[0] = 0, this.length = 1;
        return this.strip();
      }, BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        return assert(this.negative === 0), this.iushrn(bits, hint, extended);
      }, BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      }, BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      }, BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      }, BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      }, BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26, s3 = (bit - r) / 26, q3 = 1 << r;
        if (this.length <= s3)
          return false;
        var w = this.words[s3];
        return !!(w & q3);
      }, BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26, s3 = (bits - r) / 26;
        if (assert(this.negative === 0, "imaskn works only with positive numbers"), this.length <= s3)
          return this;
        if (r !== 0)
          s3++;
        if (this.length = Math.min(s3, this.length), r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      }, BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      }, BN.prototype.iaddn = function iaddn(num) {
        if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num)
            return this.words[0] = num - (this.words[0] | 0), this.negative = 0, this;
          return this.negative = 0, this.isubn(num), this.negative = 1, this;
        }
        return this._iaddn(num);
      }, BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0;i2 < this.length && this.words[i2] >= 67108864; i2++)
          if (this.words[i2] -= 67108864, i2 === this.length - 1)
            this.words[i2 + 1] = 1;
          else
            this.words[i2 + 1]++;
        return this.length = Math.max(this.length, i2 + 1), this;
      }, BN.prototype.isubn = function isubn(num) {
        if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(num), this.negative = 1, this;
        if (this.words[0] -= num, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var i2 = 0;i2 < this.length && this.words[i2] < 0; i2++)
            this.words[i2] += 67108864, this.words[i2 + 1] -= 1;
        return this.strip();
      }, BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      }, BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      }, BN.prototype.iabs = function iabs() {
        return this.negative = 0, this;
      }, BN.prototype.abs = function abs() {
        return this.clone().iabs();
      }, BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len2 = num.length + shift, i2;
        this._expand(len2);
        var w, carry = 0;
        for (i2 = 0;i2 < num.length; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul;
          w -= right & 67108863, carry = (w >> 26) - (right / 67108864 | 0), this.words[i2 + shift] = w & 67108863;
        }
        for (;i2 < this.length - shift; i2++)
          w = (this.words[i2 + shift] | 0) + carry, carry = w >> 26, this.words[i2 + shift] = w & 67108863;
        if (carry === 0)
          return this.strip();
        assert(carry === -1), carry = 0;
        for (i2 = 0;i2 < this.length; i2++)
          w = -(this.words[i2] | 0) + carry, carry = w >> 26, this.words[i2] = w & 67108863;
        return this.negative = 1, this.strip();
      }, BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length, a = this.clone(), b = num, bhi = b.words[b.length - 1] | 0, bhiBits = this._countBits(bhi);
        if (shift = 26 - bhiBits, shift !== 0)
          b = b.ushln(shift), a.iushln(shift), bhi = b.words[b.length - 1] | 0;
        var m2 = a.length - b.length, q3;
        if (mode !== "mod") {
          q3 = new BN(null), q3.length = m2 + 1, q3.words = new Array(q3.length);
          for (var i2 = 0;i2 < q3.length; i2++)
            q3.words[i2] = 0;
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m2);
        if (diff.negative === 0) {
          if (a = diff, q3)
            q3.words[m2] = 1;
        }
        for (var j3 = m2 - 1;j3 >= 0; j3--) {
          var qj = (a.words[b.length + j3] | 0) * 67108864 + (a.words[b.length + j3 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863), a._ishlnsubmul(b, qj, j3);
          while (a.negative !== 0)
            if (qj--, a.negative = 0, a._ishlnsubmul(b, 1, j3), !a.isZero())
              a.negative ^= 1;
          if (q3)
            q3.words[j3] = qj;
        }
        if (q3)
          q3.strip();
        if (a.strip(), mode !== "div" && shift !== 0)
          a.iushrn(shift);
        return { div: q3 || null, mod: a };
      }, BN.prototype.divmod = function divmod(num, mode, positive) {
        if (assert(!num.isZero()), this.isZero())
          return { div: new BN(0), mod: new BN(0) };
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          if (res = this.neg().divmod(num, mode), mode !== "mod")
            div = res.div.neg();
          if (mode !== "div") {
            if (mod = res.mod.neg(), positive && mod.negative !== 0)
              mod.iadd(num);
          }
          return { div, mod };
        }
        if (this.negative === 0 && num.negative !== 0) {
          if (res = this.divmod(num.neg(), mode), mode !== "mod")
            div = res.div.neg();
          return { div, mod: res.mod };
        }
        if ((this.negative & num.negative) !== 0) {
          if (res = this.neg().divmod(num.neg(), mode), mode !== "div") {
            if (mod = res.mod.neg(), positive && mod.negative !== 0)
              mod.isub(num);
          }
          return { div: res.div, mod };
        }
        if (num.length > this.length || this.cmp(num) < 0)
          return { div: new BN(0), mod: this };
        if (num.length === 1) {
          if (mode === "div")
            return { div: this.divn(num.words[0]), mod: null };
          if (mode === "mod")
            return { div: null, mod: new BN(this.modn(num.words[0])) };
          return { div: this.divn(num.words[0]), mod: new BN(this.modn(num.words[0])) };
        }
        return this._wordDiv(num, mode);
      }, BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      }, BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      }, BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      }, BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod, half = num.ushrn(1), r2 = num.andln(1), cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      }, BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p2 = 67108864 % num, acc = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--)
          acc = (p2 * acc + (this.words[i2] | 0)) % num;
        return acc;
      }, BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--) {
          var w = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w / num | 0, carry = w % num;
        }
        return this.strip();
      }, BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      }, BN.prototype.egcd = function egcd(p2) {
        assert(p2.negative === 0), assert(!p2.isZero());
        var x4 = this, y = p2.clone();
        if (x4.negative !== 0)
          x4 = x4.umod(p2);
        else
          x4 = x4.clone();
        var A3 = new BN(1), B3 = new BN(0), C2 = new BN(0), D2 = new BN(1), g2 = 0;
        while (x4.isEven() && y.isEven())
          x4.iushrn(1), y.iushrn(1), ++g2;
        var yp = y.clone(), xp = x4.clone();
        while (!x4.isZero()) {
          for (var i2 = 0, im = 1;(x4.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            x4.iushrn(i2);
            while (i2-- > 0) {
              if (A3.isOdd() || B3.isOdd())
                A3.iadd(yp), B3.isub(xp);
              A3.iushrn(1), B3.iushrn(1);
            }
          }
          for (var j3 = 0, jm = 1;(y.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
            ;
          if (j3 > 0) {
            y.iushrn(j3);
            while (j3-- > 0) {
              if (C2.isOdd() || D2.isOdd())
                C2.iadd(yp), D2.isub(xp);
              C2.iushrn(1), D2.iushrn(1);
            }
          }
          if (x4.cmp(y) >= 0)
            x4.isub(y), A3.isub(C2), B3.isub(D2);
          else
            y.isub(x4), C2.isub(A3), D2.isub(B3);
        }
        return { a: C2, b: D2, gcd: y.iushln(g2) };
      }, BN.prototype._invmp = function _invmp(p2) {
        assert(p2.negative === 0), assert(!p2.isZero());
        var a = this, b = p2.clone();
        if (a.negative !== 0)
          a = a.umod(p2);
        else
          a = a.clone();
        var x1 = new BN(1), x22 = new BN(0), delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i2 = 0, im = 1;(a.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            a.iushrn(i2);
            while (i2-- > 0) {
              if (x1.isOdd())
                x1.iadd(delta);
              x1.iushrn(1);
            }
          }
          for (var j3 = 0, jm = 1;(b.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
            ;
          if (j3 > 0) {
            b.iushrn(j3);
            while (j3-- > 0) {
              if (x22.isOdd())
                x22.iadd(delta);
              x22.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0)
            a.isub(b), x1.isub(x22);
          else
            b.isub(a), x22.isub(x1);
        }
        var res;
        if (a.cmpn(1) === 0)
          res = x1;
        else
          res = x22;
        if (res.cmpn(0) < 0)
          res.iadd(p2);
        return res;
      }, BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone(), b = num.clone();
        a.negative = 0, b.negative = 0;
        for (var shift = 0;a.isEven() && b.isEven(); shift++)
          a.iushrn(1), b.iushrn(1);
        do {
          while (a.isEven())
            a.iushrn(1);
          while (b.isEven())
            b.iushrn(1);
          var r = a.cmp(b);
          if (r < 0) {
            var t2 = a;
            a = b, b = t2;
          } else if (r === 0 || b.cmpn(1) === 0)
            break;
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      }, BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      }, BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      }, BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      }, BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      }, BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26, s3 = (bit - r) / 26, q3 = 1 << r;
        if (this.length <= s3)
          return this._expand(s3 + 1), this.words[s3] |= q3, this;
        var carry = q3;
        for (var i2 = s3;carry !== 0 && i2 < this.length; i2++) {
          var w = this.words[i2] | 0;
          w += carry, carry = w >>> 26, w &= 67108863, this.words[i2] = w;
        }
        if (carry !== 0)
          this.words[i2] = carry, this.length++;
        return this;
      }, BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      }, BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1)
          res = 1;
        else {
          if (negative)
            num = -num;
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--) {
          var a = this.words[i2] | 0, b = num.words[i2] | 0;
          if (a === b)
            continue;
          if (a < b)
            res = -1;
          else if (a > b)
            res = 1;
          break;
        }
        return res;
      }, BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      }, BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      }, BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      }, BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      }, BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      }, BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      }, BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      }, BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      }, BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      }, BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      }, BN.red = function red(num) {
        return new Red(num);
      }, BN.prototype.toRed = function toRed(ctx) {
        return assert(!this.red, "Already a number in reduction context"), assert(this.negative === 0, "red works only with positives"), ctx.convertTo(this)._forceRed(ctx);
      }, BN.prototype.fromRed = function fromRed() {
        return assert(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, BN.prototype._forceRed = function _forceRed(ctx) {
        return this.red = ctx, this;
      }, BN.prototype.forceRed = function forceRed(ctx) {
        return assert(!this.red, "Already a number in reduction context"), this._forceRed(ctx);
      }, BN.prototype.redAdd = function redAdd(num) {
        return assert(this.red, "redAdd works only with red numbers"), this.red.add(this, num);
      }, BN.prototype.redIAdd = function redIAdd(num) {
        return assert(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, num);
      }, BN.prototype.redSub = function redSub(num) {
        return assert(this.red, "redSub works only with red numbers"), this.red.sub(this, num);
      }, BN.prototype.redISub = function redISub(num) {
        return assert(this.red, "redISub works only with red numbers"), this.red.isub(this, num);
      }, BN.prototype.redShl = function redShl(num) {
        return assert(this.red, "redShl works only with red numbers"), this.red.shl(this, num);
      }, BN.prototype.redMul = function redMul(num) {
        return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.mul(this, num);
      }, BN.prototype.redIMul = function redIMul(num) {
        return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.imul(this, num);
      }, BN.prototype.redSqr = function redSqr() {
        return assert(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, BN.prototype.redISqr = function redISqr() {
        return assert(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, BN.prototype.redSqrt = function redSqrt() {
        return assert(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, BN.prototype.redInvm = function redInvm() {
        return assert(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, BN.prototype.redNeg = function redNeg() {
        return assert(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, BN.prototype.redPow = function redPow(num) {
        return assert(this.red && !num.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, num);
      };
      var primes = { k256: null, p224: null, p192: null, p25519: null };
      function MPrime(name, p2) {
        this.name = name, this.p = new BN(p2, 16), this.n = this.p.bitLength(), this.k = new BN(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        return tmp.words = new Array(Math.ceil(this.n / 13)), tmp;
      }, MPrime.prototype.ireduce = function ireduce(num) {
        var r = num, rlen;
        do
          this.split(r, this.tmp), r = this.imulK(r), r = r.iadd(this.tmp), rlen = r.bitLength();
        while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0)
          r.words[0] = 0, r.length = 1;
        else if (cmp > 0)
          r.isub(this.p);
        else if (r.strip !== undefined)
          r.strip();
        else
          r._strip();
        return r;
      }, MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      }, MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      inherits2(K256, MPrime), K256.prototype.split = function split(input, output) {
        var mask = 4194303, outLen = Math.min(input.length, 9);
        for (var i2 = 0;i2 < outLen; i2++)
          output.words[i2] = input.words[i2];
        if (output.length = outLen, input.length <= 9) {
          input.words[0] = 0, input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i2 = 10;i2 < input.length; i2++) {
          var next = input.words[i2] | 0;
          input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22, prev = next;
        }
        if (prev >>>= 22, input.words[i2 - 10] = prev, prev === 0 && input.length > 10)
          input.length -= 10;
        else
          input.length -= 9;
      }, K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0, num.words[num.length + 1] = 0, num.length += 2;
        var lo = 0;
        for (var i2 = 0;i2 < num.length; i2++) {
          var w = num.words[i2] | 0;
          lo += w * 977, num.words[i2] = lo & 67108863, lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          if (num.length--, num.words[num.length - 1] === 0)
            num.length--;
        }
        return num;
      };
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      inherits2(P25519, MPrime), P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0;i2 < num.length; i2++) {
          var hi2 = (num.words[i2] | 0) * 19 + carry, lo = hi2 & 67108863;
          hi2 >>>= 26, num.words[i2] = lo, carry = hi2;
        }
        if (carry !== 0)
          num.words[num.length++] = carry;
        return num;
      }, BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime;
        if (name === "k256")
          prime = new K256;
        else if (name === "p224")
          prime = new P224;
        else if (name === "p192")
          prime = new P192;
        else if (name === "p25519")
          prime = new P25519;
        else
          throw new Error("Unknown prime " + name);
        return primes[name] = prime, prime;
      };
      function Red(m2) {
        if (typeof m2 === "string") {
          var prime = BN._prime(m2);
          this.m = prime.p, this.prime = prime;
        } else
          assert(m2.gtn(1), "modulus must be greater than 1"), this.m = m2, this.prime = null;
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives"), assert(a.red, "red works only with red numbers");
      }, Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives"), assert(a.red && a.red === b.red, "red works only with red numbers");
      }, Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      }, Red.prototype.neg = function neg(a) {
        if (a.isZero())
          return a.clone();
        return this.m.sub(a)._forceRed(this);
      }, Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0)
          res.isub(this.m);
        return res._forceRed(this);
      }, Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0)
          res.isub(this.m);
        return res;
      }, Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0)
          res.iadd(this.m);
        return res._forceRed(this);
      }, Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0)
          res.iadd(this.m);
        return res;
      }, Red.prototype.shl = function shl(a, num) {
        return this._verify1(a), this.imod(a.ushln(num));
      }, Red.prototype.imul = function imul(a, b) {
        return this._verify2(a, b), this.imod(a.imul(b));
      }, Red.prototype.mul = function mul(a, b) {
        return this._verify2(a, b), this.imod(a.mul(b));
      }, Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      }, Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      }, Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        if (assert(mod3 % 2 === 1), mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q3 = this.m.subn(1), s3 = 0;
        while (!q3.isZero() && q3.andln(1) === 0)
          s3++, q3.iushrn(1);
        assert(!q3.isZero());
        var one = new BN(1).toRed(this), nOne = one.redNeg(), lpow = this.m.subn(1).iushrn(1), z2 = this.m.bitLength();
        z2 = new BN(2 * z2 * z2).toRed(this);
        while (this.pow(z2, lpow).cmp(nOne) !== 0)
          z2.redIAdd(nOne);
        var c = this.pow(z2, q3), r = this.pow(a, q3.addn(1).iushrn(1)), t2 = this.pow(a, q3), m2 = s3;
        while (t2.cmp(one) !== 0) {
          var tmp = t2;
          for (var i2 = 0;tmp.cmp(one) !== 0; i2++)
            tmp = tmp.redSqr();
          assert(i2 < m2);
          var b = this.pow(c, new BN(1).iushln(m2 - i2 - 1));
          r = r.redMul(b), c = b.redSqr(), t2 = t2.redMul(c), m2 = i2;
        }
        return r;
      }, Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0)
          return inv.negative = 0, this.imod(inv).redNeg();
        else
          return this.imod(inv);
      }, Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4, wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this), wnd[1] = a;
        for (var i2 = 2;i2 < wnd.length; i2++)
          wnd[i2] = this.mul(wnd[i2 - 1], a);
        var res = wnd[0], current = 0, currentLen = 0, start = num.bitLength() % 26;
        if (start === 0)
          start = 26;
        for (i2 = num.length - 1;i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j3 = start - 1;j3 >= 0; j3--) {
            var bit = word >> j3 & 1;
            if (res !== wnd[0])
              res = this.sqr(res);
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            if (current <<= 1, current |= bit, currentLen++, currentLen !== windowSize && (i2 !== 0 || j3 !== 0))
              continue;
            res = this.mul(res, wnd[current]), currentLen = 0, current = 0;
          }
          start = 26;
        }
        return res;
      }, Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      }, Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        return res.red = null, res;
      }, BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m2) {
        if (Red.call(this, m2), this.shift = this.m.bitLength(), this.shift % 26 !== 0)
          this.shift += 26 - this.shift % 26;
        this.r = new BN(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red), Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      }, Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        return r.red = null, r;
      }, Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero())
          return a.words[0] = 0, a.length = 1, a;
        var t2 = a.imul(b), c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t2.isub(c).iushrn(this.shift), res = u;
        if (u.cmp(this.m) >= 0)
          res = u.isub(this.m);
        else if (u.cmpn(0) < 0)
          res = u.iadd(this.m);
        return res._forceRed(this);
      }, Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t2 = a.mul(b), c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t2.isub(c).iushrn(this.shift), res = u;
        if (u.cmp(this.m) >= 0)
          res = u.isub(this.m);
        else if (u.cmpn(0) < 0)
          res = u.iadd(this.m);
        return res._forceRed(this);
      }, Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  });
  require_withPublic = __commonJS2((exports, module) => {
    var BN = require_bn4(), Buffer22 = require_safe_buffer().Buffer;
    function withPublic(paddedMsg, key) {
      return Buffer22.from(paddedMsg.toRed(BN.mont(key.modulus)).redPow(new BN(key.publicExponent)).fromRed().toArray());
    }
    module.exports = withPublic;
  });
  require_bn5 = __commonJS2((exports, module) => {
    (function(module2, exports2) {
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number))
          return number;
        if (this.negative = 0, this.words = null, this.length = 0, this.red = null, number !== null) {
          if (base === "le" || base === "be")
            endian = base, base = 10;
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object")
        module2.exports = BN;
      else
        exports2.BN = BN;
      BN.BN = BN, BN.wordSize = 26;
      var Buffer22;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined")
          Buffer22 = window.Buffer;
        else
          Buffer22 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer;
      } catch (e2) {}
      BN.isBN = function isBN(num) {
        if (num instanceof BN)
          return true;
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      }, BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      }, BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      }, BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number")
          return this._initNumber(number, base, endian);
        if (typeof number === "object")
          return this._initArray(number, base, endian);
        if (base === "hex")
          base = 16;
        assert(base === (base | 0) && base >= 2 && base <= 36), number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-")
          start++, this.negative = 1;
        if (start < number.length) {
          if (base === 16)
            this._parseHex(number, start, endian);
          else if (this._parseBase(number, base, start), endian === "le")
            this._initArray(this.toArray(), base, endian);
        }
      }, BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0)
          this.negative = 1, number = -number;
        if (number < 67108864)
          this.words = [number & 67108863], this.length = 1;
        else if (number < 4503599627370496)
          this.words = [number & 67108863, number / 67108864 & 67108863], this.length = 2;
        else
          assert(number < 9007199254740992), this.words = [number & 67108863, number / 67108864 & 67108863, 1], this.length = 3;
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      }, BN.prototype._initArray = function _initArray(number, base, endian) {
        if (assert(typeof number.length === "number"), number.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(number.length / 3), this.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          this.words[i2] = 0;
        var j3, w, off = 0;
        if (endian === "be") {
          for (i2 = number.length - 1, j3 = 0;i2 >= 0; i2 -= 3)
            if (w = number[i2] | number[i2 - 1] << 8 | number[i2 - 2] << 16, this.words[j3] |= w << off & 67108863, this.words[j3 + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
              off -= 26, j3++;
        } else if (endian === "le") {
          for (i2 = 0, j3 = 0;i2 < number.length; i2 += 3)
            if (w = number[i2] | number[i2 + 1] << 8 | number[i2 + 2] << 16, this.words[j3] |= w << off & 67108863, this.words[j3 + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
              off -= 26, j3++;
        }
        return this._strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 48 && c <= 57)
          return c - 48;
        else if (c >= 65 && c <= 70)
          return c - 55;
        else if (c >= 97 && c <= 102)
          return c - 87;
        else
          assert(false, "Invalid character in " + string);
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound)
          r |= parseHex4Bits(string, index - 1) << 4;
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6), this.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          this.words[i2] = 0;
        var off = 0, j3 = 0, w;
        if (endian === "be")
          for (i2 = number.length - 1;i2 >= start; i2 -= 2)
            if (w = parseHexByte(number, start, i2) << off, this.words[j3] |= w & 67108863, off >= 18)
              off -= 18, j3 += 1, this.words[j3] |= w >>> 26;
            else
              off += 8;
        else {
          var parseLength = number.length - start;
          for (i2 = parseLength % 2 === 0 ? start + 1 : start;i2 < number.length; i2 += 2)
            if (w = parseHexByte(number, start, i2) << off, this.words[j3] |= w & 67108863, off >= 18)
              off -= 18, j3 += 1, this.words[j3] |= w >>> 26;
            else
              off += 8;
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0, b = 0, len2 = Math.min(str.length, end);
        for (var i2 = start;i2 < len2; i2++) {
          var c = str.charCodeAt(i2) - 48;
          if (r *= mul, c >= 49)
            b = c - 49 + 10;
          else if (c >= 17)
            b = c - 17 + 10;
          else
            b = c;
          assert(c >= 0 && b < mul, "Invalid character"), r += b;
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0], this.length = 1;
        for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base)
          limbLen++;
        limbLen--, limbPow = limbPow / base | 0;
        var total = number.length - start, mod = total % limbLen, end = Math.min(total, total - mod) + start, word = 0;
        for (var i2 = start;i2 < end; i2 += limbLen)
          if (word = parseBase(number, i2, i2 + limbLen, base), this.imuln(limbPow), this.words[0] + word < 67108864)
            this.words[0] += word;
          else
            this._iaddn(word);
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i2, number.length, base);
          for (i2 = 0;i2 < mod; i2++)
            pow *= base;
          if (this.imuln(pow), this.words[0] + word < 67108864)
            this.words[0] += word;
          else
            this._iaddn(word);
        }
        this._strip();
      }, BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          dest.words[i2] = this.words[i2];
        dest.length = this.length, dest.negative = this.negative, dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words, dest.length = src.length, dest.negative = src.negative, dest.red = src.red;
      }
      if (BN.prototype._move = function _move(dest) {
        move(dest, this);
      }, BN.prototype.clone = function clone() {
        var r = new BN(null);
        return this.copy(r), r;
      }, BN.prototype._expand = function _expand(size) {
        while (this.length < size)
          this.words[this.length++] = 0;
        return this;
      }, BN.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0)
          this.length--;
        return this._normSign();
      }, BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0)
          this.negative = 0;
        return this;
      }, typeof Symbol !== "undefined" && typeof Symbol.for === "function")
        try {
          BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect3;
        } catch (e2) {
          BN.prototype.inspect = inspect3;
        }
      else
        BN.prototype.inspect = inspect3;
      function inspect3() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      if (BN.prototype.toString = function toString(base, padding) {
        base = base || 10, padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0, carry = 0;
          for (var i2 = 0;i2 < this.length; i2++) {
            var w = this.words[i2], word = ((w << off | carry) & 16777215).toString(16);
            if (carry = w >>> 24 - off & 16777215, off += 2, off >= 26)
              off -= 26, i2--;
            if (carry !== 0 || i2 !== this.length - 1)
              out = zeros[6 - word.length] + word + out;
            else
              out = word + out;
          }
          if (carry !== 0)
            out = carry.toString(16) + out;
          while (out.length % padding !== 0)
            out = "0" + out;
          if (this.negative !== 0)
            out = "-" + out;
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base], groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modrn(groupBase).toString(base);
            if (c = c.idivn(groupBase), !c.isZero())
              out = zeros[groupSize - r.length] + r + out;
            else
              out = r + out;
          }
          if (this.isZero())
            out = "0" + out;
          while (out.length % padding !== 0)
            out = "0" + out;
          if (this.negative !== 0)
            out = "-" + out;
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      }, BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2)
          ret += this.words[1] * 67108864;
        else if (this.length === 3 && this.words[2] === 1)
          ret += 4503599627370496 + this.words[1] * 67108864;
        else if (this.length > 2)
          assert(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -ret : ret;
      }, BN.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      }, Buffer22)
        BN.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer22, endian, length);
        };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate(ArrayType, size) {
        if (ArrayType.allocUnsafe)
          return ArrayType.allocUnsafe(size);
        return new ArrayType(size);
      };
      if (BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength2 = this.byteLength(), reqLength = length || Math.max(1, byteLength2);
        assert(byteLength2 <= reqLength, "byte array longer than desired length"), assert(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength), postfix = endian === "le" ? "LE" : "BE";
        return this["_toArrayLike" + postfix](res, byteLength2), res;
      }, BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength2) {
        var position = 0, carry = 0;
        for (var i2 = 0, shift = 0;i2 < this.length; i2++) {
          var word = this.words[i2] << shift | carry;
          if (res[position++] = word & 255, position < res.length)
            res[position++] = word >> 8 & 255;
          if (position < res.length)
            res[position++] = word >> 16 & 255;
          if (shift === 6) {
            if (position < res.length)
              res[position++] = word >> 24 & 255;
            carry = 0, shift = 0;
          } else
            carry = word >>> 24, shift += 2;
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length)
            res[position++] = 0;
        }
      }, BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength2) {
        var position = res.length - 1, carry = 0;
        for (var i2 = 0, shift = 0;i2 < this.length; i2++) {
          var word = this.words[i2] << shift | carry;
          if (res[position--] = word & 255, position >= 0)
            res[position--] = word >> 8 & 255;
          if (position >= 0)
            res[position--] = word >> 16 & 255;
          if (shift === 6) {
            if (position >= 0)
              res[position--] = word >> 24 & 255;
            carry = 0, shift = 0;
          } else
            carry = word >>> 24, shift += 2;
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0)
            res[position--] = 0;
        }
      }, Math.clz32)
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      else
        BN.prototype._countBits = function _countBits(w) {
          var t2 = w, r = 0;
          if (t2 >= 4096)
            r += 13, t2 >>>= 13;
          if (t2 >= 64)
            r += 7, t2 >>>= 7;
          if (t2 >= 8)
            r += 4, t2 >>>= 4;
          if (t2 >= 2)
            r += 2, t2 >>>= 2;
          return r + t2;
        };
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t2 = w, r = 0;
        if ((t2 & 8191) === 0)
          r += 13, t2 >>>= 13;
        if ((t2 & 127) === 0)
          r += 7, t2 >>>= 7;
        if ((t2 & 15) === 0)
          r += 4, t2 >>>= 4;
        if ((t2 & 3) === 0)
          r += 2, t2 >>>= 2;
        if ((t2 & 1) === 0)
          r++;
        return r;
      }, BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1], hi2 = this._countBits(w);
        return (this.length - 1) * 26 + hi2;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0;bit < w.length; bit++) {
          var off = bit / 26 | 0, wbit = bit % 26;
          w[bit] = num.words[off] >>> wbit & 1;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i2 = 0;i2 < this.length; i2++) {
          var b = this._zeroBits(this.words[i2]);
          if (r += b, b !== 26)
            break;
        }
        return r;
      }, BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      }, BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0)
          return this.abs().inotn(width).iaddn(1);
        return this.clone();
      }, BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1))
          return this.notn(width).iaddn(1).ineg();
        return this.clone();
      }, BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      }, BN.prototype.neg = function neg() {
        return this.clone().ineg();
      }, BN.prototype.ineg = function ineg() {
        if (!this.isZero())
          this.negative ^= 1;
        return this;
      }, BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length)
          this.words[this.length++] = 0;
        for (var i2 = 0;i2 < num.length; i2++)
          this.words[i2] = this.words[i2] | num.words[i2];
        return this._strip();
      }, BN.prototype.ior = function ior(num) {
        return assert((this.negative | num.negative) === 0), this.iuor(num);
      }, BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      }, BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      }, BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length)
          b = num;
        else
          b = this;
        for (var i2 = 0;i2 < b.length; i2++)
          this.words[i2] = this.words[i2] & num.words[i2];
        return this.length = b.length, this._strip();
      }, BN.prototype.iand = function iand(num) {
        return assert((this.negative | num.negative) === 0), this.iuand(num);
      }, BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      }, BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      }, BN.prototype.iuxor = function iuxor(num) {
        var a, b;
        if (this.length > num.length)
          a = this, b = num;
        else
          a = num, b = this;
        for (var i2 = 0;i2 < b.length; i2++)
          this.words[i2] = a.words[i2] ^ b.words[i2];
        if (this !== a)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        return this.length = a.length, this._strip();
      }, BN.prototype.ixor = function ixor(num) {
        return assert((this.negative | num.negative) === 0), this.iuxor(num);
      }, BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      }, BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      }, BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0, bitsLeft = width % 26;
        if (this._expand(bytesNeeded), bitsLeft > 0)
          bytesNeeded--;
        for (var i2 = 0;i2 < bytesNeeded; i2++)
          this.words[i2] = ~this.words[i2] & 67108863;
        if (bitsLeft > 0)
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        return this._strip();
      }, BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      }, BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0, wbit = bit % 26;
        if (this._expand(off + 1), val)
          this.words[off] = this.words[off] | 1 << wbit;
        else
          this.words[off] = this.words[off] & ~(1 << wbit);
        return this._strip();
      }, BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0)
          return this.negative = 0, r = this.isub(num), this.negative ^= 1, this._normSign();
        else if (this.negative === 0 && num.negative !== 0)
          return num.negative = 0, r = this.isub(num), num.negative = 1, r._normSign();
        var a, b;
        if (this.length > num.length)
          a = this, b = num;
        else
          a = num, b = this;
        var carry = 0;
        for (var i2 = 0;i2 < b.length; i2++)
          r = (a.words[i2] | 0) + (b.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
        for (;carry !== 0 && i2 < a.length; i2++)
          r = (a.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
        if (this.length = a.length, carry !== 0)
          this.words[this.length] = carry, this.length++;
        else if (a !== this)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        return this;
      }, BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0)
          return num.negative = 0, res = this.sub(num), num.negative ^= 1, res;
        else if (num.negative === 0 && this.negative !== 0)
          return this.negative = 0, res = num.sub(this), this.negative = 1, res;
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      }, BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          return num.negative = 1, r._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(num), this.negative = 1, this._normSign();
        var cmp = this.cmp(num);
        if (cmp === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var a, b;
        if (cmp > 0)
          a = this, b = num;
        else
          a = num, b = this;
        var carry = 0;
        for (var i2 = 0;i2 < b.length; i2++)
          r = (a.words[i2] | 0) - (b.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
        for (;carry !== 0 && i2 < a.length; i2++)
          r = (a.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
        if (carry === 0 && i2 < a.length && a !== this)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        if (this.length = Math.max(this.length, i2), a !== this)
          this.negative = 1;
        return this._strip();
      }, BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len2 = self2.length + num.length | 0;
        out.length = len2, len2 = len2 - 1 | 0;
        var a = self2.words[0] | 0, b = num.words[0] | 0, r = a * b, lo = r & 67108863, carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k4 = 1;k4 < len2; k4++) {
          var ncarry = carry >>> 26, rword = carry & 67108863, maxJ = Math.min(k4, num.length - 1);
          for (var j3 = Math.max(0, k4 - self2.length + 1);j3 <= maxJ; j3++) {
            var i2 = k4 - j3 | 0;
            a = self2.words[i2] | 0, b = num.words[j3] | 0, r = a * b + rword, ncarry += r / 67108864 | 0, rword = r & 67108863;
          }
          out.words[k4] = rword | 0, carry = ncarry | 0;
        }
        if (carry !== 0)
          out.words[k4] = carry | 0;
        else
          out.length--;
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo(self2, num, out) {
        var a = self2.words, b = num.words, o = out.words, c = 0, lo, mid, hi2, a0 = a[0] | 0, al0 = a0 & 8191, ah0 = a0 >>> 13, a1 = a[1] | 0, al1 = a1 & 8191, ah1 = a1 >>> 13, a2 = a[2] | 0, al2 = a2 & 8191, ah2 = a2 >>> 13, a3 = a[3] | 0, al3 = a3 & 8191, ah3 = a3 >>> 13, a4 = a[4] | 0, al4 = a4 & 8191, ah4 = a4 >>> 13, a5 = a[5] | 0, al5 = a5 & 8191, ah5 = a5 >>> 13, a6 = a[6] | 0, al6 = a6 & 8191, ah6 = a6 >>> 13, a7 = a[7] | 0, al7 = a7 & 8191, ah7 = a7 >>> 13, a8 = a[8] | 0, al8 = a8 & 8191, ah8 = a8 >>> 13, a9 = a[9] | 0, al9 = a9 & 8191, ah9 = a9 >>> 13, b0 = b[0] | 0, bl0 = b0 & 8191, bh0 = b0 >>> 13, b1 = b[1] | 0, bl1 = b1 & 8191, bh1 = b1 >>> 13, b2 = b[2] | 0, bl2 = b2 & 8191, bh2 = b2 >>> 13, b3 = b[3] | 0, bl3 = b3 & 8191, bh3 = b3 >>> 13, b4 = b[4] | 0, bl4 = b4 & 8191, bh4 = b4 >>> 13, b5 = b[5] | 0, bl5 = b5 & 8191, bh5 = b5 >>> 13, b6 = b[6] | 0, bl6 = b6 & 8191, bh6 = b6 >>> 13, b7 = b[7] | 0, bl7 = b7 & 8191, bh7 = b7 >>> 13, b8 = b[8] | 0, bl8 = b8 & 8191, bh8 = b8 >>> 13, b9 = b[9] | 0, bl9 = b9 & 8191, bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative, out.length = 19, lo = Math.imul(al0, bl0), mid = Math.imul(al0, bh0), mid = mid + Math.imul(ah0, bl0) | 0, hi2 = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w0 >>> 26) | 0, w0 &= 67108863, lo = Math.imul(al1, bl0), mid = Math.imul(al1, bh0), mid = mid + Math.imul(ah1, bl0) | 0, hi2 = Math.imul(ah1, bh0), lo = lo + Math.imul(al0, bl1) | 0, mid = mid + Math.imul(al0, bh1) | 0, mid = mid + Math.imul(ah0, bl1) | 0, hi2 = hi2 + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w1 >>> 26) | 0, w1 &= 67108863, lo = Math.imul(al2, bl0), mid = Math.imul(al2, bh0), mid = mid + Math.imul(ah2, bl0) | 0, hi2 = Math.imul(ah2, bh0), lo = lo + Math.imul(al1, bl1) | 0, mid = mid + Math.imul(al1, bh1) | 0, mid = mid + Math.imul(ah1, bl1) | 0, hi2 = hi2 + Math.imul(ah1, bh1) | 0, lo = lo + Math.imul(al0, bl2) | 0, mid = mid + Math.imul(al0, bh2) | 0, mid = mid + Math.imul(ah0, bl2) | 0, hi2 = hi2 + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w2 >>> 26) | 0, w2 &= 67108863, lo = Math.imul(al3, bl0), mid = Math.imul(al3, bh0), mid = mid + Math.imul(ah3, bl0) | 0, hi2 = Math.imul(ah3, bh0), lo = lo + Math.imul(al2, bl1) | 0, mid = mid + Math.imul(al2, bh1) | 0, mid = mid + Math.imul(ah2, bl1) | 0, hi2 = hi2 + Math.imul(ah2, bh1) | 0, lo = lo + Math.imul(al1, bl2) | 0, mid = mid + Math.imul(al1, bh2) | 0, mid = mid + Math.imul(ah1, bl2) | 0, hi2 = hi2 + Math.imul(ah1, bh2) | 0, lo = lo + Math.imul(al0, bl3) | 0, mid = mid + Math.imul(al0, bh3) | 0, mid = mid + Math.imul(ah0, bl3) | 0, hi2 = hi2 + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w3 >>> 26) | 0, w3 &= 67108863, lo = Math.imul(al4, bl0), mid = Math.imul(al4, bh0), mid = mid + Math.imul(ah4, bl0) | 0, hi2 = Math.imul(ah4, bh0), lo = lo + Math.imul(al3, bl1) | 0, mid = mid + Math.imul(al3, bh1) | 0, mid = mid + Math.imul(ah3, bl1) | 0, hi2 = hi2 + Math.imul(ah3, bh1) | 0, lo = lo + Math.imul(al2, bl2) | 0, mid = mid + Math.imul(al2, bh2) | 0, mid = mid + Math.imul(ah2, bl2) | 0, hi2 = hi2 + Math.imul(ah2, bh2) | 0, lo = lo + Math.imul(al1, bl3) | 0, mid = mid + Math.imul(al1, bh3) | 0, mid = mid + Math.imul(ah1, bl3) | 0, hi2 = hi2 + Math.imul(ah1, bh3) | 0, lo = lo + Math.imul(al0, bl4) | 0, mid = mid + Math.imul(al0, bh4) | 0, mid = mid + Math.imul(ah0, bl4) | 0, hi2 = hi2 + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w4 >>> 26) | 0, w4 &= 67108863, lo = Math.imul(al5, bl0), mid = Math.imul(al5, bh0), mid = mid + Math.imul(ah5, bl0) | 0, hi2 = Math.imul(ah5, bh0), lo = lo + Math.imul(al4, bl1) | 0, mid = mid + Math.imul(al4, bh1) | 0, mid = mid + Math.imul(ah4, bl1) | 0, hi2 = hi2 + Math.imul(ah4, bh1) | 0, lo = lo + Math.imul(al3, bl2) | 0, mid = mid + Math.imul(al3, bh2) | 0, mid = mid + Math.imul(ah3, bl2) | 0, hi2 = hi2 + Math.imul(ah3, bh2) | 0, lo = lo + Math.imul(al2, bl3) | 0, mid = mid + Math.imul(al2, bh3) | 0, mid = mid + Math.imul(ah2, bl3) | 0, hi2 = hi2 + Math.imul(ah2, bh3) | 0, lo = lo + Math.imul(al1, bl4) | 0, mid = mid + Math.imul(al1, bh4) | 0, mid = mid + Math.imul(ah1, bl4) | 0, hi2 = hi2 + Math.imul(ah1, bh4) | 0, lo = lo + Math.imul(al0, bl5) | 0, mid = mid + Math.imul(al0, bh5) | 0, mid = mid + Math.imul(ah0, bl5) | 0, hi2 = hi2 + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w5 >>> 26) | 0, w5 &= 67108863, lo = Math.imul(al6, bl0), mid = Math.imul(al6, bh0), mid = mid + Math.imul(ah6, bl0) | 0, hi2 = Math.imul(ah6, bh0), lo = lo + Math.imul(al5, bl1) | 0, mid = mid + Math.imul(al5, bh1) | 0, mid = mid + Math.imul(ah5, bl1) | 0, hi2 = hi2 + Math.imul(ah5, bh1) | 0, lo = lo + Math.imul(al4, bl2) | 0, mid = mid + Math.imul(al4, bh2) | 0, mid = mid + Math.imul(ah4, bl2) | 0, hi2 = hi2 + Math.imul(ah4, bh2) | 0, lo = lo + Math.imul(al3, bl3) | 0, mid = mid + Math.imul(al3, bh3) | 0, mid = mid + Math.imul(ah3, bl3) | 0, hi2 = hi2 + Math.imul(ah3, bh3) | 0, lo = lo + Math.imul(al2, bl4) | 0, mid = mid + Math.imul(al2, bh4) | 0, mid = mid + Math.imul(ah2, bl4) | 0, hi2 = hi2 + Math.imul(ah2, bh4) | 0, lo = lo + Math.imul(al1, bl5) | 0, mid = mid + Math.imul(al1, bh5) | 0, mid = mid + Math.imul(ah1, bl5) | 0, hi2 = hi2 + Math.imul(ah1, bh5) | 0, lo = lo + Math.imul(al0, bl6) | 0, mid = mid + Math.imul(al0, bh6) | 0, mid = mid + Math.imul(ah0, bl6) | 0, hi2 = hi2 + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w6 >>> 26) | 0, w6 &= 67108863, lo = Math.imul(al7, bl0), mid = Math.imul(al7, bh0), mid = mid + Math.imul(ah7, bl0) | 0, hi2 = Math.imul(ah7, bh0), lo = lo + Math.imul(al6, bl1) | 0, mid = mid + Math.imul(al6, bh1) | 0, mid = mid + Math.imul(ah6, bl1) | 0, hi2 = hi2 + Math.imul(ah6, bh1) | 0, lo = lo + Math.imul(al5, bl2) | 0, mid = mid + Math.imul(al5, bh2) | 0, mid = mid + Math.imul(ah5, bl2) | 0, hi2 = hi2 + Math.imul(ah5, bh2) | 0, lo = lo + Math.imul(al4, bl3) | 0, mid = mid + Math.imul(al4, bh3) | 0, mid = mid + Math.imul(ah4, bl3) | 0, hi2 = hi2 + Math.imul(ah4, bh3) | 0, lo = lo + Math.imul(al3, bl4) | 0, mid = mid + Math.imul(al3, bh4) | 0, mid = mid + Math.imul(ah3, bl4) | 0, hi2 = hi2 + Math.imul(ah3, bh4) | 0, lo = lo + Math.imul(al2, bl5) | 0, mid = mid + Math.imul(al2, bh5) | 0, mid = mid + Math.imul(ah2, bl5) | 0, hi2 = hi2 + Math.imul(ah2, bh5) | 0, lo = lo + Math.imul(al1, bl6) | 0, mid = mid + Math.imul(al1, bh6) | 0, mid = mid + Math.imul(ah1, bl6) | 0, hi2 = hi2 + Math.imul(ah1, bh6) | 0, lo = lo + Math.imul(al0, bl7) | 0, mid = mid + Math.imul(al0, bh7) | 0, mid = mid + Math.imul(ah0, bl7) | 0, hi2 = hi2 + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w7 >>> 26) | 0, w7 &= 67108863, lo = Math.imul(al8, bl0), mid = Math.imul(al8, bh0), mid = mid + Math.imul(ah8, bl0) | 0, hi2 = Math.imul(ah8, bh0), lo = lo + Math.imul(al7, bl1) | 0, mid = mid + Math.imul(al7, bh1) | 0, mid = mid + Math.imul(ah7, bl1) | 0, hi2 = hi2 + Math.imul(ah7, bh1) | 0, lo = lo + Math.imul(al6, bl2) | 0, mid = mid + Math.imul(al6, bh2) | 0, mid = mid + Math.imul(ah6, bl2) | 0, hi2 = hi2 + Math.imul(ah6, bh2) | 0, lo = lo + Math.imul(al5, bl3) | 0, mid = mid + Math.imul(al5, bh3) | 0, mid = mid + Math.imul(ah5, bl3) | 0, hi2 = hi2 + Math.imul(ah5, bh3) | 0, lo = lo + Math.imul(al4, bl4) | 0, mid = mid + Math.imul(al4, bh4) | 0, mid = mid + Math.imul(ah4, bl4) | 0, hi2 = hi2 + Math.imul(ah4, bh4) | 0, lo = lo + Math.imul(al3, bl5) | 0, mid = mid + Math.imul(al3, bh5) | 0, mid = mid + Math.imul(ah3, bl5) | 0, hi2 = hi2 + Math.imul(ah3, bh5) | 0, lo = lo + Math.imul(al2, bl6) | 0, mid = mid + Math.imul(al2, bh6) | 0, mid = mid + Math.imul(ah2, bl6) | 0, hi2 = hi2 + Math.imul(ah2, bh6) | 0, lo = lo + Math.imul(al1, bl7) | 0, mid = mid + Math.imul(al1, bh7) | 0, mid = mid + Math.imul(ah1, bl7) | 0, hi2 = hi2 + Math.imul(ah1, bh7) | 0, lo = lo + Math.imul(al0, bl8) | 0, mid = mid + Math.imul(al0, bh8) | 0, mid = mid + Math.imul(ah0, bl8) | 0, hi2 = hi2 + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0, w8 &= 67108863, lo = Math.imul(al9, bl0), mid = Math.imul(al9, bh0), mid = mid + Math.imul(ah9, bl0) | 0, hi2 = Math.imul(ah9, bh0), lo = lo + Math.imul(al8, bl1) | 0, mid = mid + Math.imul(al8, bh1) | 0, mid = mid + Math.imul(ah8, bl1) | 0, hi2 = hi2 + Math.imul(ah8, bh1) | 0, lo = lo + Math.imul(al7, bl2) | 0, mid = mid + Math.imul(al7, bh2) | 0, mid = mid + Math.imul(ah7, bl2) | 0, hi2 = hi2 + Math.imul(ah7, bh2) | 0, lo = lo + Math.imul(al6, bl3) | 0, mid = mid + Math.imul(al6, bh3) | 0, mid = mid + Math.imul(ah6, bl3) | 0, hi2 = hi2 + Math.imul(ah6, bh3) | 0, lo = lo + Math.imul(al5, bl4) | 0, mid = mid + Math.imul(al5, bh4) | 0, mid = mid + Math.imul(ah5, bl4) | 0, hi2 = hi2 + Math.imul(ah5, bh4) | 0, lo = lo + Math.imul(al4, bl5) | 0, mid = mid + Math.imul(al4, bh5) | 0, mid = mid + Math.imul(ah4, bl5) | 0, hi2 = hi2 + Math.imul(ah4, bh5) | 0, lo = lo + Math.imul(al3, bl6) | 0, mid = mid + Math.imul(al3, bh6) | 0, mid = mid + Math.imul(ah3, bl6) | 0, hi2 = hi2 + Math.imul(ah3, bh6) | 0, lo = lo + Math.imul(al2, bl7) | 0, mid = mid + Math.imul(al2, bh7) | 0, mid = mid + Math.imul(ah2, bl7) | 0, hi2 = hi2 + Math.imul(ah2, bh7) | 0, lo = lo + Math.imul(al1, bl8) | 0, mid = mid + Math.imul(al1, bh8) | 0, mid = mid + Math.imul(ah1, bl8) | 0, hi2 = hi2 + Math.imul(ah1, bh8) | 0, lo = lo + Math.imul(al0, bl9) | 0, mid = mid + Math.imul(al0, bh9) | 0, mid = mid + Math.imul(ah0, bl9) | 0, hi2 = hi2 + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0, w9 &= 67108863, lo = Math.imul(al9, bl1), mid = Math.imul(al9, bh1), mid = mid + Math.imul(ah9, bl1) | 0, hi2 = Math.imul(ah9, bh1), lo = lo + Math.imul(al8, bl2) | 0, mid = mid + Math.imul(al8, bh2) | 0, mid = mid + Math.imul(ah8, bl2) | 0, hi2 = hi2 + Math.imul(ah8, bh2) | 0, lo = lo + Math.imul(al7, bl3) | 0, mid = mid + Math.imul(al7, bh3) | 0, mid = mid + Math.imul(ah7, bl3) | 0, hi2 = hi2 + Math.imul(ah7, bh3) | 0, lo = lo + Math.imul(al6, bl4) | 0, mid = mid + Math.imul(al6, bh4) | 0, mid = mid + Math.imul(ah6, bl4) | 0, hi2 = hi2 + Math.imul(ah6, bh4) | 0, lo = lo + Math.imul(al5, bl5) | 0, mid = mid + Math.imul(al5, bh5) | 0, mid = mid + Math.imul(ah5, bl5) | 0, hi2 = hi2 + Math.imul(ah5, bh5) | 0, lo = lo + Math.imul(al4, bl6) | 0, mid = mid + Math.imul(al4, bh6) | 0, mid = mid + Math.imul(ah4, bl6) | 0, hi2 = hi2 + Math.imul(ah4, bh6) | 0, lo = lo + Math.imul(al3, bl7) | 0, mid = mid + Math.imul(al3, bh7) | 0, mid = mid + Math.imul(ah3, bl7) | 0, hi2 = hi2 + Math.imul(ah3, bh7) | 0, lo = lo + Math.imul(al2, bl8) | 0, mid = mid + Math.imul(al2, bh8) | 0, mid = mid + Math.imul(ah2, bl8) | 0, hi2 = hi2 + Math.imul(ah2, bh8) | 0, lo = lo + Math.imul(al1, bl9) | 0, mid = mid + Math.imul(al1, bh9) | 0, mid = mid + Math.imul(ah1, bl9) | 0, hi2 = hi2 + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0, w10 &= 67108863, lo = Math.imul(al9, bl2), mid = Math.imul(al9, bh2), mid = mid + Math.imul(ah9, bl2) | 0, hi2 = Math.imul(ah9, bh2), lo = lo + Math.imul(al8, bl3) | 0, mid = mid + Math.imul(al8, bh3) | 0, mid = mid + Math.imul(ah8, bl3) | 0, hi2 = hi2 + Math.imul(ah8, bh3) | 0, lo = lo + Math.imul(al7, bl4) | 0, mid = mid + Math.imul(al7, bh4) | 0, mid = mid + Math.imul(ah7, bl4) | 0, hi2 = hi2 + Math.imul(ah7, bh4) | 0, lo = lo + Math.imul(al6, bl5) | 0, mid = mid + Math.imul(al6, bh5) | 0, mid = mid + Math.imul(ah6, bl5) | 0, hi2 = hi2 + Math.imul(ah6, bh5) | 0, lo = lo + Math.imul(al5, bl6) | 0, mid = mid + Math.imul(al5, bh6) | 0, mid = mid + Math.imul(ah5, bl6) | 0, hi2 = hi2 + Math.imul(ah5, bh6) | 0, lo = lo + Math.imul(al4, bl7) | 0, mid = mid + Math.imul(al4, bh7) | 0, mid = mid + Math.imul(ah4, bl7) | 0, hi2 = hi2 + Math.imul(ah4, bh7) | 0, lo = lo + Math.imul(al3, bl8) | 0, mid = mid + Math.imul(al3, bh8) | 0, mid = mid + Math.imul(ah3, bl8) | 0, hi2 = hi2 + Math.imul(ah3, bh8) | 0, lo = lo + Math.imul(al2, bl9) | 0, mid = mid + Math.imul(al2, bh9) | 0, mid = mid + Math.imul(ah2, bl9) | 0, hi2 = hi2 + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0, w11 &= 67108863, lo = Math.imul(al9, bl3), mid = Math.imul(al9, bh3), mid = mid + Math.imul(ah9, bl3) | 0, hi2 = Math.imul(ah9, bh3), lo = lo + Math.imul(al8, bl4) | 0, mid = mid + Math.imul(al8, bh4) | 0, mid = mid + Math.imul(ah8, bl4) | 0, hi2 = hi2 + Math.imul(ah8, bh4) | 0, lo = lo + Math.imul(al7, bl5) | 0, mid = mid + Math.imul(al7, bh5) | 0, mid = mid + Math.imul(ah7, bl5) | 0, hi2 = hi2 + Math.imul(ah7, bh5) | 0, lo = lo + Math.imul(al6, bl6) | 0, mid = mid + Math.imul(al6, bh6) | 0, mid = mid + Math.imul(ah6, bl6) | 0, hi2 = hi2 + Math.imul(ah6, bh6) | 0, lo = lo + Math.imul(al5, bl7) | 0, mid = mid + Math.imul(al5, bh7) | 0, mid = mid + Math.imul(ah5, bl7) | 0, hi2 = hi2 + Math.imul(ah5, bh7) | 0, lo = lo + Math.imul(al4, bl8) | 0, mid = mid + Math.imul(al4, bh8) | 0, mid = mid + Math.imul(ah4, bl8) | 0, hi2 = hi2 + Math.imul(ah4, bh8) | 0, lo = lo + Math.imul(al3, bl9) | 0, mid = mid + Math.imul(al3, bh9) | 0, mid = mid + Math.imul(ah3, bl9) | 0, hi2 = hi2 + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0, w12 &= 67108863, lo = Math.imul(al9, bl4), mid = Math.imul(al9, bh4), mid = mid + Math.imul(ah9, bl4) | 0, hi2 = Math.imul(ah9, bh4), lo = lo + Math.imul(al8, bl5) | 0, mid = mid + Math.imul(al8, bh5) | 0, mid = mid + Math.imul(ah8, bl5) | 0, hi2 = hi2 + Math.imul(ah8, bh5) | 0, lo = lo + Math.imul(al7, bl6) | 0, mid = mid + Math.imul(al7, bh6) | 0, mid = mid + Math.imul(ah7, bl6) | 0, hi2 = hi2 + Math.imul(ah7, bh6) | 0, lo = lo + Math.imul(al6, bl7) | 0, mid = mid + Math.imul(al6, bh7) | 0, mid = mid + Math.imul(ah6, bl7) | 0, hi2 = hi2 + Math.imul(ah6, bh7) | 0, lo = lo + Math.imul(al5, bl8) | 0, mid = mid + Math.imul(al5, bh8) | 0, mid = mid + Math.imul(ah5, bl8) | 0, hi2 = hi2 + Math.imul(ah5, bh8) | 0, lo = lo + Math.imul(al4, bl9) | 0, mid = mid + Math.imul(al4, bh9) | 0, mid = mid + Math.imul(ah4, bl9) | 0, hi2 = hi2 + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0, w13 &= 67108863, lo = Math.imul(al9, bl5), mid = Math.imul(al9, bh5), mid = mid + Math.imul(ah9, bl5) | 0, hi2 = Math.imul(ah9, bh5), lo = lo + Math.imul(al8, bl6) | 0, mid = mid + Math.imul(al8, bh6) | 0, mid = mid + Math.imul(ah8, bl6) | 0, hi2 = hi2 + Math.imul(ah8, bh6) | 0, lo = lo + Math.imul(al7, bl7) | 0, mid = mid + Math.imul(al7, bh7) | 0, mid = mid + Math.imul(ah7, bl7) | 0, hi2 = hi2 + Math.imul(ah7, bh7) | 0, lo = lo + Math.imul(al6, bl8) | 0, mid = mid + Math.imul(al6, bh8) | 0, mid = mid + Math.imul(ah6, bl8) | 0, hi2 = hi2 + Math.imul(ah6, bh8) | 0, lo = lo + Math.imul(al5, bl9) | 0, mid = mid + Math.imul(al5, bh9) | 0, mid = mid + Math.imul(ah5, bl9) | 0, hi2 = hi2 + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0, w14 &= 67108863, lo = Math.imul(al9, bl6), mid = Math.imul(al9, bh6), mid = mid + Math.imul(ah9, bl6) | 0, hi2 = Math.imul(ah9, bh6), lo = lo + Math.imul(al8, bl7) | 0, mid = mid + Math.imul(al8, bh7) | 0, mid = mid + Math.imul(ah8, bl7) | 0, hi2 = hi2 + Math.imul(ah8, bh7) | 0, lo = lo + Math.imul(al7, bl8) | 0, mid = mid + Math.imul(al7, bh8) | 0, mid = mid + Math.imul(ah7, bl8) | 0, hi2 = hi2 + Math.imul(ah7, bh8) | 0, lo = lo + Math.imul(al6, bl9) | 0, mid = mid + Math.imul(al6, bh9) | 0, mid = mid + Math.imul(ah6, bl9) | 0, hi2 = hi2 + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0, w15 &= 67108863, lo = Math.imul(al9, bl7), mid = Math.imul(al9, bh7), mid = mid + Math.imul(ah9, bl7) | 0, hi2 = Math.imul(ah9, bh7), lo = lo + Math.imul(al8, bl8) | 0, mid = mid + Math.imul(al8, bh8) | 0, mid = mid + Math.imul(ah8, bl8) | 0, hi2 = hi2 + Math.imul(ah8, bh8) | 0, lo = lo + Math.imul(al7, bl9) | 0, mid = mid + Math.imul(al7, bh9) | 0, mid = mid + Math.imul(ah7, bl9) | 0, hi2 = hi2 + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0, w16 &= 67108863, lo = Math.imul(al9, bl8), mid = Math.imul(al9, bh8), mid = mid + Math.imul(ah9, bl8) | 0, hi2 = Math.imul(ah9, bh8), lo = lo + Math.imul(al8, bl9) | 0, mid = mid + Math.imul(al8, bh9) | 0, mid = mid + Math.imul(ah8, bl9) | 0, hi2 = hi2 + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0, w17 &= 67108863, lo = Math.imul(al9, bl9), mid = Math.imul(al9, bh9), mid = mid + Math.imul(ah9, bl9) | 0, hi2 = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        if (c = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0, w18 &= 67108863, o[0] = w0, o[1] = w1, o[2] = w2, o[3] = w3, o[4] = w4, o[5] = w5, o[6] = w6, o[7] = w7, o[8] = w8, o[9] = w9, o[10] = w10, o[11] = w11, o[12] = w12, o[13] = w13, o[14] = w14, o[15] = w15, o[16] = w16, o[17] = w17, o[18] = w18, c !== 0)
          o[19] = c, out.length++;
        return out;
      };
      if (!Math.imul)
        comb10MulTo = smallMulTo;
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative, out.length = self2.length + num.length;
        var carry = 0, hncarry = 0;
        for (var k4 = 0;k4 < out.length - 1; k4++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863, maxJ = Math.min(k4, num.length - 1);
          for (var j3 = Math.max(0, k4 - self2.length + 1);j3 <= maxJ; j3++) {
            var i2 = k4 - j3, a = self2.words[i2] | 0, b = num.words[j3] | 0, r = a * b, lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0, lo = lo + rword | 0, rword = lo & 67108863, ncarry = ncarry + (lo >>> 26) | 0, hncarry += ncarry >>> 26, ncarry &= 67108863;
          }
          out.words[k4] = rword, carry = ncarry, ncarry = hncarry;
        }
        if (carry !== 0)
          out.words[k4] = carry;
        else
          out.length--;
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res, len2 = this.length + num.length;
        if (this.length === 10 && num.length === 10)
          res = comb10MulTo(this, num, out);
        else if (len2 < 63)
          res = smallMulTo(this, num, out);
        else if (len2 < 1024)
          res = bigMulTo(this, num, out);
        else
          res = jumboMulTo(this, num, out);
        return res;
      };
      function FFTM(x4, y) {
        this.x = x4, this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N3) {
        var t2 = new Array(N3), l3 = BN.prototype._countBits(N3) - 1;
        for (var i2 = 0;i2 < N3; i2++)
          t2[i2] = this.revBin(i2, l3, N3);
        return t2;
      }, FFTM.prototype.revBin = function revBin(x4, l3, N3) {
        if (x4 === 0 || x4 === N3 - 1)
          return x4;
        var rb = 0;
        for (var i2 = 0;i2 < l3; i2++)
          rb |= (x4 & 1) << l3 - i2 - 1, x4 >>= 1;
        return rb;
      }, FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N3) {
        for (var i2 = 0;i2 < N3; i2++)
          rtws[i2] = rws[rbt[i2]], itws[i2] = iws[rbt[i2]];
      }, FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N3, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N3);
        for (var s3 = 1;s3 < N3; s3 <<= 1) {
          var l3 = s3 << 1, rtwdf = Math.cos(2 * Math.PI / l3), itwdf = Math.sin(2 * Math.PI / l3);
          for (var p2 = 0;p2 < N3; p2 += l3) {
            var rtwdf_ = rtwdf, itwdf_ = itwdf;
            for (var j3 = 0;j3 < s3; j3++) {
              var re2 = rtws[p2 + j3], ie4 = itws[p2 + j3], ro = rtws[p2 + j3 + s3], io = itws[p2 + j3 + s3], rx = rtwdf_ * ro - itwdf_ * io;
              if (io = rtwdf_ * io + itwdf_ * ro, ro = rx, rtws[p2 + j3] = re2 + ro, itws[p2 + j3] = ie4 + io, rtws[p2 + j3 + s3] = re2 - ro, itws[p2 + j3 + s3] = ie4 - io, j3 !== l3)
                rx = rtwdf * rtwdf_ - itwdf * itwdf_, itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_, rtwdf_ = rx;
            }
          }
        }
      }, FFTM.prototype.guessLen13b = function guessLen13b(n, m2) {
        var N3 = Math.max(m2, n) | 1, odd = N3 & 1, i2 = 0;
        for (N3 = N3 / 2 | 0;N3; N3 = N3 >>> 1)
          i2++;
        return 1 << i2 + 1 + odd;
      }, FFTM.prototype.conjugate = function conjugate(rws, iws, N3) {
        if (N3 <= 1)
          return;
        for (var i2 = 0;i2 < N3 / 2; i2++) {
          var t2 = rws[i2];
          rws[i2] = rws[N3 - i2 - 1], rws[N3 - i2 - 1] = t2, t2 = iws[i2], iws[i2] = -iws[N3 - i2 - 1], iws[N3 - i2 - 1] = -t2;
        }
      }, FFTM.prototype.normalize13b = function normalize13b(ws, N3) {
        var carry = 0;
        for (var i2 = 0;i2 < N3 / 2; i2++) {
          var w = Math.round(ws[2 * i2 + 1] / N3) * 8192 + Math.round(ws[2 * i2] / N3) + carry;
          if (ws[i2] = w & 67108863, w < 67108864)
            carry = 0;
          else
            carry = w / 67108864 | 0;
        }
        return ws;
      }, FFTM.prototype.convert13b = function convert13b(ws, len2, rws, N3) {
        var carry = 0;
        for (var i2 = 0;i2 < len2; i2++)
          carry = carry + (ws[i2] | 0), rws[2 * i2] = carry & 8191, carry = carry >>> 13, rws[2 * i2 + 1] = carry & 8191, carry = carry >>> 13;
        for (i2 = 2 * len2;i2 < N3; ++i2)
          rws[i2] = 0;
        assert(carry === 0), assert((carry & -8192) === 0);
      }, FFTM.prototype.stub = function stub(N3) {
        var ph = new Array(N3);
        for (var i2 = 0;i2 < N3; i2++)
          ph[i2] = 0;
        return ph;
      }, FFTM.prototype.mulp = function mulp(x4, y, out) {
        var N3 = 2 * this.guessLen13b(x4.length, y.length), rbt = this.makeRBT(N3), _3 = this.stub(N3), rws = new Array(N3), rwst = new Array(N3), iwst = new Array(N3), nrws = new Array(N3), nrwst = new Array(N3), niwst = new Array(N3), rmws = out.words;
        rmws.length = N3, this.convert13b(x4.words, x4.length, rws, N3), this.convert13b(y.words, y.length, nrws, N3), this.transform(rws, _3, rwst, iwst, N3, rbt), this.transform(nrws, _3, nrwst, niwst, N3, rbt);
        for (var i2 = 0;i2 < N3; i2++) {
          var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
          iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2], rwst[i2] = rx;
        }
        return this.conjugate(rwst, iwst, N3), this.transform(rwst, iwst, rmws, _3, N3, rbt), this.conjugate(rmws, _3, N3), this.normalize13b(rmws, N3), out.negative = x4.negative ^ y.negative, out.length = x4.length + y.length, out._strip();
      }, BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        return out.words = new Array(this.length + num.length), this.mulTo(num, out);
      }, BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        return out.words = new Array(this.length + num.length), jumboMulTo(this, num, out);
      }, BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      }, BN.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(typeof num === "number"), assert(num < 67108864);
        var carry = 0;
        for (var i2 = 0;i2 < this.length; i2++) {
          var w = (this.words[i2] | 0) * num, lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26, carry += w / 67108864 | 0, carry += lo >>> 26, this.words[i2] = lo & 67108863;
        }
        if (carry !== 0)
          this.words[i2] = carry, this.length++;
        return this.length = num === 0 ? 1 : this.length, isNegNum ? this.ineg() : this;
      }, BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      }, BN.prototype.sqr = function sqr() {
        return this.mul(this);
      }, BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      }, BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i2 = 0;i2 < w.length; i2++, res = res.sqr())
          if (w[i2] !== 0)
            break;
        if (++i2 < w.length)
          for (var q3 = res.sqr();i2 < w.length; i2++, q3 = q3.sqr()) {
            if (w[i2] === 0)
              continue;
            res = res.mul(q3);
          }
        return res;
      }, BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26, s3 = (bits - r) / 26, carryMask = 67108863 >>> 26 - r << 26 - r, i2;
        if (r !== 0) {
          var carry = 0;
          for (i2 = 0;i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask, c = (this.words[i2] | 0) - newCarry << r;
            this.words[i2] = c | carry, carry = newCarry >>> 26 - r;
          }
          if (carry)
            this.words[i2] = carry, this.length++;
        }
        if (s3 !== 0) {
          for (i2 = this.length - 1;i2 >= 0; i2--)
            this.words[i2 + s3] = this.words[i2];
          for (i2 = 0;i2 < s3; i2++)
            this.words[i2] = 0;
          this.length += s3;
        }
        return this._strip();
      }, BN.prototype.ishln = function ishln(bits) {
        return assert(this.negative === 0), this.iushln(bits);
      }, BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint)
          h = (hint - hint % 26) / 26;
        else
          h = 0;
        var r = bits % 26, s3 = Math.min((bits - r) / 26, this.length), mask = 67108863 ^ 67108863 >>> r << r, maskedWords = extended;
        if (h -= s3, h = Math.max(0, h), maskedWords) {
          for (var i2 = 0;i2 < s3; i2++)
            maskedWords.words[i2] = this.words[i2];
          maskedWords.length = s3;
        }
        if (s3 === 0)
          ;
        else if (this.length > s3) {
          this.length -= s3;
          for (i2 = 0;i2 < this.length; i2++)
            this.words[i2] = this.words[i2 + s3];
        } else
          this.words[0] = 0, this.length = 1;
        var carry = 0;
        for (i2 = this.length - 1;i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r | word >>> r, carry = word & mask;
        }
        if (maskedWords && carry !== 0)
          maskedWords.words[maskedWords.length++] = carry;
        if (this.length === 0)
          this.words[0] = 0, this.length = 1;
        return this._strip();
      }, BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        return assert(this.negative === 0), this.iushrn(bits, hint, extended);
      }, BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      }, BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      }, BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      }, BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      }, BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26, s3 = (bit - r) / 26, q3 = 1 << r;
        if (this.length <= s3)
          return false;
        var w = this.words[s3];
        return !!(w & q3);
      }, BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26, s3 = (bits - r) / 26;
        if (assert(this.negative === 0, "imaskn works only with positive numbers"), this.length <= s3)
          return this;
        if (r !== 0)
          s3++;
        if (this.length = Math.min(s3, this.length), r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      }, BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      }, BN.prototype.iaddn = function iaddn(num) {
        if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num)
            return this.words[0] = num - (this.words[0] | 0), this.negative = 0, this;
          return this.negative = 0, this.isubn(num), this.negative = 1, this;
        }
        return this._iaddn(num);
      }, BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0;i2 < this.length && this.words[i2] >= 67108864; i2++)
          if (this.words[i2] -= 67108864, i2 === this.length - 1)
            this.words[i2 + 1] = 1;
          else
            this.words[i2 + 1]++;
        return this.length = Math.max(this.length, i2 + 1), this;
      }, BN.prototype.isubn = function isubn(num) {
        if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(num), this.negative = 1, this;
        if (this.words[0] -= num, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var i2 = 0;i2 < this.length && this.words[i2] < 0; i2++)
            this.words[i2] += 67108864, this.words[i2 + 1] -= 1;
        return this._strip();
      }, BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      }, BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      }, BN.prototype.iabs = function iabs() {
        return this.negative = 0, this;
      }, BN.prototype.abs = function abs() {
        return this.clone().iabs();
      }, BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len2 = num.length + shift, i2;
        this._expand(len2);
        var w, carry = 0;
        for (i2 = 0;i2 < num.length; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul;
          w -= right & 67108863, carry = (w >> 26) - (right / 67108864 | 0), this.words[i2 + shift] = w & 67108863;
        }
        for (;i2 < this.length - shift; i2++)
          w = (this.words[i2 + shift] | 0) + carry, carry = w >> 26, this.words[i2 + shift] = w & 67108863;
        if (carry === 0)
          return this._strip();
        assert(carry === -1), carry = 0;
        for (i2 = 0;i2 < this.length; i2++)
          w = -(this.words[i2] | 0) + carry, carry = w >> 26, this.words[i2] = w & 67108863;
        return this.negative = 1, this._strip();
      }, BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length, a = this.clone(), b = num, bhi = b.words[b.length - 1] | 0, bhiBits = this._countBits(bhi);
        if (shift = 26 - bhiBits, shift !== 0)
          b = b.ushln(shift), a.iushln(shift), bhi = b.words[b.length - 1] | 0;
        var m2 = a.length - b.length, q3;
        if (mode !== "mod") {
          q3 = new BN(null), q3.length = m2 + 1, q3.words = new Array(q3.length);
          for (var i2 = 0;i2 < q3.length; i2++)
            q3.words[i2] = 0;
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m2);
        if (diff.negative === 0) {
          if (a = diff, q3)
            q3.words[m2] = 1;
        }
        for (var j3 = m2 - 1;j3 >= 0; j3--) {
          var qj = (a.words[b.length + j3] | 0) * 67108864 + (a.words[b.length + j3 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863), a._ishlnsubmul(b, qj, j3);
          while (a.negative !== 0)
            if (qj--, a.negative = 0, a._ishlnsubmul(b, 1, j3), !a.isZero())
              a.negative ^= 1;
          if (q3)
            q3.words[j3] = qj;
        }
        if (q3)
          q3._strip();
        if (a._strip(), mode !== "div" && shift !== 0)
          a.iushrn(shift);
        return { div: q3 || null, mod: a };
      }, BN.prototype.divmod = function divmod(num, mode, positive) {
        if (assert(!num.isZero()), this.isZero())
          return { div: new BN(0), mod: new BN(0) };
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          if (res = this.neg().divmod(num, mode), mode !== "mod")
            div = res.div.neg();
          if (mode !== "div") {
            if (mod = res.mod.neg(), positive && mod.negative !== 0)
              mod.iadd(num);
          }
          return { div, mod };
        }
        if (this.negative === 0 && num.negative !== 0) {
          if (res = this.divmod(num.neg(), mode), mode !== "mod")
            div = res.div.neg();
          return { div, mod: res.mod };
        }
        if ((this.negative & num.negative) !== 0) {
          if (res = this.neg().divmod(num.neg(), mode), mode !== "div") {
            if (mod = res.mod.neg(), positive && mod.negative !== 0)
              mod.isub(num);
          }
          return { div: res.div, mod };
        }
        if (num.length > this.length || this.cmp(num) < 0)
          return { div: new BN(0), mod: this };
        if (num.length === 1) {
          if (mode === "div")
            return { div: this.divn(num.words[0]), mod: null };
          if (mode === "mod")
            return { div: null, mod: new BN(this.modrn(num.words[0])) };
          return { div: this.divn(num.words[0]), mod: new BN(this.modrn(num.words[0])) };
        }
        return this._wordDiv(num, mode);
      }, BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      }, BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      }, BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      }, BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod, half = num.ushrn(1), r2 = num.andln(1), cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      }, BN.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(num <= 67108863);
        var p2 = 67108864 % num, acc = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--)
          acc = (p2 * acc + (this.words[i2] | 0)) % num;
        return isNegNum ? -acc : acc;
      }, BN.prototype.modn = function modn(num) {
        return this.modrn(num);
      }, BN.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--) {
          var w = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w / num | 0, carry = w % num;
        }
        return this._strip(), isNegNum ? this.ineg() : this;
      }, BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      }, BN.prototype.egcd = function egcd(p2) {
        assert(p2.negative === 0), assert(!p2.isZero());
        var x4 = this, y = p2.clone();
        if (x4.negative !== 0)
          x4 = x4.umod(p2);
        else
          x4 = x4.clone();
        var A3 = new BN(1), B3 = new BN(0), C2 = new BN(0), D2 = new BN(1), g2 = 0;
        while (x4.isEven() && y.isEven())
          x4.iushrn(1), y.iushrn(1), ++g2;
        var yp = y.clone(), xp = x4.clone();
        while (!x4.isZero()) {
          for (var i2 = 0, im = 1;(x4.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            x4.iushrn(i2);
            while (i2-- > 0) {
              if (A3.isOdd() || B3.isOdd())
                A3.iadd(yp), B3.isub(xp);
              A3.iushrn(1), B3.iushrn(1);
            }
          }
          for (var j3 = 0, jm = 1;(y.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
            ;
          if (j3 > 0) {
            y.iushrn(j3);
            while (j3-- > 0) {
              if (C2.isOdd() || D2.isOdd())
                C2.iadd(yp), D2.isub(xp);
              C2.iushrn(1), D2.iushrn(1);
            }
          }
          if (x4.cmp(y) >= 0)
            x4.isub(y), A3.isub(C2), B3.isub(D2);
          else
            y.isub(x4), C2.isub(A3), D2.isub(B3);
        }
        return { a: C2, b: D2, gcd: y.iushln(g2) };
      }, BN.prototype._invmp = function _invmp(p2) {
        assert(p2.negative === 0), assert(!p2.isZero());
        var a = this, b = p2.clone();
        if (a.negative !== 0)
          a = a.umod(p2);
        else
          a = a.clone();
        var x1 = new BN(1), x22 = new BN(0), delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i2 = 0, im = 1;(a.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            a.iushrn(i2);
            while (i2-- > 0) {
              if (x1.isOdd())
                x1.iadd(delta);
              x1.iushrn(1);
            }
          }
          for (var j3 = 0, jm = 1;(b.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
            ;
          if (j3 > 0) {
            b.iushrn(j3);
            while (j3-- > 0) {
              if (x22.isOdd())
                x22.iadd(delta);
              x22.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0)
            a.isub(b), x1.isub(x22);
          else
            b.isub(a), x22.isub(x1);
        }
        var res;
        if (a.cmpn(1) === 0)
          res = x1;
        else
          res = x22;
        if (res.cmpn(0) < 0)
          res.iadd(p2);
        return res;
      }, BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone(), b = num.clone();
        a.negative = 0, b.negative = 0;
        for (var shift = 0;a.isEven() && b.isEven(); shift++)
          a.iushrn(1), b.iushrn(1);
        do {
          while (a.isEven())
            a.iushrn(1);
          while (b.isEven())
            b.iushrn(1);
          var r = a.cmp(b);
          if (r < 0) {
            var t2 = a;
            a = b, b = t2;
          } else if (r === 0 || b.cmpn(1) === 0)
            break;
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      }, BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      }, BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      }, BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      }, BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      }, BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26, s3 = (bit - r) / 26, q3 = 1 << r;
        if (this.length <= s3)
          return this._expand(s3 + 1), this.words[s3] |= q3, this;
        var carry = q3;
        for (var i2 = s3;carry !== 0 && i2 < this.length; i2++) {
          var w = this.words[i2] | 0;
          w += carry, carry = w >>> 26, w &= 67108863, this.words[i2] = w;
        }
        if (carry !== 0)
          this.words[i2] = carry, this.length++;
        return this;
      }, BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      }, BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1)
          res = 1;
        else {
          if (negative)
            num = -num;
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--) {
          var a = this.words[i2] | 0, b = num.words[i2] | 0;
          if (a === b)
            continue;
          if (a < b)
            res = -1;
          else if (a > b)
            res = 1;
          break;
        }
        return res;
      }, BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      }, BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      }, BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      }, BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      }, BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      }, BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      }, BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      }, BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      }, BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      }, BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      }, BN.red = function red(num) {
        return new Red(num);
      }, BN.prototype.toRed = function toRed(ctx) {
        return assert(!this.red, "Already a number in reduction context"), assert(this.negative === 0, "red works only with positives"), ctx.convertTo(this)._forceRed(ctx);
      }, BN.prototype.fromRed = function fromRed() {
        return assert(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, BN.prototype._forceRed = function _forceRed(ctx) {
        return this.red = ctx, this;
      }, BN.prototype.forceRed = function forceRed(ctx) {
        return assert(!this.red, "Already a number in reduction context"), this._forceRed(ctx);
      }, BN.prototype.redAdd = function redAdd(num) {
        return assert(this.red, "redAdd works only with red numbers"), this.red.add(this, num);
      }, BN.prototype.redIAdd = function redIAdd(num) {
        return assert(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, num);
      }, BN.prototype.redSub = function redSub(num) {
        return assert(this.red, "redSub works only with red numbers"), this.red.sub(this, num);
      }, BN.prototype.redISub = function redISub(num) {
        return assert(this.red, "redISub works only with red numbers"), this.red.isub(this, num);
      }, BN.prototype.redShl = function redShl(num) {
        return assert(this.red, "redShl works only with red numbers"), this.red.shl(this, num);
      }, BN.prototype.redMul = function redMul(num) {
        return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.mul(this, num);
      }, BN.prototype.redIMul = function redIMul(num) {
        return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.imul(this, num);
      }, BN.prototype.redSqr = function redSqr() {
        return assert(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, BN.prototype.redISqr = function redISqr() {
        return assert(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, BN.prototype.redSqrt = function redSqrt() {
        return assert(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, BN.prototype.redInvm = function redInvm() {
        return assert(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, BN.prototype.redNeg = function redNeg() {
        return assert(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, BN.prototype.redPow = function redPow(num) {
        return assert(this.red && !num.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, num);
      };
      var primes = { k256: null, p224: null, p192: null, p25519: null };
      function MPrime(name, p2) {
        this.name = name, this.p = new BN(p2, 16), this.n = this.p.bitLength(), this.k = new BN(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        return tmp.words = new Array(Math.ceil(this.n / 13)), tmp;
      }, MPrime.prototype.ireduce = function ireduce(num) {
        var r = num, rlen;
        do
          this.split(r, this.tmp), r = this.imulK(r), r = r.iadd(this.tmp), rlen = r.bitLength();
        while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0)
          r.words[0] = 0, r.length = 1;
        else if (cmp > 0)
          r.isub(this.p);
        else if (r.strip !== undefined)
          r.strip();
        else
          r._strip();
        return r;
      }, MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      }, MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      inherits2(K256, MPrime), K256.prototype.split = function split(input, output) {
        var mask = 4194303, outLen = Math.min(input.length, 9);
        for (var i2 = 0;i2 < outLen; i2++)
          output.words[i2] = input.words[i2];
        if (output.length = outLen, input.length <= 9) {
          input.words[0] = 0, input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i2 = 10;i2 < input.length; i2++) {
          var next = input.words[i2] | 0;
          input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22, prev = next;
        }
        if (prev >>>= 22, input.words[i2 - 10] = prev, prev === 0 && input.length > 10)
          input.length -= 10;
        else
          input.length -= 9;
      }, K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0, num.words[num.length + 1] = 0, num.length += 2;
        var lo = 0;
        for (var i2 = 0;i2 < num.length; i2++) {
          var w = num.words[i2] | 0;
          lo += w * 977, num.words[i2] = lo & 67108863, lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          if (num.length--, num.words[num.length - 1] === 0)
            num.length--;
        }
        return num;
      };
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      inherits2(P25519, MPrime), P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0;i2 < num.length; i2++) {
          var hi2 = (num.words[i2] | 0) * 19 + carry, lo = hi2 & 67108863;
          hi2 >>>= 26, num.words[i2] = lo, carry = hi2;
        }
        if (carry !== 0)
          num.words[num.length++] = carry;
        return num;
      }, BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime;
        if (name === "k256")
          prime = new K256;
        else if (name === "p224")
          prime = new P224;
        else if (name === "p192")
          prime = new P192;
        else if (name === "p25519")
          prime = new P25519;
        else
          throw new Error("Unknown prime " + name);
        return primes[name] = prime, prime;
      };
      function Red(m2) {
        if (typeof m2 === "string") {
          var prime = BN._prime(m2);
          this.m = prime.p, this.prime = prime;
        } else
          assert(m2.gtn(1), "modulus must be greater than 1"), this.m = m2, this.prime = null;
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives"), assert(a.red, "red works only with red numbers");
      }, Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives"), assert(a.red && a.red === b.red, "red works only with red numbers");
      }, Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return move(a, a.umod(this.m)._forceRed(this)), a;
      }, Red.prototype.neg = function neg(a) {
        if (a.isZero())
          return a.clone();
        return this.m.sub(a)._forceRed(this);
      }, Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0)
          res.isub(this.m);
        return res._forceRed(this);
      }, Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0)
          res.isub(this.m);
        return res;
      }, Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0)
          res.iadd(this.m);
        return res._forceRed(this);
      }, Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0)
          res.iadd(this.m);
        return res;
      }, Red.prototype.shl = function shl(a, num) {
        return this._verify1(a), this.imod(a.ushln(num));
      }, Red.prototype.imul = function imul(a, b) {
        return this._verify2(a, b), this.imod(a.imul(b));
      }, Red.prototype.mul = function mul(a, b) {
        return this._verify2(a, b), this.imod(a.mul(b));
      }, Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      }, Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      }, Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        if (assert(mod3 % 2 === 1), mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q3 = this.m.subn(1), s3 = 0;
        while (!q3.isZero() && q3.andln(1) === 0)
          s3++, q3.iushrn(1);
        assert(!q3.isZero());
        var one = new BN(1).toRed(this), nOne = one.redNeg(), lpow = this.m.subn(1).iushrn(1), z2 = this.m.bitLength();
        z2 = new BN(2 * z2 * z2).toRed(this);
        while (this.pow(z2, lpow).cmp(nOne) !== 0)
          z2.redIAdd(nOne);
        var c = this.pow(z2, q3), r = this.pow(a, q3.addn(1).iushrn(1)), t2 = this.pow(a, q3), m2 = s3;
        while (t2.cmp(one) !== 0) {
          var tmp = t2;
          for (var i2 = 0;tmp.cmp(one) !== 0; i2++)
            tmp = tmp.redSqr();
          assert(i2 < m2);
          var b = this.pow(c, new BN(1).iushln(m2 - i2 - 1));
          r = r.redMul(b), c = b.redSqr(), t2 = t2.redMul(c), m2 = i2;
        }
        return r;
      }, Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0)
          return inv.negative = 0, this.imod(inv).redNeg();
        else
          return this.imod(inv);
      }, Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4, wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this), wnd[1] = a;
        for (var i2 = 2;i2 < wnd.length; i2++)
          wnd[i2] = this.mul(wnd[i2 - 1], a);
        var res = wnd[0], current = 0, currentLen = 0, start = num.bitLength() % 26;
        if (start === 0)
          start = 26;
        for (i2 = num.length - 1;i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j3 = start - 1;j3 >= 0; j3--) {
            var bit = word >> j3 & 1;
            if (res !== wnd[0])
              res = this.sqr(res);
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            if (current <<= 1, current |= bit, currentLen++, currentLen !== windowSize && (i2 !== 0 || j3 !== 0))
              continue;
            res = this.mul(res, wnd[current]), currentLen = 0, current = 0;
          }
          start = 26;
        }
        return res;
      }, Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      }, Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        return res.red = null, res;
      }, BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m2) {
        if (Red.call(this, m2), this.shift = this.m.bitLength(), this.shift % 26 !== 0)
          this.shift += 26 - this.shift % 26;
        this.r = new BN(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red), Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      }, Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        return r.red = null, r;
      }, Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero())
          return a.words[0] = 0, a.length = 1, a;
        var t2 = a.imul(b), c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t2.isub(c).iushrn(this.shift), res = u;
        if (u.cmp(this.m) >= 0)
          res = u.isub(this.m);
        else if (u.cmpn(0) < 0)
          res = u.iadd(this.m);
        return res._forceRed(this);
      }, Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t2 = a.mul(b), c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t2.isub(c).iushrn(this.shift), res = u;
        if (u.cmp(this.m) >= 0)
          res = u.isub(this.m);
        else if (u.cmpn(0) < 0)
          res = u.iadd(this.m);
        return res._forceRed(this);
      }, Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  });
  require_browserify_rsa = __commonJS2((exports, module) => {
    var BN = require_bn5(), randomBytes = require_randombytes(), Buffer22 = require_safe_buffer().Buffer;
    function getr(priv) {
      var len2 = priv.modulus.byteLength(), r;
      do
        r = new BN(randomBytes(len2));
      while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2));
      return r;
    }
    function blind(priv) {
      var r = getr(priv), blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();
      return { blinder, unblinder: r.invm(priv.modulus) };
    }
    function crt(msg, priv) {
      var blinds = blind(priv), len2 = priv.modulus.byteLength(), blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus), c1 = blinded.toRed(BN.mont(priv.prime1)), c2 = blinded.toRed(BN.mont(priv.prime2)), qinv = priv.coefficient, p2 = priv.prime1, q3 = priv.prime2, m1 = c1.redPow(priv.exponent1).fromRed(), m2 = c2.redPow(priv.exponent2).fromRed(), h = m1.isub(m2).imul(qinv).umod(p2).imul(q3);
      return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer22, "be", len2);
    }
    crt.getr = getr;
    module.exports = crt;
  });
  require_publicEncrypt = __commonJS2((exports, module) => {
    var parseKeys = require_parse_asn1(), randomBytes = require_randombytes(), createHash = require_create_hash(), mgf = require_mgf(), xor = require_xor(), BN = require_bn4(), withPublic = require_withPublic(), crt = require_browserify_rsa(), Buffer22 = require_safe_buffer().Buffer;
    module.exports = function publicEncrypt(publicKey, msg, reverse) {
      var padding;
      if (publicKey.padding)
        padding = publicKey.padding;
      else if (reverse)
        padding = 1;
      else
        padding = 4;
      var key = parseKeys(publicKey), paddedMsg;
      if (padding === 4)
        paddedMsg = oaep(key, msg);
      else if (padding === 1)
        paddedMsg = pkcs1(key, msg, reverse);
      else if (padding === 3) {
        if (paddedMsg = new BN(msg), paddedMsg.cmp(key.modulus) >= 0)
          throw new Error("data too long for modulus");
      } else
        throw new Error("unknown padding");
      if (reverse)
        return crt(paddedMsg, key);
      else
        return withPublic(paddedMsg, key);
    };
    function oaep(key, msg) {
      var k4 = key.modulus.byteLength(), mLen = msg.length, iHash = createHash("sha1").update(Buffer22.alloc(0)).digest(), hLen = iHash.length, hLen2 = 2 * hLen;
      if (mLen > k4 - hLen2 - 2)
        throw new Error("message too long");
      var ps = Buffer22.alloc(k4 - mLen - hLen2 - 2), dblen = k4 - hLen - 1, seed = randomBytes(hLen), maskedDb = xor(Buffer22.concat([iHash, ps, Buffer22.alloc(1, 1), msg], dblen), mgf(seed, dblen)), maskedSeed = xor(seed, mgf(maskedDb, hLen));
      return new BN(Buffer22.concat([Buffer22.alloc(1), maskedSeed, maskedDb], k4));
    }
    function pkcs1(key, msg, reverse) {
      var mLen = msg.length, k4 = key.modulus.byteLength();
      if (mLen > k4 - 11)
        throw new Error("message too long");
      var ps;
      if (reverse)
        ps = Buffer22.alloc(k4 - mLen - 3, 255);
      else
        ps = nonZero(k4 - mLen - 3);
      return new BN(Buffer22.concat([Buffer22.from([0, reverse ? 1 : 2]), ps, Buffer22.alloc(1), msg], k4));
    }
    function nonZero(len2) {
      var out = Buffer22.allocUnsafe(len2), i2 = 0, cache = randomBytes(len2 * 2), cur = 0, num;
      while (i2 < len2) {
        if (cur === cache.length)
          cache = randomBytes(len2 * 2), cur = 0;
        if (num = cache[cur++], num)
          out[i2++] = num;
      }
      return out;
    }
  });
  require_privateDecrypt = __commonJS2((exports, module) => {
    var parseKeys = require_parse_asn1(), mgf = require_mgf(), xor = require_xor(), BN = require_bn4(), crt = require_browserify_rsa(), createHash = require_create_hash(), withPublic = require_withPublic(), Buffer22 = require_safe_buffer().Buffer;
    module.exports = function privateDecrypt(privateKey, enc, reverse) {
      var padding;
      if (privateKey.padding)
        padding = privateKey.padding;
      else if (reverse)
        padding = 1;
      else
        padding = 4;
      var key = parseKeys(privateKey), k4 = key.modulus.byteLength();
      if (enc.length > k4 || new BN(enc).cmp(key.modulus) >= 0)
        throw new Error("decryption error");
      var msg;
      if (reverse)
        msg = withPublic(new BN(enc), key);
      else
        msg = crt(enc, key);
      var zBuffer = Buffer22.alloc(k4 - msg.length);
      if (msg = Buffer22.concat([zBuffer, msg], k4), padding === 4)
        return oaep(key, msg);
      else if (padding === 1)
        return pkcs1(key, msg, reverse);
      else if (padding === 3)
        return msg;
      else
        throw new Error("unknown padding");
    };
    function oaep(key, msg) {
      var k4 = key.modulus.byteLength(), iHash = createHash("sha1").update(Buffer22.alloc(0)).digest(), hLen = iHash.length;
      if (msg[0] !== 0)
        throw new Error("decryption error");
      var maskedSeed = msg.slice(1, hLen + 1), maskedDb = msg.slice(hLen + 1), seed = xor(maskedSeed, mgf(maskedDb, hLen)), db = xor(maskedDb, mgf(seed, k4 - hLen - 1));
      if (compare3(iHash, db.slice(0, hLen)))
        throw new Error("decryption error");
      var i2 = hLen;
      while (db[i2] === 0)
        i2++;
      if (db[i2++] !== 1)
        throw new Error("decryption error");
      return db.slice(i2);
    }
    function pkcs1(key, msg, reverse) {
      var p1 = msg.slice(0, 2), i2 = 2, status = 0;
      while (msg[i2++] !== 0)
        if (i2 >= msg.length) {
          status++;
          break;
        }
      var ps = msg.slice(2, i2 - 1);
      if (p1.toString("hex") !== "0002" && !reverse || p1.toString("hex") !== "0001" && reverse)
        status++;
      if (ps.length < 8)
        status++;
      if (status)
        throw new Error("decryption error");
      return msg.slice(i2);
    }
    function compare3(a, b) {
      a = Buffer22.from(a), b = Buffer22.from(b);
      var dif = 0, len2 = a.length;
      if (a.length !== b.length)
        dif++, len2 = Math.min(a.length, b.length);
      var i2 = -1;
      while (++i2 < len2)
        dif += a[i2] ^ b[i2];
      return dif;
    }
  });
  require_browser2 = __commonJS2((exports) => {
    exports.publicEncrypt = require_publicEncrypt();
    exports.privateDecrypt = require_privateDecrypt();
    exports.privateEncrypt = function privateEncrypt(key, buf) {
      return exports.publicEncrypt(key, buf, true);
    };
    exports.publicDecrypt = function publicDecrypt(key, buf) {
      return exports.privateDecrypt(key, buf, true);
    };
  });
  require_public_encrypt = __commonJS2((exports) => {
    var crypto2 = (init_crypto(), __toCommonJS(exports_crypto));
    if (typeof crypto2.publicEncrypt !== "function")
      crypto2 = require_browser2();
    exports.publicEncrypt = crypto2.publicEncrypt;
    exports.privateDecrypt = crypto2.privateDecrypt;
    if (typeof crypto2.privateEncrypt !== "function")
      exports.privateEncrypt = require_browser2().privateEncrypt;
    else
      exports.privateEncrypt = crypto2.privateEncrypt;
    if (typeof crypto2.publicDecrypt !== "function")
      exports.publicDecrypt = require_browser2().publicDecrypt;
    else
      exports.publicDecrypt = crypto2.publicDecrypt;
  });
  require_browser3 = __commonJS2((exports) => {
    var safeBuffer = require_safe_buffer(), randombytes = require_randombytes(), Buffer22 = safeBuffer.Buffer, kBufferMaxLength = safeBuffer.kMaxLength, crypto2 = globalThis.crypto || globalThis.msCrypto, kMaxUint32 = Math.pow(2, 32) - 1;
    function assertOffset(offset, length) {
      if (typeof offset !== "number" || offset !== offset)
        throw new TypeError("offset must be a number");
      if (offset > kMaxUint32 || offset < 0)
        throw new TypeError("offset must be a uint32");
      if (offset > kBufferMaxLength || offset > length)
        throw new RangeError("offset out of range");
    }
    function assertSize2(size, offset, length) {
      if (typeof size !== "number" || size !== size)
        throw new TypeError("size must be a number");
      if (size > kMaxUint32 || size < 0)
        throw new TypeError("size must be a uint32");
      if (size + offset > length || size > kBufferMaxLength)
        throw new RangeError("buffer too small");
    }
    crypto2 && crypto2.getRandomValues, exports.randomFill = randomFill, exports.randomFillSync = randomFillSync;
    function randomFill(buf, offset, size, cb) {
      if (!Buffer22.isBuffer(buf) && !(buf instanceof globalThis.Uint8Array))
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      if (typeof offset === "function")
        cb = offset, offset = 0, size = buf.length;
      else if (typeof size === "function")
        cb = size, size = buf.length - offset;
      else if (typeof cb !== "function")
        throw new TypeError('"cb" argument must be a function');
      return assertOffset(offset, buf.length), assertSize2(size, offset, buf.length), actualFill(buf, offset, size, cb);
    }
    function actualFill(buf, offset, size, cb) {
      if (false)
        var ourBuf, uint;
      if (cb) {
        randombytes(size, function(err, bytes2) {
          if (err)
            return cb(err);
          bytes2.copy(buf, offset), cb(null, buf);
        });
        return;
      }
      var bytes = randombytes(size);
      return bytes.copy(buf, offset), buf;
    }
    function randomFillSync(buf, offset, size) {
      if (typeof offset === "undefined")
        offset = 0;
      if (!Buffer22.isBuffer(buf) && !(buf instanceof globalThis.Uint8Array))
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      if (assertOffset(offset, buf.length), size === undefined)
        size = buf.length - offset;
      return assertSize2(size, offset, buf.length), actualFill(buf, offset, size);
    }
  });
  require_randomfill = __commonJS2((exports, module) => {
    var crypto2 = (init_crypto(), __toCommonJS(exports_crypto));
    if (typeof crypto2.randomFill === "function" && typeof crypto2.randomFillSync === "function")
      exports.randomFill = crypto2.randomFill, exports.randomFillSync = crypto2.randomFillSync;
    else
      module.exports = require_browser3();
  });
  require_crypto_browserify = __commonJS2((exports) => {
    exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require_randombytes();
    exports.createHash = exports.Hash = require_create_hash();
    exports.createHmac = exports.Hmac = require_create_hmac();
    var algos = require_algorithms(), algoKeys = Object.keys(algos), hashes = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(algoKeys);
    exports.getHashes = function() {
      return hashes;
    };
    var p2 = require_pbkdf2();
    exports.pbkdf2 = p2.pbkdf2;
    exports.pbkdf2Sync = p2.pbkdf2Sync;
    var aes = require_browserify_cipher();
    exports.Cipher = aes.Cipher;
    exports.createCipher = aes.createCipher;
    exports.Cipheriv = aes.Cipheriv;
    exports.createCipheriv = aes.createCipheriv;
    exports.Decipher = aes.Decipher;
    exports.createDecipher = aes.createDecipher;
    exports.Decipheriv = aes.Decipheriv;
    exports.createDecipheriv = aes.createDecipheriv;
    exports.getCiphers = aes.getCiphers;
    exports.listCiphers = aes.listCiphers;
    var dh = require_diffie_hellman();
    exports.DiffieHellmanGroup = dh.DiffieHellmanGroup;
    exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup;
    exports.getDiffieHellman = dh.getDiffieHellman;
    exports.createDiffieHellman = dh.createDiffieHellman;
    exports.DiffieHellman = dh.DiffieHellman;
    var sign = require_browserify_sign();
    exports.createSign = sign.createSign;
    exports.Sign = sign.Sign;
    exports.createVerify = sign.createVerify;
    exports.Verify = sign.Verify;
    exports.createECDH = require_create_ecdh();
    var publicEncrypt = require_public_encrypt();
    exports.publicEncrypt = publicEncrypt.publicEncrypt;
    exports.privateEncrypt = publicEncrypt.privateEncrypt;
    exports.publicDecrypt = publicEncrypt.publicDecrypt;
    exports.privateDecrypt = publicEncrypt.privateDecrypt;
    var rf = require_randomfill();
    exports.randomFill = rf.randomFill;
    exports.randomFillSync = rf.randomFillSync;
    exports.createCredentials = function() {
      throw new Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
    };
    exports.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 };
  });
  cryptoBrowserify = __toESM2(require_crypto_browserify(), 1);
  prng2 = cryptoBrowserify.prng;
  pseudoRandomBytes2 = cryptoBrowserify.pseudoRandomBytes;
  rng2 = cryptoBrowserify.rng;
  randomBytes2 = cryptoBrowserify.randomBytes;
  Hash2 = cryptoBrowserify.Hash;
  createHash2 = cryptoBrowserify.createHash;
  Hmac2 = cryptoBrowserify.Hmac;
  createHmac2 = cryptoBrowserify.createHmac;
  getHashes2 = cryptoBrowserify.getHashes;
  pbkdf22 = cryptoBrowserify.pbkdf2;
  pbkdf2Sync2 = cryptoBrowserify.pbkdf2Sync;
  Cipher2 = cryptoBrowserify.Cipher;
  createCipher2 = cryptoBrowserify.createCipher;
  Cipheriv2 = cryptoBrowserify.Cipheriv;
  createCipheriv2 = cryptoBrowserify.createCipheriv;
  Decipher2 = cryptoBrowserify.Decipher;
  createDecipher2 = cryptoBrowserify.createDecipher;
  Decipheriv2 = cryptoBrowserify.Decipheriv;
  createDecipheriv2 = cryptoBrowserify.createDecipheriv;
  getCiphers2 = cryptoBrowserify.getCiphers;
  listCiphers2 = cryptoBrowserify.listCiphers;
  DiffieHellmanGroup2 = cryptoBrowserify.DiffieHellmanGroup;
  createDiffieHellmanGroup2 = cryptoBrowserify.createDiffieHellmanGroup;
  getDiffieHellman2 = cryptoBrowserify.getDiffieHellman;
  createDiffieHellman2 = cryptoBrowserify.createDiffieHellman;
  DiffieHellman2 = cryptoBrowserify.DiffieHellman;
  createSign2 = cryptoBrowserify.createSign;
  Sign2 = cryptoBrowserify.Sign;
  createVerify2 = cryptoBrowserify.createVerify;
  Verify2 = cryptoBrowserify.Verify;
  createECDH2 = cryptoBrowserify.createECDH;
  publicEncrypt2 = cryptoBrowserify.publicEncrypt;
  privateEncrypt2 = cryptoBrowserify.privateEncrypt;
  publicDecrypt2 = cryptoBrowserify.publicDecrypt;
  privateDecrypt2 = cryptoBrowserify.privateDecrypt;
  randomFill2 = cryptoBrowserify.randomFill;
  randomFillSync2 = cryptoBrowserify.randomFillSync;
  createCredentials2 = cryptoBrowserify.createCredentials;
  constants2 = cryptoBrowserify.constants;
  hardcoded_curves = ["p192", "p224", "p256", "p384", "p521", "curve25519", "ed25519", "secp256k1", "secp224r1", "prime256v1", "prime192v1", "ed25519", "secp384r1", "secp521r1"];
  webcrypto = crypto;
  crypto_default = crypto;
});

// node_modules/sql.js/dist/sql-wasm.js
var require_sql_wasm = __commonJS((exports, module) => {
  var __dirname = "/home/austin/javascript/franz_collage/node_modules/sql.js/dist";
  var initSqlJsPromise = undefined;
  var initSqlJs = function(moduleConfig) {
    if (initSqlJsPromise) {
      return initSqlJsPromise;
    }
    initSqlJsPromise = new Promise(function(resolveModule, reject) {
      var Module = typeof moduleConfig !== "undefined" ? moduleConfig : {};
      var originalOnAbortFunction = Module["onAbort"];
      Module["onAbort"] = function(errorThatCausedAbort) {
        reject(new Error(errorThatCausedAbort));
        if (originalOnAbortFunction) {
          originalOnAbortFunction(errorThatCausedAbort);
        }
      };
      Module["postRun"] = Module["postRun"] || [];
      Module["postRun"].push(function() {
        resolveModule(Module);
      });
      module = undefined;
      var f2;
      f2 ||= typeof Module != "undefined" ? Module : {};
      var aa2 = typeof window == "object", ba2 = typeof WorkerGlobalScope != "undefined", ca2 = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string" && process.type != "renderer";
      f2.onRuntimeInitialized = function() {
        function a(g2, l3) {
          switch (typeof l3) {
            case "boolean":
              dc(g2, l3 ? 1 : 0);
              break;
            case "number":
              ec(g2, l3);
              break;
            case "string":
              fc(g2, l3, -1, -1);
              break;
            case "object":
              if (l3 === null)
                lb(g2);
              else if (l3.length != null) {
                var n = da2(l3, ea2);
                gc(g2, n, l3.length, -1);
                fa2(n);
              } else
                va2(g2, "Wrong API use : tried to return a value of an unknown type (" + l3 + ").", -1);
              break;
            default:
              lb(g2);
          }
        }
        function b(g2, l3) {
          for (var n = [], r = 0;r < g2; r += 1) {
            var t2 = m2(l3 + 4 * r, "i32"), y = hc(t2);
            if (y === 1 || y === 2)
              t2 = ic(t2);
            else if (y === 3)
              t2 = jc(t2);
            else if (y === 4) {
              y = t2;
              t2 = kc(y);
              y = lc(y);
              for (var L2 = new Uint8Array(t2), J2 = 0;J2 < t2; J2 += 1)
                L2[J2] = p2[y + J2];
              t2 = L2;
            } else
              t2 = null;
            n.push(t2);
          }
          return n;
        }
        function c(g2, l3) {
          this.Qa = g2;
          this.db = l3;
          this.Oa = 1;
          this.lb = [];
        }
        function d3(g2, l3) {
          this.db = l3;
          l3 = ha2(g2) + 1;
          this.eb = ia2(l3);
          if (this.eb === null)
            throw Error("Unable to allocate memory for the SQL string");
          u(g2, x4, this.eb, l3);
          this.kb = this.eb;
          this.Za = this.pb = null;
        }
        function e2(g2) {
          this.filename = "dbfile_" + (4294967295 * Math.random() >>> 0);
          if (g2 != null) {
            var l3 = this.filename, n = "/", r = l3;
            n && (n = typeof n == "string" ? n : ja2(n), r = l3 ? ka2(n + "/" + l3) : n);
            l3 = la2(true, true);
            r = ma2(r, l3);
            if (g2) {
              if (typeof g2 == "string") {
                n = Array(g2.length);
                for (var t2 = 0, y = g2.length;t2 < y; ++t2)
                  n[t2] = g2.charCodeAt(t2);
                g2 = n;
              }
              na2(r, l3 | 146);
              n = oa2(r, 577);
              pa2(n, g2, 0, g2.length, 0);
              qa2(n);
              na2(r, l3);
            }
          }
          this.handleError(q3(this.filename, h));
          this.db = m2(h, "i32");
          ob(this.db);
          this.fb = {};
          this.Sa = {};
        }
        var h = z2(4), k4 = f2.cwrap, q3 = k4("sqlite3_open", "number", ["string", "number"]), w = k4("sqlite3_close_v2", "number", ["number"]), v2 = k4("sqlite3_exec", "number", ["number", "string", "number", "number", "number"]), C2 = k4("sqlite3_changes", "number", ["number"]), G2 = k4("sqlite3_prepare_v2", "number", ["number", "string", "number", "number", "number"]), pb = k4("sqlite3_sql", "string", ["number"]), nc = k4("sqlite3_normalized_sql", "string", ["number"]), qb = k4("sqlite3_prepare_v2", "number", ["number", "number", "number", "number", "number"]), oc = k4("sqlite3_bind_text", "number", ["number", "number", "number", "number", "number"]), rb = k4("sqlite3_bind_blob", "number", ["number", "number", "number", "number", "number"]), pc = k4("sqlite3_bind_double", "number", ["number", "number", "number"]), qc = k4("sqlite3_bind_int", "number", ["number", "number", "number"]), rc = k4("sqlite3_bind_parameter_index", "number", ["number", "string"]), sc = k4("sqlite3_step", "number", ["number"]), tc = k4("sqlite3_errmsg", "string", ["number"]), uc = k4("sqlite3_column_count", "number", ["number"]), vc = k4("sqlite3_data_count", "number", ["number"]), wc = k4("sqlite3_column_double", "number", ["number", "number"]), sb = k4("sqlite3_column_text", "string", ["number", "number"]), xc = k4("sqlite3_column_blob", "number", ["number", "number"]), yc = k4("sqlite3_column_bytes", "number", [
          "number",
          "number"
        ]), zc = k4("sqlite3_column_type", "number", ["number", "number"]), Ac = k4("sqlite3_column_name", "string", ["number", "number"]), Bc = k4("sqlite3_reset", "number", ["number"]), Cc = k4("sqlite3_clear_bindings", "number", ["number"]), Dc = k4("sqlite3_finalize", "number", ["number"]), tb = k4("sqlite3_create_function_v2", "number", "number string number number number number number number number".split(" ")), hc = k4("sqlite3_value_type", "number", ["number"]), kc = k4("sqlite3_value_bytes", "number", ["number"]), jc = k4("sqlite3_value_text", "string", ["number"]), lc = k4("sqlite3_value_blob", "number", ["number"]), ic = k4("sqlite3_value_double", "number", ["number"]), ec = k4("sqlite3_result_double", "", ["number", "number"]), lb = k4("sqlite3_result_null", "", ["number"]), fc = k4("sqlite3_result_text", "", ["number", "string", "number", "number"]), gc = k4("sqlite3_result_blob", "", ["number", "number", "number", "number"]), dc = k4("sqlite3_result_int", "", ["number", "number"]), va2 = k4("sqlite3_result_error", "", ["number", "string", "number"]), ub = k4("sqlite3_aggregate_context", "number", ["number", "number"]), ob = k4("RegisterExtensionFunctions", "number", ["number"]), vb = k4("sqlite3_update_hook", "number", ["number", "number", "number"]);
        c.prototype.bind = function(g2) {
          if (!this.Qa)
            throw "Statement closed";
          this.reset();
          return Array.isArray(g2) ? this.Cb(g2) : g2 != null && typeof g2 === "object" ? this.Db(g2) : true;
        };
        c.prototype.step = function() {
          if (!this.Qa)
            throw "Statement closed";
          this.Oa = 1;
          var g2 = sc(this.Qa);
          switch (g2) {
            case 100:
              return true;
            case 101:
              return false;
            default:
              throw this.db.handleError(g2);
          }
        };
        c.prototype.wb = function(g2) {
          g2 == null && (g2 = this.Oa, this.Oa += 1);
          return wc(this.Qa, g2);
        };
        c.prototype.Gb = function(g2) {
          g2 == null && (g2 = this.Oa, this.Oa += 1);
          g2 = sb(this.Qa, g2);
          if (typeof BigInt !== "function")
            throw Error("BigInt is not supported");
          return BigInt(g2);
        };
        c.prototype.Hb = function(g2) {
          g2 == null && (g2 = this.Oa, this.Oa += 1);
          return sb(this.Qa, g2);
        };
        c.prototype.getBlob = function(g2) {
          g2 == null && (g2 = this.Oa, this.Oa += 1);
          var l3 = yc(this.Qa, g2);
          g2 = xc(this.Qa, g2);
          for (var n = new Uint8Array(l3), r = 0;r < l3; r += 1)
            n[r] = p2[g2 + r];
          return n;
        };
        c.prototype.get = function(g2, l3) {
          l3 = l3 || {};
          g2 != null && this.bind(g2) && this.step();
          g2 = [];
          for (var n = vc(this.Qa), r = 0;r < n; r += 1)
            switch (zc(this.Qa, r)) {
              case 1:
                var t2 = l3.useBigInt ? this.Gb(r) : this.wb(r);
                g2.push(t2);
                break;
              case 2:
                g2.push(this.wb(r));
                break;
              case 3:
                g2.push(this.Hb(r));
                break;
              case 4:
                g2.push(this.getBlob(r));
                break;
              default:
                g2.push(null);
            }
          return g2;
        };
        c.prototype.getColumnNames = function() {
          for (var g2 = [], l3 = uc(this.Qa), n = 0;n < l3; n += 1)
            g2.push(Ac(this.Qa, n));
          return g2;
        };
        c.prototype.getAsObject = function(g2, l3) {
          g2 = this.get(g2, l3);
          l3 = this.getColumnNames();
          for (var n = {}, r = 0;r < l3.length; r += 1)
            n[l3[r]] = g2[r];
          return n;
        };
        c.prototype.getSQL = function() {
          return pb(this.Qa);
        };
        c.prototype.getNormalizedSQL = function() {
          return nc(this.Qa);
        };
        c.prototype.run = function(g2) {
          g2 != null && this.bind(g2);
          this.step();
          return this.reset();
        };
        c.prototype.sb = function(g2, l3) {
          l3 == null && (l3 = this.Oa, this.Oa += 1);
          g2 = ra2(g2);
          var n = da2(g2, ea2);
          this.lb.push(n);
          this.db.handleError(oc(this.Qa, l3, n, g2.length - 1, 0));
        };
        c.prototype.Bb = function(g2, l3) {
          l3 == null && (l3 = this.Oa, this.Oa += 1);
          var n = da2(g2, ea2);
          this.lb.push(n);
          this.db.handleError(rb(this.Qa, l3, n, g2.length, 0));
        };
        c.prototype.rb = function(g2, l3) {
          l3 == null && (l3 = this.Oa, this.Oa += 1);
          this.db.handleError((g2 === (g2 | 0) ? qc : pc)(this.Qa, l3, g2));
        };
        c.prototype.Eb = function(g2) {
          g2 == null && (g2 = this.Oa, this.Oa += 1);
          rb(this.Qa, g2, 0, 0, 0);
        };
        c.prototype.tb = function(g2, l3) {
          l3 == null && (l3 = this.Oa, this.Oa += 1);
          switch (typeof g2) {
            case "string":
              this.sb(g2, l3);
              return;
            case "number":
              this.rb(g2, l3);
              return;
            case "bigint":
              this.sb(g2.toString(), l3);
              return;
            case "boolean":
              this.rb(g2 + 0, l3);
              return;
            case "object":
              if (g2 === null) {
                this.Eb(l3);
                return;
              }
              if (g2.length != null) {
                this.Bb(g2, l3);
                return;
              }
          }
          throw "Wrong API use : tried to bind a value of an unknown type (" + g2 + ").";
        };
        c.prototype.Db = function(g2) {
          var l3 = this;
          Object.keys(g2).forEach(function(n) {
            var r = rc(l3.Qa, n);
            r !== 0 && l3.tb(g2[n], r);
          });
          return true;
        };
        c.prototype.Cb = function(g2) {
          for (var l3 = 0;l3 < g2.length; l3 += 1)
            this.tb(g2[l3], l3 + 1);
          return true;
        };
        c.prototype.reset = function() {
          this.freemem();
          return Cc(this.Qa) === 0 && Bc(this.Qa) === 0;
        };
        c.prototype.freemem = function() {
          for (var g2;(g2 = this.lb.pop()) !== undefined; )
            fa2(g2);
        };
        c.prototype.free = function() {
          this.freemem();
          var g2 = Dc(this.Qa) === 0;
          delete this.db.fb[this.Qa];
          this.Qa = 0;
          return g2;
        };
        d3.prototype.next = function() {
          if (this.eb === null)
            return { done: true };
          this.Za !== null && (this.Za.free(), this.Za = null);
          if (!this.db.db)
            throw this.mb(), Error("Database closed");
          var g2 = sa2(), l3 = z2(4);
          ta2(h);
          ta2(l3);
          try {
            this.db.handleError(qb(this.db.db, this.kb, -1, h, l3));
            this.kb = m2(l3, "i32");
            var n = m2(h, "i32");
            if (n === 0)
              return this.mb(), { done: true };
            this.Za = new c(n, this.db);
            this.db.fb[n] = this.Za;
            return { value: this.Za, done: false };
          } catch (r) {
            throw this.pb = ua2(this.kb), this.mb(), r;
          } finally {
            wa2(g2);
          }
        };
        d3.prototype.mb = function() {
          fa2(this.eb);
          this.eb = null;
        };
        d3.prototype.getRemainingSQL = function() {
          return this.pb !== null ? this.pb : ua2(this.kb);
        };
        typeof Symbol === "function" && typeof Symbol.iterator === "symbol" && (d3.prototype[Symbol.iterator] = function() {
          return this;
        });
        e2.prototype.run = function(g2, l3) {
          if (!this.db)
            throw "Database closed";
          if (l3) {
            g2 = this.prepare(g2, l3);
            try {
              g2.step();
            } finally {
              g2.free();
            }
          } else
            this.handleError(v2(this.db, g2, 0, 0, h));
          return this;
        };
        e2.prototype.exec = function(g2, l3, n) {
          if (!this.db)
            throw "Database closed";
          var r = sa2(), t2 = null;
          try {
            var y = xa2(g2), L2 = z2(4);
            for (g2 = [];m2(y, "i8") !== 0; ) {
              ta2(h);
              ta2(L2);
              this.handleError(qb(this.db, y, -1, h, L2));
              var J2 = m2(h, "i32");
              y = m2(L2, "i32");
              if (J2 !== 0) {
                var I2 = null;
                t2 = new c(J2, this);
                for (l3 != null && t2.bind(l3);t2.step(); )
                  I2 === null && (I2 = { columns: t2.getColumnNames(), values: [] }, g2.push(I2)), I2.values.push(t2.get(null, n));
                t2.free();
              }
            }
            return g2;
          } catch (M2) {
            throw t2 && t2.free(), M2;
          } finally {
            wa2(r);
          }
        };
        e2.prototype.each = function(g2, l3, n, r, t2) {
          typeof l3 === "function" && (r = n, n = l3, l3 = undefined);
          g2 = this.prepare(g2, l3);
          try {
            for (;g2.step(); )
              n(g2.getAsObject(null, t2));
          } finally {
            g2.free();
          }
          if (typeof r === "function")
            return r();
        };
        e2.prototype.prepare = function(g2, l3) {
          ta2(h);
          this.handleError(G2(this.db, g2, -1, h, 0));
          g2 = m2(h, "i32");
          if (g2 === 0)
            throw "Nothing to prepare";
          var n = new c(g2, this);
          l3 != null && n.bind(l3);
          return this.fb[g2] = n;
        };
        e2.prototype.iterateStatements = function(g2) {
          return new d3(g2, this);
        };
        e2.prototype["export"] = function() {
          Object.values(this.fb).forEach(function(l3) {
            l3.free();
          });
          Object.values(this.Sa).forEach(A3);
          this.Sa = {};
          this.handleError(w(this.db));
          var g2 = ya2(this.filename);
          this.handleError(q3(this.filename, h));
          this.db = m2(h, "i32");
          ob(this.db);
          return g2;
        };
        e2.prototype.close = function() {
          this.db !== null && (Object.values(this.fb).forEach(function(g2) {
            g2.free();
          }), Object.values(this.Sa).forEach(A3), this.Sa = {}, this.Ya && (A3(this.Ya), this.Ya = undefined), this.handleError(w(this.db)), za2("/" + this.filename), this.db = null);
        };
        e2.prototype.handleError = function(g2) {
          if (g2 === 0)
            return null;
          g2 = tc(this.db);
          throw Error(g2);
        };
        e2.prototype.getRowsModified = function() {
          return C2(this.db);
        };
        e2.prototype.create_function = function(g2, l3) {
          Object.prototype.hasOwnProperty.call(this.Sa, g2) && (A3(this.Sa[g2]), delete this.Sa[g2]);
          var n = Aa2(function(r, t2, y) {
            t2 = b(t2, y);
            try {
              var L2 = l3.apply(null, t2);
            } catch (J2) {
              va2(r, J2, -1);
              return;
            }
            a(r, L2);
          }, "viii");
          this.Sa[g2] = n;
          this.handleError(tb(this.db, g2, l3.length, 1, 0, n, 0, 0, 0));
          return this;
        };
        e2.prototype.create_aggregate = function(g2, l3) {
          var n = l3.init || function() {
            return null;
          }, r = l3.finalize || function(I2) {
            return I2;
          }, t2 = l3.step;
          if (!t2)
            throw "An aggregate function must have a step function in " + g2;
          var y = {};
          Object.hasOwnProperty.call(this.Sa, g2) && (A3(this.Sa[g2]), delete this.Sa[g2]);
          l3 = g2 + "__finalize";
          Object.hasOwnProperty.call(this.Sa, l3) && (A3(this.Sa[l3]), delete this.Sa[l3]);
          var L2 = Aa2(function(I2, M2, Ra2) {
            var X2 = ub(I2, 1);
            Object.hasOwnProperty.call(y, X2) || (y[X2] = n());
            M2 = b(M2, Ra2);
            M2 = [y[X2]].concat(M2);
            try {
              y[X2] = t2.apply(null, M2);
            } catch (Fc) {
              delete y[X2], va2(I2, Fc, -1);
            }
          }, "viii"), J2 = Aa2(function(I2) {
            var M2 = ub(I2, 1);
            try {
              var Ra2 = r(y[M2]);
            } catch (X2) {
              delete y[M2];
              va2(I2, X2, -1);
              return;
            }
            a(I2, Ra2);
            delete y[M2];
          }, "vi");
          this.Sa[g2] = L2;
          this.Sa[l3] = J2;
          this.handleError(tb(this.db, g2, t2.length - 1, 1, 0, 0, L2, J2, 0));
          return this;
        };
        e2.prototype.updateHook = function(g2) {
          this.Ya && (vb(this.db, 0, 0), A3(this.Ya), this.Ya = undefined);
          g2 && (this.Ya = Aa2(function(l3, n, r, t2, y) {
            switch (n) {
              case 18:
                l3 = "insert";
                break;
              case 23:
                l3 = "update";
                break;
              case 9:
                l3 = "delete";
                break;
              default:
                throw "unknown operationCode in updateHook callback: " + n;
            }
            r = r ? B3(x4, r) : "";
            t2 = t2 ? B3(x4, t2) : "";
            if (y > Number.MAX_SAFE_INTEGER)
              throw "rowId too big to fit inside a Number";
            g2(l3, r, t2, Number(y));
          }, "viiiij"), vb(this.db, this.Ya, 0));
        };
        f2.Database = e2;
      };
      var Ba2 = { ...f2 }, Ca2 = "./this.program", Da2 = (a, b) => {
        throw b;
      }, D2 = "", Ea2, Fa2;
      if (ca2) {
        var fs = (() => ({}));
        init_path();
        D2 = __dirname + "/";
        Fa2 = (a) => {
          a = Ga2(a) ? new URL(a) : a;
          return fs.readFileSync(a);
        };
        Ea2 = async (a) => {
          a = Ga2(a) ? new URL(a) : a;
          return fs.readFileSync(a, undefined);
        };
        !f2.thisProgram && 1 < process.argv.length && (Ca2 = process.argv[1].replace(/\\/g, "/"));
        process.argv.slice(2);
        typeof module != "undefined" && (module.exports = f2);
        Da2 = (a, b) => {
          process.exitCode = a;
          throw b;
        };
      } else if (aa2 || ba2)
        ba2 ? D2 = self.location.href : typeof document != "undefined" && document.currentScript && (D2 = document.currentScript.src), D2 = D2.startsWith("blob:") ? "" : D2.slice(0, D2.replace(/[?#].*/, "").lastIndexOf("/") + 1), ba2 && (Fa2 = (a) => {
          var b = new XMLHttpRequest;
          b.open("GET", a, false);
          b.responseType = "arraybuffer";
          b.send(null);
          return new Uint8Array(b.response);
        }), Ea2 = async (a) => {
          if (Ga2(a))
            return new Promise((c, d3) => {
              var e2 = new XMLHttpRequest;
              e2.open("GET", a, true);
              e2.responseType = "arraybuffer";
              e2.onload = () => {
                e2.status == 200 || e2.status == 0 && e2.response ? c(e2.response) : d3(e2.status);
              };
              e2.onerror = d3;
              e2.send(null);
            });
          var b = await fetch(a, { credentials: "same-origin" });
          if (b.ok)
            return b.arrayBuffer();
          throw Error(b.status + " : " + b.url);
        };
      var Ha2 = f2.print || console.log.bind(console), Ia2 = f2.printErr || console.error.bind(console);
      Object.assign(f2, Ba2);
      Ba2 = null;
      f2.thisProgram && (Ca2 = f2.thisProgram);
      var Ja2 = f2.wasmBinary, Ka2, La2 = false, Ma2, p2, x4, Na2, E4, F2, Oa2, H3, Pa2, Ga2 = (a) => a.startsWith("file://");
      function Qa2() {
        var a = Ka2.buffer;
        f2.HEAP8 = p2 = new Int8Array(a);
        f2.HEAP16 = Na2 = new Int16Array(a);
        f2.HEAPU8 = x4 = new Uint8Array(a);
        f2.HEAPU16 = new Uint16Array(a);
        f2.HEAP32 = E4 = new Int32Array(a);
        f2.HEAPU32 = F2 = new Uint32Array(a);
        f2.HEAPF32 = Oa2 = new Float32Array(a);
        f2.HEAPF64 = Pa2 = new Float64Array(a);
        f2.HEAP64 = H3 = new BigInt64Array(a);
        f2.HEAPU64 = new BigUint64Array(a);
      }
      var K4 = 0, Sa2 = null;
      function Ta2(a) {
        f2.onAbort?.(a);
        a = "Aborted(" + a + ")";
        Ia2(a);
        La2 = true;
        throw new WebAssembly.RuntimeError(a + ". Build with -sASSERTIONS for more info.");
      }
      var Ua2;
      async function Va2(a) {
        if (!Ja2)
          try {
            var b = await Ea2(a);
            return new Uint8Array(b);
          } catch {}
        if (a == Ua2 && Ja2)
          a = new Uint8Array(Ja2);
        else if (Fa2)
          a = Fa2(a);
        else
          throw "both async and sync fetching of the wasm failed";
        return a;
      }
      async function Wa2(a, b) {
        try {
          var c = await Va2(a);
          return await WebAssembly.instantiate(c, b);
        } catch (d3) {
          Ia2(`failed to asynchronously prepare wasm: ${d3}`), Ta2(d3);
        }
      }
      async function Xa2(a) {
        var b = Ua2;
        if (!Ja2 && typeof WebAssembly.instantiateStreaming == "function" && !Ga2(b) && !ca2)
          try {
            var c = fetch(b, { credentials: "same-origin" });
            return await WebAssembly.instantiateStreaming(c, a);
          } catch (d3) {
            Ia2(`wasm streaming compile failed: ${d3}`), Ia2("falling back to ArrayBuffer instantiation");
          }
        return Wa2(b, a);
      }

      class Ya2 {
        name = "ExitStatus";
        constructor(a) {
          this.message = `Program terminated with exit(${a})`;
          this.status = a;
        }
      }
      var Za2 = (a) => {
        for (;0 < a.length; )
          a.shift()(f2);
      }, $a2 = [], ab = [], bb = () => {
        var a = f2.preRun.shift();
        ab.unshift(a);
      };
      function m2(a, b = "i8") {
        b.endsWith("*") && (b = "*");
        switch (b) {
          case "i1":
            return p2[a];
          case "i8":
            return p2[a];
          case "i16":
            return Na2[a >> 1];
          case "i32":
            return E4[a >> 2];
          case "i64":
            return H3[a >> 3];
          case "float":
            return Oa2[a >> 2];
          case "double":
            return Pa2[a >> 3];
          case "*":
            return F2[a >> 2];
          default:
            Ta2(`invalid type for getValue: ${b}`);
        }
      }
      var cb = f2.noExitRuntime || true;
      function ta2(a) {
        var b = "i32";
        b.endsWith("*") && (b = "*");
        switch (b) {
          case "i1":
            p2[a] = 0;
            break;
          case "i8":
            p2[a] = 0;
            break;
          case "i16":
            Na2[a >> 1] = 0;
            break;
          case "i32":
            E4[a >> 2] = 0;
            break;
          case "i64":
            H3[a >> 3] = BigInt(0);
            break;
          case "float":
            Oa2[a >> 2] = 0;
            break;
          case "double":
            Pa2[a >> 3] = 0;
            break;
          case "*":
            F2[a >> 2] = 0;
            break;
          default:
            Ta2(`invalid type for setValue: ${b}`);
        }
      }
      var db = typeof TextDecoder != "undefined" ? new TextDecoder : undefined, B3 = (a, b = 0, c = NaN) => {
        var d3 = b + c;
        for (c = b;a[c] && !(c >= d3); )
          ++c;
        if (16 < c - b && a.buffer && db)
          return db.decode(a.subarray(b, c));
        for (d3 = "";b < c; ) {
          var e2 = a[b++];
          if (e2 & 128) {
            var h = a[b++] & 63;
            if ((e2 & 224) == 192)
              d3 += String.fromCharCode((e2 & 31) << 6 | h);
            else {
              var k4 = a[b++] & 63;
              e2 = (e2 & 240) == 224 ? (e2 & 15) << 12 | h << 6 | k4 : (e2 & 7) << 18 | h << 12 | k4 << 6 | a[b++] & 63;
              65536 > e2 ? d3 += String.fromCharCode(e2) : (e2 -= 65536, d3 += String.fromCharCode(55296 | e2 >> 10, 56320 | e2 & 1023));
            }
          } else
            d3 += String.fromCharCode(e2);
        }
        return d3;
      }, ua2 = (a, b) => a ? B3(x4, a, b) : "", eb = (a, b) => {
        for (var c = 0, d3 = a.length - 1;0 <= d3; d3--) {
          var e2 = a[d3];
          e2 === "." ? a.splice(d3, 1) : e2 === ".." ? (a.splice(d3, 1), c++) : c && (a.splice(d3, 1), c--);
        }
        if (b)
          for (;c; c--)
            a.unshift("..");
        return a;
      }, ka2 = (a) => {
        var b = a.charAt(0) === "/", c = a.slice(-1) === "/";
        (a = eb(a.split("/").filter((d3) => !!d3), !b).join("/")) || b || (a = ".");
        a && c && (a += "/");
        return (b ? "/" : "") + a;
      }, fb = (a) => {
        var b = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/.exec(a).slice(1);
        a = b[0];
        b = b[1];
        if (!a && !b)
          return ".";
        b &&= b.slice(0, -1);
        return a + b;
      }, gb = (a) => a && a.match(/([^\/]+|\/)\/*$/)[1], hb = () => {
        if (ca2) {
          var a = (init_crypto(), __toCommonJS(exports_crypto));
          return (b) => a.randomFillSync(b);
        }
        return (b) => crypto.getRandomValues(b);
      }, ib = (a) => {
        (ib = hb())(a);
      }, jb = (...a) => {
        for (var b = "", c = false, d3 = a.length - 1;-1 <= d3 && !c; d3--) {
          c = 0 <= d3 ? a[d3] : "/";
          if (typeof c != "string")
            throw new TypeError("Arguments to path.resolve must be strings");
          if (!c)
            return "";
          b = c + "/" + b;
          c = c.charAt(0) === "/";
        }
        b = eb(b.split("/").filter((e2) => !!e2), !c).join("/");
        return (c ? "/" : "") + b || ".";
      }, kb = [], ha2 = (a) => {
        for (var b = 0, c = 0;c < a.length; ++c) {
          var d3 = a.charCodeAt(c);
          127 >= d3 ? b++ : 2047 >= d3 ? b += 2 : 55296 <= d3 && 57343 >= d3 ? (b += 4, ++c) : b += 3;
        }
        return b;
      }, u = (a, b, c, d3) => {
        if (!(0 < d3))
          return 0;
        var e2 = c;
        d3 = c + d3 - 1;
        for (var h = 0;h < a.length; ++h) {
          var k4 = a.charCodeAt(h);
          if (55296 <= k4 && 57343 >= k4) {
            var q3 = a.charCodeAt(++h);
            k4 = 65536 + ((k4 & 1023) << 10) | q3 & 1023;
          }
          if (127 >= k4) {
            if (c >= d3)
              break;
            b[c++] = k4;
          } else {
            if (2047 >= k4) {
              if (c + 1 >= d3)
                break;
              b[c++] = 192 | k4 >> 6;
            } else {
              if (65535 >= k4) {
                if (c + 2 >= d3)
                  break;
                b[c++] = 224 | k4 >> 12;
              } else {
                if (c + 3 >= d3)
                  break;
                b[c++] = 240 | k4 >> 18;
                b[c++] = 128 | k4 >> 12 & 63;
              }
              b[c++] = 128 | k4 >> 6 & 63;
            }
            b[c++] = 128 | k4 & 63;
          }
        }
        b[c] = 0;
        return c - e2;
      }, ra2 = (a, b) => {
        var c = Array(ha2(a) + 1);
        a = u(a, c, 0, c.length);
        b && (c.length = a);
        return c;
      }, mb = [];
      function nb(a, b) {
        mb[a] = { input: [], output: [], cb: b };
        wb(a, xb);
      }
      var xb = { open(a) {
        var b = mb[a.node.rdev];
        if (!b)
          throw new N3(43);
        a.tty = b;
        a.seekable = false;
      }, close(a) {
        a.tty.cb.fsync(a.tty);
      }, fsync(a) {
        a.tty.cb.fsync(a.tty);
      }, read(a, b, c, d3) {
        if (!a.tty || !a.tty.cb.xb)
          throw new N3(60);
        for (var e2 = 0, h = 0;h < d3; h++) {
          try {
            var k4 = a.tty.cb.xb(a.tty);
          } catch (q3) {
            throw new N3(29);
          }
          if (k4 === undefined && e2 === 0)
            throw new N3(6);
          if (k4 === null || k4 === undefined)
            break;
          e2++;
          b[c + h] = k4;
        }
        e2 && (a.node.atime = Date.now());
        return e2;
      }, write(a, b, c, d3) {
        if (!a.tty || !a.tty.cb.qb)
          throw new N3(60);
        try {
          for (var e2 = 0;e2 < d3; e2++)
            a.tty.cb.qb(a.tty, b[c + e2]);
        } catch (h) {
          throw new N3(29);
        }
        d3 && (a.node.mtime = a.node.ctime = Date.now());
        return e2;
      } }, yb = { xb() {
        a: {
          if (!kb.length) {
            var a = null;
            if (ca2) {
              var b = Buffer.alloc(256), c = 0, d3 = process.stdin.fd;
              try {
                c = fs.readSync(d3, b, 0, 256);
              } catch (e2) {
                if (e2.toString().includes("EOF"))
                  c = 0;
                else
                  throw e2;
              }
              0 < c && (a = b.slice(0, c).toString("utf-8"));
            } else
              typeof window != "undefined" && typeof window.prompt == "function" && (a = window.prompt("Input: "), a !== null && (a += `
`));
            if (!a) {
              a = null;
              break a;
            }
            kb = ra2(a, true);
          }
          a = kb.shift();
        }
        return a;
      }, qb(a, b) {
        b === null || b === 10 ? (Ha2(B3(a.output)), a.output = []) : b != 0 && a.output.push(b);
      }, fsync(a) {
        0 < a.output?.length && (Ha2(B3(a.output)), a.output = []);
      }, Tb() {
        return { Ob: 25856, Qb: 5, Nb: 191, Pb: 35387, Mb: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] };
      }, Ub() {
        return 0;
      }, Vb() {
        return [24, 80];
      } }, zb = { qb(a, b) {
        b === null || b === 10 ? (Ia2(B3(a.output)), a.output = []) : b != 0 && a.output.push(b);
      }, fsync(a) {
        0 < a.output?.length && (Ia2(B3(a.output)), a.output = []);
      } }, O3 = { Wa: null, Xa() {
        return O3.createNode(null, "/", 16895, 0);
      }, createNode(a, b, c, d3) {
        if ((c & 61440) === 24576 || (c & 61440) === 4096)
          throw new N3(63);
        O3.Wa || (O3.Wa = { dir: { node: { Ta: O3.La.Ta, Ua: O3.La.Ua, lookup: O3.La.lookup, hb: O3.La.hb, rename: O3.La.rename, unlink: O3.La.unlink, rmdir: O3.La.rmdir, readdir: O3.La.readdir, symlink: O3.La.symlink }, stream: { Va: O3.Ma.Va } }, file: { node: { Ta: O3.La.Ta, Ua: O3.La.Ua }, stream: { Va: O3.Ma.Va, read: O3.Ma.read, write: O3.Ma.write, ib: O3.Ma.ib, jb: O3.Ma.jb } }, link: { node: { Ta: O3.La.Ta, Ua: O3.La.Ua, readlink: O3.La.readlink }, stream: {} }, ub: { node: { Ta: O3.La.Ta, Ua: O3.La.Ua }, stream: Ab } });
        c = Bb(a, b, c, d3);
        P2(c.mode) ? (c.La = O3.Wa.dir.node, c.Ma = O3.Wa.dir.stream, c.Na = {}) : (c.mode & 61440) === 32768 ? (c.La = O3.Wa.file.node, c.Ma = O3.Wa.file.stream, c.Ra = 0, c.Na = null) : (c.mode & 61440) === 40960 ? (c.La = O3.Wa.link.node, c.Ma = O3.Wa.link.stream) : (c.mode & 61440) === 8192 && (c.La = O3.Wa.ub.node, c.Ma = O3.Wa.ub.stream);
        c.atime = c.mtime = c.ctime = Date.now();
        a && (a.Na[b] = c, a.atime = a.mtime = a.ctime = c.atime);
        return c;
      }, Sb(a) {
        return a.Na ? a.Na.subarray ? a.Na.subarray(0, a.Ra) : new Uint8Array(a.Na) : new Uint8Array(0);
      }, La: { Ta(a) {
        var b = {};
        b.dev = (a.mode & 61440) === 8192 ? a.id : 1;
        b.ino = a.id;
        b.mode = a.mode;
        b.nlink = 1;
        b.uid = 0;
        b.gid = 0;
        b.rdev = a.rdev;
        P2(a.mode) ? b.size = 4096 : (a.mode & 61440) === 32768 ? b.size = a.Ra : (a.mode & 61440) === 40960 ? b.size = a.link.length : b.size = 0;
        b.atime = new Date(a.atime);
        b.mtime = new Date(a.mtime);
        b.ctime = new Date(a.ctime);
        b.blksize = 4096;
        b.blocks = Math.ceil(b.size / b.blksize);
        return b;
      }, Ua(a, b) {
        for (var c of ["mode", "atime", "mtime", "ctime"])
          b[c] != null && (a[c] = b[c]);
        b.size !== undefined && (b = b.size, a.Ra != b && (b == 0 ? (a.Na = null, a.Ra = 0) : (c = a.Na, a.Na = new Uint8Array(b), c && a.Na.set(c.subarray(0, Math.min(b, a.Ra))), a.Ra = b)));
      }, lookup() {
        throw O3.vb;
      }, hb(a, b, c, d3) {
        return O3.createNode(a, b, c, d3);
      }, rename(a, b, c) {
        try {
          var d3 = Q4(b, c);
        } catch (h) {}
        if (d3) {
          if (P2(a.mode))
            for (var e2 in d3.Na)
              throw new N3(55);
          Cb(d3);
        }
        delete a.parent.Na[a.name];
        b.Na[c] = a;
        a.name = c;
        b.ctime = b.mtime = a.parent.ctime = a.parent.mtime = Date.now();
      }, unlink(a, b) {
        delete a.Na[b];
        a.ctime = a.mtime = Date.now();
      }, rmdir(a, b) {
        var c = Q4(a, b), d3;
        for (d3 in c.Na)
          throw new N3(55);
        delete a.Na[b];
        a.ctime = a.mtime = Date.now();
      }, readdir(a) {
        return [".", "..", ...Object.keys(a.Na)];
      }, symlink(a, b, c) {
        a = O3.createNode(a, b, 41471, 0);
        a.link = c;
        return a;
      }, readlink(a) {
        if ((a.mode & 61440) !== 40960)
          throw new N3(28);
        return a.link;
      } }, Ma: { read(a, b, c, d3, e2) {
        var h = a.node.Na;
        if (e2 >= a.node.Ra)
          return 0;
        a = Math.min(a.node.Ra - e2, d3);
        if (8 < a && h.subarray)
          b.set(h.subarray(e2, e2 + a), c);
        else
          for (d3 = 0;d3 < a; d3++)
            b[c + d3] = h[e2 + d3];
        return a;
      }, write(a, b, c, d3, e2, h) {
        b.buffer === p2.buffer && (h = false);
        if (!d3)
          return 0;
        a = a.node;
        a.mtime = a.ctime = Date.now();
        if (b.subarray && (!a.Na || a.Na.subarray)) {
          if (h)
            return a.Na = b.subarray(c, c + d3), a.Ra = d3;
          if (a.Ra === 0 && e2 === 0)
            return a.Na = b.slice(c, c + d3), a.Ra = d3;
          if (e2 + d3 <= a.Ra)
            return a.Na.set(b.subarray(c, c + d3), e2), d3;
        }
        h = e2 + d3;
        var k4 = a.Na ? a.Na.length : 0;
        k4 >= h || (h = Math.max(h, k4 * (1048576 > k4 ? 2 : 1.125) >>> 0), k4 != 0 && (h = Math.max(h, 256)), k4 = a.Na, a.Na = new Uint8Array(h), 0 < a.Ra && a.Na.set(k4.subarray(0, a.Ra), 0));
        if (a.Na.subarray && b.subarray)
          a.Na.set(b.subarray(c, c + d3), e2);
        else
          for (h = 0;h < d3; h++)
            a.Na[e2 + h] = b[c + h];
        a.Ra = Math.max(a.Ra, e2 + d3);
        return d3;
      }, Va(a, b, c) {
        c === 1 ? b += a.position : c === 2 && (a.node.mode & 61440) === 32768 && (b += a.node.Ra);
        if (0 > b)
          throw new N3(28);
        return b;
      }, ib(a, b, c, d3, e2) {
        if ((a.node.mode & 61440) !== 32768)
          throw new N3(43);
        a = a.node.Na;
        if (e2 & 2 || !a || a.buffer !== p2.buffer) {
          e2 = true;
          d3 = 65536 * Math.ceil(b / 65536);
          var h = Db(65536, d3);
          h && x4.fill(0, h, h + d3);
          d3 = h;
          if (!d3)
            throw new N3(48);
          if (a) {
            if (0 < c || c + b < a.length)
              a.subarray ? a = a.subarray(c, c + b) : a = Array.prototype.slice.call(a, c, c + b);
            p2.set(a, d3);
          }
        } else
          e2 = false, d3 = a.byteOffset;
        return { Kb: d3, Ab: e2 };
      }, jb(a, b, c, d3) {
        O3.Ma.write(a, b, 0, d3, c, false);
        return 0;
      } } }, la2 = (a, b) => {
        var c = 0;
        a && (c |= 365);
        b && (c |= 146);
        return c;
      }, Eb = null, Fb = {}, Gb = [], Hb = 1, R3 = null, Ib = false, Jb = true, Kb = {}, N3 = class {
        name = "ErrnoError";
        constructor(a) {
          this.Pa = a;
        }
      }, Lb = class {
        gb = {};
        node = null;
        get flags() {
          return this.gb.flags;
        }
        set flags(a) {
          this.gb.flags = a;
        }
        get position() {
          return this.gb.position;
        }
        set position(a) {
          this.gb.position = a;
        }
      }, Mb = class {
        La = {};
        Ma = {};
        ab = null;
        constructor(a, b, c, d3) {
          a ||= this;
          this.parent = a;
          this.Xa = a.Xa;
          this.id = Hb++;
          this.name = b;
          this.mode = c;
          this.rdev = d3;
          this.atime = this.mtime = this.ctime = Date.now();
        }
        get read() {
          return (this.mode & 365) === 365;
        }
        set read(a) {
          a ? this.mode |= 365 : this.mode &= -366;
        }
        get write() {
          return (this.mode & 146) === 146;
        }
        set write(a) {
          a ? this.mode |= 146 : this.mode &= -147;
        }
      };
      function S2(a, b = {}) {
        if (!a)
          throw new N3(44);
        b.nb ?? (b.nb = true);
        a.charAt(0) === "/" || (a = "//" + a);
        var c = 0;
        a:
          for (;40 > c; c++) {
            a = a.split("/").filter((q3) => !!q3);
            for (var d3 = Eb, e2 = "/", h = 0;h < a.length; h++) {
              var k4 = h === a.length - 1;
              if (k4 && b.parent)
                break;
              if (a[h] !== ".")
                if (a[h] === "..")
                  e2 = fb(e2), d3 = d3.parent;
                else {
                  e2 = ka2(e2 + "/" + a[h]);
                  try {
                    d3 = Q4(d3, a[h]);
                  } catch (q3) {
                    if (q3?.Pa === 44 && k4 && b.Jb)
                      return { path: e2 };
                    throw q3;
                  }
                  !d3.ab || k4 && !b.nb || (d3 = d3.ab.root);
                  if ((d3.mode & 61440) === 40960 && (!k4 || b.$a)) {
                    if (!d3.La.readlink)
                      throw new N3(52);
                    d3 = d3.La.readlink(d3);
                    d3.charAt(0) === "/" || (d3 = fb(e2) + "/" + d3);
                    a = d3 + "/" + a.slice(h + 1).join("/");
                    continue a;
                  }
                }
            }
            return { path: e2, node: d3 };
          }
        throw new N3(32);
      }
      function ja2(a) {
        for (var b;; ) {
          if (a === a.parent)
            return a = a.Xa.zb, b ? a[a.length - 1] !== "/" ? `${a}/${b}` : a + b : a;
          b = b ? `${a.name}/${b}` : a.name;
          a = a.parent;
        }
      }
      function Nb(a, b) {
        for (var c = 0, d3 = 0;d3 < b.length; d3++)
          c = (c << 5) - c + b.charCodeAt(d3) | 0;
        return (a + c >>> 0) % R3.length;
      }
      function Cb(a) {
        var b = Nb(a.parent.id, a.name);
        if (R3[b] === a)
          R3[b] = a.bb;
        else
          for (b = R3[b];b; ) {
            if (b.bb === a) {
              b.bb = a.bb;
              break;
            }
            b = b.bb;
          }
      }
      function Q4(a, b) {
        var c = P2(a.mode) ? (c = Ob(a, "x")) ? c : a.La.lookup ? 0 : 2 : 54;
        if (c)
          throw new N3(c);
        for (c = R3[Nb(a.id, b)];c; c = c.bb) {
          var d3 = c.name;
          if (c.parent.id === a.id && d3 === b)
            return c;
        }
        return a.La.lookup(a, b);
      }
      function Bb(a, b, c, d3) {
        a = new Mb(a, b, c, d3);
        b = Nb(a.parent.id, a.name);
        a.bb = R3[b];
        return R3[b] = a;
      }
      function P2(a) {
        return (a & 61440) === 16384;
      }
      function Pb(a) {
        var b = ["r", "w", "rw"][a & 3];
        a & 512 && (b += "w");
        return b;
      }
      function Ob(a, b) {
        if (Jb)
          return 0;
        if (!b.includes("r") || a.mode & 292) {
          if (b.includes("w") && !(a.mode & 146) || b.includes("x") && !(a.mode & 73))
            return 2;
        } else
          return 2;
        return 0;
      }
      function Qb(a, b) {
        if (!P2(a.mode))
          return 54;
        try {
          return Q4(a, b), 20;
        } catch (c) {}
        return Ob(a, "wx");
      }
      function Rb(a, b, c) {
        try {
          var d3 = Q4(a, b);
        } catch (e2) {
          return e2.Pa;
        }
        if (a = Ob(a, "wx"))
          return a;
        if (c) {
          if (!P2(d3.mode))
            return 54;
          if (d3 === d3.parent || ja2(d3) === "/")
            return 10;
        } else if (P2(d3.mode))
          return 31;
        return 0;
      }
      function Sb(a) {
        if (!a)
          throw new N3(63);
        return a;
      }
      function T2(a) {
        a = Gb[a];
        if (!a)
          throw new N3(8);
        return a;
      }
      function Tb(a, b = -1) {
        a = Object.assign(new Lb, a);
        if (b == -1)
          a: {
            for (b = 0;4096 >= b; b++)
              if (!Gb[b])
                break a;
            throw new N3(33);
          }
        a.fd = b;
        return Gb[b] = a;
      }
      function Ub(a, b = -1) {
        a = Tb(a, b);
        a.Ma?.Rb?.(a);
        return a;
      }
      function Vb(a, b, c) {
        var d3 = a?.Ma.Ua;
        a = d3 ? a : b;
        d3 ??= b.La.Ua;
        Sb(d3);
        d3(a, c);
      }
      var Ab = { open(a) {
        a.Ma = Fb[a.node.rdev].Ma;
        a.Ma.open?.(a);
      }, Va() {
        throw new N3(70);
      } };
      function wb(a, b) {
        Fb[a] = { Ma: b };
      }
      function Wb(a, b) {
        var c = b === "/";
        if (c && Eb)
          throw new N3(10);
        if (!c && b) {
          var d3 = S2(b, { nb: false });
          b = d3.path;
          d3 = d3.node;
          if (d3.ab)
            throw new N3(10);
          if (!P2(d3.mode))
            throw new N3(54);
        }
        b = { type: a, Wb: {}, zb: b, Ib: [] };
        a = a.Xa(b);
        a.Xa = b;
        b.root = a;
        c ? Eb = a : d3 && (d3.ab = b, d3.Xa && d3.Xa.Ib.push(b));
      }
      function Xb(a, b, c) {
        var d3 = S2(a, { parent: true }).node;
        a = gb(a);
        if (!a)
          throw new N3(28);
        if (a === "." || a === "..")
          throw new N3(20);
        var e2 = Qb(d3, a);
        if (e2)
          throw new N3(e2);
        if (!d3.La.hb)
          throw new N3(63);
        return d3.La.hb(d3, a, b, c);
      }
      function ma2(a, b = 438) {
        return Xb(a, b & 4095 | 32768, 0);
      }
      function U3(a, b = 511) {
        return Xb(a, b & 1023 | 16384, 0);
      }
      function Yb(a, b, c) {
        typeof c == "undefined" && (c = b, b = 438);
        Xb(a, b | 8192, c);
      }
      function Zb(a, b) {
        if (!jb(a))
          throw new N3(44);
        var c = S2(b, { parent: true }).node;
        if (!c)
          throw new N3(44);
        b = gb(b);
        var d3 = Qb(c, b);
        if (d3)
          throw new N3(d3);
        if (!c.La.symlink)
          throw new N3(63);
        c.La.symlink(c, b, a);
      }
      function $b(a) {
        var b = S2(a, { parent: true }).node;
        a = gb(a);
        var c = Q4(b, a), d3 = Rb(b, a, true);
        if (d3)
          throw new N3(d3);
        if (!b.La.rmdir)
          throw new N3(63);
        if (c.ab)
          throw new N3(10);
        b.La.rmdir(b, a);
        Cb(c);
      }
      function za2(a) {
        var b = S2(a, { parent: true }).node;
        if (!b)
          throw new N3(44);
        a = gb(a);
        var c = Q4(b, a), d3 = Rb(b, a, false);
        if (d3)
          throw new N3(d3);
        if (!b.La.unlink)
          throw new N3(63);
        if (c.ab)
          throw new N3(10);
        b.La.unlink(b, a);
        Cb(c);
      }
      function ac(a, b) {
        a = S2(a, { $a: !b }).node;
        return Sb(a.La.Ta)(a);
      }
      function bc(a, b, c, d3) {
        Vb(a, b, { mode: c & 4095 | b.mode & -4096, ctime: Date.now(), Fb: d3 });
      }
      function na2(a, b) {
        a = typeof a == "string" ? S2(a, { $a: true }).node : a;
        bc(null, a, b);
      }
      function cc(a, b, c) {
        if (P2(b.mode))
          throw new N3(31);
        if ((b.mode & 61440) !== 32768)
          throw new N3(28);
        var d3 = Ob(b, "w");
        if (d3)
          throw new N3(d3);
        Vb(a, b, { size: c, timestamp: Date.now() });
      }
      function oa2(a, b, c = 438) {
        if (a === "")
          throw new N3(44);
        if (typeof b == "string") {
          var d3 = { r: 0, "r+": 2, w: 577, "w+": 578, a: 1089, "a+": 1090 }[b];
          if (typeof d3 == "undefined")
            throw Error(`Unknown file open mode: ${b}`);
          b = d3;
        }
        c = b & 64 ? c & 4095 | 32768 : 0;
        if (typeof a == "object")
          d3 = a;
        else {
          var e2 = a.endsWith("/");
          a = S2(a, { $a: !(b & 131072), Jb: true });
          d3 = a.node;
          a = a.path;
        }
        var h = false;
        if (b & 64)
          if (d3) {
            if (b & 128)
              throw new N3(20);
          } else {
            if (e2)
              throw new N3(31);
            d3 = Xb(a, c | 511, 0);
            h = true;
          }
        if (!d3)
          throw new N3(44);
        (d3.mode & 61440) === 8192 && (b &= -513);
        if (b & 65536 && !P2(d3.mode))
          throw new N3(54);
        if (!h && (e2 = d3 ? (d3.mode & 61440) === 40960 ? 32 : P2(d3.mode) && (Pb(b) !== "r" || b & 576) ? 31 : Ob(d3, Pb(b)) : 44))
          throw new N3(e2);
        b & 512 && !h && (e2 = d3, e2 = typeof e2 == "string" ? S2(e2, { $a: true }).node : e2, cc(null, e2, 0));
        b &= -131713;
        e2 = Tb({ node: d3, path: ja2(d3), flags: b, seekable: true, position: 0, Ma: d3.Ma, Lb: [], error: false });
        e2.Ma.open && e2.Ma.open(e2);
        h && na2(d3, c & 511);
        !f2.logReadFiles || b & 1 || a in Kb || (Kb[a] = 1);
        return e2;
      }
      function qa2(a) {
        if (a.fd === null)
          throw new N3(8);
        a.ob && (a.ob = null);
        try {
          a.Ma.close && a.Ma.close(a);
        } catch (b) {
          throw b;
        } finally {
          Gb[a.fd] = null;
        }
        a.fd = null;
      }
      function mc(a, b, c) {
        if (a.fd === null)
          throw new N3(8);
        if (!a.seekable || !a.Ma.Va)
          throw new N3(70);
        if (c != 0 && c != 1 && c != 2)
          throw new N3(28);
        a.position = a.Ma.Va(a, b, c);
        a.Lb = [];
      }
      function Ec(a, b, c, d3, e2) {
        if (0 > d3 || 0 > e2)
          throw new N3(28);
        if (a.fd === null)
          throw new N3(8);
        if ((a.flags & 2097155) === 1)
          throw new N3(8);
        if (P2(a.node.mode))
          throw new N3(31);
        if (!a.Ma.read)
          throw new N3(28);
        var h = typeof e2 != "undefined";
        if (!h)
          e2 = a.position;
        else if (!a.seekable)
          throw new N3(70);
        b = a.Ma.read(a, b, c, d3, e2);
        h || (a.position += b);
        return b;
      }
      function pa2(a, b, c, d3, e2) {
        if (0 > d3 || 0 > e2)
          throw new N3(28);
        if (a.fd === null)
          throw new N3(8);
        if ((a.flags & 2097155) === 0)
          throw new N3(8);
        if (P2(a.node.mode))
          throw new N3(31);
        if (!a.Ma.write)
          throw new N3(28);
        a.seekable && a.flags & 1024 && mc(a, 0, 2);
        var h = typeof e2 != "undefined";
        if (!h)
          e2 = a.position;
        else if (!a.seekable)
          throw new N3(70);
        b = a.Ma.write(a, b, c, d3, e2, undefined);
        h || (a.position += b);
        return b;
      }
      function ya2(a) {
        var b = "binary";
        if (b !== "utf8" && b !== "binary")
          throw Error(`Invalid encoding type "${b}"`);
        var c;
        var d3 = oa2(a, d3 || 0);
        a = ac(a).size;
        var e2 = new Uint8Array(a);
        Ec(d3, e2, 0, a, 0);
        b === "utf8" ? c = B3(e2) : b === "binary" && (c = e2);
        qa2(d3);
        return c;
      }
      function V3(a, b, c) {
        a = ka2("/dev/" + a);
        var d3 = la2(!!b, !!c);
        V3.yb ?? (V3.yb = 64);
        var e2 = V3.yb++ << 8 | 0;
        wb(e2, { open(h) {
          h.seekable = false;
        }, close() {
          c?.buffer?.length && c(10);
        }, read(h, k4, q3, w) {
          for (var v2 = 0, C2 = 0;C2 < w; C2++) {
            try {
              var G2 = b();
            } catch (pb) {
              throw new N3(29);
            }
            if (G2 === undefined && v2 === 0)
              throw new N3(6);
            if (G2 === null || G2 === undefined)
              break;
            v2++;
            k4[q3 + C2] = G2;
          }
          v2 && (h.node.atime = Date.now());
          return v2;
        }, write(h, k4, q3, w) {
          for (var v2 = 0;v2 < w; v2++)
            try {
              c(k4[q3 + v2]);
            } catch (C2) {
              throw new N3(29);
            }
          w && (h.node.mtime = h.node.ctime = Date.now());
          return v2;
        } });
        Yb(a, d3, e2);
      }
      var W3 = {};
      function Gc(a, b, c) {
        if (b.charAt(0) === "/")
          return b;
        a = a === -100 ? "/" : T2(a).path;
        if (b.length == 0) {
          if (!c)
            throw new N3(44);
          return a;
        }
        return a + "/" + b;
      }
      function Hc(a, b) {
        E4[a >> 2] = b.dev;
        E4[a + 4 >> 2] = b.mode;
        F2[a + 8 >> 2] = b.nlink;
        E4[a + 12 >> 2] = b.uid;
        E4[a + 16 >> 2] = b.gid;
        E4[a + 20 >> 2] = b.rdev;
        H3[a + 24 >> 3] = BigInt(b.size);
        E4[a + 32 >> 2] = 4096;
        E4[a + 36 >> 2] = b.blocks;
        var c = b.atime.getTime(), d3 = b.mtime.getTime(), e2 = b.ctime.getTime();
        H3[a + 40 >> 3] = BigInt(Math.floor(c / 1000));
        F2[a + 48 >> 2] = c % 1000 * 1e6;
        H3[a + 56 >> 3] = BigInt(Math.floor(d3 / 1000));
        F2[a + 64 >> 2] = d3 % 1000 * 1e6;
        H3[a + 72 >> 3] = BigInt(Math.floor(e2 / 1000));
        F2[a + 80 >> 2] = e2 % 1000 * 1e6;
        H3[a + 88 >> 3] = BigInt(b.ino);
        return 0;
      }
      var Ic = undefined, Jc = () => {
        var a = E4[+Ic >> 2];
        Ic += 4;
        return a;
      }, Kc = 0, Lc = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], Mc = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], Nc = {}, Oc = (a) => {
        Ma2 = a;
        cb || 0 < Kc || (f2.onExit?.(a), La2 = true);
        Da2(a, new Ya2(a));
      }, Pc = (a) => {
        if (!La2)
          try {
            if (a(), !(cb || 0 < Kc))
              try {
                Ma2 = a = Ma2, Oc(a);
              } catch (b) {
                b instanceof Ya2 || b == "unwind" || Da2(1, b);
              }
          } catch (b) {
            b instanceof Ya2 || b == "unwind" || Da2(1, b);
          }
      }, Qc = {}, Sc = () => {
        if (!Rc) {
          var a = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: Ca2 || "./this.program" }, b;
          for (b in Qc)
            Qc[b] === undefined ? delete a[b] : a[b] = Qc[b];
          var c = [];
          for (b in a)
            c.push(`${b}=${a[b]}`);
          Rc = c;
        }
        return Rc;
      }, Rc, xa2 = (a) => {
        var b = ha2(a) + 1, c = z2(b);
        u(a, x4, c, b);
        return c;
      }, Tc = (a, b, c, d3) => {
        var e2 = { string: (v2) => {
          var C2 = 0;
          v2 !== null && v2 !== undefined && v2 !== 0 && (C2 = xa2(v2));
          return C2;
        }, array: (v2) => {
          var C2 = z2(v2.length);
          p2.set(v2, C2);
          return C2;
        } };
        a = f2["_" + a];
        var h = [], k4 = 0;
        if (d3)
          for (var q3 = 0;q3 < d3.length; q3++) {
            var w = e2[c[q3]];
            w ? (k4 === 0 && (k4 = sa2()), h[q3] = w(d3[q3])) : h[q3] = d3[q3];
          }
        c = a(...h);
        return c = function(v2) {
          k4 !== 0 && wa2(k4);
          return b === "string" ? v2 ? B3(x4, v2) : "" : b === "boolean" ? !!v2 : v2;
        }(c);
      }, ea2 = 0, da2 = (a, b) => {
        b = b == 1 ? z2(a.length) : ia2(a.length);
        a.subarray || a.slice || (a = new Uint8Array(a));
        x4.set(a, b);
        return b;
      }, Uc, Vc = [], Y4, A3 = (a) => {
        Uc.delete(Y4.get(a));
        Y4.set(a, null);
        Vc.push(a);
      }, Aa2 = (a, b) => {
        if (!Uc) {
          Uc = new WeakMap;
          var c = Y4.length;
          if (Uc)
            for (var d3 = 0;d3 < 0 + c; d3++) {
              var e2 = Y4.get(d3);
              e2 && Uc.set(e2, d3);
            }
        }
        if (c = Uc.get(a) || 0)
          return c;
        if (Vc.length)
          c = Vc.pop();
        else {
          try {
            Y4.grow(1);
          } catch (w) {
            if (!(w instanceof RangeError))
              throw w;
            throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
          }
          c = Y4.length - 1;
        }
        try {
          Y4.set(c, a);
        } catch (w) {
          if (!(w instanceof TypeError))
            throw w;
          if (typeof WebAssembly.Function == "function") {
            var h = WebAssembly.Function;
            d3 = { i: "i32", j: "i64", f: "f32", d: "f64", e: "externref", p: "i32" };
            e2 = { parameters: [], results: b[0] == "v" ? [] : [d3[b[0]]] };
            for (var k4 = 1;k4 < b.length; ++k4)
              e2.parameters.push(d3[b[k4]]);
            b = new h(e2, a);
          } else {
            d3 = [1];
            e2 = b.slice(0, 1);
            b = b.slice(1);
            k4 = { i: 127, p: 127, j: 126, f: 125, d: 124, e: 111 };
            d3.push(96);
            var q3 = b.length;
            128 > q3 ? d3.push(q3) : d3.push(q3 % 128 | 128, q3 >> 7);
            for (h of b)
              d3.push(k4[h]);
            e2 == "v" ? d3.push(0) : d3.push(1, k4[e2]);
            b = [0, 97, 115, 109, 1, 0, 0, 0, 1];
            h = d3.length;
            128 > h ? b.push(h) : b.push(h % 128 | 128, h >> 7);
            b.push(...d3);
            b.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0);
            b = new WebAssembly.Module(new Uint8Array(b));
            b = new WebAssembly.Instance(b, { e: { f: a } }).exports.f;
          }
          Y4.set(c, b);
        }
        Uc.set(a, c);
        return c;
      };
      R3 = Array(4096);
      Wb(O3, "/");
      U3("/tmp");
      U3("/home");
      U3("/home/web_user");
      (function() {
        U3("/dev");
        wb(259, { read: () => 0, write: (d3, e2, h, k4) => k4, Va: () => 0 });
        Yb("/dev/null", 259);
        nb(1280, yb);
        nb(1536, zb);
        Yb("/dev/tty", 1280);
        Yb("/dev/tty1", 1536);
        var a = new Uint8Array(1024), b = 0, c = () => {
          b === 0 && (ib(a), b = a.byteLength);
          return a[--b];
        };
        V3("random", c);
        V3("urandom", c);
        U3("/dev/shm");
        U3("/dev/shm/tmp");
      })();
      (function() {
        U3("/proc");
        var a = U3("/proc/self");
        U3("/proc/self/fd");
        Wb({ Xa() {
          var b = Bb(a, "fd", 16895, 73);
          b.Ma = { Va: O3.Ma.Va };
          b.La = { lookup(c, d3) {
            c = +d3;
            var e2 = T2(c);
            c = { parent: null, Xa: { zb: "fake" }, La: { readlink: () => e2.path }, id: c + 1 };
            return c.parent = c;
          }, readdir() {
            return Array.from(Gb.entries()).filter(([, c]) => c).map(([c]) => c.toString());
          } };
          return b;
        } }, "/proc/self/fd");
      })();
      O3.vb = new N3(44);
      O3.vb.stack = "<generic error, no stack>";
      var Xc = { a: (a, b, c, d3) => Ta2(`Assertion failed: ${a ? B3(x4, a) : ""}, at: ` + [b ? b ? B3(x4, b) : "" : "unknown filename", c, d3 ? d3 ? B3(x4, d3) : "" : "unknown function"]), i: function(a, b) {
        try {
          return a = a ? B3(x4, a) : "", na2(a, b), 0;
        } catch (c) {
          if (typeof W3 == "undefined" || c.name !== "ErrnoError")
            throw c;
          return -c.Pa;
        }
      }, L: function(a, b, c) {
        try {
          b = b ? B3(x4, b) : "";
          b = Gc(a, b);
          if (c & -8)
            return -28;
          var d3 = S2(b, { $a: true }).node;
          if (!d3)
            return -44;
          a = "";
          c & 4 && (a += "r");
          c & 2 && (a += "w");
          c & 1 && (a += "x");
          return a && Ob(d3, a) ? -2 : 0;
        } catch (e2) {
          if (typeof W3 == "undefined" || e2.name !== "ErrnoError")
            throw e2;
          return -e2.Pa;
        }
      }, j: function(a, b) {
        try {
          var c = T2(a);
          bc(c, c.node, b, false);
          return 0;
        } catch (d3) {
          if (typeof W3 == "undefined" || d3.name !== "ErrnoError")
            throw d3;
          return -d3.Pa;
        }
      }, h: function(a) {
        try {
          var b = T2(a);
          Vb(b, b.node, { timestamp: Date.now(), Fb: false });
          return 0;
        } catch (c) {
          if (typeof W3 == "undefined" || c.name !== "ErrnoError")
            throw c;
          return -c.Pa;
        }
      }, b: function(a, b, c) {
        Ic = c;
        try {
          var d3 = T2(a);
          switch (b) {
            case 0:
              var e2 = Jc();
              if (0 > e2)
                break;
              for (;Gb[e2]; )
                e2++;
              return Ub(d3, e2).fd;
            case 1:
            case 2:
              return 0;
            case 3:
              return d3.flags;
            case 4:
              return e2 = Jc(), d3.flags |= e2, 0;
            case 12:
              return e2 = Jc(), Na2[e2 + 0 >> 1] = 2, 0;
            case 13:
            case 14:
              return 0;
          }
          return -28;
        } catch (h) {
          if (typeof W3 == "undefined" || h.name !== "ErrnoError")
            throw h;
          return -h.Pa;
        }
      }, g: function(a, b) {
        try {
          var c = T2(a), d3 = c.node, e2 = c.Ma.Ta;
          a = e2 ? c : d3;
          e2 ??= d3.La.Ta;
          Sb(e2);
          var h = e2(a);
          return Hc(b, h);
        } catch (k4) {
          if (typeof W3 == "undefined" || k4.name !== "ErrnoError")
            throw k4;
          return -k4.Pa;
        }
      }, H: function(a, b) {
        b = -9007199254740992 > b || 9007199254740992 < b ? NaN : Number(b);
        try {
          if (isNaN(b))
            return 61;
          var c = T2(a);
          if (0 > b || (c.flags & 2097155) === 0)
            throw new N3(28);
          cc(c, c.node, b);
          return 0;
        } catch (d3) {
          if (typeof W3 == "undefined" || d3.name !== "ErrnoError")
            throw d3;
          return -d3.Pa;
        }
      }, G: function(a, b) {
        try {
          if (b === 0)
            return -28;
          var c = ha2("/") + 1;
          if (b < c)
            return -68;
          u("/", x4, a, b);
          return c;
        } catch (d3) {
          if (typeof W3 == "undefined" || d3.name !== "ErrnoError")
            throw d3;
          return -d3.Pa;
        }
      }, K: function(a, b) {
        try {
          return a = a ? B3(x4, a) : "", Hc(b, ac(a, true));
        } catch (c) {
          if (typeof W3 == "undefined" || c.name !== "ErrnoError")
            throw c;
          return -c.Pa;
        }
      }, C: function(a, b, c) {
        try {
          return b = b ? B3(x4, b) : "", b = Gc(a, b), U3(b, c), 0;
        } catch (d3) {
          if (typeof W3 == "undefined" || d3.name !== "ErrnoError")
            throw d3;
          return -d3.Pa;
        }
      }, J: function(a, b, c, d3) {
        try {
          b = b ? B3(x4, b) : "";
          var e2 = d3 & 256;
          b = Gc(a, b, d3 & 4096);
          return Hc(c, e2 ? ac(b, true) : ac(b));
        } catch (h) {
          if (typeof W3 == "undefined" || h.name !== "ErrnoError")
            throw h;
          return -h.Pa;
        }
      }, x: function(a, b, c, d3) {
        Ic = d3;
        try {
          b = b ? B3(x4, b) : "";
          b = Gc(a, b);
          var e2 = d3 ? Jc() : 0;
          return oa2(b, c, e2).fd;
        } catch (h) {
          if (typeof W3 == "undefined" || h.name !== "ErrnoError")
            throw h;
          return -h.Pa;
        }
      }, v: function(a, b, c, d3) {
        try {
          b = b ? B3(x4, b) : "";
          b = Gc(a, b);
          if (0 >= d3)
            return -28;
          var e2 = S2(b).node;
          if (!e2)
            throw new N3(44);
          if (!e2.La.readlink)
            throw new N3(28);
          var h = e2.La.readlink(e2);
          var k4 = Math.min(d3, ha2(h)), q3 = p2[c + k4];
          u(h, x4, c, d3 + 1);
          p2[c + k4] = q3;
          return k4;
        } catch (w) {
          if (typeof W3 == "undefined" || w.name !== "ErrnoError")
            throw w;
          return -w.Pa;
        }
      }, u: function(a) {
        try {
          return a = a ? B3(x4, a) : "", $b(a), 0;
        } catch (b) {
          if (typeof W3 == "undefined" || b.name !== "ErrnoError")
            throw b;
          return -b.Pa;
        }
      }, f: function(a, b) {
        try {
          return a = a ? B3(x4, a) : "", Hc(b, ac(a));
        } catch (c) {
          if (typeof W3 == "undefined" || c.name !== "ErrnoError")
            throw c;
          return -c.Pa;
        }
      }, r: function(a, b, c) {
        try {
          return b = b ? B3(x4, b) : "", b = Gc(a, b), c === 0 ? za2(b) : c === 512 ? $b(b) : Ta2("Invalid flags passed to unlinkat"), 0;
        } catch (d3) {
          if (typeof W3 == "undefined" || d3.name !== "ErrnoError")
            throw d3;
          return -d3.Pa;
        }
      }, q: function(a, b, c) {
        try {
          b = b ? B3(x4, b) : "";
          b = Gc(a, b, true);
          var d3 = Date.now(), e2, h;
          if (c) {
            var k4 = F2[c >> 2] + 4294967296 * E4[c + 4 >> 2], q3 = E4[c + 8 >> 2];
            q3 == 1073741823 ? e2 = d3 : q3 == 1073741822 ? e2 = null : e2 = 1000 * k4 + q3 / 1e6;
            c += 16;
            k4 = F2[c >> 2] + 4294967296 * E4[c + 4 >> 2];
            q3 = E4[c + 8 >> 2];
            q3 == 1073741823 ? h = d3 : q3 == 1073741822 ? h = null : h = 1000 * k4 + q3 / 1e6;
          } else
            h = e2 = d3;
          if ((h ?? e2) !== null) {
            a = e2;
            var w = S2(b, { $a: true }).node;
            Sb(w.La.Ua)(w, { atime: a, mtime: h });
          }
          return 0;
        } catch (v2) {
          if (typeof W3 == "undefined" || v2.name !== "ErrnoError")
            throw v2;
          return -v2.Pa;
        }
      }, m: () => Ta2(""), l: () => {
        cb = false;
        Kc = 0;
      }, A: function(a, b) {
        a = -9007199254740992 > a || 9007199254740992 < a ? NaN : Number(a);
        a = new Date(1000 * a);
        E4[b >> 2] = a.getSeconds();
        E4[b + 4 >> 2] = a.getMinutes();
        E4[b + 8 >> 2] = a.getHours();
        E4[b + 12 >> 2] = a.getDate();
        E4[b + 16 >> 2] = a.getMonth();
        E4[b + 20 >> 2] = a.getFullYear() - 1900;
        E4[b + 24 >> 2] = a.getDay();
        var c = a.getFullYear();
        E4[b + 28 >> 2] = (c % 4 !== 0 || c % 100 === 0 && c % 400 !== 0 ? Mc : Lc)[a.getMonth()] + a.getDate() - 1 | 0;
        E4[b + 36 >> 2] = -(60 * a.getTimezoneOffset());
        c = new Date(a.getFullYear(), 6, 1).getTimezoneOffset();
        var d3 = new Date(a.getFullYear(), 0, 1).getTimezoneOffset();
        E4[b + 32 >> 2] = (c != d3 && a.getTimezoneOffset() == Math.min(d3, c)) | 0;
      }, y: function(a, b, c, d3, e2, h, k4) {
        e2 = -9007199254740992 > e2 || 9007199254740992 < e2 ? NaN : Number(e2);
        try {
          if (isNaN(e2))
            return 61;
          var q3 = T2(d3);
          if ((b & 2) !== 0 && (c & 2) === 0 && (q3.flags & 2097155) !== 2)
            throw new N3(2);
          if ((q3.flags & 2097155) === 1)
            throw new N3(2);
          if (!q3.Ma.ib)
            throw new N3(43);
          if (!a)
            throw new N3(28);
          var w = q3.Ma.ib(q3, a, e2, b, c);
          var v2 = w.Kb;
          E4[h >> 2] = w.Ab;
          F2[k4 >> 2] = v2;
          return 0;
        } catch (C2) {
          if (typeof W3 == "undefined" || C2.name !== "ErrnoError")
            throw C2;
          return -C2.Pa;
        }
      }, z: function(a, b, c, d3, e2, h) {
        h = -9007199254740992 > h || 9007199254740992 < h ? NaN : Number(h);
        try {
          var k4 = T2(e2);
          if (c & 2) {
            c = h;
            if ((k4.node.mode & 61440) !== 32768)
              throw new N3(43);
            if (!(d3 & 2)) {
              var q3 = x4.slice(a, a + b);
              k4.Ma.jb && k4.Ma.jb(k4, q3, c, b, d3);
            }
          }
        } catch (w) {
          if (typeof W3 == "undefined" || w.name !== "ErrnoError")
            throw w;
          return -w.Pa;
        }
      }, n: (a, b) => {
        Nc[a] && (clearTimeout(Nc[a].id), delete Nc[a]);
        if (!b)
          return 0;
        var c = setTimeout(() => {
          delete Nc[a];
          Pc(() => Wc(a, performance.now()));
        }, b);
        Nc[a] = {
          id: c,
          Xb: b
        };
        return 0;
      }, B: (a, b, c, d3) => {
        var e2 = new Date().getFullYear(), h = new Date(e2, 0, 1).getTimezoneOffset();
        e2 = new Date(e2, 6, 1).getTimezoneOffset();
        F2[a >> 2] = 60 * Math.max(h, e2);
        E4[b >> 2] = Number(h != e2);
        b = (k4) => {
          var q3 = Math.abs(k4);
          return `UTC${0 <= k4 ? "-" : "+"}${String(Math.floor(q3 / 60)).padStart(2, "0")}${String(q3 % 60).padStart(2, "0")}`;
        };
        a = b(h);
        b = b(e2);
        e2 < h ? (u(a, x4, c, 17), u(b, x4, d3, 17)) : (u(a, x4, d3, 17), u(b, x4, c, 17));
      }, d: () => Date.now(), s: () => 2147483648, c: () => performance.now(), o: (a) => {
        var b = x4.length;
        a >>>= 0;
        if (2147483648 < a)
          return false;
        for (var c = 1;4 >= c; c *= 2) {
          var d3 = b * (1 + 0.2 / c);
          d3 = Math.min(d3, a + 100663296);
          a: {
            d3 = (Math.min(2147483648, 65536 * Math.ceil(Math.max(a, d3) / 65536)) - Ka2.buffer.byteLength + 65535) / 65536 | 0;
            try {
              Ka2.grow(d3);
              Qa2();
              var e2 = 1;
              break a;
            } catch (h) {}
            e2 = undefined;
          }
          if (e2)
            return true;
        }
        return false;
      }, E: (a, b) => {
        var c = 0;
        Sc().forEach((d3, e2) => {
          var h = b + c;
          e2 = F2[a + 4 * e2 >> 2] = h;
          for (h = 0;h < d3.length; ++h)
            p2[e2++] = d3.charCodeAt(h);
          p2[e2] = 0;
          c += d3.length + 1;
        });
        return 0;
      }, F: (a, b) => {
        var c = Sc();
        F2[a >> 2] = c.length;
        var d3 = 0;
        c.forEach((e2) => d3 += e2.length + 1);
        F2[b >> 2] = d3;
        return 0;
      }, e: function(a) {
        try {
          var b = T2(a);
          qa2(b);
          return 0;
        } catch (c) {
          if (typeof W3 == "undefined" || c.name !== "ErrnoError")
            throw c;
          return c.Pa;
        }
      }, p: function(a, b) {
        try {
          var c = T2(a);
          p2[b] = c.tty ? 2 : P2(c.mode) ? 3 : (c.mode & 61440) === 40960 ? 7 : 4;
          Na2[b + 2 >> 1] = 0;
          H3[b + 8 >> 3] = BigInt(0);
          H3[b + 16 >> 3] = BigInt(0);
          return 0;
        } catch (d3) {
          if (typeof W3 == "undefined" || d3.name !== "ErrnoError")
            throw d3;
          return d3.Pa;
        }
      }, w: function(a, b, c, d3) {
        try {
          a: {
            var e2 = T2(a);
            a = b;
            for (var h, k4 = b = 0;k4 < c; k4++) {
              var q3 = F2[a >> 2], w = F2[a + 4 >> 2];
              a += 8;
              var v2 = Ec(e2, p2, q3, w, h);
              if (0 > v2) {
                var C2 = -1;
                break a;
              }
              b += v2;
              if (v2 < w)
                break;
              typeof h != "undefined" && (h += v2);
            }
            C2 = b;
          }
          F2[d3 >> 2] = C2;
          return 0;
        } catch (G2) {
          if (typeof W3 == "undefined" || G2.name !== "ErrnoError")
            throw G2;
          return G2.Pa;
        }
      }, D: function(a, b, c, d3) {
        b = -9007199254740992 > b || 9007199254740992 < b ? NaN : Number(b);
        try {
          if (isNaN(b))
            return 61;
          var e2 = T2(a);
          mc(e2, b, c);
          H3[d3 >> 3] = BigInt(e2.position);
          e2.ob && b === 0 && c === 0 && (e2.ob = null);
          return 0;
        } catch (h) {
          if (typeof W3 == "undefined" || h.name !== "ErrnoError")
            throw h;
          return h.Pa;
        }
      }, I: function(a) {
        try {
          var b = T2(a);
          return b.Ma?.fsync ? b.Ma.fsync(b) : 0;
        } catch (c) {
          if (typeof W3 == "undefined" || c.name !== "ErrnoError")
            throw c;
          return c.Pa;
        }
      }, t: function(a, b, c, d3) {
        try {
          a: {
            var e2 = T2(a);
            a = b;
            for (var h, k4 = b = 0;k4 < c; k4++) {
              var q3 = F2[a >> 2], w = F2[a + 4 >> 2];
              a += 8;
              var v2 = pa2(e2, p2, q3, w, h);
              if (0 > v2) {
                var C2 = -1;
                break a;
              }
              b += v2;
              if (v2 < w)
                break;
              typeof h != "undefined" && (h += v2);
            }
            C2 = b;
          }
          F2[d3 >> 2] = C2;
          return 0;
        } catch (G2) {
          if (typeof W3 == "undefined" || G2.name !== "ErrnoError")
            throw G2;
          return G2.Pa;
        }
      }, k: Oc }, Z3;
      (async function() {
        function a(c) {
          Z3 = c.exports;
          Ka2 = Z3.M;
          Qa2();
          Y4 = Z3.O;
          K4--;
          f2.monitorRunDependencies?.(K4);
          K4 == 0 && Sa2 && (c = Sa2, Sa2 = null, c());
          return Z3;
        }
        K4++;
        f2.monitorRunDependencies?.(K4);
        var b = { a: Xc };
        if (f2.instantiateWasm)
          return new Promise((c) => {
            f2.instantiateWasm(b, (d3, e2) => {
              a(d3, e2);
              c(d3.exports);
            });
          });
        Ua2 ??= f2.locateFile ? f2.locateFile("sql-wasm.wasm", D2) : D2 + "sql-wasm.wasm";
        return a((await Xa2(b)).instance);
      })();
      f2._sqlite3_free = (a) => (f2._sqlite3_free = Z3.P)(a);
      f2._sqlite3_value_text = (a) => (f2._sqlite3_value_text = Z3.Q)(a);
      f2._sqlite3_prepare_v2 = (a, b, c, d3, e2) => (f2._sqlite3_prepare_v2 = Z3.R)(a, b, c, d3, e2);
      f2._sqlite3_step = (a) => (f2._sqlite3_step = Z3.S)(a);
      f2._sqlite3_reset = (a) => (f2._sqlite3_reset = Z3.T)(a);
      f2._sqlite3_exec = (a, b, c, d3, e2) => (f2._sqlite3_exec = Z3.U)(a, b, c, d3, e2);
      f2._sqlite3_finalize = (a) => (f2._sqlite3_finalize = Z3.V)(a);
      f2._sqlite3_column_name = (a, b) => (f2._sqlite3_column_name = Z3.W)(a, b);
      f2._sqlite3_column_text = (a, b) => (f2._sqlite3_column_text = Z3.X)(a, b);
      f2._sqlite3_column_type = (a, b) => (f2._sqlite3_column_type = Z3.Y)(a, b);
      f2._sqlite3_errmsg = (a) => (f2._sqlite3_errmsg = Z3.Z)(a);
      f2._sqlite3_clear_bindings = (a) => (f2._sqlite3_clear_bindings = Z3._)(a);
      f2._sqlite3_value_blob = (a) => (f2._sqlite3_value_blob = Z3.$)(a);
      f2._sqlite3_value_bytes = (a) => (f2._sqlite3_value_bytes = Z3.aa)(a);
      f2._sqlite3_value_double = (a) => (f2._sqlite3_value_double = Z3.ba)(a);
      f2._sqlite3_value_int = (a) => (f2._sqlite3_value_int = Z3.ca)(a);
      f2._sqlite3_value_type = (a) => (f2._sqlite3_value_type = Z3.da)(a);
      f2._sqlite3_result_blob = (a, b, c, d3) => (f2._sqlite3_result_blob = Z3.ea)(a, b, c, d3);
      f2._sqlite3_result_double = (a, b) => (f2._sqlite3_result_double = Z3.fa)(a, b);
      f2._sqlite3_result_error = (a, b, c) => (f2._sqlite3_result_error = Z3.ga)(a, b, c);
      f2._sqlite3_result_int = (a, b) => (f2._sqlite3_result_int = Z3.ha)(a, b);
      f2._sqlite3_result_int64 = (a, b) => (f2._sqlite3_result_int64 = Z3.ia)(a, b);
      f2._sqlite3_result_null = (a) => (f2._sqlite3_result_null = Z3.ja)(a);
      f2._sqlite3_result_text = (a, b, c, d3) => (f2._sqlite3_result_text = Z3.ka)(a, b, c, d3);
      f2._sqlite3_aggregate_context = (a, b) => (f2._sqlite3_aggregate_context = Z3.la)(a, b);
      f2._sqlite3_column_count = (a) => (f2._sqlite3_column_count = Z3.ma)(a);
      f2._sqlite3_data_count = (a) => (f2._sqlite3_data_count = Z3.na)(a);
      f2._sqlite3_column_blob = (a, b) => (f2._sqlite3_column_blob = Z3.oa)(a, b);
      f2._sqlite3_column_bytes = (a, b) => (f2._sqlite3_column_bytes = Z3.pa)(a, b);
      f2._sqlite3_column_double = (a, b) => (f2._sqlite3_column_double = Z3.qa)(a, b);
      f2._sqlite3_bind_blob = (a, b, c, d3, e2) => (f2._sqlite3_bind_blob = Z3.ra)(a, b, c, d3, e2);
      f2._sqlite3_bind_double = (a, b, c) => (f2._sqlite3_bind_double = Z3.sa)(a, b, c);
      f2._sqlite3_bind_int = (a, b, c) => (f2._sqlite3_bind_int = Z3.ta)(a, b, c);
      f2._sqlite3_bind_text = (a, b, c, d3, e2) => (f2._sqlite3_bind_text = Z3.ua)(a, b, c, d3, e2);
      f2._sqlite3_bind_parameter_index = (a, b) => (f2._sqlite3_bind_parameter_index = Z3.va)(a, b);
      f2._sqlite3_sql = (a) => (f2._sqlite3_sql = Z3.wa)(a);
      f2._sqlite3_normalized_sql = (a) => (f2._sqlite3_normalized_sql = Z3.xa)(a);
      f2._sqlite3_changes = (a) => (f2._sqlite3_changes = Z3.ya)(a);
      f2._sqlite3_close_v2 = (a) => (f2._sqlite3_close_v2 = Z3.za)(a);
      f2._sqlite3_create_function_v2 = (a, b, c, d3, e2, h, k4, q3, w) => (f2._sqlite3_create_function_v2 = Z3.Aa)(a, b, c, d3, e2, h, k4, q3, w);
      f2._sqlite3_update_hook = (a, b, c) => (f2._sqlite3_update_hook = Z3.Ba)(a, b, c);
      f2._sqlite3_open = (a, b) => (f2._sqlite3_open = Z3.Ca)(a, b);
      var ia2 = f2._malloc = (a) => (ia2 = f2._malloc = Z3.Da)(a), fa2 = f2._free = (a) => (fa2 = f2._free = Z3.Ea)(a);
      f2._RegisterExtensionFunctions = (a) => (f2._RegisterExtensionFunctions = Z3.Fa)(a);
      var Db = (a, b) => (Db = Z3.Ga)(a, b), Wc = (a, b) => (Wc = Z3.Ha)(a, b), wa2 = (a) => (wa2 = Z3.Ia)(a), z2 = (a) => (z2 = Z3.Ja)(a), sa2 = () => (sa2 = Z3.Ka)();
      f2.stackSave = () => sa2();
      f2.stackRestore = (a) => wa2(a);
      f2.stackAlloc = (a) => z2(a);
      f2.cwrap = (a, b, c, d3) => {
        var e2 = !c || c.every((h) => h === "number" || h === "boolean");
        return b !== "string" && e2 && !d3 ? f2["_" + a] : (...h) => Tc(a, b, c, h);
      };
      f2.addFunction = Aa2;
      f2.removeFunction = A3;
      f2.UTF8ToString = ua2;
      f2.ALLOC_NORMAL = ea2;
      f2.allocate = da2;
      f2.allocateUTF8OnStack = xa2;
      function Yc() {
        function a() {
          f2.calledRun = true;
          if (!La2) {
            if (!f2.noFSInit && !Ib) {
              var b, c;
              Ib = true;
              d3 ??= f2.stdin;
              b ??= f2.stdout;
              c ??= f2.stderr;
              d3 ? V3("stdin", d3) : Zb("/dev/tty", "/dev/stdin");
              b ? V3("stdout", null, b) : Zb("/dev/tty", "/dev/stdout");
              c ? V3("stderr", null, c) : Zb("/dev/tty1", "/dev/stderr");
              oa2("/dev/stdin", 0);
              oa2("/dev/stdout", 1);
              oa2("/dev/stderr", 1);
            }
            Z3.N();
            Jb = false;
            f2.onRuntimeInitialized?.();
            if (f2.postRun)
              for (typeof f2.postRun == "function" && (f2.postRun = [f2.postRun]);f2.postRun.length; ) {
                var d3 = f2.postRun.shift();
                $a2.unshift(d3);
              }
            Za2($a2);
          }
        }
        if (0 < K4)
          Sa2 = Yc;
        else {
          if (f2.preRun)
            for (typeof f2.preRun == "function" && (f2.preRun = [f2.preRun]);f2.preRun.length; )
              bb();
          Za2(ab);
          0 < K4 ? Sa2 = Yc : f2.setStatus ? (f2.setStatus("Running..."), setTimeout(() => {
            setTimeout(() => f2.setStatus(""), 1);
            a();
          }, 1)) : a();
        }
      }
      if (f2.preInit)
        for (typeof f2.preInit == "function" && (f2.preInit = [f2.preInit]);0 < f2.preInit.length; )
          f2.preInit.pop()();
      Yc();
      return Module;
    });
    return initSqlJsPromise;
  };
  if (typeof exports === "object" && typeof module === "object") {
    module.exports = initSqlJs;
    module.exports.default = initSqlJs;
  } else if (typeof define === "function" && define["amd"]) {
    define([], function() {
      return initSqlJs;
    });
  } else if (typeof exports === "object") {
    exports["Module"] = initSqlJs;
  }
});

// src/static/util.ts
var import_openseadragon = __toESM(require_openseadragon(), 1);

// node_modules/geotiff-tilesource/dist/geotiff-tilesource.mjs
init_main_8v7k2MJ1();

// src/static/util.ts
var import_sql = __toESM(require_sql_wasm(), 1);
function hideLoader() {
  const loader = document.getElementById("loader");
  const canvas = document.getElementById("seadragon-viewer");
  if (loader) {
    loader.style.display = "none";
  }
  if (canvas) {
    canvas.style.display = "block";
  }
}
function setLoaderProgressText(text) {
  const loaderText = document.getElementById("loaderprogress");
  if (loaderText) {
    loaderText.innerText = text;
  }
}
function showNotfound() {
  const notfound = document.getElementById("nophotos");
  const loader = document.getElementById("loader");
  if (loader) {
    loader.style.display = "none";
  }
  if (notfound) {
    notfound.style.display = "block";
  }
}
async function getTileSources(url) {
  return import_openseadragon.default.GeoTIFFTileSource.getAllTileSources(url, {
    logLatency: false
  });
}
function imageNameToUrl(name) {
  const namePyr = name.replace(".tif", "_pyr.tif");
  return `https://live.cutedogs.org/${namePyr}`;
}
function parseImageName(name) {
  const regex = /^([A-Za-z]+)_(\d+)_(\d+)\.tif$/;
  const match = name.match(regex);
  if (!match)
    return null;
  return {
    colorKind: match[1] || "",
    rollNumber: parseInt(match[2] || "0", 10),
    frame: parseInt(match[3] || "0", 10),
    originalName: name
  };
}
function sortImagesByRoll(images) {
  const parsedImages = images.map(parseImageName).filter((info) => info !== null);
  parsedImages.sort((a, b) => {
    if (a.rollNumber == b.rollNumber) {
      return a.frame - b.frame;
    }
    return a.rollNumber - b.rollNumber;
  });
  return parsedImages.map((info) => info.originalName);
}
function getPhotosByQuery(db, query, bindParams, sort = true) {
  const stmt = db.prepare(query);
  if (bindParams)
    stmt.bind(bindParams);
  let images = [];
  while (stmt.step()) {
    const row = stmt.getAsObject();
    images.push(row.name);
  }
  if (sort) {
    images = sortImagesByRoll(images);
  }
  stmt.free();
  return images.map(imageNameToUrl);
}
async function fetchPhotoDB() {
  setLoaderProgressText("loading photo database");
  const SQL = await import_sql.default({
    locateFile: (file) => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.13.0/${file}`
  });
  const resp = await fetch("/api/db", {
    method: "GET"
  });
  const arrayBuffer = await resp.arrayBuffer();
  const u8Array = new Uint8Array(arrayBuffer);
  const db = new SQL.Database(u8Array);
  setLoaderProgressText("Photo database loaded");
  return db;
}
function getImageWithTags(db, tags) {
  setLoaderProgressText(`querying photos with ${tags.length} tags`);
  let query = "SELECT name FROM images WHERE 1=1";
  for (let i2 = 0;i2 < tags.length; i2++) {
    query += ` AND keywords LIKE $TAG${i2}`;
  }
  const tagParams = tags.map((tag) => `%${tag}%`);
  setLoaderProgressText(`found photos with ${tags.length} tags`);
  return getPhotosByQuery(db, query, tagParams);
}
function getImagesWithPrefix(db, prefix) {
  setLoaderProgressText(`Querying photos with prefix "${prefix}"`);
  const query = "SELECT name FROM images WHERE name LIKE $PREFIX";
  const prefixParams = [`${prefix}%`];
  setLoaderProgressText(`Found photos with prefix "${prefix}"`);
  return getPhotosByQuery(db, query, prefixParams);
}
function getAllImages(db) {
  setLoaderProgressText("Querying all photos");
  const query = "SELECT name FROM images";
  setLoaderProgressText("Found all photos");
  return getPhotosByQuery(db, query);
}
async function initViewer(photoUrls) {
  if (photoUrls.length === 0) {
    showNotfound();
    return;
  }
  console.log(`initializing viewer with ${photoUrls.length} photos...`);
  qr(import_openseadragon.default);
  const isPrimaryTouch = window.matchMedia("(pointer: coarse)").matches;
  const isIOSDevice = /iPad|iPhone|iPod|Max/.test(navigator.userAgent) && isPrimaryTouch;
  const isAndroidDevice = /Android/.test(navigator.userAgent) && isPrimaryTouch;
  setLoaderProgressText("Loading tile sources for photos");
  let tileSourceCounter = 0;
  setLoaderProgressText(`loaded 0 tile sources of ${photoUrls.length} photos`);
  const tileSourcesPromises = photoUrls.map(async (url) => {
    const tileSource = (await getTileSources(url))[0];
    tileSourceCounter++;
    setLoaderProgressText(`loaded ${tileSourceCounter} tile sources of ${photoUrls.length} photos`);
    return tileSource;
  });
  const tileSources = await Promise.all(tileSourcesPromises);
  const windowRatio = window.innerWidth / window.innerHeight;
  let collectionRows = Math.round(Math.sqrt(tileSources.length / windowRatio));
  let options = {
    id: "seadragon-viewer",
    tileSources,
    collectionMode: true,
    collectionRows,
    collectionTileSize: 256,
    collectionTileMargin: 5,
    crossOriginPolicy: "Anonymous",
    showNavigator: true,
    showNavigationControl: false,
    drawer: isIOSDevice || isAndroidDevice ? "canvas" : "webgl",
    immediateRender: isIOSDevice || isAndroidDevice
  };
  setLoaderProgressText(`Loading ${tileSources.length} photos into viewer`);
  const viewer = import_openseadragon.default(options);
  let item_count = 0;
  tileSources.forEach((ts2) => {
    ts2.addOnceHandler("ready", () => {
      console.log("Tile source ready:", ts2);
    });
  });
  viewer.addHandler("tile-loaded", () => {
    console.log("Tile drawn");
  });
  const allItemsAddedPromise = new Promise((resolve2) => {
    viewer.world.addHandler("add-item", (i2) => {
      i2.item.addOnceHandler("fully-loaded-change", () => {
        setLoaderProgressText(`Loaded ${item_count + 1} of ${tileSources.length} photos`);
        item_count++;
        if (item_count === tileSources.length) {
          resolve2();
        }
      });
    });
  });
  await allItemsAddedPromise;
  setLoaderProgressText("Moving you to a good viewpoint");
  viewer.viewport.goHome(true);
  hideLoader();
}

// src/static/collection.ts
var queryParams = new URLSearchParams(window.location.search);
var tags = queryParams.get("tags")?.split(",") || undefined;
var prefix = queryParams.get("prefix") || undefined;
async function collectionPhotos() {
  const db = await fetchPhotoDB();
  let photoUrls = [];
  if (prefix) {
    photoUrls = getImagesWithPrefix(db, prefix);
  } else if (tags && tags.length > 0) {
    photoUrls = getImageWithTags(db, tags);
  } else {
    photoUrls = getAllImages(db);
  }
  return photoUrls;
}
collectionPhotos().then(async (photoUrls) => {
  await initViewer(photoUrls);
});
